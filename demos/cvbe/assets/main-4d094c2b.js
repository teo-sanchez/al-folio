var fge=Object.defineProperty;var dge=(n,e,t)=>e in n?fge(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var Nt=(n,e,t)=>(dge(n,typeof e!="symbol"?e+"":e,t),t);function pge(n,e){for(var t=0;t<e.length;t++){const r=e[t];if(typeof r!="string"&&!Array.isArray(r)){for(const i in r)if(i!=="default"&&!(i in n)){const s=Object.getOwnPropertyDescriptor(r,i);s&&Object.defineProperty(n,i,s.get?s:{enumerable:!0,get:()=>r[i]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))r(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function t(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(i){if(i.ep)return;i.ep=!0;const s=t(i);fetch(i.href,s)}})();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mge=1e-7,gge=1e-4;class gM{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}let VS=class{refCount(e){return Fa("refCount")}incRef(e){return Fa("incRef")}timerAvailable(){return!0}time(e){return Fa("time")}read(e){return Fa("read")}readSync(e){return Fa("readSync")}readToGPU(e,t){return Fa("readToGPU")}numDataIds(){return Fa("numDataIds")}disposeData(e,t){return Fa("disposeData")}write(e,t,r){return Fa("write")}move(e,t,r,i,s){return Fa("move")}createTensorFromGPUData(e,t,r){return Fa("createTensorFromGPUData")}memory(){return Fa("memory")}floatPrecision(){return Fa("floatPrecision")}epsilon(){return this.floatPrecision()===32?mge:gge}dispose(){return Fa("dispose")}};function Fa(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gL(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Sf(n,e,t)}function yge(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,r=0;for(;t>0;)r=Math.random()*t|0,t--,Sf(n,t,r),Sf(e,t,r)}function Zd(n,e,t){return Math.max(n,Math.min(e,t))}function yM(n){return n%2===0?n:n+1}function Sf(n,e,t){const r=n[e];n[e]=n[t],n[t]=r}function yL(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function bge(n,e){const t=Math.random();return e*t+(1-t)*n}function vge(n,e){let t=0;for(let r=0;r<n.length;r++){const i=Number(n[r])-Number(e[r]);t+=i*i}return t}function U(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function qs(n,e,t=""){U(Rn(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function $g(n){U(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Ee(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function tD(n){return n.length===0}function B7(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function Rn(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function eg(n){return n%1===0}function wge(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function mI(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function xge(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return gL(e),e}function Wm(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function nD(n,e=i=>0,t,r){return new Promise((i,s)=>{let o=0;const a=()=>{if(n()){i();return}o++;const l=e(o);if(t!=null&&o>=t){s();return}r!=null?r(a,l):setTimeout(a,l)};a()})}function bM(n,e){let t=1,r=-1;for(let s=0;s<n.length;++s)if(n[s]>=0)t*=n[s];else if(n[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(n[s]<0)throw Error(`Shapes can not be < 0. Found ${n[s]} at dim ${s}`);if(r===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const i=n.slice();return i[r]=e/t,i}function An(n,e){const t=e.length;return n=n==null?e.map((r,i)=>i):[].concat(n),U(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),U(n.every(r=>eg(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function Bf(n,e){const t=[],r=[],i=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||i?null:An(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(s!=null){if(s[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(s[o]==null||s[o]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),s[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function cs(n,e){return Si(n,e)}function Si(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function V7(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function U7(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function vM(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function h_(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function W7(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function du(n){return typeof n=="string"||n instanceof String}function H7(n){return typeof n=="boolean"}function gI(n){return typeof n=="number"}function xp(n){return Array.isArray(n)?xp(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":gI(n)?"float32":du(n)?"string":H7(n)?"bool":"float32"}function Jd(n){return!!(n&&n.constructor&&n.call&&n.apply)}function yI(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Zt(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function G7(n,e,t,r=!1){const i=new Array;if(e.length===1){const s=e[0]*(r?2:1);for(let o=0;o<s;o++)i[o]=t[n+o]}else{const s=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<s;l++)i[l]=G7(n+l*a,o,t,r)}return i}function El(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((i,s)=>i*s)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return G7(0,n,e,t)}function q1(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function wM(n,e){const t=js(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function js(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function bL(n,e){const t=n.reduce((r,i)=>r*i,1);if(e==null||e==="float32")return El(n,new Float32Array(t));if(e==="int32")return El(n,new Int32Array(t));if(e==="bool")return El(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Ja(n){n.forEach(e=>{U(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function bu(n,e,t){if(e===0)return 0;if(e===1)return n[0];let r=n[n.length-1];for(let i=0;i<n.length-1;++i)r+=t[i]*n[i];return r}function Rg(n,e,t){if(e===0)return[];if(e===1)return[n];const r=new Array(e);for(let i=0;i<r.length-1;++i)r[i]=Math.floor(n/t[i]),n-=r[i]*t[i];return r[r.length-1]=n,r}function Qd(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LW="tfjsflags";let j7=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=_ge,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const i=this.urlFlags[e];Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${i}.`),this.set(e,i)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Qd(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);LW in e&&e[LW].split(",").forEach(r=>{const[i,s]=r.split(":");this.urlFlags[i]=Cge(i,s)})}};function _ge(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(Sge(e,r[0],r[1]),r.join("="))),e}function Sge(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function Cge(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function Ie(){return vL}let vL=null;function kge(n){vL=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let QR;function q7(){if(QR==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");QR=n}return QR}function Tge(){const n=q7();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function wL(n,e){const t=Tge();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const Tv="Abs",Pg="Acos",Dg="Acosh",_p="Add",Ev="AddN",US="All",WS="Any",Iv="ArgMax",Av="ArgMin",Og="Asin",Fg="Asinh",Lg="Atan",zg="Atanh",Bg="Atan2",Mv="AvgPool",HS="AvgPoolGrad",Nv="AvgPool3D",GS="AvgPool3DGrad",$v="BatchMatMul",Rv="BatchToSpaceND",jS="Bincount",qS="BitwiseAnd",X7="BroadcastTo",XS="BroadcastArgs",Vg="Cast",Ug="Ceil",Wg="ClipByValue",KS="Complex",Pv="ComplexAbs",Dv="Concat",Ov="Conv2D",YS="Conv2DBackpropFilter",Fv="Conv2DBackpropInput",Lv="Conv3D",ZS="Conv3DBackpropFilterV2",JS="Conv3DBackpropInputV2",Hg="Cos",Gg="Cosh",QS="Cumprod",zv="Cumsum",e2="CropAndResize",t2="DenseBincount",n2="DepthToSpace",Bv="DepthwiseConv2dNative",r2="DepthwiseConv2dNativeBackpropFilter",i2="DepthwiseConv2dNativeBackpropInput",s2="Diag",Vv="Dilation2D",f_="Dilation2DBackpropInput",d_="Dilation2DBackpropFilter",o2="Draw",jg="RealDiv",a2="Einsum",qg="Elu",l2="EluGrad",Xg="Erf",Uv="Equal",Kg="Exp",Wv="ExpandDims",Yg="Expm1",c2="FFT",u2="Fill",h2="FlipLeftRight",Zg="Floor",Jg="FloorDiv",Hv="FusedBatchNorm",Gv="GatherV2",f2="GatherNd",jv="Greater",Qg="GreaterEqual",ey="Identity",d2="IFFT",p2="Imag",ty="IsFinite",ny="IsInf",ry="IsNan",qv="LeakyRelu",Xv="Less",Kv="LessEqual",m2="LinSpace",iy="Log",sy="Log1p",Yv="LogicalAnd",Zv="LogicalNot",Jv="LogicalOr",Ege="LogicalXor",K7="LogSoftmax",Ige="LowerBound",Qv="LRN",g2="LRNGrad",Age="MatrixBandPart",ew="Max",oy="Maximum",tw="MaxPool",y2="MaxPoolGrad",nw="MaxPool3D",b2="MaxPool3DGrad",v2="MaxPoolWithArgmax",rw="Mean",iw="Min",ay="Minimum",sw="MirrorPad",ly="Mod",w2="Multinomial",cy="Multiply",ow="Neg",aw="NotEqual",x2="NonMaxSuppressionV3",xM="NonMaxSuppressionV4",_2="NonMaxSuppressionV5",lw="OnesLike",cw="OneHot",uw="Pack",hw="PadV2",Mge="Pool",uy="Pow",fw="Prelu",dw="Prod",_M="RaggedGather",SM="RaggedRange",CM="RaggedTensorToTensor",S2="Range",C2="Real",hy="Reciprocal",fy="Relu",pw="Reshape",mw="ResizeNearestNeighbor",k2="ResizeNearestNeighborGrad",gw="ResizeBilinear",T2="ResizeBilinearGrad",dy="Relu6",yw="Reverse",py="Round",my="Rsqrt",E2="ScatterNd",I2="TensorScatterUpdate",A2="SearchSorted",bw="Select",gy="Selu",vw="Slice",yy="Sin",by="Sinh",vy="Sign",wy="Sigmoid",xy="Softplus",_y="Sqrt",ww="Sum",xw="SpaceToBatchND",_w="SplitV",Sw="Softmax",kM="SparseFillEmptyRows",TM="SparseReshape",M2="SparseSegmentMean",N2="SparseSegmentSum",$2="SparseToDense",Sy="SquaredDifference",R2="Square",P2="StaticRegexReplace",D2="StridedSlice",O2="StringNGrams",EM="StringSplit",IM="StringToHashBucketFast",Cy="Sub",ky="Tan",Ty="Tanh",Ey="Tile",F2="TopK",L2="Transform",Ld="Transpose",AM="Unique",Cw="Unpack",kw="UnsortedSegmentSum",Nge="UpperBound",Tw="ZerosLike",Iy="Step",p_="FromPixels",z2="RotateWithOffset",Vb="_FusedMatMul",Ub="FusedConv2D",Wb="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xl(...n){Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.warn(...n)}function $ge(...n){Ie().getBool("IS_TEST")||Ie().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hb=wL("kernelRegistry",()=>new Map),m_=wL("gradRegistry",()=>new Map);function g_(n,e){const t=xL(n,e);return Hb.get(t)}function rD(n){return m_.get(n)}function bI(n){const e=Hb.entries(),t=[];for(;;){const{done:r,value:i}=e.next();if(r)break;const[s,o]=i,[a]=s.split("_");a===n&&t.push(o)}return t}function B2(n){const{kernelName:e,backendName:t}=n,r=xL(e,t);Hb.has(r)&&xl(`The kernel '${e}' for backend '${t}' is already registered`),Hb.set(r,n)}function Y7(n){const{kernelName:e}=n;m_.has(e)&&Ie().getBool("DEBUG")&&xl(`Overriding the gradient for '${e}'`),m_.set(e,n)}function Rge(n,e){const t=xL(n,e);if(!Hb.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);Hb.delete(t)}function Pge(n){if(!m_.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);m_.delete(n)}function Dge(n,e){bI(n).forEach(r=>{const i=Object.assign({},r,{backendName:e});B2(i)})}function xL(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z7(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var gt=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Ay(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function My(n){if(n.__esModule)return n;var e=n.default;if(typeof e=="function"){var t=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(r){var i=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(t,r,i.get?i:{enumerable:!0,get:function(){return n[r]}})}),t}var J7=oi,uc=null;try{uc=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch()function oi(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}oi.prototype.__isLong__;Object.defineProperty(oi.prototype,"__isLong__",{value:!0});function Qa(n){return(n&&n.__isLong__)===!0}oi.isLong=Qa;var zW={},BW={};function Ny(n,e){var t,r,i;return e?(n>>>=0,(i=0<=n&&n<256)&&(r=BW[n],r)?r:(t=ai(n,(n|0)<0?-1:0,!0),i&&(BW[n]=t),t)):(n|=0,(i=-128<=n&&n<128)&&(r=zW[n],r)?r:(t=ai(n,n<0?-1:0,!1),i&&(zW[n]=t),t))}oi.fromInt=Ny;function hc(n,e){if(isNaN(n))return e?Dm:fc;if(e){if(n<0)return Dm;if(n>=Q7)return nX}else{if(n<=-UW)return Wa;if(n+1>=UW)return tX}return n<0?hc(-n,e).neg():ai(n%Gb|0,n/Gb|0,e)}oi.fromNumber=hc;function ai(n,e,t){return new oi(n,e,t)}oi.fromBits=ai;var vI=Math.pow;function _L(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return fc;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var r;if((r=n.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return _L(n.substring(1),e,t).neg();for(var i=hc(vI(t,8)),s=fc,o=0;o<n.length;o+=8){var a=Math.min(8,n.length-o),l=parseInt(n.substring(o,o+a),t);if(a<8){var c=hc(vI(t,a));s=s.mul(c).add(hc(l))}else s=s.mul(i),s=s.add(hc(l))}return s.unsigned=e,s}oi.fromString=_L;function Du(n,e){return typeof n=="number"?hc(n,e):typeof n=="string"?_L(n,e):ai(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}oi.fromValue=Du;var VW=65536,Oge=1<<24,Gb=VW*VW,Q7=Gb*Gb,UW=Q7/2,WW=Ny(Oge),fc=Ny(0);oi.ZERO=fc;var Dm=Ny(0,!0);oi.UZERO=Dm;var xb=Ny(1);oi.ONE=xb;var eX=Ny(1,!0);oi.UONE=eX;var iD=Ny(-1);oi.NEG_ONE=iD;var tX=ai(-1,2147483647,!1);oi.MAX_VALUE=tX;var nX=ai(-1,-1,!0);oi.MAX_UNSIGNED_VALUE=nX;var Wa=ai(0,-2147483648,!1);oi.MIN_VALUE=Wa;var $t=oi.prototype;$t.toInt=function(){return this.unsigned?this.low>>>0:this.low};$t.toNumber=function(){return this.unsigned?(this.high>>>0)*Gb+(this.low>>>0):this.high*Gb+(this.low>>>0)};$t.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Wa)){var t=hc(e),r=this.div(t),i=r.mul(t).sub(this);return r.toString(e)+i.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var s=hc(vI(e,6),this.unsigned),o=this,a="";;){var l=o.div(s),c=o.sub(l.mul(s)).toInt()>>>0,u=c.toString(e);if(o=l,o.isZero())return u+a;for(;u.length<6;)u="0"+u;a=""+u+a}};$t.getHighBits=function(){return this.high};$t.getHighBitsUnsigned=function(){return this.high>>>0};$t.getLowBits=function(){return this.low};$t.getLowBitsUnsigned=function(){return this.low>>>0};$t.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Wa)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return this.high!=0?t+33:t+1};$t.isZero=function(){return this.high===0&&this.low===0};$t.eqz=$t.isZero;$t.isNegative=function(){return!this.unsigned&&this.high<0};$t.isPositive=function(){return this.unsigned||this.high>=0};$t.isOdd=function(){return(this.low&1)===1};$t.isEven=function(){return(this.low&1)===0};$t.equals=function(e){return Qa(e)||(e=Du(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};$t.eq=$t.equals;$t.notEquals=function(e){return!this.eq(e)};$t.neq=$t.notEquals;$t.ne=$t.notEquals;$t.lessThan=function(e){return this.comp(e)<0};$t.lt=$t.lessThan;$t.lessThanOrEqual=function(e){return this.comp(e)<=0};$t.lte=$t.lessThanOrEqual;$t.le=$t.lessThanOrEqual;$t.greaterThan=function(e){return this.comp(e)>0};$t.gt=$t.greaterThan;$t.greaterThanOrEqual=function(e){return this.comp(e)>=0};$t.gte=$t.greaterThanOrEqual;$t.ge=$t.greaterThanOrEqual;$t.compare=function(e){if(Qa(e)||(e=Du(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};$t.comp=$t.compare;$t.negate=function(){return!this.unsigned&&this.eq(Wa)?Wa:this.not().add(xb)};$t.neg=$t.negate;$t.add=function(e){Qa(e)||(e=Du(e));var t=this.high>>>16,r=this.high&65535,i=this.low>>>16,s=this.low&65535,o=e.high>>>16,a=e.high&65535,l=e.low>>>16,c=e.low&65535,u=0,h=0,f=0,d=0;return d+=s+c,f+=d>>>16,d&=65535,f+=i+l,h+=f>>>16,f&=65535,h+=r+a,u+=h>>>16,h&=65535,u+=t+o,u&=65535,ai(f<<16|d,u<<16|h,this.unsigned)};$t.subtract=function(e){return Qa(e)||(e=Du(e)),this.add(e.neg())};$t.sub=$t.subtract;$t.multiply=function(e){if(this.isZero())return fc;if(Qa(e)||(e=Du(e)),uc){var t=uc.mul(this.low,this.high,e.low,e.high);return ai(t,uc.get_high(),this.unsigned)}if(e.isZero())return fc;if(this.eq(Wa))return e.isOdd()?Wa:fc;if(e.eq(Wa))return this.isOdd()?Wa:fc;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(WW)&&e.lt(WW))return hc(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,i=this.high&65535,s=this.low>>>16,o=this.low&65535,a=e.high>>>16,l=e.high&65535,c=e.low>>>16,u=e.low&65535,h=0,f=0,d=0,p=0;return p+=o*u,d+=p>>>16,p&=65535,d+=s*u,f+=d>>>16,d&=65535,d+=o*c,f+=d>>>16,d&=65535,f+=i*u,h+=f>>>16,f&=65535,f+=s*c,h+=f>>>16,f&=65535,f+=o*l,h+=f>>>16,f&=65535,h+=r*u+i*c+s*l+o*a,h&=65535,ai(d<<16|p,h<<16|f,this.unsigned)};$t.mul=$t.multiply;$t.divide=function(e){if(Qa(e)||(e=Du(e)),e.isZero())throw Error("division by zero");if(uc){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?uc.div_u:uc.div_s)(this.low,this.high,e.low,e.high);return ai(t,uc.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Dm:fc;var r,i,s;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Dm;if(e.gt(this.shru(1)))return eX;s=Dm}else{if(this.eq(Wa)){if(e.eq(xb)||e.eq(iD))return Wa;if(e.eq(Wa))return xb;var o=this.shr(1);return r=o.div(e).shl(1),r.eq(fc)?e.isNegative()?xb:iD:(i=this.sub(e.mul(r)),s=r.add(i.div(e)),s)}else if(e.eq(Wa))return this.unsigned?Dm:fc;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=fc}for(i=this;i.gte(e);){r=Math.max(1,Math.floor(i.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),l=a<=48?1:vI(2,a-48),c=hc(r),u=c.mul(e);u.isNegative()||u.gt(i);)r-=l,c=hc(r,this.unsigned),u=c.mul(e);c.isZero()&&(c=xb),s=s.add(c),i=i.sub(u)}return s};$t.div=$t.divide;$t.modulo=function(e){if(Qa(e)||(e=Du(e)),uc){var t=(this.unsigned?uc.rem_u:uc.rem_s)(this.low,this.high,e.low,e.high);return ai(t,uc.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};$t.mod=$t.modulo;$t.rem=$t.modulo;$t.not=function(){return ai(~this.low,~this.high,this.unsigned)};$t.and=function(e){return Qa(e)||(e=Du(e)),ai(this.low&e.low,this.high&e.high,this.unsigned)};$t.or=function(e){return Qa(e)||(e=Du(e)),ai(this.low|e.low,this.high|e.high,this.unsigned)};$t.xor=function(e){return Qa(e)||(e=Du(e)),ai(this.low^e.low,this.high^e.high,this.unsigned)};$t.shiftLeft=function(e){return Qa(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?ai(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):ai(0,this.low<<e-32,this.unsigned)};$t.shl=$t.shiftLeft;$t.shiftRight=function(e){return Qa(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?ai(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):ai(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};$t.shr=$t.shiftRight;$t.shiftRightUnsigned=function(e){if(Qa(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var r=this.low;return ai(r>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?ai(t,0,this.unsigned):ai(t>>>e-32,0,this.unsigned)};$t.shru=$t.shiftRightUnsigned;$t.shr_u=$t.shiftRightUnsigned;$t.toSigned=function(){return this.unsigned?ai(this.low,this.high,!1):this};$t.toUnsigned=function(){return this.unsigned?this:ai(this.low,this.high,!0)};$t.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};$t.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};$t.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};oi.fromBytes=function(e,t,r){return r?oi.fromBytesLE(e,t):oi.fromBytesBE(e,t)};oi.fromBytesLE=function(e,t){return new oi(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};oi.fromBytesBE=function(e,t){return new oi(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};const rX=Ay(J7),Fge=pge({__proto__:null,default:rX},[J7]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Im=rX||Fge;function V2(n){return Im.fromString(n,!0,16)}const iX=V2("c3a5c85c97cb3127"),ym=V2("b492b66fbe98f273"),Wo=V2("9ae16a3b2f90404f");function sD(n){return n.xor(n.shru(47))}function sX(n,e,t){const r=n.slice(e,e+t);return Im.fromBytes(Array.from(r),!0,!0)}function Qr(n,e){return sX(n,e,8)}function HW(n,e){return sX(n,e,4)}function Vs(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function zd(n,e,t=V2("9ddfea08eb382d69")){let r=n.xor(e).mul(t);r=r.xor(r.shru(47));let i=e.xor(r).mul(t);return i=i.xor(i.shru(47)),i=i.mul(t),i}function Lge(n,e,t,r,i,s){i=i.add(n),s=Vs(s.add(i).add(r),21);const o=i;return i=i.add(e),i=i.add(t),s=s.add(Vs(i,44)),[i.add(r),s.add(o)]}function Uk(n,e,t,r){return Lge(Qr(n,e),Qr(n,e+8),Qr(n,e+16),Qr(n,e+24),t,r)}function zge(n,e=n.length){if(e>=8){const t=Wo.add(e*2),r=Qr(n,0).add(Wo),i=Qr(n,e-8),s=Vs(i,37).mul(t).add(r),o=Vs(r,25).add(i).mul(t);return zd(s,o,t)}if(e>=4){const t=Wo.add(e*2),r=HW(n,0);return zd(r.shl(3).add(e),HW(n,e-4),t)}if(e>0){const t=n[0],r=n[e>>1],i=n[e-1],s=t+(r<<8),o=e+(i<<2);return sD(Wo.mul(s).xor(iX.mul(o))).mul(Wo)}return Wo}function Bge(n,e=n.length){const t=Wo.add(e*2),r=Qr(n,0).mul(ym),i=Qr(n,8),s=Qr(n,e-8).mul(t),o=Qr(n,e-16).mul(Wo);return zd(Vs(r.add(i),43).add(Vs(s,30)).add(o),r.add(Vs(i.add(Wo),18)).add(s),t)}function Vge(n,e=n.length){const t=Wo.add(e*2),r=Qr(n,0).mul(Wo),i=Qr(n,8),s=Qr(n,e-8).mul(t),o=Qr(n,e-16).mul(Wo),a=Vs(r.add(i),43).add(Vs(s,30)).add(o),l=zd(a,r.add(Vs(i.add(Wo),18)).add(s),t),c=Qr(n,16).mul(t),u=Qr(n,24),h=a.add(Qr(n,e-32)).mul(t),f=l.add(Qr(n,e-24)).mul(t);return zd(Vs(c.add(u),43).add(Vs(h,30)).add(f),c.add(Vs(u.add(r),18)).add(h),t)}function oX(n,e=n.length){const t=Im.fromNumber(81,!0);if(e<=32)return e<=16?zge(n,e):Bge(n,e);if(e<=64)return Vge(n,e);let r=t,i=t.mul(ym).add(113),s=sD(i.mul(Wo).add(113)).mul(Wo),o=[Im.UZERO,Im.UZERO],a=[Im.UZERO,Im.UZERO];r=r.mul(Wo).add(Qr(n,0));let l=0;const c=(e-1>>6)*64,u=c+(e-1&63)-63;do r=Vs(r.add(i).add(o[0]).add(Qr(n,l+8)),37).mul(ym),i=Vs(i.add(o[1]).add(Qr(n,l+48)),42).mul(ym),r=r.xor(a[1]),i=i.add(o[0]).add(Qr(n,l+40)),s=Vs(s.add(a[0]),33).mul(ym),o=Uk(n,l,o[1].mul(ym),r.add(a[0])),a=Uk(n,l+32,s.add(a[1]),i.add(Qr(n,l+16))),[s,r]=[r,s],l+=64;while(l!==c);const h=ym.add(s.and(255).shl(1));return l=u,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),r=Vs(r.add(i).add(o[0]).add(Qr(n,l+8)),37).mul(h),i=Vs(i.add(o[1]).add(Qr(n,l+48)),42).mul(h),r=r.xor(a[1].mul(9)),i=i.add(o[0].mul(9).add(Qr(n,l+40))),s=Vs(s.add(a[0]),33).mul(h),o=Uk(n,l,o[1].mul(h),r.add(a[0])),a=Uk(n,l+32,s.add(a[1]),i.add(Qr(n,l+16))),[s,r]=[r,s],zd(zd(o[0],a[0],h).add(sD(i).mul(iX)).add(s),zd(o[1],a[1],h).add(r),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vf(n,e){return e==="string"?vu(n):Sp([n],e)}function Uge(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Sp(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Cc(n)),Ie().getBool("DEBUG")&&V7(n,e),Uge(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function io(){return Ie().platform.now()}function Wge(n,e){return Ie().platform.fetch(n,e)}function vu(n,e="utf-8"){return e=e||"utf-8",Ie().platform.encode(n,e)}function Sc(n,e="utf-8"){return e=e||"utf-8",Ie().platform.decode(n,e)}function xs(n){return Ie().platform.isTypedArray!=null?Ie().platform.isTypedArray(n):Z7(n)}function Cc(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Qd(n)||n==null||xs(n)&&t)e.push(n);else if(Array.isArray(n)||xs(n))for(let r=0;r<n.length;++r)Cc(n[r],e,t);else{let r=-1;for(const i of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(i)&&(r=Math.max(r,Number(i)));for(let i=0;i<=r;i++)Cc(n[i],e,t)}return e}const Hge=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:Rn,arraysEqualWithNull:B7,assert:U,assertNonNegativeIntegerDimensions:Ja,assertNonNull:$g,assertShapesMatch:qs,bytesFromStringArray:W7,bytesPerElement:h_,checkConversionForErrors:V7,clamp:Zd,computeStrides:Zt,convertBackendValuesAndArrayBuffer:q1,createScalarValue:Vf,createShuffledIndices:xge,decodeString:Sc,distSquared:vge,encodeString:vu,fetch:Wge,fingerPrint64:oX,flatten:Cc,getArrayFromDType:Si,getTypedArrayFromDType:cs,hasEncodingLoss:vM,hexToLong:V2,indexToLoc:Rg,inferDtype:xp,inferFromImplicitShape:bM,isBoolean:H7,isFunction:Jd,isInt:eg,isNumber:gI,isPromise:Qd,isScalarShape:tD,isString:du,isTypedArray:xs,isValidDtype:U7,locToIndex:bu,makeOnesTypedArray:wM,makeZerosNestedTypedArray:bL,makeZerosTypedArray:js,nearestDivisor:yI,nearestLargerEven:yM,now:io,parseAxisParam:An,randUniform:bge,repeatedTry:nD,rightPad:Wm,shuffle:gL,shuffleCombo:yge,sizeFromShape:Ee,sizeToSquarishShape:mI,squeezeShape:Bf,sum:yL,swap:Sf,tanh:wge,toNestedArray:El,toTypedArray:Sp},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Gge=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new qge)}profileKernel(e,t,r){let i;const s=()=>{i=r()};let o;const a=io();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(s);else{s();for(const c of i)c.dataSync();o=Promise.resolve({kernelMs:io()-a})}if(Ie().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<i.length;c++){const u=i[c];u.data().then(h=>{jge(h,u.dtype,e)})}return{kernelName:e,outputs:i,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:i,inputs:s,extraInfo:o}=e;r.forEach(a=>{Promise.all([a.data(),i,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],s,l[2])})})}};function jge(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const i=n[r];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${t}'`),!0}return!1}let qge=class{logKernelProfile(e,t,r,i,s,o){const a=typeof i=="number"?Wm(`${i}ms`,9):i.error,l=Wm(e,25),c=t.rank,u=t.size,h=Wm(t.shape.toString(),14);let f="";for(const d in s){const p=s[d];if(p!=null){const m=p.shape||t.shape,g=m.length;f+=`${d}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${h}	%c${u}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xge(n,e,t){const r={},i={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const h in u){const f=u[h];let d=!1;for(let p=0;p<e.length;p++)if(r[f.id]){c.outputs.forEach(m=>r[m.id]=!0),d=!0,i[c.id]=!0;break}if(d)break}}const s={};s[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(s[c.outputs[h].id]){for(const f in u)s[u[f].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(i[c.id]&&o[c.id]){const u={};for(const f in c.inputs){const d=c.inputs[f];r[d.id]&&(u[f]=d)}const h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,a.push(h)}}return a}function Kge(n,e,t,r){for(let i=e.length-1;i>=0;i--){const s=e[i],o=[];if(s.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const a=s.gradient(o);for(const l in s.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=t(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=s.inputs[l];if(!Rn(c.shape,u.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{const h=n[u.id];n[u.id]=r(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GW=20,Lx=3,e3=7;function Yge(n,e,t,r){const i=Zt(e),s=Zge(n,e,t,i),o=e.length,a=ME(n,e,t,i,s),l=["Tensor"];return r&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function Zge(n,e,t,r){const i=Ee(e),s=r[r.length-1],o=new Array(s).fill(0),a=e.length,l=t==="complex64"?b1(n):n;if(a>1)for(let c=0;c<i/s;c++){const u=c*s;for(let h=0;h<s;h++)o[h]=Math.max(o[h],y1(l[u+h],0,t).length)}return o}function y1(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(e3))} + ${parseFloat(n[1].toFixed(e3))}j`:du(n)?r=`'${n}'`:t==="bool"?r=aX(n):r=parseFloat(n.toFixed(e3)).toString(),Wm(r,e)}function aX(n){return n===0?"false":"true"}function ME(n,e,t,r,i,s=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const m=b1(n);return[y1(m[0],0,t)]}return t==="bool"?[aX(n[0])]:[n[0].toString()]}if(l===1){if(a>GW){const g=Lx*o;let y=Array.from(n.slice(0,g)),b=Array.from(n.slice((a-Lx)*o,a*o));return t==="complex64"&&(y=b1(y),b=b1(b)),["["+y.map((_,w)=>y1(_,i[w],t)).join(", ")+", ..., "+b.map((_,w)=>y1(_,i[a-Lx+w],t)).join(", ")+"]"]}return["["+(t==="complex64"?b1(n):Array.from(n)).map((g,y)=>y1(g,i[y],t)).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,f=[];if(a>GW){for(let m=0;m<Lx;m++){const g=m*h,y=g+h;f.push(...ME(n.slice(g,y),c,t,u,i,!1))}f.push("...");for(let m=a-Lx;m<a;m++){const g=m*h,y=g+h;f.push(...ME(n.slice(g,y),c,t,u,i,m===a-1))}}else for(let m=0;m<a;m++){const g=m*h,y=g+h;f.push(...ME(n.slice(g,y),c,t,u,i,m===a-1))}const d=l===2?",":"";f[0]="["+(a>0?f[0]+d:"");for(let m=1;m<f.length-1;m++)f[m]=" "+f[m]+d;let p=`,
`;for(let m=2;m<l;m++)p+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(s?"":p),f}function b1(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ls{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=Ee(e),r!=null){const i=r.length;U(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Si(t,this.size),this.strides=Zt(e)}set(e,...t){t.length===0&&(t=[0]),U(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const i of e){if(i<0||i>=this.shape[t]){const s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let r=e[e.length-1];for(let i=0;i<e.length-1;++i)r+=this.strides[i]*e[i];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return au().makeTensor(this.values,this.shape,this.dtype)}}let au=null,ub=null;function Jge(n){au=n}function Qge(n){ub=n}let jn=class{constructor(e,t,r,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Ee(e),this.strides=Zt(e),this.dataId=r,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return ub.buffer(this.shape,this.dtype,e)}bufferSync(){return ub.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return El(this.shape,e,this.dtype==="complex64")}arraySync(){return El(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=au().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>Sc(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),au().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=au().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Sc(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await au().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),au().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return ub.print(this,e)}clone(){return this.throwIfDisposed(),ub.clone(this)}toString(e=!1){const t=this.dataSync();return Yge(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),ub.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),au().makeVariable(this,e,t,r)}};Object.defineProperty(jn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function eye(){return wL("Tensor",()=>jn)}eye();let y_=class extends jn{constructor(e,t,r,i){super(e.shape,e.dtype,e.dataId,i),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Rn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);au().disposeTensor(this),this.dataId=e.dataId,au().incRef(this,null)}dispose(){au().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(y_,Symbol.hasInstance,{value:n=>n instanceof jn&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var oD;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(oD||(oD={}));var aD;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(aD||(aD={}));var lD;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(lD||(lD={}));var cD;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(cD||(cD={}));var uD;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(uD||(uD={}));const tye={float32:cD,int32:aD,bool:lD,complex64:uD};function As(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return tye[n][e]}function U2(n){return As(n,"int32")}function lX(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function cX(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ki(n,e){if(n.dtype===e.dtype)return[n,e];const t=As(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function uX(n,e){U(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function MM(n,e){return e.some(t=>t.id===n.id)}function $f(n){const e=[];return hX(n,e,new Set),e}function hX(n,e,t){if(n==null)return;if(n instanceof jn){e.push(n);return}if(!nye(n))return;const r=n;for(const i in r){const s=r[i];t.has(s)||(t.add(s),hX(s,e,t))}}function nye(n){return Array.isArray(n)||typeof n=="object"}const rye=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:uX,getTensorsInContainer:$f,isTensorInList:MM,makeTypesMatch:ki},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t3(n){return n.kernelName!=null}let jW=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}},SL=class hD{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new jW}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(xl(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Gge(this.backendInstance),!0}setupRegisteredKernels(){bI(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){bI(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof VS)&&typeof r.then=="function"){const i=++this.pendingBackendInitId,s=r.then(o=>i<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,xl(`Initialization of backend ${e} failed`),xl(o.stack||o.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return xl(`Initialization of backend ${e} failed`),xl(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:i,asyncInit:s}=this.initializeBackend(r);if(s||i)return{name:r,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),i=r.backend,s=this.readSync(t),o=i.refCount(t);i.disposeData(t,!0),r.backend=e,e.move(t,s,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let i;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(i),()=>(i=t(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,t,r){e();try{const i=r();return t(),i}catch(i){throw t(),i}}nextTensorId(){return hD.nextTensorId++}nextVariableId(){return hD.nextVariableId++}clone(e){const t=ue.runKernel(ey,{x:e}),r={x:e},i=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return ue.runKernel(Vg,l,c)}}),s=[];return this.addTapeNode(this.state.activeScope.name,r,[t],i,s,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(g_(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const i=this.backend.numDataIds();let s=0;r.forEach(l=>{s+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=i-t-s-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const i=this.isTapeOn(),s=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=t3(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(t3(e)){const{kernelName:p,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=g_(p,this.backendName);U(y!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),a=()=>{const b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const _=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,b,_);const w=_.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(i){const S=this.getTensorsForGradient(p,m,w);r=this.saveTensorsForBackwardMode(S)}return w}}else{const{forwardFunc:p}=e,m=g=>{i&&(r=g.map(y=>this.keep(this.clone(y))))};a=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>p(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,g,y),y}}const{inputs:u,attrs:h}=e,f=t3(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(d=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),i&&this.addTapeNode(c,u,t,f,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(p=>u[p]!=null?u[p].shape:null),outputShapes:t.map(p=>p.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const i=rD(e);if(i!=null){const s=i.inputsToSave||[],o=i.outputsToSave||[];let a;i.saveAllInputs?(U(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(c=>t[c])):a=s.map(c=>t[c]);const l=r.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(e,t,r,i){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",i=i||this.backend;let s=e;r==="string"&&du(e[0])&&(s=e.map(l=>vu(l)));const o=i.write(s,t,r),a=new jn(t,r,o,this.nextTensorId());if(this.trackTensor(a,i),r==="string"){const l=this.state.tensorInfo.get(o),c=W7(s);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,t,r,i){r=r||"float32";const s={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(s,i)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:i,dtype:s}=e,o=new jn(i,s,r,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,r,i){r=r||this.nextVariableId().toString(),i!=null&&i!==e.dtype&&(e=e.cast(i));const s=new y_(e,t,r,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*h_(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof y_||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*h_(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,i,s,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:s},l=rD(e);l!=null&&(i=l.gradFunc),i!=null&&(a.gradient=c=>(c=c.map((u,h)=>{if(u==null){const f=r[h],d=js(f.size,f.dtype);return this.makeTensor(d,f.shape,f.dtype)}return u}),i(c.length>1?c:c[0],s,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=$f(e),r=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){const o=this.state.activeScope.track[s];!o.kept&&!r.has(o.id)&&o.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===i.id&&this.track(s)})}gradients(e,t,r,i=!1){if(U(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));U(s instanceof jn,()=>"The result y returned by f() must be a tensor.");const o=Xge(this.state.activeTape,t,s);if(!i&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[s.id]=r??iye(s.shape),Kge(a,o,c=>this.tidy(c),sye);const l=t.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(e){return U(Jd(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{U(t.every(a=>a instanceof jn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const i={};t.forEach((a,l)=>{i[l]=a});const s=(a,l)=>(r=e(...t,l),U(r.value instanceof jn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),U(Jd(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(a,l)=>{const c=r.gradFunc(a,l),u=Array.isArray(c)?c:[c];U(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),U(u.every(f=>f instanceof jn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((f,d)=>{h[d]=()=>f}),h};return this.runKernelFunc({forwardFunc:s,backwardsFunc:o,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=io(),r=await this.backend.time(e);return r.wallMs=io()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new jW;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};SL.nextTensorId=0;SL.nextVariableId=0;function iye(n){const e=wM(Ee(n),"float32");return ue.makeTensor(e,n,"float32")}function fX(){const n=q7();if(n._tfengine==null){const e=new j7(n);n._tfengine=new SL(e)}return kge(n._tfengine.ENV),Jge(()=>n._tfengine),n._tfengine}const ue=fX();function sye(n,e){const t={a:n,b:e};return ue.runKernel(_p,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oye(){return typeof navigator<"u"&&navigator!=null}let fD;function aye(n){fD=n}function CL(n){if(fD!==void 0)return fD;if(n||oye()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function kL(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const lye=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:kL,isMobile:CL,mockIsMobile:aye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xa=Ie();xa.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});xa.registerFlag("IS_BROWSER",()=>kL());xa.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");xa.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));xa.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));xa.registerFlag("PROD",()=>!1);xa.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>xa.getBool("DEBUG"));xa.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);xa.registerFlag("IS_TEST",()=>!1);xa.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>xa.getBool("DEBUG"));xa.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);xa.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);xa.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wh(n,e){let t=n;if(xs(n))return e==="string"?[]:[n.length];if(lX(n)){const i=n.channels||"RGBA";return[n.height,n.width*i.length]}else if(cX(n))return[n.buffer.size/(e==null?4:h_(e))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||xs(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&Ie().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&dX(n,r,[]),r}function dX(n,e,t){if(t=t||[],!Array.isArray(n)&&!xs(n)){U(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}U(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),U(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let i=0;i<n.length;++i)dX(n[i],r,t.concat(i))}function qW(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function j(n,e,t,r="numeric"){if(n instanceof jn)return qW(r,n.dtype,e,t),n;let i=xp(n);if(i!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(i=r),qW(r,i,e,t),n==null||!xs(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const s=wh(n,i);!xs(n)&&!Array.isArray(n)&&(n=[n]);const a=i!=="string"?Sp(n,i):Cc(n,[],!0);return ue.makeTensor(a,s,i)}function b_(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((s,o)=>j(s,`${e}[${o}]`,t,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TL="__op";function he(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+TL;const i=(...s)=>{ue.startScope(t);try{const o=r(...s);return Qd(o)&&console.error("Cannot return a Promise inside of tidy."),ue.endScope(o),o}catch(o){throw ue.endScope(null),o}};return Object.defineProperty(i,"name",{value:t,configurable:!0}),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cye(n,e){const t=j(n,"real","complex"),r=j(e,"imag","complex");qs(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const i={real:t,imag:r};return ue.runKernel(KS,i)}const Rf=he({complex_:cye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cp(n,e,t,r){if(r==null)r=xp(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(cX(n)||lX(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return ue.backend.createTensorFromGPUData(n,e||t,r)}if(!xs(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Ja(e);const i=Ee(e),s=Ee(t);U(i===s,()=>`Based on the provided shape, [${e}], the tensor should have ${i} values but has ${s}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Ee(e.slice(o)):!0;U(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!xs(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?Sp(n,r):Cc(n,[],!0),ue.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ts(n,e,t){const r=wh(n,t);return Cp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dD={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Ou{static join(e){return new Ou(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>xs(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let r=0;r<e.length;r++){const i=e[r];r!==e.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+i.byteLength;this.shards.push({buffer:i,start:t,end:s}),t=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const i=t-e,s=new ArrayBuffer(i),o=new Uint8Array(s);let a=0;for(let l=r;l<this.shards.length;l++){const c=this.shards[l],h=e+a-c.start,f=a,p=Math.min(t,c.end)-c.start,m=new Uint8Array(c.buffer,h,p-h);if(o.set(m,f),a+=m.length,t<c.end)break}return s}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(i){return e<i.start?-1:e>=i.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=uye(this.shards,t);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function uye(n,e){let t=0,r=n.length;for(;t<=r;){const i=Math.floor((r-t)/2)+t,s=e(n[i]);if(s===0)return i;s<0?r=i:t=i+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wI=4;async function pD(n,e){const t=[],r=[],i=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<i.length;++o){const a=i[o],l=Array.isArray(n)?n[o].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const u=new Promise(async h=>{const f=await l.bytes(),d=f.reduce((g,y)=>g+y.length,0)+wI*f.length,p=new Uint8Array(d);let m=0;for(let g=0;g<f.length;g++){const y=f[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);p.set(b,m),m+=wI,p.set(y,m),m+=y.length}h(p)});r.push(u)}else r.push(l.data());e!=null&&(c.group=e),t.push(c)}const s=await Promise.all(r);return{data:hye(s),specs:t}}function EL(n,e){const t=new Ou(n),r={};let i,s=0;for(const o of e){const a=o.name,l=o.dtype,c=o.shape,u=Ee(c);let h;if("quantization"in o){const f=o.quantization;if(f.dtype==="uint8"||f.dtype==="uint16"){if(!("min"in f&&"scale"in f))throw new Error(`Weight ${o.name} with quantization ${f.dtype} doesn't have corresponding metadata min and scale.`)}else if(f.dtype==="float16"){if(l!=="float32")throw new Error(`Weight ${o.name} is quantized with ${f.dtype} which only supports weights of type float32 not ${l}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${f.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const d=dD[f.dtype],p=t.slice(s,s+u*d),m=f.dtype==="uint8"?new Uint8Array(p):new Uint16Array(p);if(l==="float32")if(f.dtype==="uint8"||f.dtype==="uint16"){h=new Float32Array(m.length);for(let g=0;g<m.length;g++){const y=m[g];h[g]=y*f.scale+f.min}}else if(f.dtype==="float16")i===void 0&&(i=yye()),h=i(m);else throw new Error(`Unsupported quantization type ${f.dtype} for weight type float32.`);else if(l==="int32"){if(f.dtype!=="uint8"&&f.dtype!=="uint16")throw new Error(`Unsupported quantization type ${f.dtype} for weight type int32.`);h=new Int32Array(m.length);for(let g=0;g<m.length;g++){const y=m[g];h[g]=Math.round(y*f.scale+f.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${l}`);s+=u*d}else if(l==="string"){const f=Ee(o.shape);h=[];for(let d=0;d<f;d++){const p=new Uint32Array(t.slice(s,s+wI))[0];s+=wI;const m=new Uint8Array(t.slice(s,s+p));h.push(m),s+=p}}else{const f=dD[l],d=t.slice(s,s+u*f);if(l==="float32")h=new Float32Array(d);else if(l==="int32")h=new Int32Array(d);else if(l==="bool")h=new Uint8Array(d);else if(l==="complex64"){h=new Float32Array(d);const p=new Float32Array(h.length/2),m=new Float32Array(h.length/2);for(let b=0;b<p.length;b++)p[b]=h[b*2],m[b]=h[b*2+1];const g=Ts(p,c,"float32"),y=Ts(m,c,"float32");r[a]=Rf(g,y),g.dispose(),y.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${l}`);s+=u*f}l!=="complex64"&&(r[a]=Ts(h,c,l))}return r}function hye(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(s=>{if(e+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});const r=new Uint8Array(e);let i=0;return t.forEach(s=>{r.set(new Uint8Array(s.buffer),i),i+=s.byteLength}),r.buffer}const IL=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function XW(n){return IL?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function fye(n){if(IL)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let r=0,i=e.length;r<i;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function dye(n){if(IL){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function pX(n){return Ou.join(n)}function KW(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function mX(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function AL(n,e,t){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(r.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=t}return n.signature!=null&&(r.signature=n.signature),n.userDefinedMetadata!=null&&(r.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(r.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(r.initializerSignature=n.initializerSignature),r}async function ML(n,e){let t,r;return n.weightsManifest!=null&&([t,r]=await e(n.weightsManifest)),AL(n,t,r)}function W2(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:XW(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:XW(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Ou(n.weightData).byteLength}}function NL(n){const e=[];for(const t of n)e.push(...t.weights);return e}function pye(){const n=t=>{let r=t<<13,i=0;for(;!(r&8388608);)i-=8388608,r<<=1;return r&=-8388609,i+=947912704,r|i},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function mye(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function gye(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function yye(){const n=pye(),e=mye(),t=gye();return r=>{const i=new ArrayBuffer(4*r.length),s=new Uint32Array(i);for(let o=0;o<r.length;o++){const a=r[o],l=n[t[a>>10]+(a&1023)]+e[a>>10];s[o]=l}return new Float32Array(i)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _i{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return _i.instance==null&&(_i.instance=new _i),_i.instance}static registerSaveRouter(e){_i.getInstance().saveRouters.push(e)}static registerLoadRouter(e){_i.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return _i.getHandlers(e,"save")}static getLoadHandlers(e,t){return _i.getHandlers(e,"load",t)}static getHandlers(e,t,r){const i=[];return(t==="load"?_i.getInstance().loadRouters:_i.getInstance().saveRouters).forEach(o=>{const a=o(e,r);a!==null&&i.push(a)}),i}}const bye=n=>_i.registerSaveRouter(n),vye=n=>_i.registerLoadRouter(n),gX=n=>_i.getSaveHandlers(n),yX=(n,e)=>_i.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mD="tensorflowjs",gD=1,Om="models_store",Td="model_info_store";function bX(){if(!Ie().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function yD(n){const e=n.result;e.createObjectStore(Om,{keyPath:"modelPath"}),e.createObjectStore(Td,{keyPath:"modelPath"})}class tg{constructor(e){if(this.indexedDB=bX(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,i)=>{const s=this.indexedDB.open(mD,gD);s.onupgradeneeded=()=>yD(s),s.onsuccess=()=>{const o=s.result;if(t==null){const a=o.transaction(Om,"readonly"),c=a.objectStore(Om).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(c.result.modelArtifacts)},c.onerror=u=>(o.close(),i(c.error)),a.oncomplete=()=>o.close()}else{t.weightData=Ou.join(t.weightData);const a=W2(t),l=o.transaction(Td,"readwrite");let c=l.objectStore(Td),u;try{u=c.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(f){return i(f)}let h;u.onsuccess=()=>{h=o.transaction(Om,"readwrite");const f=h.objectStore(Om);let d;try{d=f.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(p){return i(p)}d.onsuccess=()=>r({modelArtifactsInfo:a}),d.onerror=p=>{c=l.objectStore(Td);const m=c.delete(this.modelPath);m.onsuccess=()=>(o.close(),i(d.error)),m.onerror=g=>(o.close(),i(d.error))}},u.onerror=f=>(o.close(),i(u.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},s.onerror=o=>i(s.error)})}}tg.URL_SCHEME="indexeddb://";const vX=n=>Ie().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(tg.URL_SCHEME)?wye(n.slice(tg.URL_SCHEME.length)):null;_i.registerSaveRouter(vX);_i.registerLoadRouter(vX);function wye(n){return new tg(n)}function xye(n){return n.startsWith(tg.URL_SCHEME)?n.slice(tg.URL_SCHEME.length):n}class _ye{constructor(){this.indexedDB=bX()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(mD,gD);r.onupgradeneeded=()=>yD(r),r.onsuccess=()=>{const i=r.result,s=i.transaction(Td,"readonly"),a=s.objectStore(Td).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},a.onerror=l=>(i.close(),t(a.error)),s.oncomplete=()=>i.close()},r.onerror=i=>t(r.error)})}async removeModel(e){return e=xye(e),new Promise((t,r)=>{const i=this.indexedDB.open(mD,gD);i.onupgradeneeded=()=>yD(i),i.onsuccess=()=>{const s=i.result,o=s.transaction(Td,"readwrite"),a=o.objectStore(Td),l=a.get(e);let c;l.onsuccess=()=>{if(l.result==null)return s.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=a.delete(e),h=()=>{c=s.transaction(Om,"readwrite");const d=c.objectStore(Om).delete(e);d.onsuccess=()=>t(l.result.modelArtifactsInfo),d.onerror=p=>r(l.error)};u.onsuccess=h,u.onerror=f=>(h(),s.close(),r(l.error))}},l.onerror=u=>(s.close(),r(l.error)),o.oncomplete=()=>{c==null?s.close():c.oncomplete=()=>s.close()}},i.onerror=s=>r(i.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cf="/",hb="tensorflowjs_models",wX="info",Sye="model_topology",Cye="weight_specs",kye="weight_data",Tye="model_metadata";function xX(n){return{info:[hb,n,wX].join(Cf),topology:[hb,n,Sye].join(Cf),weightSpecs:[hb,n,Cye].join(Cf),weightData:[hb,n,kye].join(Cf),modelMetadata:[hb,n,Tye].join(Cf)}}function _X(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function Eye(n){const e=n.split(Cf);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Cf)}function Iye(n){return n.startsWith(ng.URL_SCHEME)?n.slice(ng.URL_SCHEME.length):n}class ng{constructor(e){if(!Ie().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=xX(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),i=W2(e),s=Ou.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,fye(s));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:i}}catch{throw _X(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=i;const s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){const a=JSON.parse(s);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=dye(o),t}}ng.URL_SCHEME="localstorage://";const SX=n=>Ie().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ng.URL_SCHEME)?Aye(n.slice(ng.URL_SCHEME.length)):null;_i.registerSaveRouter(SX);_i.registerLoadRouter(SX);function Aye(n){return new ng(n)}class Mye{constructor(){U(Ie().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),U(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=hb+Cf,r=Cf+wX;for(let i=0;i<this.LS.length;++i){const s=this.LS.key(i);if(s.startsWith(t)&&s.endsWith(r)){const o=Eye(s);e[o]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=Iye(e);const t=xX(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(t.info));return _X(t),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eb="://";class Vo{constructor(){this.managers={}}static getInstance(){return Vo.instance==null&&(Vo.instance=new Vo),Vo.instance}static registerManager(e,t){U(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Eb)&&(e=e.slice(0,e.indexOf(Eb))),U(e.length>0,()=>"scheme must not be an empty string.");const r=Vo.getInstance();U(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=Vo.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Vo.getInstance().managers)}}function NE(n){if(n.indexOf(Eb)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Vo.getSchemes().join(",")}`);return{scheme:n.split(Eb)[0],path:n.split(Eb)[1]}}async function CX(n,e,t=!1){U(n!==e,()=>`Old path and new path are the same: '${n}'`);const r=_i.getLoadHandlers(n);U(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),U(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const i=r[0],s=_i.getSaveHandlers(e);U(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),U(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=s[0],a=NE(n).scheme,l=NE(n).path,c=a===NE(n).scheme,u=await i.load();t&&c&&await Vo.getManager(a).removeModel(l);const h=await o.save(u);return t&&!c&&await Vo.getManager(a).removeModel(l),h.modelArtifactsInfo}async function $L(){const n=Vo.getSchemes(),e={};for(const t of n){const r=await Vo.getManager(t).listModels();for(const i in r){const s=t+Eb+i;e[s]=r[i]}}return e}async function RL(n){const e=NE(n);return Vo.getManager(e.scheme).removeModel(e.path)}async function Nye(n,e){return CX(n,e,!1)}async function $ye(n,e){return CX(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rye{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!Ie().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const i=this.functionRefs[r.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return Z7(e)}}if(Ie().get("IS_BROWSER")){Ie().setPlatform("browser",new Rye);try{Vo.registerManager(ng.URL_SCHEME,new Mye)}catch{}try{Vo.registerManager(tg.URL_SCHEME,new _ye)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pye={importFetch:()=>require("node-fetch")};let n3;class Dye{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return Ie().global.fetch!=null?Ie().global.fetch(e,t):(n3==null&&(n3=Pye.importFetch()),n3(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}Ie().get("IS_NODE")&&!Ie().get("IS_BROWSER")&&Ie().setPlatform("node",new Dye);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sn(n,e="float32",t){return e=e||"float32",Ja(n),new ls(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oye(n,e){const t=j(n,"x","cast");if(!U7(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},i={dtype:e};return ue.runKernel(Vg,r,i)}const St=he({cast_:Oye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fye(n){const t={x:j(n,"x","clone","string_or_numeric")};return ue.runKernel(ey,t)}const mh=he({clone_:Fye});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PL(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */fX();const Lye={buffer:Sn,cast:St,clone:mh,print:PL};Qge(Lye);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zye(){Ie().set("PROD",!0)}function Bye(){Ie().set("DEBUG",!0)}function Vye(){Ie().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Uye(n){Ie().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Wye(){ue.disposeVariables()}function wo(){return ue}function xI(){return ue.memory()}function Hye(n){return ue.profile(n)}function Se(n,e){return ue.tidy(n,e)}function nn(n){$f(n).forEach(t=>t.dispose())}function qi(n){return ue.keep(n)}function Gye(n){return ue.time(n)}function jye(n){return ue.setBackend(n)}function H2(){return ue.ready()}function v_(){return ue.backendName}function qye(n){ue.removeBackend(n)}function Xye(n){return ue.findBackend(n)}function Kye(n){return ue.findBackendFactory(n)}function NM(n,e,t=1){return ue.registerBackend(n,e,t)}function rg(){return ue.backend}function Yye(n,e){Ie().setPlatform(n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zye(n,e){let t=j(n,"a","add"),r=j(e,"b","add");[t,r]=ki(t,r);const i={a:t,b:r};return ue.runKernel(_p,i)}const Xe=he({add_:Zye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jye(n,e){let t=j(n,"a","floorDiv"),r=j(e,"b","floorDiv");[t,r]=ki(t,r);const i={a:t,b:r};return ue.runKernel(Jg,i)}const DL=he({floorDiv_:Jye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qye(n,e){let t=j(n,"a","div"),r=j(e,"b","div");if([t,r]=ki(t,r),t.dtype==="int32"&&r.dtype==="int32")return DL(t,r);const i={a:t,b:r},s={};return ue.runKernel(jg,i,s)}const Lt=he({div_:Qye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e0e(n,e){let t=j(n,"a","mul"),r=j(e,"b","mul");[t,r]=ki(t,r);const i={a:t,b:r};return ue.runKernel(cy,i)}const fe=he({mul_:e0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t0e(n){const e=j(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return ue.runKernel(Pv,t)}else{const t={x:e};return ue.runKernel(Tv,t)}}const vs=he({abs_:t0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n0e(n){const t={x:j(n,"x","acos")};return ue.runKernel(Pg,t)}const kX=he({acos_:n0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r0e(n){const t={x:j(n,"x","acosh")};return ue.runKernel(Dg,t)}const TX=he({acosh_:r0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i0e(n){U(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),U(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((i,s)=>j(i,`tensors${s}`,"addN")),t=e[0];e.forEach(i=>{if(i.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(i=>{if(!Rn(i.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return ue.runKernel(Ev,r)}const EX=he({addN_:i0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s0e(n,e=null,t=!1){const i={x:j(n,"x","all","bool")},s={axis:e,keepDims:t};return ue.runKernel(US,i,s)}const OL=he({all_:s0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o0e(n,e=null,t=!1){const i={x:j(n,"x","any","bool")},s={axis:e,keepDims:t};return ue.runKernel(WS,i,s)}const _I=he({any_:o0e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a0e(n,e=0){const r={x:j(n,"x","argMax")},i={axis:e};return ue.runKernel(Iv,r,i)}const ig=he({argMax_:a0e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l0e(n,e=0){const r={x:j(n,"x","argMin")},i={axis:e};return ue.runKernel(Av,r,i)}const IX=he({argMin_:l0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c0e(n){const t={x:j(n,"x","asin")};return ue.runKernel(Og,t)}const AX=he({asin_:c0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u0e(n){const t={x:j(n,"x","asinh")};return ue.runKernel(Fg,t)}const MX=he({asinh_:u0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h0e(n){const t={x:j(n,"x","atan")};return ue.runKernel(Lg,t)}const NX=he({atan_:h0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f0e(n,e){let t=j(n,"a","atan2"),r=j(e,"b","atan2");[t,r]=ki(t,r);const i={a:t,b:r};return ue.runKernel(Bg,i)}const $X=he({atan2_:f0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d0e(n){const t={x:j(n,"x","atanh")};return ue.runKernel(zg,t)}const RX=he({atanh_:d0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kp(n,e,t,r,i="NHWC",s){const o=n[3],a=[...e,o],l=el(i);return ti(n,a,t,s,r,null,null,l)}function ko(n,e,t,r,i,s,o="channelsLast"){const[a,l]=w_(e);let c;if(o==="channelsLast")c=[a,l,n[3],n[3]];else if(o==="channelsFirst")c=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return ti(n,c,t,r,i,s,!1,o)}function Ll(n,e,t,r,i,s,o="NDHWC"){const[a,l,c]=bD(e);let u,h;if(o==="NDHWC")h="channelsLast",u=[a,l,c,n[4],n[4]];else if(o==="NCDHW")h="channelsFirst",u=[a,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Fu(n,u,t,r,i,!1,h,s)}function ti(n,e,t,r,i,s,o=!1,a="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,h]=n;else if(a==="channelsFirst")[l,h,c,u]=n;else throw new Error(`Unknown dataFormat ${a}`);const[f,d,,p]=e,[m,g]=w_(t),[y,b]=w_(r),_=Ib(f,y),w=Ib(d,b),{padInfo:S,outHeight:C,outWidth:k}=g0e(i,c,u,m,g,_,w,s,a),A=o?p*h:p;let M;return a==="channelsFirst"?M=[l,A,C,k]:a==="channelsLast"&&(M=[l,C,k,A]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:h,outHeight:C,outWidth:k,outChannels:A,padInfo:S,strideHeight:m,strideWidth:g,filterHeight:f,filterWidth:d,effectiveFilterHeight:_,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:n,outShape:M,filterShape:e}}function Fu(n,e,t,r,i,s=!1,o="channelsLast",a){let[l,c,u,h,f]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,u,h,f]=n;else if(o==="channelsFirst")[l,f,c,u,h]=n;else throw new Error(`Unknown dataFormat ${o}`);const[d,p,m,,g]=e,[y,b,_]=bD(t),[w,S,C]=bD(r),k=Ib(d,w),A=Ib(p,S),M=Ib(m,C),{padInfo:E,outDepth:N,outHeight:O,outWidth:R}=y0e(i,c,u,h,y,b,_,k,A,M,a),D=s?g*f:g;let z;return o==="channelsFirst"?z=[l,D,N,O,R]:o==="channelsLast"&&(z=[l,N,O,R,D]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:f,outDepth:N,outHeight:O,outWidth:R,outChannels:D,padInfo:E,strideDepth:y,strideHeight:b,strideWidth:_,filterDepth:d,filterHeight:p,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:A,effectiveFilterWidth:M,dilationDepth:w,dilationHeight:S,dilationWidth:C,inShape:n,outShape:z,filterShape:e}}function p0e(n,e,t,r,i){r==null&&(r=FL(n,e,t));const s=n[0],o=n[1],a=x_((s-e+2*r)/t+1,i),l=x_((o-e+2*r)/t+1,i);return[a,l]}function m0e(n,e,t,r,i,s){i==null&&(i=FL(n,e[0],r[0]));const o=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*i>=e[a]&&(o[a]=x_((n[a]-e[a]+2*i)/r[a]+1,s));return o}function FL(n,e,t,r=1){const i=Ib(e,r);return Math.floor((n[0]*(t-1)-t+i)/2)}function w_(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function bD(n){return typeof n=="number"?[n,n,n]:n}function Ib(n,e){return e<=1?n:n+(n-1)*(e-1)}function g0e(n,e,t,r,i,s,o,a,l){let c,u,h;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const d=p0e([e,t],s,r,n,a);u=d[0],h=d[1]}else if(n==="same"){u=Math.ceil(e/r),h=Math.ceil(t/i);const f=Math.max(0,(u-1)*r+s-e),d=Math.max(0,(h-1)*i+o-t),p=Math.floor(f/2),m=f-p,g=Math.floor(d/2),y=d-g;c={top:p,bottom:m,left:g,right:y,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-s+1)/r),h=Math.ceil((t-o+1)/i);else if(typeof n=="object"){const f=l==="channelsLast"?n[1][0]:n[2][0],d=l==="channelsLast"?n[1][1]:n[2][1],p=l==="channelsLast"?n[2][0]:n[3][0],m=l==="channelsLast"?n[2][1]:n[3][1];c={top:f,bottom:d,left:p,right:m,type:f===0&&d===0&&p===0&&m===0?"VALID":"EXPLICIT"},u=x_((e-s+f+d)/r+1,a),h=x_((t-o+p+m)/i+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:u,outWidth:h}}function y0e(n,e,t,r,i,s,o,a,l,c,u){let h,f,d,p;if(n==="valid"&&(n=0),typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const g=m0e([e,t,r,1],[a,l,c],1,[i,s,o],n,u);f=g[0],d=g[1],p=g[2]}else if(n==="same"){f=Math.ceil(e/i),d=Math.ceil(t/s),p=Math.ceil(r/o);const m=(f-1)*i+a-e,g=(d-1)*s+l-t,y=(p-1)*o+c-r,b=Math.floor(m/2),_=m-b,w=Math.floor(g/2),S=g-w,C=Math.floor(y/2),k=y-C;h={top:w,bottom:S,left:C,right:k,front:b,back:_,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:f,outHeight:d,outWidth:p}}function x_(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function ep(n){const[e,t,r]=w_(n);return e===1&&t===1&&r===1}function $s(n,e){return ep(n)||ep(e)}function sg(n){return w_(n).every(e=>e>0)}function el(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function na(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")U(eg(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(i=>{U(eg(i),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${i}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b0e(n,e){const r={x:j(n,"x","reshape","string_or_numeric")},i={shape:e};return ue.runKernel(pw,r,i)}const ve=he({reshape_:b0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v0e(n,e,t,r,i){const s=j(n,"x","avgPool","float32"),o=1;U($s(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=s,l=!1;s.rank===3&&(l=!0,a=ve(s,[1,s.shape[0],s.shape[1],s.shape[2]])),U(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),na("avgPool",r,i);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:i};let h=ue.runKernel(Mv,c,u);return h=St(h,s.dtype),l?ve(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const $M=he({avgPool_:v0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0e(n,e,t,r,i,s="NDHWC"){const o=j(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),U(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),U(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),na("avgPool3d",r,i);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:i,dataFormat:s};let h=ue.runKernel(Nv,c,u);return h=St(h,a.dtype),l?ve(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const LL=he({avgPool3d_:w0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x0e(n,e=0){U(n.length>=1,()=>"Pass at least one tensor to concat");const t=b_(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return mh(t[0]);const r=t,i={axis:e};return ue.runKernel(Dv,r,i)}const li=he({concat_:x0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _0e(n,e,t=!1,r=!1){let i=j(n,"a","matMul"),s=j(e,"b","matMul");[i,s]=ki(i,s);const o={a:i,b:s},a={transposeA:t,transposeB:r};return ue.runKernel($v,o,a)}const Gn=he({matMul_:_0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S0e(n){const t={x:j(n,"x","sigmoid","float32")};return ue.runKernel(wy,t)}const Il=he({sigmoid_:S0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C0e(n,e,t){const r=j(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const i={x:r},s={begin:e,size:t};return ue.runKernel(vw,i,s)}const pn=he({slice_:C0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k0e(n){const t={x:j(n,"x","tanh","float32")};return ue.runKernel(Ty,t)}const jb=he({tanh_:k0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T0e(n,e,t,r,i,s){const o=j(n,"forgetBias","basicLSTMCell"),a=j(e,"lstmKernel","basicLSTMCell"),l=j(t,"lstmBias","basicLSTMCell"),c=j(r,"data","basicLSTMCell"),u=j(i,"c","basicLSTMCell"),h=j(s,"h","basicLSTMCell"),f=li([c,h],1),d=Gn(f,a),p=Xe(d,l),m=p.shape[0],g=p.shape[1]/4,y=[m,g],b=pn(p,[0,0],y),_=pn(p,[0,g],y),w=pn(p,[0,g*2],y),S=pn(p,[0,g*3],y),C=Xe(fe(Il(b),jb(_)),fe(u,Il(Xe(o,w)))),k=fe(jb(C),Il(S));return[C,k]}const PX=he({basicLSTMCell_:T0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E0e(n,e,t){const r=j(n,"x","batchToSpaceND"),i=e.reduce((a,l)=>a*l);U(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),U(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),U(r.shape[0]%i===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`);const s={x:r},o={blockShape:e,crops:t};return ue.runKernel(Rv,s,o)}const RM=he({batchToSpaceND_:E0e});function I0e(n){let e;return n.rank===0||n.rank===1?e=ve(n,[1,1,1,n.size]):n.rank===2?e=ve(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=ve(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0e(n,e,t,r,i,s){s==null&&(s=.001);const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;i!=null&&(c=j(i,"scale","batchNorm"));let u;r!=null&&(u=j(r,"offset","batchNorm")),U(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:I0e(o),scale:c,offset:u,mean:a,variance:l},d={varianceEpsilon:s},p=ue.runKernel(Hv,f,d);return ve(p,o.shape)}const G2=he({batchNorm_:A0e});function M0e(n,e,t,r,i,s){const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;i!=null&&(c=j(i,"scale","batchNorm"));let u;return r!=null&&(u=j(r,"offset","batchNorm")),U(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),U(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),U(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&U(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&U(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),G2(o,a,l,u,c,s)}const zL=he({batchNorm2d_:M0e});function N0e(n,e,t,r,i,s){const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;i!=null&&(c=j(i,"scale","batchNorm"));let u;return r!=null&&(u=j(r,"offset","batchNorm")),U(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),U(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),U(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&U(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&U(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),G2(o,a,l,u,c,s)}const BL=he({batchNorm3d_:N0e});function $0e(n,e,t,r,i,s){const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;i!=null&&(c=j(i,"scale","batchNorm"));let u;return r!=null&&(u=j(r,"offset","batchNorm")),U(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),U(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),U(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&U(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&U(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),G2(o,a,l,u,c,s)}const VL=he({batchNorm4d_:$0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R0e(n,e,t){const r=j(n,"x","bincount"),i=j(e,"weights","bincount");U(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),U(t>=0,()=>`size must be non-negative, but got ${t}.`),U(i.size===r.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${i.shape}.`);const s={x:r,weights:i},o={size:t};return ue.runKernel(jS,s,o)}const UL=he({bincount_:R0e});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P0e(n,e){const t=j(n,"x","bitwiseAnd"),r=j(e,"y","bitwiseAnd");if(!Rn(t.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${r.shape}`);if(t.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${r.dtype}`);const i={a:t,b:r};return ue.runKernel(qS,i)}const DX=he({bitwiseAnd_:P0e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D0e(n,e){const t=j(n,"s0","broadcastArgs","int32"),r=j(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const i={s0:t,s1:r};return ue.runKernel(XS,i)}const OX=he({broadcastArgs_:D0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O0e(n,e){let t=j(n,"broadcastTo","x");const r=t.shape;if(Ja(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=ve(t,c)}const i=t.shape,s=Array.from(e);for(let c=e.length-1;c>=0;c--)if(i[c]===e[c])s[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(s.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length===0)return mh(t);const a={x:t},l={reps:s};return ue.runKernel(Ey,a,l)}const Ab=he({broadcastTo_:O0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F0e(n){const t={x:j(n,"x","ceil","float32")};return ue.runKernel(Ug,t)}const FX=he({ceil_:F0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $y(n,e,t){Ja(n),t=t||xp(e);const r={shape:n,value:e,dtype:t};return ue.runKernel(u2,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L0e(n,e,t){const r=j(n,"x","clipByValue");if(U(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return $y(r.shape,e,r.dtype);const i={x:r},s={clipValueMin:e,clipValueMax:t};return ue.runKernel(Wg,i,s)}const _a=he({clipByValue_:L0e});function z0e(n){return li(n,0)}const WL=he({concat1d_:z0e});function B0e(n,e){return li(n,e)}const HL=he({concat2d_:B0e});function V0e(n,e){return li(n,e)}const GL=he({concat3d_:V0e});function U0e(n,e){return li(n,e)}const jL=he({concat4d_:U0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W0e(n,e,t,r,i="NHWC",s=[1,1],o){const a=j(n,"x","conv2d","float32"),l=j(e,"filter","conv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),U(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),na("conv2d",r,o);const h=i==="NHWC"?c.shape[3]:c.shape[1];U(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),U($s(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),U(sg(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),U(sg(t),()=>"Error in conv2D: Strides should be larger than 0.");const f={x:c,filter:l},d={strides:t,pad:r,dataFormat:i,dilations:s,dimRoundingMode:o},p=ue.runKernel(Ov,f,d);return u?ve(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const tp=he({conv2d_:W0e});function H0e(n,e,t,r,i="NWC",s=1,o){const a=j(n,"x","conv1d"),l=j(e,"filter","conv1d");let c=a,u=!1;a.rank===2&&(u=!0,c=ve(a,[1,a.shape[0],a.shape[1]])),U(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),U(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),na("conv1d",r,o),U(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),U($s(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),U(sg(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),U(sg(t),()=>"Error in conv1D: Stride should be larger than 0."),U(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const h=ve(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=ve(c,[c.shape[0],1,c.shape[1],c.shape[2]]),g=tp(f,h,[1,t],r,"NHWC",[1,s],o);return u?ve(g,[g.shape[2],g.shape[3]]):ve(g,[g.shape[0],g.shape[2],g.shape[3]])}const qL=he({conv1d_:H0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G0e(n,e,t,r,i,s="NHWC",o){U(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,c=!1;e.rank===3&&(c=!0,l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),U(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),U(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),U(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const u=s==="NHWC"?a[3]:a[1],h=s==="NHWC"?l.shape[3]:l.shape[1];U(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),U(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),na("conv2dDerInput",i,o);const f={dy:l,filter:t},d={strides:r,pad:i,dataFormat:s,dimRoundingMode:o,inputShape:a},p=ue.runKernel(Fv,f,d);return c?ve(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const XL=he({conv2DBackpropInput_:G0e});function j0e(n,e,t,r,i,s){const o=j(n,"x","conv2dTranspose"),a=j(e,"filter","conv2dTranspose");return XL(t,o,a,r,i,"NHWC",s)}const KL=he({conv2dTranspose_:j0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q0e(n,e,t,r,i="NDHWC",s=[1,1,1]){const o=j(n,"x","conv3d"),a=j(e,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),U(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),U(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),U($s(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),U(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),U(sg(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),U(sg(t),()=>"Error in conv3D: Strides should be larger than 0.");const u={x:l,filter:a},h={strides:t,pad:r,dataFormat:i,dilations:s},f=ue.runKernel(Lv,u,h);return c?ve(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const YL=he({conv3d_:q0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X0e(n,e,t,r,i){U(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let s=n,o=e,a=!1;e.rank===4&&(a=!0,o=ve(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,n[0],n[1],n[2],n[3]]);const l=s[4],c=o.shape[4];U(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),U(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),U(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),U(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),U(c===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[4]}.`);const u={dy:o,filter:t},h={pad:i,strides:r,inputShape:s},f=ue.runKernel(JS,u,h);return a?ve(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const LX=he({conv3DBackpropInput_:X0e});function K0e(n,e,t,r,i){const s=j(n,"x","conv3dTranspose"),o=j(e,"filter","conv3dTranspose");return LX(t,s,o,r,i)}const ZL=he({conv3dTranspose_:K0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y0e(n){const t={x:j(n,"x","cos","float32")};return ue.runKernel(Hg,t)}const PM=he({cos_:Y0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z0e(n){const t={x:j(n,"x","cosh","float32")};return ue.runKernel(Gg,t)}const JL=he({cosh_:Z0e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J0e(n,e=0,t=!1,r=!1){const s={x:j(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:r};return ue.runKernel(QS,s,o)}const SI=he({cumprod_:J0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q0e(n,e=0,t=!1,r=!1){const s={x:j(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:r};return ue.runKernel(zv,s,o)}const QL=he({cumsum_:Q0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ebe(n,e,t,r=!1){const i=j(n,"x","denseBincount"),s=j(e,"weights","denseBincount");U(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),U(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),U(t>=0,()=>`size must be non-negative, but got ${t}.`),U(s.size===i.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${s.shape}.`);const o={x:i,weights:s},a={size:t,binaryOutput:r};return ue.runKernel(t2,o,a)}const CI=he({denseBincount_:ebe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tbe(n,e,t="NHWC"){const r=j(n,"x","depthToSpace","float32"),i=t==="NHWC"?r.shape[1]:r.shape[2],s=t==="NHWC"?r.shape[2]:r.shape[3],o=t==="NHWC"?r.shape[3]:r.shape[1];U(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),U(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e}  for depthToSpace with input shape
    ${r.shape}`),U(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${r.shape}`),U(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`);const a={x:r},l={blockSize:e,dataFormat:t};return ue.runKernel(n2,a,l)}const zX=he({depthToSpace_:tbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nbe(n,e,t,r,i="NHWC",s=[1,1],o){const a=j(n,"x","depthwiseConv2d","float32"),l=j(e,"filter","depthwiseConv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),U(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=i==="NHWC"?c.shape[3]:c.shape[1];U(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),na("depthwiseConv2d",r,o);const f={x:c,filter:l},d={strides:t,pad:r,dataFormat:i,dilations:s,dimRoundingMode:o},p=ue.runKernel(Bv,f,d);return u?ve(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const j2=he({depthwiseConv2d_:nbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rbe(n){const t={x:j(n,"x","diag")};return ue.runKernel(s2,t)}const BX=he({diag_:rbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ibe(n,e,t,r,i=[1,1],s="NHWC"){const o=j(n,"x","dilation2d"),a=j(e,"filter","dilation2d");U(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),U(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),U(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=o,c=!1;o.rank===3&&(l=ve(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),U(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const u={x:l,filter:a},h={strides:t,pad:r,dilations:i},f=ue.runKernel(Vv,u,h);return c?ve(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const VX=he({dilation2d_:ibe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pf(n,e){const t=n.length,r=[];for(let i=0;i<t;i++){const s=t-1-i,o=n[s]||1;(e[e.length-1-i]||1)>1&&o===1&&r.unshift(s)}return r}function us(n,e){const t=[];for(let r=0;r<e.length;r++){const i=n[n.length-r-1],s=e.length-r-1,o=e[s];(i==null||i===1&&o>1)&&t.unshift(s)}return t}function ln(n,e){const t=Math.max(n.length,e.length),r=new Array(t);for(let i=0;i<t;i++){let s=n[n.length-i-1];s==null&&(s=1);let o=e[e.length-i-1];if(o==null&&(o=1),s===1)r[t-i-1]=o;else if(o===1)r[t-i-1]=s;else if(s!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else r[t-i-1]=s}return r}const sbe=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:ln,getBroadcastDims:Pf,getReductionAxes:us},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function obe(n,e){let t=j(n,"a","equal","string_or_numeric"),r=j(e,"b","equal","string_or_numeric");[t,r]=ki(t,r),ln(t.shape,r.shape);const i={a:t,b:r};return ue.runKernel(Uv,i)}const xu=he({equal_:obe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function abe(n,e,t){const r=j(e,"a","where"),i=j(t,"b","where"),s=j(n,"condition","where","bool"),o=ln(ln(s.shape,r.shape),i.shape),a=Ab(s,o),l=Ab(r,o),c=Ab(i,o),u={condition:a,t:l,e:c};return ue.runKernel(bw,u)}const xo=he({where_:abe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lbe(n){const t={x:j(n,"x","zerosLike")};return ue.runKernel(Tw,t)}const ur=he({zerosLike_:lbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cbe(n,e){let t=j(n,"a","div"),r=j(e,"b","div");[t,r]=ki(t,r);const i=Lt(t,r),s=ur(i),o=xu(r,s);return xo(o,s,i)}const UX=he({divNoNan_:cbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ube(n,e){const t=j(n,"t1","dot"),r=j(e,"t2","dot");U((t.rank===1||t.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);const i=t.rank===1?t.size:t.shape[1],s=r.rank===1?r.size:r.shape[0];if(U(i===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${s}.`),t.rank===1&&r.rank===1){const o=ve(t,[1,-1]),a=ve(r,[-1,1]),l=Gn(o,a);return ve(l,[])}else if(t.rank===1&&r.rank===2){const o=ve(t,[1,-1]),a=ve(r,[r.shape[0],r.shape[1]]),l=Gn(o,a);return ve(l,[l.size])}else if(t.rank===2&&r.rank===1){const o=ve(r,[-1,1]),a=Gn(t,o);return ve(a,[a.size])}else{const o=ve(r,[r.shape[0],r.shape[1]]);return Gn(t,o)}}const WX=he({dot_:ube});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hbe(n,...e){const t=e.map((i,s)=>j(i,`tensors${s}`,"einsum")),r={equation:n};return ue.runKernel(a2,t,r)}const Am=he({einsum_:hbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fbe(n){const t={x:j(n,"x","elu","float32")};return ue.runKernel(qg,t)}const q2=he({elu_:fbe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dbe(n,e){const t=j(n,"x","ensureShape","string_or_numeric");if(!B7(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const HX=he({ensureShape_:dbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pbe(n){let e=j(n,"x","erf");U(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=St(e,"float32"));const t={x:e};return ue.runKernel(Xg,t)}const GX=he({erf_:pbe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ez(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function jX(n,e,t){const r=n.length+e.length,i=[];let s=0,o=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?i.push(n[s++]):i.push(e[o++]);return i}function Ji(n,e){const t=[],r=n.length;for(let s=0;s<r;s++)e.indexOf(s)===-1&&t.push(n[s]);const i=e.map(s=>n[s]);return[t,i]}function Fi(n,e){const t=e.map(r=>1);return jX(n,t,e)}function hs(n,e,t){U(ez(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Lr(n,e){if(ez(n,e))return null;const t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function Ph(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function ni(n,e){const t=[];for(let r=e-n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mbe(n,e=null,t=!1){const i={x:j(n,"x","max")},s={reductionIndices:e,keepDims:t};return ue.runKernel(ew,i,s)}const vc=he({max_:mbe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gbe(n,e=null,t=!1){const i={x:j(n,"x","min")},s={axis:e,keepDims:t};return ue.runKernel(iw,i,s)}const __=he({min_:gbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ybe(n,e){let t=j(n,"base","pow"),r=j(e,"exp","pow");[t,r]=ki(t,r);const i={a:t,b:r};return ue.runKernel(uy,i)}const np=he({pow_:ybe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qt(n,e){if((xs(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&xs(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Cp(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bbe(n){const t={x:j(n,"x","sqrt","float32")};return ue.runKernel(_y,t)}const _o=he({sqrt_:bbe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vbe(n){const e=j(n,"x","square"),t={};return ue.runKernel("Square",{x:e},t)}const Or=he({square_:vbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wbe(n,e=null,t=!1){let r=j(n,"x","sum");r.dtype==="bool"&&(r=St(r,"int32"));const i={x:r},s={axis:e,keepDims:t};return ue.runKernel(ww,i,s)}const Kt=he({sum_:wbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xbe(n,e="euclidean",t=null,r=!1){n=j(n,"x","norm");const i=qX(n,e,t);let s=i.shape;if(r){const o=An(t,n.shape);s=Fi(i.shape,o)}return ve(i,s)}function qX(n,e,t=null){if(n.rank===0)return vs(n);if(n.rank!==1&&t===null)return qX(ve(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Kt(vs(n),t);if(e===1/0)return vc(vs(n),t);if(e===-1/0)return __(vs(n),t);if(e==="euclidean"||e===2)return _o(Kt(np(vs(n),Qt(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return vc(Kt(vs(n),t[0]),t[1]-1);if(e===1/0)return vc(Kt(vs(n),t[1]),t[0]);if(e===-1/0)return __(Kt(vs(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return _o(Kt(Or(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Ew=he({norm_:xbe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _be(n,e=null,t=!1){return Ew(n,"euclidean",e,t)}const XX=he({euclideanNorm_:_be});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sbe(n){const t={x:j(n,"x","exp")};return ue.runKernel(Kg,t)}const Jo=he({exp_:Sbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cbe(n,e=0){const t=j(n,"x","expandDims","string_or_numeric");U(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},i={dim:e};return ue.runKernel(Wv,r,i)}const ss=he({expandDims_:Cbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kbe(n){const t={x:j(n,"x","expm1")};return ue.runKernel(Yg,t)}const KX=he({expm1_:kbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tbe(n,e){const t=j(n,"x","tile","string_or_numeric");U(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},i={reps:e};return ue.runKernel(Ey,r,i)}const dc=he({tile_:Tbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ebe(n,e,t,r="float32"){e==null&&(e=n);const i=Sn([n,e],r),s=n<=e?n:e;for(let a=0;a<s;++a)i.set(1,a,a);const o=ve(i.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return dc(ss(o,0),[t[0],1,1]);if(t.length===2)return dc(ss(ss(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return dc(ss(ss(ss(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const DM=he({eye_:Ebe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ibe(n){const t={x:j(n,"x","floor","float32")};return ue.runKernel(Zg,t)}const X2=he({floor_:Ibe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Abe(n,e,t=0,r=0){const i=j(n,"x","gather"),s=j(e,"indices","gather","int32"),o={x:i,indices:s},a={axis:t,batchDims:r};return ue.runKernel(Gv,o,a)}const K2=he({gather_:Abe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mbe(n,e){let t=j(n,"a","greater","string_or_numeric"),r=j(e,"b","greater","string_or_numeric");[t,r]=ki(t,r),ln(t.shape,r.shape);const i={a:t,b:r};return ue.runKernel(jv,i)}const tl=he({greater_:Mbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nbe(n,e){let t=j(n,"a","greaterEqual","string_or_numeric"),r=j(e,"b","greaterEqual","string_or_numeric");[t,r]=ki(t,r),ln(t.shape,r.shape);const i={a:t,b:r};return ue.runKernel(Qg,i)}const Tp=he({greaterEqual_:Nbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $be(n){const t={input:j(n,"input","imag")};return ue.runKernel(p2,t)}const Y2=he({imag_:$be});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rbe(n){const t={x:j(n,"x","isFinite")};return ue.runKernel(ty,t)}const YX=he({isFinite_:Rbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pbe(n){const t={x:j(n,"x","isInf")};return ue.runKernel(ny,t)}const ZX=he({isInf_:Pbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dbe(n){const t={x:j(n,"x","isNaN")};return ue.runKernel(ry,t)}const JX=he({isNaN_:Dbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Obe(n,e=.2){const r={x:j(n,"x","leakyRelu")},i={alpha:e};return ue.runKernel(qv,r,i)}const OM=he({leakyRelu_:Obe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fbe(n,e){let t=j(n,"a","less","string_or_numeric"),r=j(e,"b","less","string_or_numeric");[t,r]=ki(t,r),ln(t.shape,r.shape);const i={a:t,b:r};return ue.runKernel(Xv,i)}const S_=he({less_:Fbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lbe(n,e){let t=j(n,"a","lessEqual","string_or_numeric"),r=j(e,"b","lessEqual","string_or_numeric");[t,r]=ki(t,r),ln(t.shape,r.shape);const i={a:t,b:r};return ue.runKernel(Kv,i)}const Ry=he({lessEqual_:Lbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QX(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const r={start:n,stop:e,num:t};return ue.runKernel(m2,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zbe(n,e=5,t=1,r=1,i=.5){const s=j(n,"x","localResponseNormalization");U(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),U(eg(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=s,a=!1;s.rank===3&&(a=!0,o=ve(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:o},c={depthRadius:e,bias:t,alpha:r,beta:i},u=ue.runKernel(Qv,l,c);return a?ve(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const eK=he({localResponseNormalization_:zbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bbe(n){const t={x:j(n,"x","log","float32")};return ue.runKernel(iy,t)}const $l=he({log_:Bbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vbe(n){const t={x:j(n,"x","log1p")};return ue.runKernel(sy,t)}const FM=he({log1p_:Vbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ube(n){return U(Jd(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const r=j(e,"x","tf.grad","string_or_numeric"),i=t!=null?j(t,"dy","tf.grad"):null;return ue.tidy(()=>{const{value:s,grads:o}=ue.gradients(()=>n(r),[r],i);return i!=null&&qs(s.shape,i.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),LM(o),o[0]})}}function Wbe(n){return U(Jd(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{U(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=b_(e,"args","tf.grads","string_or_numeric"),i=t!=null?j(t,"dy","tf.grads"):null;return ue.tidy(()=>{const{value:s,grads:o}=ue.gradients(()=>n(...r),r,i);return i!=null&&qs(s.shape,i.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),LM(o),o})}}function Hbe(n){return U(Jd(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{U(e instanceof jn,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),U(t==null||t instanceof jn,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:i}=ue.gradients(()=>n(e),[e],t);return LM(r),{grad:r[0],value:i}}}function Gbe(n){return U(Jd(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{U(Array.isArray(e)&&e.every(i=>i instanceof jn),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),U(t==null||t instanceof jn,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=ue.gradients(()=>n(...e),e,t);return t!=null&&qs(r.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),LM(r.grads),r}}function tK(n,e){U(Jd(n),()=>"The f passed in variableGrads(f) must be a function"),U(e==null||Array.isArray(e)&&e.every(c=>c instanceof y_),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const c in ue.registeredVariables)e.push(ue.registeredVariables[c])}const r=t?e.filter(c=>!c.trainable):null,i=e.length;e=e.filter(c=>c.trainable),U(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const s=!0,{value:o,grads:a}=ue.gradients(n,e,null,s);U(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),U(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((c,u)=>{a[u]!=null&&(l[c.name]=a[u])}),r!=null&&r.forEach(c=>l[c.name]=null),{value:o,grads:l}}function xh(n){return ue.customGrad(n)}function LM(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jbe(n){const t={x:j(n,"x","neg")};return ue.runKernel(ow,t)}const ci=he({neg_:jbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qbe(n){const t={x:j(n,"x","softplus")};return ue.runKernel(xy,t)}const Iw=he({softplus_:qbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xbe(n){const e=j(n,"x","logSigmoid");return xh(r=>({value:ci(Iw(ci(r))),gradFunc:o=>fe(o,Il(ci(r)))}))(e)}const nK=he({logSigmoid_:Xbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kbe(n,e){let t=j(n,"a","sub"),r=j(e,"b","sub");[t,r]=ki(t,r);const i={a:t,b:r};return ue.runKernel(Cy,i)}const Dt=he({sub_:Kbe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ybe(n,e=-1){const t=j(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return xh((i,s)=>{const a=vc(i,e,!0),l=Dt(i,a),c=Dt(St(l,"float32"),$l(Kt(Jo(l),e,!0)));return s([c]),{value:c,gradFunc:(h,f)=>{const[d]=f,p=!0,m=Jo(d);return Dt(h,fe(Kt(h,e,p),m))}}})(t)}const tz=he({logSoftmax_:Ybe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zbe(n,e=null,t=!1){const r=j(n,"x","logSumExp"),i=An(e,r.shape),s=vc(r,i,!0),o=Dt(r,s),a=Jo(o),l=Kt(a,i),c=$l(l),u=Xe(ve(s,c.shape),c);if(t){const h=Fi(u.shape,i);return ve(u,h)}return u}const zM=he({logSumExp_:Zbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jbe(n,e){const t=j(n,"a","logicalAnd","bool"),r=j(e,"b","logicalAnd","bool");ln(t.shape,r.shape);const i={a:t,b:r};return ue.runKernel(Yv,i)}const _h=he({logicalAnd_:Jbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qbe(n){const t={x:j(n,"x","logicalNot","bool")};return ue.runKernel(Zv,t)}const BM=he({logicalNot_:Qbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eve(n,e){const t=j(n,"a","logicalOr","bool"),r=j(e,"b","logicalOr","bool");ln(t.shape,r.shape);const i={a:t,b:r};return ue.runKernel(Jv,i)}const nz=he({logicalOr_:eve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tve(n,e){const t=j(n,"a","logicalXor","bool"),r=j(e,"b","logicalXor","bool");return ln(t.shape,r.shape),_h(nz(n,e),BM(_h(n,e)))}const rK=he({logicalXor_:tve});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wk=2147483648;function nve(n,e,t="left"){const r=j(n,"sortedSequence","searchSorted"),i=j(e,"values","searchSorted"),s=r.shape[r.shape.length-1],o=i.shape[i.shape.length-1],a=ve(r,[-1,s]),l=ve(i,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Ee(l.shape)>=Wk)throw new Error(`values tensor size must less than ${Wk}`);if(a.shape[1]>=Wk)throw new Error(`trailing dim_size must less than ${Wk} for int32 output type, was ${a.shape[1]}`);const c={sortedSequence:a,values:l},u={side:t};return ue.runKernel(A2,c,u)}const VM=he({searchSorted_:nve});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iK(n,e){return VM(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rve(n,e,t,r,i){const s=j(n,"x","maxPool"),o=1;let a=s,l=!1;s.rank===3&&(l=!0,a=ve(s,[1,s.shape[0],s.shape[1],s.shape[2]])),U(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),U($s(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),na("maxPool",r,i);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:i},h=ue.runKernel(tw,c,u);return l?ve(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const UM=he({maxPool_:rve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ive(n,e=[1,1,1],t,r,i,s="NDHWC"){const o=j(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),U(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),na("maxPool3d",r,i);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:i,dataFormat:s},h=ue.runKernel(nw,c,u);return l?ve(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const rz=he({maxPool3d_:ive});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sve(n,e,t,r,i=!1){const o={x:j(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:r,includeBatchInIndex:i},l=ue.runKernel(v2,o,a);return{result:l[0],indexes:l[1]}}const sK=he({maxPoolWithArgmax_:sve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ove(n,e){let t=j(n,"a","maximum"),r=j(e,"b","maximum");[t,r]=ki(t,r),t.dtype==="bool"&&(t=St(t,"int32"),r=St(r,"int32")),ln(t.shape,r.shape);const i={a:t,b:r};return ue.runKernel(oy,i)}const Uf=he({maximum_:ove});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ave(n,e=null,t=!1){const i={x:j(n,"x","mean")},s={axis:e,keepDims:t};return ue.runKernel(rw,i,s)}const Di=he({mean_:ave});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pi(n,e="float32"){if(Ja(n),e==="complex64"){const r=pi(n,"float32"),i=pi(n,"float32");return Rf(r,i)}const t=js(Ee(n),e);return ue.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ga(n,e="float32"){if(Ja(n),e==="complex64"){const r=ga(n,"float32"),i=pi(n,"float32");return Rf(r,i)}const t=wM(Ee(n),e);return ue.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oK(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let r=j(n,"x","meshgrid",n instanceof jn?n.dtype:"float32");if(e===void 0)return[r];let i=j(e,"y","meshgrid",e instanceof jn?e.dtype:"float32");const s=Ee(r.shape),o=Ee(i.shape);return t==="xy"?(r=ve(r,[1,-1]),i=ve(i,[-1,1]),[Gn(ga([o,1],r.dtype),r),Gn(i,ga([1,s],i.dtype))]):(r=ve(r,[-1,1]),i=ve(i,[1,-1]),[Gn(r,ga([1,o],r.dtype)),Gn(ga([s,1],i.dtype),i)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lve(n,e){let t=j(n,"a","minimum"),r=j(e,"b","minimum");[t,r]=ki(t,r),t.dtype==="bool"&&(t=St(t,"int32"),r=St(r,"int32")),ln(t.shape,r.shape);const i={a:t,b:r};return ue.runKernel(ay,i)}const rp=he({minimum_:lve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cve(n,e,t){U(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=j(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");U(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const i=t==="reflect"?1:0;for(let a=0;a<r.rank;a++)U(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),U(e[a][0]>=0&&e[a][0]<=r.shape[a]-i&&e[a][1]>=0&&e[a][1]<=r.shape[a]-i,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-i} or less than 0 for input of shape ${r.shape}`);const s={paddings:e,mode:t},o={x:r};return ue.runKernel(sw,o,s)}const iz=he({mirrorPad_:cve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uve(n,e){let t=j(n,"a","mod"),r=j(e,"b","mod");[t,r]=ki(t,r);const i={a:t,b:r};return ue.runKernel(ly,i)}const aK=he({mod_:uve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hve(n,e=null,t=!1){n=j(n,"x","moments");const r=An(e,n.shape),i=Di(n,r,t);let s=i.shape;t||(s=Fi(i.shape,r));const o=Or(Dt(St(n,"float32"),ve(i,s))),a=Di(o,r,t);return{mean:i,variance:a}}const Z2=he({moments_:hve});function fve(n,e,t,r){const i=j(e,"data","multiRNNCell"),s=b_(t,"c","multiRNNCell"),o=b_(r,"h","multiRNNCell");let a=i;const l=[];for(let h=0;h<n.length;h++){const f=n[h](a,s[h],o[h]);l.push(f[0]),l.push(f[1]),a=f[1]}const c=[],u=[];for(let h=0;h<l.length;h+=2)c.push(l[h]),u.push(l[h+1]);return[c,u]}const lK=he({multiRNNCell_:fve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dve(n,e,t,r=!1){const i=j(n,"logits","multinomial"),s=i.size,o=i.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const l={logits:o===1?ve(i,[1,-1]):i},c={numSamples:e,seed:t,normalized:r},u=ue.runKernel(w2,l,c);return o===1?ve(u,[u.size]):u}const cK=he({multinomial_:dve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pve(n,e){let t=j(n,"a","notEqual","string_or_numeric"),r=j(e,"b","notEqual","string_or_numeric");[t,r]=ki(t,r),ln(t.shape,r.shape);const i={a:t,b:r};return ue.runKernel(aw,i)}const qb=he({notEqual_:pve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mve(n,e,t=1,r=0,i="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:j(n,"indices","oneHot","int32")},a={dtype:i,depth:e,onValue:t,offValue:r};return ue.runKernel(cw,o,a)}const Xb=he({oneHot_:mve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gve(n){const t={x:j(n,"x","onesLike")};return ue.runKernel(lw,t)}const Rl=he({onesLike_:gve});function yve(n,e){const t=j(n,"v1","outerProduct"),r=j(e,"v2","outerProduct");U(t.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${r.rank}.`);const i=ve(t,[-1,1]),s=ve(r,[1,-1]);return Gn(i,s)}const uK=he({outerProduct_:yve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bve(n,e,t=0){const r=j(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:t},s={x:r};return ue.runKernel(hw,s,i)}const _u=he({pad_:bve});function vve(n,e,t=0){return U(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),_u(n,[e],t)}const hK=he({pad1d_:vve});function wve(n,e,t=0){return U(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),_u(n,e,t)}const fK=he({pad2d_:wve});function xve(n,e,t=0){return U(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),_u(n,e,t)}const dK=he({pad3d_:xve});function _ve(n,e,t=0){return U(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),_u(n,e,t)}const pK=he({pad4d_:_ve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sve(n,e,t){const r=j(n,"x","spaceToBatchND");U(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),U(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),U(r.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const i={x:r},s={blockShape:e,paddings:t};return ue.runKernel(xw,i,s)}const WM=he({spaceToBatchND_:Sve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cve(n,e,t,r,i,s,o){i==null&&(i=[1,1]),s==null&&(s=1),r===0&&(r="valid");const a=j(n,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U($s(s,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${i}'`);const u=ko(l.shape,e,s,i,r),h=[u.dilationHeight,u.dilationWidth];let f;r==="same"?f=Tve([u.filterHeight,u.filterWidth],h):f=[[0,0],[0,0]];const d=h[0]===1&&h[1]===1,[p,m]=kve([u.inHeight,u.inWidth],h,f),g=d?r:"valid",y=d?l:WM(l,h,p),_=(t==="avg"?()=>$M(y,e,s,g,o):()=>UM(y,e,s,g,o))(),w=d?_:RM(_,h,m);return c?ve(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function kve(n,e,t){const r=t.map(u=>u[0]),i=t.map(u=>u[1]),s=n.concat(r,i),o=e.map((u,h)=>(u-s[h]%u)%u),a=i.map((u,h)=>u+o[h]),l=e.map((u,h)=>[r[h],a[h]]),c=e.map((u,h)=>[0,o[h]]);return[l,c]}function Tve(n,e){const r=n.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),i=r.map(o=>Math.floor(o/2)),s=r.map((o,a)=>o-i[a]);return r.map((o,a)=>[i[a],s[a]])}const mK=he({pool_:Cve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eve(n,e){const t=j(n,"x","prelu"),r=j(e,"alpha","prelu"),i={x:t,alpha:r};return ue.runKernel(fw,i)}const HM=he({prelu_:Eve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ive(n,e=null,t=!1){let r=j(n,"x","prod");r.dtype==="bool"&&(r=St(r,"int32"));const i={x:r},s={axis:e,keepDims:t};return ue.runKernel(dw,i,s)}const gK=he({prod_:Ive});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ave(n,e,t,r){const i=n.map((u,h)=>j(u,`tensors${h}`,"raggedGather","int32")),s=j(e,"paramsDenseValues","raggedGather"),o=j(t,"indices","raggedGather","int32"),a={paramsNestedSplits:i,paramsDenseValues:s,indices:o},l={outputRaggedRank:r},c=ue.runKernel(_M,a,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const yK=he({raggedGather_:Ave});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mve(n,e,t){const r=j(n,"starts","raggedRange"),i=j(e,"limits","raggedRange",r.dtype),s=j(t,"deltas","raggedRange",r.dtype),o={starts:r,limits:i,deltas:s},a=ue.runKernel(SM,o);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const bK=he({raggedRange_:Mve});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nve(n,e,t,r,i){const s=j(n,"shape","raggedTensorToTensor","int32"),o=j(e,"values","raggedTensorToTensor"),a=j(t,"defaultValue","raggedTensorToTensor",o.dtype),l=r.map((h,f)=>j(h,`tensors${f}`,"raggedTensorToTensor","int32")),c={shape:s,values:o,defaultValue:a,rowPartitionTensors:l},u={rowPartitionTypes:i};return ue.runKernel(CM,c,u)}const vK=he({raggedTensorToTensor_:Nve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ve(n,e,t){Ja(n);const r=Ee(n);let i=null;if(t==null||t==="float32")i=new Float32Array(r);else if(t==="int32")i=new Int32Array(r);else if(t==="bool")i=new Uint8Array(r);else throw new Error(`Unknown data type ${t}`);for(let s=0;s<r;s++)i[s]=e();return ue.makeTensor(i,n,t)}const wK=he({rand_:$ve});var sz={exports:{}};sz.exports;(function(n){(function(e,t,r){function i(l){var c=this,u=a();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function s(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var u=new i(l),h=c&&c.state,f=u.next;return f.int32=function(){return u.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,h&&(typeof h=="object"&&s(h,u),f.state=function(){return s(u,{})}),f}function a(){var l=4022871197,c=function(u){u=String(u);for(var h=0;h<u.length;h++){l+=u.charCodeAt(h);var f=.02519603282416938*l;l=f>>>0,f-=l,f*=l,l=f>>>0,f-=l,l+=f*4294967296}return(l>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(gt,n,!1)})(sz);var Rve=sz.exports,oz={exports:{}};oz.exports;(function(n){(function(e,t,r){function i(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function s(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&s(u,c),h.state=function(){return s(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(gt,n,!1)})(oz);var Pve=oz.exports,az={exports:{}};az.exports;(function(n){(function(e,t,r){function i(a){var l=this,c="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function s(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&s(u,c),h.state=function(){return s(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(gt,n,!1)})(az);var Dve=az.exports,lz={exports:{}};lz.exports;(function(n){(function(e,t,r){function i(a){var l=this;l.next=function(){var u=l.x,h=l.i,f,d;return f=u[h],f^=f>>>7,d=f^f<<24,f=u[h+1&7],d^=f^f>>>10,f=u[h+3&7],d^=f^f>>>3,f=u[h+4&7],d^=f^f<<7,f=u[h+7&7],f=f^f<<13,d^=f^f<<9,u[h]=d,l.i=h+1&7,d};function c(u,h){var f,d=[];if(h===(h|0))d[0]=h;else for(h=""+h,f=0;f<h.length;++f)d[f&7]=d[f&7]<<15^h.charCodeAt(f)+d[f+1&7]<<13;for(;d.length<8;)d.push(0);for(f=0;f<8&&d[f]===0;++f);for(f==8?d[7]=-1:d[f],u.x=d,u.i=0,f=256;f>0;--f)u.next()}c(l,a)}function s(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(u.x&&s(u,c),h.state=function(){return s(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(gt,n,!1)})(lz);var Ove=lz.exports,cz={exports:{}};cz.exports;(function(n){(function(e,t,r){function i(a){var l=this;l.next=function(){var u=l.w,h=l.X,f=l.i,d,p;return l.w=u=u+1640531527|0,p=h[f+34&127],d=h[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,p=h[f]=p^d,l.i=f,p+(u^u>>>16)|0};function c(u,h){var f,d,p,m,g,y=[],b=128;for(h===(h|0)?(d=h,h=null):(h=h+"\0",d=0,b=Math.max(b,h.length)),p=0,m=-32;m<b;++m)h&&(d^=h.charCodeAt((m+32)%h.length)),m===0&&(g=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,m>=0&&(g=g+1640531527|0,f=y[m&127]^=d+g,p=f==0?p+1:0);for(p>=128&&(y[(h&&h.length||0)&127]=-1),p=127,m=4*128;m>0;--m)d=y[p+34&127],f=y[p=p+1&127],d^=d<<13,f^=f<<17,d^=d>>>15,f^=f>>>12,y[p]=d^f;u.w=g,u.X=y,u.i=p}c(l,a)}function s(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(u.X&&s(u,c),h.state=function(){return s(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(gt,n,!1)})(cz);var Fve=cz.exports,uz={exports:{}};uz.exports;(function(n){(function(e,t,r){function i(a){var l=this,c="";l.next=function(){var h=l.b,f=l.c,d=l.d,p=l.a;return h=h<<25^h>>>7^f,f=f-d|0,d=d<<24^d>>>8^p,p=p-h|0,l.b=h=h<<20^h>>>12^f,l.c=f=f-d|0,l.d=d<<16^f>>>16^p,l.a=p-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function s(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var c=new i(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&s(u,c),h.state=function(){return s(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(gt,n,!1)})(uz);var Lve=uz.exports,xK={exports:{}};const zve={},Bve=Object.freeze(Object.defineProperty({__proto__:null,default:zve},Symbol.toStringTag,{value:"Module"})),_K=My(Bve);(function(n){(function(e,t,r){var i=256,s=6,o=52,a="random",l=r.pow(i,s),c=r.pow(2,o),u=c*2,h=i-1,f;function d(w,S,C){var k=[];S=S==!0?{entropy:!0}:S||{};var A=y(g(S.entropy?[w,_(t)]:w??b(),3),k),M=new p(k),E=function(){for(var N=M.g(s),O=l,R=0;N<c;)N=(N+R)*i,O*=i,R=M.g(1);for(;N>=u;)N/=2,O/=2,R>>>=1;return(N+R)/O};return E.int32=function(){return M.g(4)|0},E.quick=function(){return M.g(4)/4294967296},E.double=E,y(_(M.S),t),(S.pass||C||function(N,O,R,D){return D&&(D.S&&m(D,M),N.state=function(){return m(M,{})}),R?(r[a]=N,O):N})(E,A,"global"in S?S.global:this==r,S.state)}function p(w){var S,C=w.length,k=this,A=0,M=k.i=k.j=0,E=k.S=[];for(C||(w=[C++]);A<i;)E[A]=A++;for(A=0;A<i;A++)E[A]=E[M=h&M+w[A%C]+(S=E[A])],E[M]=S;(k.g=function(N){for(var O,R=0,D=k.i,z=k.j,B=k.S;N--;)O=B[D=h&D+1],R=R*i+B[h&(B[D]=B[z=h&z+O])+(B[z]=O)];return k.i=D,k.j=z,R})(i)}function m(w,S){return S.i=w.i,S.j=w.j,S.S=w.S.slice(),S}function g(w,S){var C=[],k=typeof w,A;if(S&&k=="object")for(A in w)try{C.push(g(w[A],S-1))}catch{}return C.length?C:k=="string"?w:w+"\0"}function y(w,S){for(var C=w+"",k,A=0;A<C.length;)S[h&A]=h&(k^=S[h&A]*19)+C.charCodeAt(A++);return _(S)}function b(){try{var w;return f&&(w=f.randomBytes)?w=w(i):(w=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(w)),_(w)}catch{var S=e.navigator,C=S&&S.plugins;return[+new Date,e,C,e.screen,_(t)]}}function _(w){return String.fromCharCode.apply(0,w)}if(y(r.random(),t),n.exports){n.exports=d;try{f=_K}catch{}}else r["seed"+a]=d})(typeof self<"u"?self:gt,[],Math)})(xK);var Vve=xK.exports,Uve=Rve,Wve=Pve,Hve=Dve,Gve=Ove,jve=Fve,qve=Lve,Py=Vve;Py.alea=Uve;Py.xor128=Wve;Py.xorwow=Hve;Py.xorshift7=Gve;Py.xor4096=jve;Py.tychei=qve;var Aw=Py;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xve=.001,SK=.1;function Kve(n,e,t){return t==null&&(t=hz()),vD(n,e,(r,i)=>fz(r,i,t))}function hz(){return ue.backend.floatPrecision()===32?Xve:SK}function vD(n,e,t){let r=!0;if((xs(n)||xs(e))&&(r=!1),xs(n)&&xs(e)&&(r=!0),r){const o=n.constructor.name,a=e.constructor.name;if(o!==a)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${a}`)}if(Array.isArray(n)&&Array.isArray(e)){const o=wh(n),a=wh(e);if(!Rn(o,a))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${a}]`)}const i=xs(n)?n:Cc(n),s=xs(e)?e:Cc(e);if(i.length!==s.length)throw new Error(`Arrays have different lengths actual: ${i.length} vs expected: ${s.length}.
Actual:   ${i}.
Expected: ${s}.`);for(let o=0;o<s.length;++o){const a=i[o],l=s[o];if(!t(a,l))throw new Error(`Arrays differ: actual[${o}] = ${a}, expected[${o}] = ${l}.
Actual:   ${i}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function Yve(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function Zve(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return du(n)||du(n[0])||du(e)||du(e[0])?vD(n,t,(r,i)=>r==i):vD(n,e,(r,i)=>fz(r,i,0))}function Jve(n,e,t){if(t==null&&(t=hz()),!fz(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function fz(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function Qve(n,e,t){for(let r=0;r<n.length;r++)if(n[r]<e||n[r]>t)throw new Error(`Value out of range:${n[r]} low: ${e}, high: ${t}`)}function ewe(n,e){const t=new Float32Array(n),r=new Float32Array(e);if(t.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${t.length}`);for(let i=0;i<r.length;i++)if(t[i]!==r[i])throw new Error(`Expected ArrayBuffer value at ${i} to be ${r[i]} but got ${t[i]} instead`)}function CK(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?CK(t):n[e]=vu(t)}return n}function twe(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",r=>t(e)),e.load()})}async function nwe(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const rwe=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:SK,createVideoElement:twe,encodeStrings:CK,expectArrayBuffersEqual:ewe,expectArraysClose:Kve,expectArraysEqual:Zve,expectNumbersClose:Jve,expectPromiseToFail:Yve,expectValuesInRange:Qve,play:nwe,testEpsilon:hz},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dz{constructor(e,t,r,i,s){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=s||Math.random();this.random=Aw.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let e,t,r=!1;for(;!r;){let i,s,o;do i=2*this.random()-1,s=2*this.random()-1,o=i*i+s*s;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*i*a,t=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class iwe{constructor(e,t,r,i){this.alpha=e,this.beta=1/t,this.dtype=r;const s=i||Math.random();this.randu=Aw.alea(s.toString()),this.randn=new dz(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,r,i,s,o;for(;;){do i=this.randn.nextValue(),o=1+this.c*i;while(o<=0);if(o*=o*o,e=i*i,t=1-.331*e*e,r=.5*e+this.d*(1-o+Math.log(o)),s=this.randu(),s<t||Math.log(s)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class swe{constructor(e=0,t=1,r,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Aw.alea(i)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function owe(n,e,t=1,r="float32",i){if(Ja(n),t==null&&(t=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const s=new iwe(e,t,r,i),o=Sn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}const kK=he({randomGamma_:owe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function awe(n,e=0,t=1,r,i){if(Ja(n),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const s=new dz(e,t,r,!1,i),o=Sn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}const GM=he({randomNormal_:awe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lwe(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return GM(n,0,1,e,t)}const TK=he({randomStandardNormal_:lwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cwe(n,e=0,t=1,r="float32",i){Ja(n);const s=Sn(n,r),o=new swe(e,t,null,i);for(let a=0;a<s.values.length;a++)s.values[a]=o.nextValue();return s.toTensor()}const Ep=he({randomUniform_:cwe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uwe(n,e,t,r){return Ep(n,e,t,"int32",r)}const EK=he({randomUniformInt_:uwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function og(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const i={start:n,stop:e,step:t,dtype:r};return ue.runKernel(S2,{},i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hwe(n){const t={input:j(n,"input","real")};return ue.runKernel(C2,t)}const Kb=he({real_:hwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fwe(n){const t={x:j(n,"x","reciprocal")};return ue.runKernel(hy,t)}const IK=he({reciprocal_:fwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dwe(n){const t={x:j(n,"x","relu")};return ue.runKernel(fy,t)}const Dh=he({relu_:dwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pwe(n){const t={x:j(n,"x","relu6")};return ue.runKernel(dy,t)}const pz=he({relu6_:pwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mwe(n,e){const r={x:j(n,"x","reverse")},i={dims:e};return ue.runKernel(yw,r,i)}const kc=he({reverse_:mwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gwe(n){const e=j(n,"x","reverse");return U(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),kc(e,0)}const AK=he({reverse1d_:gwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ywe(n,e){const t=j(n,"x","reverse");return U(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),kc(t,e)}const MK=he({reverse2d_:ywe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bwe(n,e){const t=j(n,"x","reverse");return U(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),kc(t,e)}const NK=he({reverse3d_:bwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vwe(n,e){const t=j(n,"x","reverse");return U(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),kc(t,e)}const $K=he({reverse4d_:vwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wwe(n){const t={x:j(n,"x","round")};return ue.runKernel(py,t)}const mz=he({round_:wwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xwe(n){const t={x:j(n,"x","rsqrt","float32")};return ue.runKernel(my,t)}const gz=he({rsqrt_:xwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _we(n){const t={x:j(n,"x","selu")};return ue.runKernel(gy,t)}const yz=he({selu_:_we});function Swe(n,e,t,r,i,s=[1,1],o="NHWC"){const a=j(n,"x","separableConv2d"),l=j(e,"depthwiseFilter","separableConv2d"),c=j(t,"pointwiseFilter","separableConv2d");let u=a,h=!1;if(a.rank===3&&(h=!0,u=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");U(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),U(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),U(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),U(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),U(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const f=l.shape[2],d=l.shape[3];U(c.shape[2]===f*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*d}, but got ${c.shape[2]}.`);const p=j2(u,l,r,i,o,s),g=tp(p,c,1,"valid",o);return h?ve(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const bz=he({separableConv2d_:Swe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Cwe(n,e){const t=j(n,"x","setdiff1d"),r=j(e,"y","setdiff1d");U(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),U(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),U(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const i=await t.data(),s=await r.data(),o=new Set(s);let a=0;for(let u=0;u<i.length;u++)o.has(i[u])||a++;const l=new ls([a],t.dtype),c=new ls([a],"int32");for(let u=0,h=0;u<i.length;u++)o.has(i[u])||(l.values[h]=i[u],c.values[h]=u,h++);return[l.toTensor(),c.toTensor()]}const RK=Cwe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kwe(n){const t={x:j(n,"x","sign")};return ue.runKernel(vy,t)}const PK=he({sign_:kwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Twe(n){const t={x:j(n,"x","sin","float32")};return ue.runKernel(yy,t)}const vz=he({sin_:Twe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ewe(n){const t={x:j(n,"x","sinh")};return ue.runKernel(by,t)}const wz=he({sinh_:Ewe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iwe(n,e,t){const r=j(n,"x","slice1d");return U(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),pn(r,[e],[t])}const J2=he({slice1d_:Iwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Awe(n,e,t){const r=j(n,"x","slice2d");return U(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),pn(r,e,t)}const jM=he({slice2d_:Awe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mwe(n,e,t){const r=j(n,"x","slice3d");return U(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),pn(r,e,t)}const Q2=he({slice3d_:Mwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nwe(n,e,t){const r=j(n,"x","slice4d");return U(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),pn(r,e,t)}const Yb=he({slice4d_:Nwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $we(n,e=-1){const t=j(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},i={dim:e};return ue.runKernel(Sw,r,i)}const eC=he({softmax_:$we});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rwe(n){U(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return ue.runKernel(c2,e)}const qM=he({fft_:Rwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pwe(n){U(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return ue.runKernel(d2,e)}const C_=he({ifft_:Pwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dwe(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const i=ve(n,[t,e]);r=C_(i)}else{const i=[t,2*(e-1)],s=ve(Kb(n),[t,e]),o=ve(Y2(n),[t,e]),a=kc(pn(s,[0,1],[t,e-2]),1),l=fe(kc(pn(o,[0,1],[t,e-2]),1),Qt(-1)),c=li([s,a],1),u=li([o,l],1),h=ve(Rf(c,u),[i[0],i[1]]);r=C_(h)}if(r=Kb(r),n.rank===3&&n.shape[0]!==0){const i=r,s=n.shape[0];r=ve(r,[s,r.shape[0]/s,r.shape[1]]),i.dispose()}return r}const xz=he({irfft_:Dwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Owe(n,e,t=0){const i={x:j(n,"x","split")},s={numOrSizeSplits:e,axis:t};return ue.runKernel(_w,i,s)}const Ga=he({split_:Owe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fwe(n,e){U(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let i;if(e!=null&&e<t){const p=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=e,i=pn(n,p,m),t=e}else if(e!=null&&e>t){const p=n.shape.map(m=>m);p[n.shape.length-1]=e-t,i=li([n,pi(p)],n.shape.length-1),t=e}else i=n;const s=ur(i),o=ve(Rf(i,s),[r,t]),a=qM(o),l=Math.floor(t/2)+1,c=Kb(a),u=Y2(a),h=Ga(c,[l,t-l],c.shape.length-1),f=Ga(u,[l,t-l],u.shape.length-1),d=i.shape.slice();return d[i.shape.length-1]=l,ve(Rf(h[0],f[0]),d)}const XM=he({rfft_:Fwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lwe(n,e){let t=j(n,"a","squaredDifference"),r=j(e,"b","squaredDifference");[t,r]=ki(t,r),ln(t.shape,r.shape);const i={a:t,b:r},s={};return ue.runKernel(Sy,i,s)}const _z=he({squaredDifference_:Lwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zwe(n,e){const t=j(n,"x","squeeze","string_or_numeric");return ve(t,Bf(t.shape,e).newShape)}const br=he({squeeze_:zwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bwe(n,e=0){const t=b_(n,"tensors","stack","string_or_numeric");U(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&U(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,i={axis:e};return ue.runKernel(uw,r,i)}const Sa=he({stack_:Bwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vwe(n,e=0){const r={x:j(n,"x","step")},i={alpha:e};return ue.runKernel(Iy,r,i)}const Mw=he({step_:Vwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uwe(n,e,t,r,i=0,s=0,o=0,a=0,l=0){const u={x:j(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:r,beginMask:i,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return ue.runKernel(D2,u,h)}const DK=he({stridedSlice_:Uwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wwe(n){const t={x:j(n,"x","tan","float32")};return ue.runKernel(ky,t)}const OK=he({tan_:Wwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xi(n,e){$g(n);const t=wh(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Cp(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ja(n,e,t){if($g(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=wh(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Cp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sz(n,e,t){if($g(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=wh(n,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Cp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FK(n,e,t){if($g(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=wh(n,t);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Cp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LK(n,e,t){if($g(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=wh(n,t);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Cp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zK(n,e,t){if($g(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=wh(n,t);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,Cp(n,e,r,t)}function Cz(n,e,t){const r=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${i}.`;if(t.rank<i)throw new Error(s+` update.rank < ${i}. `);if(n.length<r+(t.rank-i))throw new Error(s+` Output shape length < ${r+(t.rank-i)}`);if(t.rank!==i+n.length-r)throw new Error(s+` update.rank != ${i+n.length-r}`);for(let o=0;o<i;++o)if(t.shape[o]!==e.shape[o])throw new Error(s+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-i;++o)if(t.shape[o+i]!==n[o+r])throw new Error(s+` updates.shape[${o+i}] (${t.shape[o+i]}) != shape[${o+i}] (${n[o+i]})`)}function KM(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}Cz(t,e,n)}function Lu(n,e,t){const r=e.shape.length,i=r>1?e.shape[r-1]:1,s=t.length;let o=1;for(let h=i;h<s;++h)o*=t[h];const a=i<1?1:i,l=Ee(e.shape)/a,c=[...Zt(t.slice(0,i)),1],u=Ee(t);return{sliceRank:i,numUpdates:l,sliceSize:o,strides:c,outputSize:u}}const Hwe=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:Lu,validateInput:KM,validateUpdateShape:Cz},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gwe(n,e,t){const r=j(n,"tensor","tensorScatterupdate"),i=j(e,"indices","tensorScatterupdate","int32"),s=j(t,"updates","tensorScatterupdate");if(KM(s,i,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);const o={tensor:r,indices:i,updates:s},a={};return ue.runKernel(I2,o,a)}const BK=he({tensorScatterUpdate_:Gwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jwe(n,e=1,t=!0){const r=j(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const s={x:r},o={k:e,sorted:t},[a,l]=ue.runKernel(F2,s,o);return{values:a,indices:l}}const VK=he({topk_:jwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qwe(n,e=0,t=1,r,i){if(Ja(n),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const s=new dz(e,t,r,!0,i),o=Sn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}const YM=he({truncatedNormal_:qwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xwe(n,e=0){const t=j(n,"x","unique","string_or_numeric");U(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},i={axis:e},[s,o]=ue.runKernel(AM,r,i);return{values:s,indices:o}}const UK=he({unique_:Xwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kwe(n,e,t){const r=j(n,"x","unsortedSegmentSum"),i=j(e,"segmentIds","unsortedSegmentSum","int32");U(eg(t),()=>"numSegments must be of dtype int");const s={x:r,segmentIds:i},o={numSegments:t};return ue.runKernel(kw,s,o)}const kz=he({unsortedSegmentSum_:Kwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ywe(n,e=0){const t=j(n,"x","unstack","string_or_numeric");U(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},i={axis:e};return ue.runKernel(Cw,r,i)}const Tc=he({unstack_:Ywe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WK(n,e){return VM(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tz(n,e=!0,t,r){return ue.makeVariable(n,e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZM(n,e){const t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);const r=Sn(n,"int32"),i=Sn([t.length,n.length],"int32");for(let s=0;s<t.length;s++){const o=r.indexToLoc(t[s]),a=s*n.length;i.values.set(o,a)}return i.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Zwe(n){const e=j(n,"condition","whereAsync","bool"),t=await e.data(),r=ZM(e.shape,t);return n!==e&&e.dispose(),r}const Ez=Zwe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Jwe(n,e,t){const r=j(n,"tensor","boolMask"),i=j(e,"mask","boolMask","bool"),s=t??0,o=i.rank,a=r.shape;U(o>0,()=>"mask cannot be scalar"),qs(a.slice(s,s+o),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+o;m++)l*=a[m];const c=a.slice(0,s).concat([l],a.slice(s+o)),u=ve(r,c),h=ve(i,[-1]),f=await Ez(h),d=br(f,[1]),p=K2(u,d,s);return n!==r&&r.dispose(),e!==i&&i.dispose(),d.dispose(),u.dispose(),h.dispose(),f.dispose(),p}const HK=Jwe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qwe(n,e,t){const r=j(n,"x","transpose");if(e==null&&(e=r.shape.map((o,a)=>a).reverse()),U(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(o=>{U(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const i={x:r},s={perm:e};return r.dtype==="complex64"?Se(()=>{let o=Kb(r),a=Y2(r);return o=ue.runKernel(Ld,{x:o},s),a=ue.runKernel(Ld,{x:a},s),t&&(a=ci(a)),Rf(o,a)}):ue.runKernel(Ld,i,s)}const ir=he({transpose_:Qwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function exe(n,e,t,r,i=!0){const s=j(n,"v","movingAverage"),o=j(e,"x","movingAverage"),a=j(t,"decay","movingAverage");uX(s,o),U(Rn(s.shape,o.shape),()=>"Shape mismatch in v and x");const l=Qt(1),c=Dt(l,a);let u=fe(Dt(o,s),c);if(i){U(r!=null,()=>"When using zeroDebias: true, step is required.");const h=j(r,"step","movingAverage");u=Lt(u,Dt(l,np(a,h)))}return Xe(s,u)}const GK=he({movingAverage_:exe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function txe(n,e,t){Ja(t);const r=j(n,"indices","scatterND","int32"),i=j(e,"updates","scatterND");KM(i,r,t);const s={indices:r,updates:i},o={shape:t};return ue.runKernel(E2,s,o)}const jK=he({scatterND_:txe});function nxe(n,e,t,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const i=n.rank>0?n.shape[0]:1,s=n.rank>1?n.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===i))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${i}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rxe(n,e,t,r=0){Ja(t);const i=j(n,"sparseIndices","sparseToDense","int32"),s=j(e,"sparseValues","sparseToDense","string_or_numeric"),o=j(r,"defaultValue","sparseToDense",s.dtype);nxe(i,s,t,o);const a={sparseIndices:i,sparseValues:s,defaultValue:o},l={outputShape:t};return ue.runKernel($2,a,l)}const qK=he({sparseToDense_:rxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ixe(n,e){const t=j(e,"indices","gatherND","int32"),i={params:j(n,"x","gatherND","string_or_numeric"),indices:t};return ue.runKernel(f2,i)}const XK=he({gatherND_:ixe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sxe(n,e){if(e==null)return n.shape.slice();if(Rn(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let r=0;r<n.shape.length;r++)e[r]==null&&n.shape[r]!=null?t.push(n.shape[r]):t.push(e[r]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oxe(n,e,t,r){const i=j(n,"x","dropout");if(U(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),U(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof jn?i.clone():i;const s=sxe(i,t),o=1-e,a=Lt(X2(Xe(Ep(s,0,1,"float32",r),o)),o);return fe(i,a)}const Iz=he({dropout_:oxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Az(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function JM(n,e,t){const r=1-n%2,i=new Float32Array(n);for(let s=0;s<n;++s){const o=2*Math.PI*s/(n+r-1);i[s]=e-t*Math.cos(o)}return Xi(i,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function axe(n,e,t=1){const r=j(n,"predictions","inTopK"),i=j(e,"targets","inTopK");U(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),U(r.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${i.rank}`),qs(r.shape.slice(0,r.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=r.shape[r.shape.length-1];U(t>0&&t<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${t}`);const o=await r.data(),a=await i.data(),[l,c]=[o.length/s,s],u=cs("bool",l);for(let h=0;h<l;h++){const f=h*c,d=o.subarray(f,f+c),p=[];for(let m=0;m<d.length;m++)p.push({value:d[m],index:m});p.sort((m,g)=>g.value-m.value),u[h]=0;for(let m=0;m<t;m++)if(p[m].index===a[h]){u[h]=1;break}}return n!==r&&r.dispose(),e!==i&&i.dispose(),Ts(u,i.shape,"bool")}const KK=axe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lxe(n,e,t,r,i,s="NHWC",o){let a=n;n.rank===3&&(a=ve(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]])),U(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),U(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),U(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=s==="NHWC"?a.shape[3]:a.shape[1],u=s==="NHWC"?l.shape[3]:l.shape[1];U(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),U(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),na("conv2dDerFilter",i,o);const h={x:a,dy:l},f={strides:r,pad:i,dataFormat:s,dimRoundingMode:o,filterShape:t};return ue.runKernel(YS,h,f)}const Mz=he({conv2DBackpropFilter_:lxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QM(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return fe(n,Mw(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function eN(n,e){let t=e;const r=us(n.shape,e.shape);return r.length>0&&(t=Kt(t,r)),ve(t,n.shape)}function tN(n,e,t,r){if(e==="linear")return n;if(e==="relu")return Dh(n);if(e==="elu")return q2(n);if(e==="relu6")return pz(n);if(e==="prelu")return HM(n,t);if(e==="leakyrelu")return OM(n,r);if(e==="sigmoid")return Il(n);throw new Error(`Unknown fused activation ${e}.`)}const nN=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cxe({x:n,filter:e,strides:t,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",nN(ue.state.gradientDepth,l)===!1){U(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let C=tp(n,e,t,r,i,s,o);return a!=null&&(C=Xe(C,a)),tN(C,l,c,u)}const h=j(n,"x","conv2d","float32"),f=j(e,"filter","conv2d","float32");let d=h,p=!1;h.rank===3&&(p=!0,d=ve(h,[1,h.shape[0],h.shape[1],h.shape[2]])),U(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),U(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),na("fused conv2d",r,o);const m=i==="NHWC"?d.shape[3]:d.shape[1];U(f.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${f.shape[2]}.`),U($s(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);const g=ti(d.shape,f.shape,t,s,r,o);let y;a!=null&&(y=j(a,"bias","fused conv2d"),[y]=ki(y,h),i==="NHWC"?ln(g.outShape,y.shape):(U(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),U(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(c!=null){const C=c.shape;if(U(C.length<=1||C.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C.length}.`),C.length===1)U(C[0]===1||C[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the number of output channels (${g.outChannels}).`);else if(C.length===3)try{ln(C,g.outShape)}catch{const A=`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(A)}b=j(c,"prelu weights","fused conv2d")}const _=(C,k)=>{U(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[A,M,E,N]=k,O=QM(C,E,l);U(ep(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const R=XL(M.shape,O,A,t,r),D=Mz(M,O,A.shape,t,r),z=[R,D];if(N!=null){const B=eN(N,O);z.push(B)}return z},w={x:d,filter:f,bias:y,preluActivationWeights:b},S={strides:t,pad:r,dataFormat:i,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?xh((k,A,M)=>{let E=ue.runKernel(Ub,w,S);return M([A,k,E]),p&&(E=ve(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:_}})(d,f):xh((k,A,M,E)=>{let N=ue.runKernel(Ub,w,S);return E([A,k,N,M]),p&&(N=ve(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:_}})(d,f,y)}const YK=he({fusedConv2d_:cxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uxe(n,e,t,r,i,s=[1,1],o){let a=n;n.rank===3&&(a=ve(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},u={strides:r,pad:i,dimRoundingMode:o,dilations:s,filterShape:t};return ue.runKernel(r2,c,u)}const ZK=he({depthwiseConv2dNativeBackpropFilter_:uxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hxe(n,e,t,r,i,s=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:t},u={strides:r,pad:i,dimRoundingMode:o,dilations:s,inputShape:n},h=ue.runKernel(i2,c,u);return l?ve(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const JK=he({depthwiseConv2dNativeBackpropInput_:hxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fxe({x:n,filter:e,strides:t,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(nN(ue.state.gradientDepth,l)===!1){let S=j2(n,e,t,r,i,s,o);return a!=null&&(S=Xe(S,a)),tN(S,l,c,u)}const h=j(n,"x","depthwiseConv2d","float32"),f=j(e,"filter","depthwiseConv2d","float32");let d=h,p=!1;h.rank===3&&(p=!0,d=ve(h,[1,h.shape[0],h.shape[1],h.shape[2]])),U(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),U(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),U(d.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),s==null&&(s=[1,1]),U($s(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),na("fused depthwiseConv2d",r,o);const m=ti(d.shape,f.shape,t,s,r,o,!0);let g;a!=null&&(g=j(a,"bias","fused conv2d"),[g]=ki(g,h),ln(m.outShape,g.shape));let y;c!=null&&(y=j(c,"prelu weights","fused depthwiseConv2d"));const b=(S,C)=>{U(ep(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);const[k,A,M,E]=C,N=QM(S,M,l),O=JK(A.shape,N,k,t,r,s,o),R=ZK(A,N,k.shape,t,r,s,o);if(E!=null){const D=eN(g,N);return[O,R,D]}return[O,R]},_={x:d,filter:f,bias:g,preluActivationWeights:y},w={strides:t,pad:r,dataFormat:i,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?xh((C,k,A)=>{let M=ue.runKernel(Wb,_,w);return A([k,C,M]),p&&(M=ve(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:b}})(d,f):xh((C,k,A,M)=>{let E=ue.runKernel(Wb,_,w);return M([k,C,E,A]),p&&(E=ve(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:b}})(d,f,g)}const dxe=he({fusedDepthwiseConv2d_:fxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pxe({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:i,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(nN(ue.state.gradientDepth,s)===!1){let N=Gn(n,e,t,r);return i!=null&&(N=Xe(N,i)),tN(N,s,o,a)}let l=j(n,"a","fused matMul"),c=j(e,"b","fused matMul");[l,c]=ki(l,c);const u=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=t?l.shape[l.rank-1]:l.shape[l.rank-2],d=r?c.shape[c.rank-2]:c.shape[c.rank-1],p=l.shape.slice(0,-2),m=c.shape.slice(0,-2),g=Ee(p),y=Ee(m);U(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${t} and transposeB=${r} must match.`);const _=ln(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([f,d]),w=t?ve(l,[g,u,f]):ve(l,[g,f,u]),S=r?ve(c,[y,d,h]):ve(c,[y,h,d]);let C;i!=null&&(C=j(i,"bias","fused matMul"),[C]=ki(C,l),ln(_,C.shape));let k;o!=null&&(k=j(o,"prelu weights","fused matMul"));const A=(N,O)=>{const[R,D,z,B]=O,X=QM(ve(N,z.shape),z,s);let H,te;if(!t&&!r?(H=Gn(X,D,!1,!0),te=Gn(R,X,!0,!1)):!t&&r?(H=Gn(X,D,!1,!1),te=Gn(X,R,!0,!1)):t&&!r?(H=Gn(D,X,!1,!0),te=Gn(R,X,!1,!1)):(H=Gn(D,X,!0,!0),te=Gn(X,R,!0,!0)),i!=null){const ge=eN(B,X);return[H,te,ge]}else return[H,te]},M={a:w,b:S,bias:C,preluActivationWeights:k},E={transposeA:t,transposeB:r,activation:s,leakyreluAlpha:a};return i==null?xh((O,R,D)=>{const z=ue.runKernel(Vb,M,E);return D([O,R,z]),{value:ve(z,_),gradFunc:A}})(w,S):xh((O,R,D,z)=>{const B=ue.runKernel(Vb,M,E);return z([O,R,B,D]),{value:ve(B,_),gradFunc:A}})(w,S,C)}const wD=he({fusedMatMul_:pxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QK=Object.freeze(Object.defineProperty({__proto__:null,conv2d:YK,depthwiseConv2d:dxe,matMul:wD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mxe(n){return JM(n,.54,.46)}const gxe=he({hammingWindow_:mxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yxe(n){return JM(n,.5,.5)}const eY=he({hannWindow_:yxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bxe(n,e,t,r=!1,i=0){let s=0;const o=[];for(;s+e<=n.size;)o.push(pn(n,s,e)),s+=t;if(r)for(;s<n.size;){const a=s+e-n.size,l=li([pn(n,s,e-a),$y([a],i)]);o.push(l),s+=t}return o.length===0?ja([],[0,e]):ve(li(o),[o.length,e])}const tY=he({frame_:bxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vxe(n,e,t,r,i=eY){r==null&&(r=Az(e));const s=tY(n,e,t),o=fe(s,i(e));return XM(o,r)}const wxe=he({stft_:vxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xxe(n,e,t,r,i="bilinear",s=0){const o=j(n,"image","cropAndResize"),a=j(e,"boxes","cropAndResize","float32"),l=j(t,"boxInd","cropAndResize","int32"),c=a.shape[0];U(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),U(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),U(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),U(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),U(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),U(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const u={image:o,boxes:a,boxInd:l},h={method:i,extrapolationValue:s,cropSize:r};return ue.runKernel(e2,u,h)}const _xe=he({cropAndResize_:xxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sxe(n){const e=j(n,"image","flipLeftRight","float32");U(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return ue.runKernel(h2,t,{})}const Cxe=he({flipLeftRight_:Sxe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kxe(n){const e=j(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];U(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),U(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const i=new Array(e.rank);return i.fill(1,0,t),i[t]=3,dc(e,i)}const Txe=he({grayscaleToRGB_:kxe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Exe(n){const e=j(n,"image","RGBToGrayscale"),t=e.rank-1,r=e.shape[t];U(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),U(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const i=e.dtype,s=St(e,"float32"),o=Xi([.2989,.587,.114]);let a;switch(e.rank){case 2:a=Am("ij,j->i",s,o);break;case 3:a=Am("ijk,k->ij",s,o);break;case 4:a=Am("ijkl,l->ijk",s,o);break;case 5:a=Am("ijklm,m->ijkl",s,o);break;case 6:a=Am("ijklmn,n->ijklm",s,o);break;default:throw new Error("Not a valid tensor rank.")}return a=ss(a,-1),St(a,i)}const Ixe=he({rgbToGrayscale_:Exe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Axe(n,e,t=0,r=.5){const i=j(n,"image","rotateWithOffset","float32");U(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const s={image:i},o={radians:e,fillValue:t,center:r};return ue.runKernel(z2,s,o)}const Mxe=he({rotateWithOffset_:Axe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nw(n,e,t,r,i,s){r==null&&(r=.5),i==null&&(i=Number.NEGATIVE_INFINITY),s==null&&(s=0);const o=n.shape[0];return t=Math.min(t,o),U(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),U(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),U(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),U(e.rank===1,()=>"scores must be a 1D tensor"),U(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),U(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:i,softNmsSigma:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nxe(n,e,t,r=.5,i=Number.NEGATIVE_INFINITY){const s=j(n,"boxes","nonMaxSuppression","float32"),o=j(e,"scores","nonMaxSuppression","float32"),a=Nw(s,o,t,r,i);t=a.maxOutputSize,r=a.iouThreshold,i=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:r,scoreThreshold:i};return ue.runKernel(x2,{boxes:s,scores:o},l)}const $xe=he({nonMaxSuppression_:Nxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rxe(n,e,t){const r=Pxe(n,e,t),i=r<0?-(r+1):r;n.splice(i,0,e)}function Pxe(n,e,t){return Oxe(n,e,t||Dxe)}function Dxe(n,e){return n>e?1:n<e?-1:0}function Oxe(n,e,t){let r=0,i=n.length,s=0,o=!1;for(;r<i;){s=r+(i-r>>>1);const a=t(e,n[s]);a>0?r=s+1:(i=s,o=!a)}return o?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tC(n,e,t,r,i){return Nz(n,e,t,r,i,0)}function rN(n,e,t,r,i,s){return Nz(n,e,t,r,i,0,!1,s,!0)}function nC(n,e,t,r,i,s){return Nz(n,e,t,r,i,s,!0)}function Nz(n,e,t,r,i,s,o=!1,a=!1,l=!1){const c=[];for(let g=0;g<e.length;g++)e[g]>i&&c.push({score:e[g],boxIndex:g,suppressBeginIndex:0});c.sort(YW);const u=s>0?-.5/s:0,h=[],f=[];for(;h.length<t&&c.length>0;){const g=c.pop(),{score:y,boxIndex:b,suppressBeginIndex:_}=g;if(y<i)break;let w=!1;for(let S=h.length-1;S>=_;--S){const C=Fxe(n,b,h[S]);if(C>=r){w=!0;break}if(g.score=g.score*Lxe(r,u,C),g.score<=i)break}g.suppressBeginIndex=h.length,w||(g.score===y?(h.push(b),f.push(g.score)):g.score>i&&Rxe(c,g,YW))}const d=h.length,p=t-d;a&&p>0&&(h.push(...new Array(p).fill(0)),f.push(...new Array(p).fill(0)));const m={selectedIndices:h};return o&&(m.selectedScores=f),l&&(m.validOutputs=d),m}function Fxe(n,e,t){const r=n.subarray(e*4,e*4+4),i=n.subarray(t*4,t*4+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(i[0],i[2]),u=Math.min(i[1],i[3]),h=Math.max(i[0],i[2]),f=Math.max(i[1],i[3]),d=(a-s)*(l-o),p=(h-c)*(f-u);if(d<=0||p<=0)return 0;const m=Math.max(s,c),g=Math.max(o,u),y=Math.min(a,h),b=Math.min(l,f),_=Math.max(y-m,0)*Math.max(b-g,0);return _/(d+p-_)}function Lxe(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function YW(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function zxe(n,e,t,r=.5,i=Number.NEGATIVE_INFINITY){const s=j(n,"boxes","nonMaxSuppressionAsync"),o=j(e,"scores","nonMaxSuppressionAsync"),a=Nw(s,o,t,r,i);t=a.maxOutputSize,r=a.iouThreshold,i=a.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=tC(c,u,t,r,i);return s!==n&&s.dispose(),o!==e&&o.dispose(),Xi(h,"int32")}const Bxe=zxe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vxe(n,e,t,r=.5,i=Number.NEGATIVE_INFINITY,s=0){const o=j(n,"boxes","nonMaxSuppression"),a=j(e,"scores","nonMaxSuppression"),l=Nw(o,a,t,r,i,s);t=l.maxOutputSize,r=l.iouThreshold,i=l.scoreThreshold,s=l.softNmsSigma;const c={boxes:o,scores:a},u={maxOutputSize:t,iouThreshold:r,scoreThreshold:i,softNmsSigma:s},h=ue.runKernel(_2,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}const Uxe=he({nonMaxSuppressionWithScore_:Vxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Wxe(n,e,t,r=.5,i=Number.NEGATIVE_INFINITY,s=0){const o=j(n,"boxes","nonMaxSuppressionAsync"),a=j(e,"scores","nonMaxSuppressionAsync"),l=Nw(o,a,t,r,i,s);t=l.maxOutputSize,r=l.iouThreshold,i=l.scoreThreshold,s=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),u=c[0],h=c[1],{selectedIndices:f,selectedScores:d}=nC(u,h,t,r,i,s);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Xi(f,"int32"),selectedScores:Xi(d)}}const Hxe=Wxe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gxe(n,e,t,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){const o=j(n,"boxes","nonMaxSuppression"),a=j(e,"scores","nonMaxSuppression"),l=Nw(o,a,t,r,i,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,f={boxes:o,scores:a},d={maxOutputSize:c,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:s},p=ue.runKernel(xM,f,d);return{selectedIndices:p[0],validOutputs:p[1]}}const jxe=he({nonMaxSuppressionPadded_:Gxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function qxe(n,e,t,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){const o=j(n,"boxes","nonMaxSuppressionAsync"),a=j(e,"scores","nonMaxSuppressionAsync"),l=Nw(o,a,t,r,i,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[f,d]=await Promise.all([o.data(),a.data()]),{selectedIndices:p,validOutputs:m}=rN(f,d,c,u,h,s);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Xi(p,"int32"),validOutputs:Qt(m,"int32")}}const Xxe=qxe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kxe(n,e,t=!1,r=!1){const i=j(n,"images","resizeBilinear");U(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),U(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),U(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=i,o=!1;i.rank===3&&(o=!0,s=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const a={images:s},l={alignCorners:t,halfPixelCenters:r,size:e},c=ue.runKernel(gw,a,l);return o?ve(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Yxe=he({resizeBilinear_:Kxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zxe(n,e,t=!1,r=!1){const i=j(n,"images","resizeNearestNeighbor");U(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),U(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),U(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),U(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=i,o=!1;i.rank===3&&(o=!0,s=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const a={images:s},l={alignCorners:t,halfPixelCenters:r,size:e},c=ue.runKernel(mw,a,l);return o?ve(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Jxe=he({resizeNearestNeighbor_:Zxe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qxe(n,e="binary",t=!1,r=.5){const i=j(n,"image","threshold"),s=.2989,o=.587,a=.114,l=i.shape[0]*i.shape[1];let c=fe(Xi([r]),255),u,h,f,d;if(U(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),U(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),U(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),U(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),i.shape[2]===3){[u,h,f]=Ga(i,[1,1,1],-1);const g=fe(u,s),y=fe(h,o),b=fe(f,a);d=Xe(Xe(g,y),b)}else d=n;if(e==="otsu"){const g=UL(St(mz(d),"int32"),Ts([]),256);c=e1e(g,l)}const p=t?Ry(d,c):tl(d,c);return St(fe(p,255),"int32")}function e1e(n,e){let t=Xi([-1]),r=Xi([0]),i=Xi([0]),s,o,a,l,c,u;for(let h=0;h<n.size-1;h++){s=pn(n,0,h+1),o=pn(n,h+1),c=Lt(Kt(s),e),u=Lt(Kt(o),e);const f=Kt(fe(s,og(0,s.size)));a=Lt(f,Kt(s));const d=$y(o.shape,s.size),p=Xe(og(0,o.size),d),m=fe(o,p);l=Lt(Kt(m),Kt(o));const g=Dt(a,l),y=Dt(a,l),b=fe(c,u);i=fe(fe(b,g),y);const _=tl(i,r);r=xo(_,i,r),t=xo(_,Xi([h]),t)}return t}const t1e=he({threshold_:Qxe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n1e(n,e,t="nearest",r="constant",i=0,s){const o=j(n,"image","transform","float32"),a=j(e,"transforms","transform","float32");U(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),U(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),U(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);const l={image:o,transforms:a},c={interpolation:t,fillMode:r,fillValue:i,outputShape:s};return ue.runKernel(L2,l,c)}const r1e=he({transform_:n1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i1e(n,e,t){const r=j(n,"a","bandPart");U(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const i=r.shape,[s,o]=r.shape.slice(-2);let a,l;typeof e=="number"?(U(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),U(e<=s,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`),a=j(e<0?s:e,"numLower","bandPart")):(U(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=xo(S_(e,0),s,rp(e,s))),typeof t=="number"?(U(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),U(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),l=j(t<0?o:t,"numUpper","bandPart")):(U(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=xo(S_(t,0),o,rp(t,o)));const c=ve(og(0,s,1,"int32"),[-1,1]),u=og(0,o,1,"int32"),h=Dt(c,u),f=_h(Ry(h,a),Tp(h,ci(l))),d=pi([s,o],r.dtype);return ve(Sa(Tc(ve(r,[-1,s,o])).map(p=>xo(f,p,d))),i)}const s1e=he({bandPart_:i1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o1e(n){let e;if(Array.isArray(n)){e=!1,U(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=n[0].shape[0];for(let s=1;s<n.length;++s)U(n[s].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[s].shape[0]} vs. ${i})`)}else e=!0,n=Ga(n,n.shape[0],0).map(i=>br(i,[0]));U(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let i=0;i<n.length;++i)t.push(ue.tidy(()=>{let s=r[i];if(i>0)for(let o=0;o<i;++o){const a=fe(Kt(fe(t[o],s)),t[o]);s=Dt(s,a)}return Lt(s,Ew(s,"euclidean"))}));return e?Sa(t,0):t}const a1e=he({gramSchmidt_:o1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l1e(n,e=!1){if(U(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return ZW(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),r=Tc(ve(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),i=[],s=[];r.forEach(l=>{const[c,u]=ZW(l,e);i.push(c),s.push(u)});const o=ve(Sa(i,0),n.shape),a=ve(Sa(s,0),n.shape);return[o,a]}}function ZW(n,e=!1){return ue.tidy(()=>{U(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let i=DM(t),s=mh(n);const o=ja([[1]],[1,1]);let a=mh(o);const l=t>=r?r:t;for(let c=0;c<l;++c){const u=s,h=a,f=i;[a,s,i]=ue.tidy(()=>{const d=pn(s,[c,c],[t-c,1]),p=Ew(d),m=pn(s,[c,c],[1,1]),g=xo(tl(m,0),ja([[-1]]),ja([[1]])),y=Dt(m,fe(g,p)),b=Lt(d,y);b.shape[0]===1?a=mh(o):a=li([o,pn(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const _=ci(Lt(Gn(g,y),p)),w=pn(s,[c,0],[t-c,r]),S=fe(_,a),C=ir(a);if(c===0)s=Dt(w,Gn(S,Gn(C,w)));else{const M=Dt(w,Gn(S,Gn(C,w)));s=li([pn(s,[0,0],[c,r]),M],0)}const k=ir(S),A=pn(i,[0,c],[t,i.shape[1]-c]);if(c===0)i=Dt(A,Gn(Gn(A,a),k));else{const M=Dt(A,Gn(Gn(A,a),k));i=li([pn(i,[0,0],[t,c]),M],1)}return[a,s,i]}),nn([u,h,f])}return!e&&t>r&&(i=pn(i,[0,0],[t,r]),s=pn(s,[0,0],[r,r])),[i,s]})}const c1e=he({qr_:l1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ho;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ho||(Ho={}));function u1e(n,e,t=Ho.SUM_BY_NONZERO_WEIGHTS){const r=j(n,"losses","computeWeightedLoss");let i=null;e!=null&&(i=j(e,"weights","computeWeightedLoss"));const s=i==null?r:fe(r,i);if(t===Ho.NONE)return s;if(t===Ho.SUM)return Kt(s);if(t===Ho.MEAN){if(i==null)return Di(s);{const o=r.size/i.size,a=Lt(Kt(s),Kt(i));return o>1?Lt(a,Qt(o)):a}}if(t===Ho.SUM_BY_NONZERO_WEIGHTS){if(i==null)return Lt(Kt(s),Qt(r.size));{const o=fe(i,ga(r.shape)),a=St(Kt(qb(o,Qt(0))),"float32");return Lt(Kt(s),a)}}throw Error(`Unknown reduction: ${t}`)}const Wf=he({computeWeightedLoss_:u1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h1e(n,e,t,r=Ho.SUM_BY_NONZERO_WEIGHTS){const i=j(n,"labels","absoluteDifference"),s=j(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=j(t,"weights","absoluteDifference")),qs(i.shape,s.shape,"Error in absoluteDifference: ");const a=vs(Dt(i,s));return Wf(a,o,r)}const f1e=he({absoluteDifference_:h1e});function d1e(n,e,t,r,i=Ho.SUM_BY_NONZERO_WEIGHTS){const s=j(n,"labels","cosineDistance"),o=j(e,"predictions","cosineDistance");let a=null;r!=null&&(a=j(r,"weights","cosineDistance")),qs(s.shape,o.shape,"Error in cosineDistance: ");const l=Qt(1),c=Dt(l,Kt(fe(s,o),t,!0));return Wf(c,a,i)}const p1e=he({cosineDistance_:d1e});function m1e(n,e,t,r=Ho.SUM_BY_NONZERO_WEIGHTS){let i=j(n,"labels","hingeLoss");const s=j(e,"predictions","hingeLoss");let o=null;t!=null&&(o=j(t,"weights","hingeLoss")),qs(i.shape,s.shape,"Error in hingeLoss: ");const a=Qt(1);i=Dt(fe(Qt(2),i),a);const l=Dh(Dt(a,fe(i,s)));return Wf(l,o,r)}const g1e=he({hingeLoss_:m1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y1e(n,e,t,r=1,i=Ho.SUM_BY_NONZERO_WEIGHTS){const s=j(n,"labels","huberLoss"),o=j(e,"predictions","huberLoss");let a=null;t!=null&&(a=j(t,"weights","huberLoss")),qs(s.shape,o.shape,"Error in huberLoss: ");const l=Qt(r),c=vs(Dt(o,s)),u=rp(c,l),h=Dt(c,u),f=Xe(fe(Qt(.5),Or(u)),fe(l,h));return Wf(f,a,i)}const b1e=he({huberLoss_:y1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v1e(n,e,t,r=1e-7,i=Ho.SUM_BY_NONZERO_WEIGHTS){const s=j(n,"labels","logLoss"),o=j(e,"predictions","logLoss");let a=null;t!=null&&(a=j(t,"weights","logLoss")),qs(s.shape,o.shape,"Error in logLoss: ");const l=Qt(1),c=Qt(r),u=ci(fe(s,$l(Xe(o,c)))),h=fe(Dt(l,s),$l(Xe(Dt(l,o),c))),f=Dt(u,h);return Wf(f,a,i)}const w1e=he({logLoss_:v1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x1e(n,e,t,r=Ho.SUM_BY_NONZERO_WEIGHTS){const i=j(n,"labels","meanSquaredError"),s=j(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=j(t,"weights","meanSquaredError")),qs(i.shape,s.shape,"Error in meanSquaredError: ");const a=_z(i,s);return Wf(a,o,r)}const _1e=he({meanSquaredError_:x1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S1e(n,e){const t=j(n,"labels","sigmoidCrossEntropyWithLogits"),r=j(e,"logits","sigmoidCrossEntropyWithLogits");qs(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const i=Dh(r),s=fe(r,t),o=FM(Jo(ci(vs(r))));return Xe(Dt(i,s),o)}function C1e(n,e,t,r=0,i=Ho.SUM_BY_NONZERO_WEIGHTS){let s=j(n,"multiClassLabels","sigmoidCrossEntropy");const o=j(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=j(t,"weights","sigmoidCrossEntropy")),qs(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=Qt(r),u=Qt(1),h=Qt(.5);s=Xe(fe(s,Dt(u,c)),fe(h,c))}const l=S1e(s,o);return Wf(l,a,i)}const k1e=he({sigmoidCrossEntropy_:C1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T1e(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return xh((i,s,o)=>{const l=zM(s,[t],!0),c=Dt(St(s,"float32"),l);o([i,c]);const u=ci(fe(c,i));return{value:Kt(u,[t]),gradFunc:(d,p)=>{const[m,g]=p,y=Fi(d.shape,[t]);return[fe(ve(d,y),Dt(St(m,"float32"),Jo(g))),fe(ve(d,y),Dt(Jo(g),St(m,"float32")))]}}})(n,e)}function E1e(n,e,t,r=0,i=Ho.SUM_BY_NONZERO_WEIGHTS){let s=j(n,"onehotLabels","softmaxCrossEntropy");const o=j(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=j(t,"weights","softmaxCrossEntropy")),qs(s.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const c=Qt(r),u=Qt(1),h=Qt(s.shape[1]);s=Xe(fe(s,Dt(u,c)),Lt(c,h))}const l=T1e(s,o);return Wf(l,a,i)}const I1e=he({softmaxCrossEntropy_:E1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1e(n,e,t,r){const i=j(n,"indices","sparseFillEmptyRows","int32"),s=j(e,"values","sparseFillEmptyRows"),o=j(t,"denseShape","sparseFillEmptyRows","int32"),a=j(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(i.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:i,values:s,denseShape:o,defaultValue:a},c=ue.runKernel(kM,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const M1e=he({sparseFillEmptyRows_:A1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N1e(n,e,t){const r=j(n,"inputIndices","sparseReshape","int32"),i=j(e,"inputShape","sparseReshape","int32"),s=j(t,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const o={inputIndices:r,inputShape:i,newShape:s},a=ue.runKernel(TM,o);return{outputIndices:a[0],outputShape:a[1]}}const $1e=he({sparseReshape_:N1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R1e(n,e,t){const r=j(n,"data","sparseSegmentMean"),i=j(e,"indices","sparseSegmentMean","int32"),s=j(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);const o={data:r,indices:i,segmentIds:s};return ue.runKernel(M2,o)}const P1e=he({sparseSegmentMean_:R1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D1e(n,e,t){const r=j(n,"data","sparseSegmentSum"),i=j(e,"indices","sparseSegmentSum","int32"),s=j(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);const o={data:r,indices:i,segmentIds:s};return ue.runKernel(N2,o)}const O1e=he({sparseSegmentSum_:D1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F1e(n,e,t,r,i,s,o,a){const l=j(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=j(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const u={separator:t,nGramWidths:r,leftPad:i,rightPad:s,padWidth:o,preserveShortSequences:a},h={data:l,dataSplits:c},f=ue.runKernel(O2,h,u);return{nGrams:f[0],nGramsSplits:f[1]}}const L1e=he({stringNGrams_:F1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z1e(n,e,t=!0){const r=j(n,"input","stringSplit","string"),i=j(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(i.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);const s={skipEmpty:t},o={input:r,delimiter:i},a=ue.runKernel(EM,o,s);return{indices:a[0],values:a[1],shape:a[2]}}const B1e=he({stringSplit_:z1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V1e(n,e){const t=j(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const i={input:t};return ue.runKernel(IM,i,r)}const U1e=he({stringToHashBucketFast_:V1e});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W1e(n,e,t,r=!0){const i=j(n,"input","staticRegexReplace","string"),s={pattern:e,rewrite:t,replaceGlobal:r};return ue.runKernel(P2,{x:i},s)}const H1e=he({staticRegexReplace_:W1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nY={fft:qM,ifft:C_,rfft:XM,irfft:xz},rY={hammingWindow:gxe,hannWindow:eY,frame:tY,stft:wxe},Ss={flipLeftRight:Cxe,grayscaleToRGB:Txe,resizeNearestNeighbor:Jxe,resizeBilinear:Yxe,rgbToGrayscale:Ixe,rotateWithOffset:Mxe,cropAndResize:_xe,nonMaxSuppression:$xe,nonMaxSuppressionAsync:Bxe,nonMaxSuppressionWithScore:Uxe,nonMaxSuppressionWithScoreAsync:Hxe,nonMaxSuppressionPadded:jxe,nonMaxSuppressionPaddedAsync:Xxe,threshold:t1e,transform:r1e},$z={bandPart:s1e,gramSchmidt:a1e,qr:c1e},iY={absoluteDifference:f1e,computeWeightedLoss:Wf,cosineDistance:p1e,hingeLoss:g1e,huberLoss:b1e,logLoss:w1e,meanSquaredError:_1e,sigmoidCrossEntropy:k1e,softmaxCrossEntropy:I1e},sY={sparseFillEmptyRows:M1e,sparseReshape:$1e,sparseSegmentMean:P1e,sparseSegmentSum:O1e},oY={stringNGrams:L1e,stringSplit:B1e,stringToHashBucketFast:U1e,staticRegexReplace:H1e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G1e=new Map,xD=new Map;class Dy{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class _l{constructor(){this.classNameMap={}}static getMap(){return _l.instance==null&&(_l.instance=new _l),_l.instance}static register(e){_l.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function at(n,e,t){U(n.className!=null,()=>"Class being registered does not have the static className property defined."),U(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),U(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const r=t,i=e+">"+r;return _l.register(n),G1e.set(i,n),xD.set(n,i),n}function j1e(n){return xD.has(n)?xD.get(n):n.className}const q1e=Object.freeze(Object.defineProperty({__proto__:null,Serializable:Dy,SerializationMap:_l,getRegisteredName:j1e,registerClass:at},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hf extends Dy{minimize(e,t=!1,r){const{value:i,grads:s}=this.computeGradients(e,r);if(r!=null){const o=r.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(o)}else this.applyGradients(s);return nn(s),t?i:(i.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return tK(e,t)}dispose(){this.iterations_!=null&&nn(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Qt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Hf,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rz extends Hf{static get className(){return"Adadelta"}constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=ue.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,i)=>{const s=ue.registeredVariables[r],o=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${r}/accum_grad`,variable:Se(()=>ur(s).variable(o))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${r}/accum_var`,variable:Se(()=>ur(s).variable(o))});const a=Array.isArray(e)?e[i].tensor:e[r];if(a==null)return;const l=this.accumulatedGrads[i].variable,c=this.accumulatedUpdates[i].variable;Se(()=>{const u=Xe(fe(l,this.rho),fe(Or(a),1-this.rho)),h=fe(Lt(_o(Xe(c,this.epsilon)),_o(Xe(l,this.epsilon))),a),f=Xe(fe(c,this.rho),fe(Or(h),1-this.rho));l.assign(u),c.assign(f);const d=Xe(fe(h,-this.learningRate),s);s.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(nn(this.accumulatedGrads.map(e=>e.variable)),nn(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(r)})),this.accumulatedUpdates=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pz extends Hf{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,i)=>{const s=ue.registeredVariables[r];this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${r}/accumulator`,variable:Se(()=>$y(s.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[i].tensor:e[r];if(o==null)return;const a=this.accumulatedGrads[i].variable;Se(()=>{const l=Xe(a,Or(o));a.assign(l);const c=Xe(fe(Lt(o,_o(Xe(l,ue.backend.epsilon()))),-this.learningRate),s);s.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&nn(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dz extends Hf{static get className(){return"Adam"}constructor(e,t,r,i=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Se(()=>{this.accBeta1=Qt(t).variable(),this.accBeta2=Qt(r).variable()}),i==null&&(this.epsilon=ue.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Se(()=>{const r=Dt(1,this.accBeta1),i=Dt(1,this.accBeta2);t.forEach((s,o)=>{const a=ue.registeredVariables[s],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${s}/m`,variable:Se(()=>ur(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${s}/v`,variable:Se(()=>ur(a).variable(l))});const c=Array.isArray(e)?e[o].tensor:e[s];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,f=Xe(fe(u,this.beta1),fe(c,1-this.beta1)),d=Xe(fe(h,this.beta2),fe(Or(c),1-this.beta2)),p=Lt(f,r),m=Lt(d,i);u.assign(f),h.assign(d);const g=Xe(fe(Lt(p,Xe(_o(m),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(fe(this.accBeta1,this.beta1)),this.accBeta2.assign(fe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&nn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&nn(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),Se(()=>{this.accBeta1.assign(np(this.beta1,this.iterations_+1)),this.accBeta2.assign(np(this.beta2,this.iterations_+1))});const t=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oz extends Hf{static get className(){return"Adamax"}constructor(e,t,r,i=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=i,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Se(()=>{this.iteration=Qt(0).variable(),this.accBeta1=Qt(t).variable()}),i==null&&(this.epsilon=ue.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Se(()=>{const r=Dt(1,this.accBeta1),i=Lt(-this.learningRate,Xe(fe(this.iteration,this.decay),1));t.forEach((s,o)=>{const a=ue.registeredVariables[s],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${s}/m`,variable:ur(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${s}/v`,variable:ur(a).variable(l)});const c=Array.isArray(e)?e[o].tensor:e[s];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,f=Xe(fe(u,this.beta1),fe(c,1-this.beta1)),d=fe(h,this.beta2),p=vs(c),m=Uf(d,p);u.assign(f),h.assign(m);const g=Xe(fe(Lt(i,r),Lt(f,Xe(m,this.epsilon))),a);a.assign(g)}),this.iteration.assign(Xe(this.iteration,1)),this.accBeta1.assign(fe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&nn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&nn(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iN extends Hf{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,i)=>{const s=Array.isArray(e)?e[i].tensor:e[r];if(s==null)return;const o=ue.registeredVariables[r];Se(()=>{const a=Xe(fe(this.c,s),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=qi(Qt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fz extends iN{static get className(){return"Momentum"}constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=Qt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,i)=>{const s=ue.registeredVariables[r];this.accumulations[i]==null&&(this.accumulations[i]={originalName:`${r}/momentum`,variable:Se(()=>ur(s).variable(!1))});const o=this.accumulations[i].variable,a=Array.isArray(e)?e[i].tensor:e[r];a!=null&&Se(()=>{let l;const c=Xe(fe(this.m,o),a);this.useNesterov?l=Xe(fe(this.c,Xe(a,fe(c,this.m))),s):l=Xe(fe(this.c,c),s),o.assign(c),s.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&nn(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lz extends Hf{static get className(){return"RMSProp"}constructor(e,t=.9,r=0,i=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,i==null&&(this.epsilon=ue.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,i)=>{const s=ue.registeredVariables[r],o=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${r}/rms`,variable:Se(()=>ur(s).variable(o))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${r}/momentum`,variable:Se(()=>ur(s).variable(o))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${r}/mg`,variable:Se(()=>ur(s).variable(o))});const a=Array.isArray(e)?e[i].tensor:e[r];if(a==null)return;const l=this.accumulatedMeanSquares[i].variable,c=this.accumulatedMoments[i].variable;Se(()=>{const u=Xe(fe(l,this.decay),fe(Or(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[i].variable,f=Xe(fe(h,this.decay),fe(a,1-this.decay)),d=Lt(fe(a,this.learningRate),_o(Dt(u,Xe(Or(f),this.epsilon)))),p=Xe(fe(c,this.momentum),d);l.assign(u),h.assign(f),c.assign(p);const m=Dt(s,p);s.assign(m)}else{const h=Xe(fe(l,this.decay),fe(Or(a),1-this.decay)),f=Xe(fe(c,this.momentum),Lt(fe(a,this.learningRate),_o(Xe(h,this.epsilon))));l.assign(h),c.assign(f);const d=Dt(s,f);s.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&nn(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&nn(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&nn(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(r)})),this.accumulatedMoments=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(i=>({originalName:i.name,variable:i.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X1e=[Rz,Pz,Dz,Oz,Fz,Lz,iN];function K1e(){for(const n of X1e)at(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y1e="model",Z1e=".json",J1e=".weights.bin";function JW(n){return new Promise(e=>setTimeout(e)).then(n)}class ag{constructor(e){if(!Ie().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ag.URL_SCHEME)&&(e=e.slice(ag.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Y1e),this.modelJsonFileName=e+Z1e,this.weightDataFileName=e+J1e}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Ou.join(e.weightData),r=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],s=mX(e,i),o=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=o,await JW(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await JW(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:W2(e)}}}}ag.URL_SCHEME="downloads://";class Q1e{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const r=new FileReader;r.onload=i=>{const s=JSON.parse(i.target.result),o=s.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const l=ML(s,c=>this.loadWeights(c));e(l)},r.onerror=i=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const t=[],r=[];for(const o of e)t.push(...o.weights),r.push(...o.paths);const i=this.checkManifestAndWeightFiles(e),s=r.map(o=>this.loadWeightsFile(o,i[o]));return Promise.all(s).then(o=>[t,o])}loadWeightsFile(e,t){return new Promise((r,i)=>{const s=new FileReader;s.onload=o=>{const a=o.target.result;r(a)},s.onerror=o=>i(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],r=this.weightsFiles.map(s=>KW(s.name)),i={};for(const s of e)s.paths.forEach(o=>{const a=KW(o);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);i[o]=this.weightsFiles[r.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}const e_e=n=>Ie().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ag.URL_SCHEME)?t_e(n.slice(ag.URL_SCHEME.length)):null;_i.registerSaveRouter(e_e);function t_e(n="model"){return new ag(n)}function aY(n){return new Q1e(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QW(n,e,t,r){o(n),t=t??0,r=r??1,a(t,r);let i=0;const s=l=>(l.then(c=>{const u=t+ ++i/n.length*(r-t);return e(u),c}),l);function o(l){U(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){U(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),U(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),U(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(n.map(s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function lY(n,e){e==null&&(e={});const t=e.fetchFunc==null?Ie().platform.fetch:e.fetchFunc,r=n.map(h=>t(h,e.requestInit,{isBinary:!0})),i=0,s=.5,a=(e.onProgress==null?await Promise.all(r):await QW(r,e.onProgress,i,s)).map(h=>h.arrayBuffer()),l=.5,c=1;return e.onProgress==null?await Promise.all(a):await QW(a,e.onProgress,l,c)}async function n_e(n,e="",t,r){return cY(o=>lY(o,{requestInit:r}))(n,e,t)}function cY(n){return async(e,t="",r)=>{const i=e.map(()=>!1),s={},o=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((d,p)=>{let m=0;d.weights.forEach(g=>{const y="quantization"in g?g.quantization.dtype:g.dtype,b=dD[y]*Ee(g.shape),_=()=>{i[p]=!0,s[p]==null&&(s[p]=[]),s[p].push({manifestEntry:g,groupOffset:m,sizeBytes:b})};r!=null?r.forEach((w,S)=>{w===g.name&&(_(),o[S]=!0)}):_(),a.push(g.name),m+=b})}),!o.every(d=>d)){const d=r.filter((p,m)=>!o[m]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=i.reduce((d,p,m)=>(p&&d.push(m),d),[]),c=[];l.forEach(d=>{e[d].paths.forEach(p=>{const m=t+(t.endsWith("/")?"":"/")+p;c.push(m)})});const u=await n(c),h={};let f=0;return l.forEach(d=>{const p=e[d].paths.length,m=new Ou(u.slice(f,f+p));s[d].forEach(y=>{const b=m.slice(y.groupOffset,y.groupOffset+y.sizeBytes),_=EL(b,[y.manifestEntry]);for(const w in _)h[w]=_[w]}),f+=p}),h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r_e="application/octet-stream",i_e="application/json";class zz{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(U(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Ie().platform.fetch,U(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&U(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],i=mX(e,r);if(t.body.append("model.json",new Blob([JSON.stringify(i)],{type:i_e}),"model.json"),e.weightData!=null){const o=Ou.join(e.weightData);t.body.append("model.weights.bin",new Blob([o],{type:r_e}),"model.weights.bin")}const s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:W2(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const r=t.modelTopology,i=t.weightsManifest;if(r==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return ML(t,s=>this.loadWeights(s))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[r,i]=s_e(t),s=this.weightPathPrefix||r,o=NL(e),a=[],l=[];for(const u of e)for(const h of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):a.push(s+h+i);this.weightUrlConverter&&a.push(...await Promise.all(l));const c=await lY(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,c]}}zz.URL_SCHEME_REGEX=/^https?:\/\//;function s_e(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),r=n.substring(0,e),i=t>e?n.substring(t):"";return[r+"/",i]}function _D(n){return n.match(zz.URL_SCHEME_REGEX)!=null}const uY=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(r=>_D(r)):t=_D(n),t)return sN(n,e)}return null};_i.registerSaveRouter(uY);_i.registerLoadRouter(uY);function sN(n,e){return new zz(n,e)}function hY(n,e){return sN(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r3{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class fY{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class o_e{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function a_e(n,e,t,r){const i=arguments;return new o_e(kI(...i))}function kI(n,e,t,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new r3(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new r3({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new r3({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:r}))}function dY(n){return new fY(n)}function l_e(n){return new fY(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bz=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Ou,browserFiles:aY,browserHTTPRequest:hY,concatenateArrayBuffers:pX,copyModel:Nye,decodeWeights:EL,encodeWeights:pD,fromMemory:a_e,fromMemorySync:kI,getLoadHandlers:yX,getModelArtifactsForJSON:ML,getModelArtifactsForJSONSync:AL,getModelArtifactsInfoForJSON:W2,getSaveHandlers:gX,getWeightSpecs:NL,http:sN,isHTTPScheme:_D,listModels:$L,loadWeights:n_e,moveModel:$ye,registerLoadRouter:vye,registerSaveRouter:bye,removeModel:RL,weightsLoaderFactory:cY,withSaveHandler:dY,withSaveHandlerSync:l_e},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c_e(n,e,t){const r=j(n,"labels","confusionMatrix"),i=j(e,"predictions","confusionMatrix");U(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),U(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),U(i.rank===1,()=>`Expected the rank of predictions to be 1, but got ${i.rank}`),U(r.shape[0]===i.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${i.shape[0]}. Labels and predictions should have the same number of elements.`),U(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const s=Xb(St(r,"int32"),t),o=Xb(St(i,"int32"),t),a=ir(s),l=Gn(a,o);return St(l,"int32")}const u_e=he({confusionMatrix_:c_e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h_e=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:u_e},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qp,eH=!1;function pY(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,i=!1,s=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)s=!0;else if(n.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(g_(p_,ue.backendName)!=null){const p={pixels:n},m={numChannels:e};return ue.runKernel(p_,p,m)}const[c,u]=i?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(o)h=n.getContext("2d").getImageData(0,0,c,u).data;else if(r||t)h=n.data;else if(s||i||a){if(Qp==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Qp=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Qp=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Qp.canvas.width=c,Qp.canvas.height=u,Qp.drawImage(n,0,0,c,u),h=Qp.getImageData(0,0,c,u).data}let f;if(e===4)f=new Int32Array(h);else{const p=c*u;f=new Int32Array(p*e);for(let m=0;m<p;m++)for(let g=0;g<e;++g)f[m*e+g]=h[m*4+g]}return Sz(f,[u,c,e],"int32")}function f_e(n){return n!=null&&n.data instanceof Uint8Array}function d_e(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function p_e(n){return n!=null&&n.width!==0&&n.height!==0}function m_e(n){return d_e()&&!(n instanceof ImageBitmap)&&p_e(n)&&!f_e(n)}async function g_e(n,e=3){let t=null;if(Ie().getBool("WRAP_TO_IMAGEBITMAP")&&m_e(n)){let r;try{r=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===n.width&&r.height===n.height?t=r:t=n}else t=n;return pY(t,e)}function mY(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function y_e(n){const e=(n==null?void 0:n.alpha)||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function rC(n,e){let t=j(n,"img","toPixels");if(!(n instanceof jn)){const c=t;t=St(c,"int32"),c.dispose()}mY(t);const[r,i]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2],o=await t.data(),a=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(i*r*4);for(let c=0;c<r*i;++c){const u=[0,0,0,255];for(let f=0;f<s;f++){const d=o[c*s+f];if(t.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(t.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);s===1?(u[0]=d*a,u[1]=d*a,u[2]=d*a):u[f]=d*a}const h=c*4;l[h+0]=Math.round(u[0]),l[h+1]=Math.round(u[1]),l[h+2]=Math.round(u[2]),l[h+3]=Math.round(u[3])}if(e!=null){eH||g_(o2,ue.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),eH=!0),e.width=i,e.height=r;const c=e.getContext("2d"),u=new ImageData(l,i,r);c.putImageData(u,0,0)}return t!==n&&t.dispose(),l}function b_e(n,e,t){let r=j(n,"img","draw");if(!(n instanceof jn)){const o=r;r=St(o,"int32"),o.dispose()}mY(r),y_e(t==null?void 0:t.imageOptions);const i={image:r},s={canvas:e,options:t};ue.runKernel(o2,i,s)}const iC=he({fromPixels_:pY}),v_e=Object.freeze(Object.defineProperty({__proto__:null,draw:b_e,fromPixels:iC,fromPixelsAsync:g_e,toPixels:rC},Symbol.toStringTag,{value:"Module"}));function sC(n,e){const t=n.shape.length,r=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${t}`);if(Ee(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const i=e.shape,s=i[i.length-1];let o=1;for(let h=0;h<i.length-1;++h)o*=i[h];const a=n.shape,l=i.slice();l.pop();let c=1;for(let h=s;h<t;++h)c*=a[h],l.push(a[h]);const u=[...Zt(n.shape).map(h=>h/c),1].slice(0,s);return[l,o,c,u]}const w_e=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:sC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SD=-2,x_e=-1;function oN(n,e,t){const r=n.shape.length;U(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),U(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let i=0;i<r;++i)U(e[i]+t[i]<=n.shape[i],()=>`Error in slice${r}D: begin[${i}] + size[${i}] (${e[i]+t[i]}) would overflow input.shape[${i}] (${n.shape[i]})`)}function __e(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function aN(n,e,t){const r=[];for(let i=0;i<n.length;i++)r[i]=Math.ceil((e[i]-n[i])/t[i]);return r}function gY(n,e,t,r){const i=[...n];for(let s=i.length;s<r.length;s++)i.push(1);for(let s=0;s<t;s++)s===0?i[e]=1:(i.splice(e,0,1),i.pop());return i}function yY(n,e,t){return t<=n?t:t-(e-1)}function bY(n,e){const t=[];for(let r=0;r<n;r++)t.push(e+r);return t}function S_e(n,e,t,r,i,s,o,a,l){const c=n.length;let u=new Array(c),h=new Array(c),f=new Array(c);if(e.length&&t>0){const d=e[0],p=t+1;u=vY(o,d,p,r,n),h=wY(a,d,p,i,n),f=gY(s,d,p,n)}else for(let d=0;d<c;d++)u[d]=_Y(o,r,s,n,d,l),h[d]=SY(a,i,s,n,d,l),f[d]=xY(s,d,l);return{begin:u,end:h,strides:f}}function vY(n,e,t,r,i){const s=[...i],o=bY(t,e);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=0;else{const l=yY(e,t,a);let c=r[l];n&1<<l&&(c=0),s[a]=c}return s}function wY(n,e,t,r,i){const s=[...i],o=bY(t,e);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{const l=yY(e,t,a);let c=r[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),s[a]=c}for(let a=0;a<s.length;a++){const l=i[a];s[a]<0&&(s[a]+=l),s[a]=Zd(0,s[a],i[a])}return s}function xY(n,e,t){let r=n[e];return(t&1<<e||r==null)&&(r=1),r}function _Y(n,e,t,r,i,s){let o=e[i];const a=t[i]||1;(n&1<<i||s&1<<i||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=r[i];return o<0&&(o+=l),o=Zd(0,o,l-1),o}function SY(n,e,t,r,i,s){let o=e[i];const a=t[i]||1;(n&1<<i||s&1<<i||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=r[i];return o<0&&(o+=l),a>0?o=Zd(0,o,l):o=Zd(-1,o,l-1),o}function Vz(n,e,t){let r=t.length;for(let i=0;i<t.length;i++)if(t[i]>1){r=i;break}for(let i=r+1;i<t.length;i++)if(e[i]>0||t[i]!==n[i])return!1;return!0}function Uz(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function oC(n,e,t){let r;const i=n.shape.length;typeof e=="number"?r=[e,...new Array(i-1).fill(0)]:e.length<i?r=e.concat(new Array(i-e.length).fill(0)):r=e.slice(),r.forEach(o=>{U(o!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(i).fill(-1):typeof t=="number"?s=[t,...new Array(i-1).fill(-1)]:t.length<i?s=t.concat(new Array(i-t.length).fill(-1)):s=t,s=s.map((o,a)=>o>=0?o:(U(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,s]}function lN(n,e,t,r,i,s,o,a,l){let c;if(r==null?(c=new Array(e.length),c.fill(1)):c=r,o!=null&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:i,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let _=0;_<h.dims;_++)u&&1<<_&a&&h.numAddAxisAfterEllipsis++,1<<_&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const f={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};C_e(h,f);let d=!0,p=!0,m=!0;const g=[],y=[];for(let _=0;_<n.length;++_){if(f.strides[_]===0)throw Error(`strides[${_}] must be non-zero`);const w=!!(f.shrinkAxisMask&1<<_),S=n[_];if(S===-1){g.push(w?1:-1);continue}const C=[f.beginMask&1<<_,f.endMask&1<<_],k=[f.strides[_]>0?0:-1,f.strides[_]>0?S:S-1];if(w&&f.strides[_]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&f.strides[_]===1;const A=!!(f.beginMask&1<<_&&f.endMask&1<<_);if(f.beginValid&&f.endValid){if(w){const O=f.begin[_]<0?S+f.begin[_]:f.begin[_];if(f.begin[_]=O,f.end[_]=f.begin[_]+1,O<0||O>=S)throw Error(`slice index ${f.begin[_]} of dimension ${_} out of bounds.`)}else f.begin[_]=tH(f.begin[_],0,f.strides[_],S,C,k),f.end[_]=tH(f.end[_],1,f.strides[_],S,C,k);const N=f.strides[_]===1&&f.begin[_]===0&&f.end[_]===S;d=d&&N,p=p&&(_===0&&f.strides[_]===1||N)}else d=d&&f.strides[_]===1&&A,p=p&&(_===0&&f.strides[_]===1||A);let M,E=!1;if(f.beginValid&&f.endValid?(M=f.end[_]-f.begin[_],E=!0):w?(M=1,E=!0):A&&S>=0&&(f.strides[_]<0?M=-S:M=S,E=!0),E){let N;M===0||M<0!=f.strides[_]<0?N=0:N=Math.trunc(M/f.strides[_])+(M%f.strides[_]!==0?1:0),g.push(N)}else g.push(-1)}for(let _=0;_<f.finalShapeGatherIndices.length;++_){const w=f.finalShapeGatherIndices[_];w>=0?y.push(g[w]):w===SD&&y.push(1)}return{finalShapeSparse:y.filter((_,w)=>f.finalShapeGatherIndices[w]!==SD),finalShape:y,isIdentity:d,sliceDim0:p,isSimpleSlice:m,begin:f.begin,end:f.end,strides:f.strides}}function C_e(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const i=Math.min(e.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<i;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&n.newAxisMask)e.finalShapeGatherIndices.push(SD),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[r]),n.end!=null&&(e.end[t]=n.end[r]),e.strides[t]=n.strides[r],n.beginMask&1<<r&&(e.beginMask|=1<<t),n.endMask&1<<r&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(x_e),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[t]=r,t++}}function tH(n,e,t,r,i,s){if(i[e])return t>0?s[e]:s[e+1&1];{const o=n<0?r+n:n;return o<s[0]?s[0]:o>s[1]?s[1]:o}}const CY=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:oN,computeFlatOffset:Uz,computeOutShape:aN,getNormalizedAxes:S_e,isSliceContinous:Vz,maskToAxes:__e,parseSliceParams:oC,sliceInfo:lN,startForAxis:_Y,startIndicesWithElidedDims:vY,stopForAxis:SY,stopIndicesWithElidedDims:wY,stridesForAxis:xY,stridesWithElidedDims:gY},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const k_e="4.11.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kY{static sgd(e){return new iN(e)}static momentum(e,t,r=!1){return new Fz(e,t,r)}static rmsprop(e,t=.9,r=0,i=null,s=!1){return new Lz(e,t,r,i,s)}static adam(e=.001,t=.9,r=.999,i=null){return new Dz(e,t,r,i)}static adadelta(e=.001,t=.95,r=null){return new Rz(e,t,r)}static adamax(e=.002,t=.9,r=.999,i=null,s=0){return new Oz(e,t,r,i,s)}static adagrad(e,t=.1){return new Pz(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wd=kY;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T_e=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n())();function Wz(){return new Promise(n=>T_e(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cN(n,e){const t=n[0].length;n.forEach((i,s)=>{U(i.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),U(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const r=n[0];n.forEach((i,s)=>{for(let o=0;o<t;o++)U(o===e||i[o]===r[o],()=>`Error in concat${t}D: Shape of tensors[${s}] (${i}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function va(n,e){const t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var lu;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(lu||(lu={}));function TY(n,e,t){let r=new Array;if(t==null&&e==null)return r;if(e==null)for(;r.length<n+t.length;)r.push(-1);else r=e.slice();if(t==null)return r;if(n+t.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${r.length}`);for(let i=1;i<t.length;++i){const s=t[i],o=r[r.length-t.length+i],a=r[o];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i+n}] = ${s} but shape[${i+n}] = ${a}`)}else r[o]=s}return r}function EY(n){const e={FIRST_DIM_SIZE:lu.FIRST_DIM_SIZE,VALUE_ROWIDS:lu.VALUE_ROWIDS,ROW_LENGTHS:lu.ROW_LENGTHS,ROW_SPLITS:lu.ROW_SPLITS,ROW_LIMITS:lu.ROW_LIMITS,ROW_STARTS:lu.ROW_STARTS},t=[];for(const r of n)if(r in e)t.push(e[r]);else break;return t}function IY(n){return n.length===0?0:n[0]===lu.FIRST_DIM_SIZE?n.length-1:n.length}function AY(n,e){if(n==null||e==null)return;const t=n.length,r=e.length;if(t>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${r})`);for(let i=0;i<Math.min(t,r-1);++i){const s=n[i],o=e[i+1];if(s>=0&&o>=0&&s!==1&&s!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i-n.length}] = ${s} but ragged tensor input.flatValues.shape[${i-n.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hz=30;function uN(n){return n<=Hz?n:yI(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hN(n,e,t){const r=t*(typeof n=="number"?n:n[0]),i=e*(typeof n=="number"?n:n[1]);return[r,i]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oy(n,e,t,r=!0){let i=[];if(r)i=i.concat(e.slice(0)),i.push(n[0]/t),i=i.concat(n.slice(1));else{i=i.concat(n[0]);const s=e.length;for(let o=0;o<s;++o)i=i.concat([n[o+1]/e[o],e[o]]);i=i.concat(n.slice(s+1))}return i}function Fy(n,e,t=!0){const r=[];if(t){r.push(e);for(let i=e+1;i<n;++i)i<=2*e?(r.push(i),r.push(i-(e+1))):r.push(i)}else{const i=[],s=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?s.push(o):i.push(o);r.push(...i),r.push(0),r.push(...s)}return r}function Ly(n,e,t,r=!0){const i=[];r?i.push(n[0]/t):i.push(n[0]*t);for(let s=1;s<n.length;++s)s<=e.length?r?i.push(e[s-1]*n[s]):i.push(n[s]/e[s-1]):i.push(n[s]);return i}function fN(n,e){const t=[0];for(let r=0;r<e;++r)t.push(n[r][0]);return t}function dN(n,e,t){const r=n.slice(0,1);for(let i=0;i<t;++i)r.push(n[i+1]-e[i][0]-e[i][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aC=1.7580993408473768,lC=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pN=.3275911,mN=.254829592,gN=-.284496736,yN=1.421413741,bN=-1.453152027,vN=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Su(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let r=0;r<t.length;r+=2)t[r]=n[r/2],t[r+1]=e[r/2];return t}function MY(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)e[r/2]=n[r],t[r/2]=n[r+1];return{real:e,imag:t}}function NY(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let i=0;i<n.length;i+=4)t[Math.floor(i/4)]=n[i],r[Math.floor(i/4)]=n[i+1];return{real:t,imag:r}}function $Y(n){const e=Math.floor(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let i=2;i<n.length;i+=4)t[Math.floor(i/4)]=n[i],r[Math.floor(i/4)]=n[i+1];return{real:t,imag:r}}function Gz(n,e){const t=n[e*2],r=n[e*2+1];return{real:t,imag:r}}function RY(n,e,t,r){n[r*2]=e,n[r*2+1]=t}function PY(n,e){const t=new Float32Array(n/2),r=new Float32Array(n/2);for(let i=0;i<Math.ceil(n/2);i++){const s=(e?2:-2)*Math.PI*(i/n);t[i]=Math.cos(s),r[i]=Math.sin(s)}return{real:t,imag:r}}function DY(n,e,t){const r=(t?2:-2)*Math.PI*(n/e),i=Math.cos(r),s=Math.sin(r);return{real:i,imag:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i3="->",E_e=/->/g,nH=",",rH="...";function wN(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(E_e,"").length)/i3.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${i3}").`);const[r,i]=n.split(i3);U(r.indexOf(rH)===-1,()=>`The ellipsis notation ("${rH}") is not supported yet.`);const s=r.split(nH),o=s.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let f=0;f<i.length;++f){const d=i[f];if(!s.some(p=>p.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);a.indexOf(d)===-1&&a.push(d)}for(let f=0;f<r.length;++f){const d=r[f];a.indexOf(d)===-1&&d!==nH&&a.push(d)}const l=new Array(s.length);for(let f=0;f<o;++f){if(new Set(s[f].split("")).size!==s[f].length)throw new Error(`Found duplicate axes in input component ${s[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let d=0;d<s[f].length;++d)l[f].push(a.indexOf(s[f][d]))}const c=a.length,u=i.length,h=[];for(let f=u;f<c;++f)h.push(f);return{allDims:a,summedDims:h,idDims:l}}function xN(n,e){let t=new Array(n);t.fill(-1);for(let i=0;i<e.length;++i)t[e[i]]=i;const r=[];for(let i=0;i<n;++i)t[i]===-1&&r.push(i);return t=t.filter(i=>i!==-1),{permutationIndices:t,expandDims:r}}function _N(n,e,t){const r=new Array(n);for(let i=0;i<t.length;++i){const s=t[i].shape;for(let o=0;o<e[i].length;++o)r[e[i][o]]===void 0?r[e[i][o]]=s[o]:U(r[e[i][o]]===s[o],()=>`Expected dimension ${r[e[i][o]]} at axis ${o} of input shaped ${JSON.stringify(s)}, but got dimension ${s[o]}`)}}function SN(n,e){const t=n,r=[];let i=0;n.length===0&&t.push(-1),i=n.length+1;for(let o=0;o<i;++o)r.push([]);const s=[];for(let o=0;o<t.length;++o){const a=t[o],l=I_e(e,a);for(const c of l)s.indexOf(c)===-1&&(r[o].push(c),s.push(c))}return{path:t,steps:r}}function CN(n){return n.every((e,t)=>e===t)}function I_e(n,e){const t=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(e)!==-1||e===-1)&&t.push(r);return t}function kN(n,e,t=0){let r=[];if(typeof e=="number")U(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(n.shape[t]/e);else{const i=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);U(i<=1,()=>"There should be only one negative value in split array.");const s=e.indexOf(-1);if(s!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[s]=n.shape[t]-o}U(n.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OY(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function FY(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function LY(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zY(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function BY(n,e){return`size ${n} must be non-negative, not ${e}`}function VY(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function UY(n,e){const t=Ee(n),r=Ee(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${e}`}function WY(n,e){const t=Ee(n),r=Ee(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CD(){return"segment ids must be >= 0"}function HY(){return"segment ids are not increasing"}function GY(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function jY(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qY(n,e){let t=!1,r;for(n<=Hz?(r=n,t=!0):r=yI(n,Math.floor(Math.sqrt(n)));!t;)r>e||r===n?t=!0:r=yI(n,r+1);return r}function jz(n,e,t){const r=[],i=n.length;for(let s=0;s<i;s++)s!==e?r.push(n[s]):r.push(t);return r}function TN(n,e,t,r){const i=e.shape.length,s=n.shape.length;if(r!==0&&(r<-i||r>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${r}`);if(r<0&&(r+=i),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let h=0;h<r;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=n.shape[t],a=[];let l=1,c=1,u=1;for(let h=0;h<r;++h)a.push(n.shape[h]),l*=n.shape[h];for(let h=r;h<t;h++)a.push(n.shape[h]),c*=n.shape[h];for(let h=r;h<i;h++)a.push(e.shape[h]);for(let h=t+1;h<s;h++)a.push(n.shape[h]),u*=n.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}const A_e=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:TN,computeOutShape:jz,segOpComputeOptimalWindowSize:qY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cu(n){try{return n.map(e=>Sc(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function XY(n){return n.map(e=>vu(e))}const KY=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:mN,ERF_A2:gN,ERF_A3:yN,ERF_A4:bN,ERF_A5:vN,ERF_P:pN,PARALLELIZE_THRESHOLD:Hz,get RowPartitionType(){return lu},SELU_SCALE:lC,SELU_SCALEALPHA:aC,applyActivation:tN,assertAndGetBroadcastShape:ln,assertAxesAreInnerMostDims:hs,assertParamsConsistent:cN,assignToTypedArray:RY,axesAreInnerMostDims:ez,calculateShapes:Lu,checkEinsumDimSizes:_N,checkPadOnDimRoundingMode:na,combineLocations:jX,combineRaggedTensorToTensorShapes:TY,complexWithEvenIndex:NY,complexWithOddIndex:$Y,computeConv2DInfo:ti,computeConv3DInfo:Fu,computeDefaultPad:FL,computeDilation2DInfo:kp,computeOptimalWindowSize:uN,computeOutAndReduceShapes:Ji,computeOutShape:va,computePool2DInfo:ko,computePool3DInfo:Ll,convertConv2DDataFormat:el,decodeEinsumEquation:wN,eitherStridesOrDilationsAreOne:$s,expandShapeToKeepDim:Fi,exponent:DY,exponents:PY,fromStringArrayToUint8:XY,fromUint8ToStringArray:Cu,getAxesPermutation:Lr,getBroadcastDims:Pf,getComplexWithIndex:Gz,getEinsumComputePath:SN,getEinsumPermutation:xN,getFusedBiasGradient:eN,getFusedDyActivation:QM,getImageCenter:hN,getInnerMostAxes:ni,getPermuted:Fy,getRaggedRank:IY,getReductionAxes:us,getReshaped:Oy,getReshapedPermuted:Ly,getRowPartitionTypesHelper:EY,getSliceBeginCoords:fN,getSliceSize:dN,getSparseFillEmptyRowsIndicesDenseShapeMismatch:OY,getSparseFillEmptyRowsNegativeIndexErrorMessage:FY,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:LY,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:VY,getSparseReshapeInputOutputMismatchErrorMessage:WY,getSparseReshapeInputOutputMultipleErrorMessage:UY,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:zY,getSparseReshapeNegativeOutputDimErrorMessage:BY,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:jY,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:CD,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:HY,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:GY,getUndoAxesPermutation:Ph,isIdentityPermutation:CN,log:$ge,mergeRealAndImagArrays:Su,prepareAndValidate:sC,prepareSplitSize:kN,segment_util:A_e,shouldFuse:nN,slice_util:CY,splitRealAndImagArrays:MY,stridesOrDilationsArePositive:sg,tupleValuesAreOne:ep,upcastType:As,validateDefaultValueShape:AY,validateInput:KM,validateUpdateShape:Cz,warn:xl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M_e=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:tC,nonMaxSuppressionV4Impl:rN,nonMaxSuppressionV5Impl:nC,whereImpl:ZM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */K1e();const YY=Object.freeze(Object.defineProperty({__proto__:null,Abs:Tv,Acos:Pg,Acosh:Dg,AdadeltaOptimizer:Rz,AdagradOptimizer:Pz,AdamOptimizer:Dz,AdamaxOptimizer:Oz,Add:_p,AddN:Ev,All:US,Any:WS,ArgMax:Iv,ArgMin:Av,Asin:Og,Asinh:Fg,Atan:Lg,Atan2:Bg,Atanh:zg,AvgPool:Mv,AvgPool3D:Nv,AvgPool3DGrad:GS,AvgPoolGrad:HS,BatchMatMul:$v,BatchToSpaceND:Rv,Bincount:jS,BitwiseAnd:qS,BroadcastArgs:XS,BroadcastTo:X7,Cast:Vg,Ceil:Ug,ClipByValue:Wg,Complex:KS,ComplexAbs:Pv,Concat:Dv,Conv2D:Ov,Conv2DBackpropFilter:YS,Conv2DBackpropInput:Fv,Conv3D:Lv,Conv3DBackpropFilterV2:ZS,Conv3DBackpropInputV2:JS,Cos:Hg,Cosh:Gg,CropAndResize:e2,Cumprod:QS,Cumsum:zv,DataStorage:gM,DenseBincount:t2,DepthToSpace:n2,DepthwiseConv2dNative:Bv,DepthwiseConv2dNativeBackpropFilter:r2,DepthwiseConv2dNativeBackpropInput:i2,Diag:s2,Dilation2D:Vv,Dilation2DBackpropFilter:d_,Dilation2DBackpropInput:f_,Draw:o2,get ENV(){return vL},Einsum:a2,Elu:qg,EluGrad:l2,Environment:j7,Equal:Uv,Erf:Xg,Exp:Kg,ExpandDims:Wv,Expm1:Yg,FFT:c2,Fill:u2,FlipLeftRight:h2,Floor:Zg,FloorDiv:Jg,FromPixels:p_,FusedBatchNorm:Hv,FusedConv2D:Ub,FusedDepthwiseConv2D:Wb,GatherNd:f2,GatherV2:Gv,Greater:jv,GreaterEqual:Qg,IFFT:d2,Identity:ey,Imag:p2,IsFinite:ty,IsInf:ny,IsNan:ry,KernelBackend:VS,LRN:Qv,LRNGrad:g2,LeakyRelu:qv,Less:Xv,LessEqual:Kv,LinSpace:m2,Log:iy,Log1p:sy,LogSoftmax:K7,LogicalAnd:Yv,LogicalNot:Zv,LogicalOr:Jv,LogicalXor:Ege,LowerBound:Ige,MatrixBandPart:Age,Max:ew,MaxPool:tw,MaxPool3D:nw,MaxPool3DGrad:b2,MaxPoolGrad:y2,MaxPoolWithArgmax:v2,Maximum:oy,Mean:rw,Min:iw,Minimum:ay,MirrorPad:sw,Mod:ly,MomentumOptimizer:Fz,Multinomial:w2,Multiply:cy,Neg:ow,NonMaxSuppressionV3:x2,NonMaxSuppressionV4:xM,NonMaxSuppressionV5:_2,NotEqual:aw,OP_SCOPE_SUFFIX:TL,OneHot:cw,OnesLike:lw,Optimizer:Hf,OptimizerConstructors:kY,Pack:uw,PadV2:hw,Pool:Mge,Pow:uy,Prelu:fw,Prod:dw,RMSPropOptimizer:Lz,RaggedGather:_M,RaggedRange:SM,RaggedTensorToTensor:CM,Range:S2,get Rank(){return oD},Real:C2,RealDiv:jg,Reciprocal:hy,get Reduction(){return Ho},Relu:fy,Relu6:dy,Reshape:pw,ResizeBilinear:gw,ResizeBilinearGrad:T2,ResizeNearestNeighbor:mw,ResizeNearestNeighborGrad:k2,Reverse:yw,RotateWithOffset:z2,Round:py,Rsqrt:my,SGDOptimizer:iN,ScatterNd:E2,SearchSorted:A2,Select:bw,Selu:gy,Sigmoid:wy,Sign:vy,Sin:yy,Sinh:by,Slice:vw,Softmax:Sw,Softplus:xy,SpaceToBatchND:xw,SparseFillEmptyRows:kM,SparseReshape:TM,SparseSegmentMean:M2,SparseSegmentSum:N2,SparseToDense:$2,SplitV:_w,Sqrt:_y,Square:R2,SquaredDifference:Sy,StaticRegexReplace:P2,Step:Iy,StridedSlice:D2,StringNGrams:O2,StringSplit:EM,StringToHashBucketFast:IM,Sub:Cy,Sum:ww,Tan:ky,Tanh:Ty,Tensor:jn,TensorBuffer:ls,TensorScatterUpdate:I2,Tile:Ey,TopK:F2,Transform:L2,Transpose:Ld,Unique:AM,Unpack:Cw,UnsortedSegmentSum:kw,UpperBound:Nge,Variable:y_,ZerosLike:Tw,_FusedMatMul:Vb,abs:vs,acos:kX,acosh:TX,add:Xe,addN:EX,all:OL,any:_I,argMax:ig,argMin:IX,asin:AX,asinh:MX,atan:NX,atan2:$X,atanh:RX,avgPool:$M,avgPool3d:LL,backend:rg,backend_util:KY,basicLSTMCell:PX,batchNorm:G2,batchNorm2d:zL,batchNorm3d:BL,batchNorm4d:VL,batchToSpaceND:RM,bincount:UL,bitwiseAnd:DX,booleanMaskAsync:HK,broadcastArgs:OX,broadcastTo:Ab,broadcast_util:sbe,browser:v_e,buffer:Sn,cast:St,ceil:FX,clipByValue:_a,clone:mh,complex:Rf,concat:li,concat1d:WL,concat2d:HL,concat3d:GL,concat4d:jL,conv1d:qL,conv2d:tp,conv2dTranspose:KL,conv3d:YL,conv3dTranspose:ZL,copyRegisteredKernels:Dge,cos:PM,cosh:JL,cosineWindow:JM,cumprod:SI,cumsum:QL,customGrad:xh,denseBincount:CI,deprecationWarn:Uye,depthToSpace:zX,depthwiseConv2d:j2,device_util:lye,diag:BX,dilation2d:VX,disableDeprecationWarnings:Vye,dispose:nn,disposeVariables:Wye,div:Lt,divNoNan:UX,dot:WX,dropout:Iz,einsum:Am,elu:q2,enableDebugMode:Bye,enableProdMode:zye,enclosingPowerOfTwo:Az,engine:wo,ensureShape:HX,env:Ie,equal:xu,erf:GX,euclideanNorm:XX,exp:Jo,expandDims:ss,expm1:KX,eye:DM,fft:qM,fill:$y,findBackend:Xye,findBackendFactory:Kye,floor:X2,floorDiv:DL,fused:QK,gather:K2,gatherND:XK,gather_util:w_e,getBackend:v_,getGradient:rD,getKernel:g_,getKernelsForBackend:bI,grad:Ube,grads:Wbe,greater:tl,greaterEqual:Tp,ifft:C_,imag:Y2,image:Ss,inTopKAsync:KK,io:Bz,irfft:xz,isFinite:YX,isInf:ZX,isNaN:JX,keep:qi,kernel_impls:M_e,leakyRelu:OM,less:S_,lessEqual:Ry,linalg:$z,linspace:QX,localResponseNormalization:eK,log:$l,log1p:FM,logSigmoid:nK,logSoftmax:tz,logSumExp:zM,logicalAnd:_h,logicalNot:BM,logicalOr:nz,logicalXor:rK,losses:iY,lowerBound:iK,matMul:Gn,math:h_e,max:vc,maxPool:UM,maxPool3d:rz,maxPoolWithArgmax:sK,maximum:Uf,mean:Di,memory:xI,meshgrid:oK,min:__,minimum:rp,mirrorPad:iz,mod:aK,moments:Z2,movingAverage:GK,mul:fe,multiRNNCell:lK,multinomial:cK,neg:ci,nextFrame:Wz,norm:Ew,notEqual:qb,oneHot:Xb,ones:ga,onesLike:Rl,op:he,outerProduct:uK,pad:_u,pad1d:hK,pad2d:fK,pad3d:dK,pad4d:pK,pool:mK,pow:np,prelu:HM,print:PL,prod:gK,profile:Hye,raggedGather:yK,raggedRange:bK,raggedTensorToTensor:vK,rand:wK,randomGamma:kK,randomNormal:GM,randomStandardNormal:TK,randomUniform:Ep,randomUniformInt:EK,range:og,ready:H2,real:Kb,reciprocal:IK,registerBackend:NM,registerGradient:Y7,registerKernel:B2,relu:Dh,relu6:pz,removeBackend:qye,reshape:ve,reverse:kc,reverse1d:AK,reverse2d:MK,reverse3d:NK,reverse4d:$K,rfft:XM,round:mz,rsqrt:gz,scalar:Qt,scatterND:jK,scatter_util:Hwe,searchSorted:VM,selu:yz,separableConv2d:bz,serialization:q1e,setBackend:jye,setPlatform:Yye,setdiff1dAsync:RK,sigmoid:Il,sign:PK,signal:rY,sin:vz,sinh:wz,slice:pn,slice1d:J2,slice2d:jM,slice3d:Q2,slice4d:Yb,slice_util:CY,softmax:eC,softplus:Iw,spaceToBatchND:WM,sparse:sY,sparseToDense:qK,spectral:nY,split:Ga,sqrt:_o,square:Or,squaredDifference:_z,squeeze:br,stack:Sa,step:Mw,stridedSlice:DK,string:oY,sub:Dt,sum:Kt,sumOutType:U2,tan:OK,tanh:jb,tensor:Ts,tensor1d:Xi,tensor2d:ja,tensor3d:Sz,tensor4d:FK,tensor5d:LK,tensor6d:zK,tensorScatterUpdate:BK,tensor_util:rye,test_util:rwe,tidy:Se,tile:dc,time:Gye,topk:VK,train:wd,transpose:ir,truncatedNormal:YM,unique:UK,unregisterGradient:Pge,unregisterKernel:Rge,unsortedSegmentSum:kz,unstack:Tc,upcastType:As,upperBound:WK,util:Hge,valueAndGrad:Hbe,valueAndGrads:Gbe,variable:Tz,variableGrads:tK,version_core:k_e,where:xo,whereAsync:Ez,zeros:pi,zerosLike:ur},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yt(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&U(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N_e=ZM;class EN extends VS{nextDataId(){return EN.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new gM(this,wo())}write(e,t,r){this.firstUse&&(this.firstUse=!1,Ie().get("IS_NODE")&&xl(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:r,refCount:1}),i}makeTensorInfo(e,t,r){let i;if(t==="string"&&r!=null&&r.length>0&&du(r[0])){const s=r.map(o=>vu(o));i=this.write(s,e,t)}else i=this.write(r,e,t);return{dataId:i,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,r,i,s){this.data.set(e,{values:t,dtype:i,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:r}=this.data.get(e);if(t==="complex64"){const i=this.readSync(r.real.dataId),s=this.readSync(r.imag.dataId);return Su(i,s)}return q1(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(i=>Sc(i));return Sn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Sn(e.shape,e.dtype,t)}makeOutput(e,t,r){return wo().makeTensorFromTensorInfo(this.makeTensorInfo(t,r,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(e);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=io();return e(),{kernelMs:io()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Yt([e],"where");const t=this.readSync(e.dataId);return N_e(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}EN.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZY(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const $_e=n=>{const{x:e}=n.inputs,t=n.backend;Yt(e,"abs");let r=new Float32Array(Ee(e.shape));const i=t.data.get(e.dataId).values;return r=ZY(i),t.makeOutput(r,e.shape,e.dtype)},R_e={kernelName:Tv,backendName:"cpu",kernelFunc:$_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qi(n){return(e,t,r,i,s)=>{const o=ln(e,t),a=o.length,l=Zt(o),c=Ee(o),u=cs(s,c),h=e.length,f=t.length,d=Zt(e),p=Zt(t),m=Pf(e,o),g=Pf(t,o);if(m.length+g.length===0)for(let y=0;y<u.length;++y)u[y]=n(r[y%r.length],i[y%i.length]);else for(let y=0;y<u.length;++y){const b=Rg(y,a,l),_=b.slice(-h);m.forEach(k=>_[k]=0);const w=bu(_,h,d),S=b.slice(-f);g.forEach(k=>S[k]=0);const C=bu(S,f,p);u[y]=n(r[w],i[C])}return[u,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Va(n){const{inputs:e,backend:t}=n,{real:r,imag:i}=e,s=t.data.get(r.dataId).values,o=t.data.get(i.dataId).values,a=t.makeTensorInfo(r.shape,"complex64"),l=t.data.get(a.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(r.shape,"float32",s),imag:t.makeTensorInfo(i.shape,"float32",o)},a}const P_e={kernelName:KS,backendName:"cpu",kernelFunc:Va};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TI(n,e,t="float32"){if(t==="complex64"){const i=TI(n,e,"float32"),s=TI(n,e,"float32");return Va({inputs:{real:i,imag:s},backend:n})}const r=js(Ee(e),t);return n.makeTensorInfo(e,t,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sh(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const D_e={kernelName:ey,backendName:"cpu",kernelFunc:Sh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lg(n){const{inputs:e,backend:t}=n,{input:r}=e,i=t.data.get(r.dataId).complexTensorInfos.real,s=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,s)}const O_e={kernelName:C2,backendName:"cpu",kernelFunc:lg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JY(n,e,t,r){if(r==="int32"){const i=Int32Array.from(n);return[e,"int32",i]}if(r==="bool"){const i=Sp([0],t),[s,o]=Qi((a,l)=>a!==l?1:0)(e,[],n,i,"bool");return[o,"bool",s]}throw new Error(`Error in Cast: failed to cast ${t} to ${r}`)}function ip(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{dtype:s}=r;if(s==="complex64"){if(i.dtype==="complex64")return Sh({inputs:{x:i},backend:t});const u=TI(t,i.shape,i.dtype),h=ip({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),f=Va({inputs:{real:h,imag:u},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),f}if(i.dtype==="complex64"){const u=lg({inputs:{input:i},backend:t}),h=ip({inputs:{x:u},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(u),h}if(!vM(i.dtype,s)){const u=Sh({inputs:{x:i},backend:t});return{dataId:u.dataId,shape:u.shape,dtype:s}}const o=t.data.get(i.dataId).values,[a,l,c]=JY(o,i.shape,i.dtype,s);return t.makeTensorInfo(a,l,c)}const F_e={kernelName:Vg,backendName:"cpu",kernelFunc:ip};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rs(n,e,t,r){return t==null?({inputs:i,backend:s})=>{const{a:o,b:a}=i,l=s;Yt([o,a],n);const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,h=o.dtype==="string"?Cu(c):c,f=o.dtype==="string"?Cu(u):u,d=r||o.dtype,[p,m]=e(o.shape,a.shape,h,f,d);return l.makeTensorInfo(m,d,p)}:({inputs:i,backend:s})=>{const{a:o,b:a}=i,l=s;if(o.dtype==="complex64"||a.dtype==="complex64"){const c=ip({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.real,f=u.complexTensorInfos.imag,d=l.data.get(h.dataId).values,p=l.data.get(f.dataId).values,m=ip({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,_=l.data.get(y.dataId).values,w=l.data.get(b.dataId).values,[S,C,k]=t(o.shape,a.shape,d,p,_,w),A=l.makeTensorInfo(k,"float32",S),M=l.makeTensorInfo(k,"float32",C),E=Va({inputs:{real:A,imag:M},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(A),l.disposeIntermediateTensorInfo(M),E}else{const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,h=r||o.dtype,[f,d]=e(o.shape,a.shape,c,u,h);return l.makeTensorInfo(d,h,f)}}}function qz(n){return(e,t,r,i,s,o)=>{const a=ln(e,t),l=Ee(a),c=a.length,u=Zt(a),h=cs("float32",l),f=cs("float32",l),d=Pf(e,a),p=Pf(t,a),m=Su(r,i),g=Su(s,o),y=e.length,b=Zt(e),_=t.length,w=Zt(t);if(d.length+p.length===0)for(let S=0;S<h.length;S++){const C=S%m.length,k=S%g.length,A=n(m[C*2],m[C*2+1],g[k*2],g[k*2+1]);h[S]=A.real,f[S]=A.imag}else for(let S=0;S<h.length;S++){const C=Rg(S,c,u),k=C.slice(-y);d.forEach(O=>k[O]=0);const A=bu(k,y,b),M=C.slice(-_);p.forEach(O=>M[O]=0);const E=bu(M,_,w),N=n(m[A*2],m[A*2+1],g[E*2],g[E*2+1]);h[S]=N.real,f[S]=N.imag}return[h,f,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QY=Qi((n,e)=>n+e),L_e=qz((n,e,t,r)=>({real:n+t,imag:e+r})),Zb=Rs(_p,QY,L_e),z_e={kernelName:_p,backendName:"cpu",kernelFunc:Zb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xz(n,e,t,r,i){const s=Ee(r),o=js(i,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(s>0?o[l]+=e[a]:o[l]+=1)}return o}function eZ(n,e,t,r=!1){const i=n.shape[0],s=n.shape[1],o=Sn([i,t],e.dtype);for(let a=0;a<i;a++)for(let l=0;l<s;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(r?o.set(1,a,c):e.size>0?o.set(o.get(a,c)+e.get(a,l),a,c):o.set(o.get(a,c)+1,a,c))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tZ=Qi((n,e)=>n&e),B_e=Rs(qS,tZ),V_e={kernelName:qS,backendName:"cpu",kernelFunc:B_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oh(n){return(e,t,r)=>{const i=Si(t,e.length);for(let s=0;s<e.length;++s)i[s]=n(e[s],r);return i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $r(n,e,t){const r=Oh(e);return Ip(n,r,t)}function Ip(n,e,t){return({inputs:r,attrs:i,backend:s})=>{const{x:o}=r;Yt(o,n);const a=s,l=a.data.get(o.dataId).values;let c;if(o.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=Cu(l)}else c=l;const u=t||o.dtype,h=e(c,u,i);return a.makeTensorInfo(o.shape,u,h)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nZ=Oh(n=>Math.ceil(n)),U_e=Ip(Ug,nZ),W_e={kernelName:Ug,backendName:"cpu",kernelFunc:U_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rZ(n,e,t,r){const i=Si(t,Ee(e));if(r&&t!=="string"){let s=0;n.forEach(o=>{const a=Ee(o.shape);i.set(o.vals,s),s+=a})}else{let s=0;n.forEach(o=>{const a=t==="string"?Cu(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*e[1]+s;for(let h=0;h<o.shape[1];++h)i[u+h]=a[l++]}s+=o.shape[1]})}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iZ=Qi((n,e)=>n===e?1:0),sZ=Rs(Uv,iZ,null,"bool"),H_e={kernelName:Uv,backendName:"cpu",kernelFunc:sZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oZ=Oh(n=>Math.exp(n)),aZ=Ip(Kg,oZ,"float32"),G_e={kernelName:Kg,backendName:"cpu",kernelFunc:aZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lZ=Oh(n=>Math.expm1(n)),j_e=Ip(Yg,lZ),q_e={kernelName:Yg,backendName:"cpu",kernelFunc:j_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cZ=Oh(n=>Math.floor(n)),X_e=Ip(Zg,cZ),K_e={kernelName:Zg,backendName:"cpu",kernelFunc:X_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uZ=Qi((n,e)=>Math.floor(n/e)),Y_e=Rs(Jg,uZ,null,"int32"),Z_e={kernelName:Jg,backendName:"cpu",kernelFunc:Y_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hZ(n,e,t,r,i,s,o,a,l){const c=Sn([r,s],t);for(let u=0;u<r;u++){const h=[];let f=0;for(let d=0;d<i;d++){const p=n[u*i+d];f+=p*o[d],h.push(p)}if(f<0||f>=l/s)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let d=0;d<s;d++)c.values[u*s+d]=e.get(...e.indexToLoc(f*s+d))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fZ(n,e,t){const r=Sn(t,n.dtype);for(let i=0;i<r.size;++i){const o=r.indexToLoc(i).slice(),a=o[0],l=o[2],c=e.locToIndex([a,l]);o[2]=e.values[c];const u=n.locToIndex(o);0<=u&&u<n.values.length&&(r.values[i]=n.values[u])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dZ=Qi((n,e)=>n>e?1:0),J_e=Rs(jv,dZ,null,"bool"),Q_e={kernelName:jv,backendName:"cpu",kernelFunc:J_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pZ=Qi((n,e)=>n>=e?1:0),eSe=Rs(Qg,pZ,null,"bool"),tSe={kernelName:Qg,backendName:"cpu",kernelFunc:eSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mZ=Qi((n,e)=>n<e?1:0),nSe=Rs(Xv,mZ,null,"bool"),rSe={kernelName:Xv,backendName:"cpu",kernelFunc:nSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gZ=Qi((n,e)=>n<=e?1:0),iSe=Rs(Kv,gZ,null,"bool"),sSe={kernelName:Kv,backendName:"cpu",kernelFunc:iSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yZ(n,e,t){const r=(e-n)/(t-1),i=js(t,"float32");i[0]=n;for(let s=1;s<i.length;s++)i[s]=i[s-1]+r;return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bZ=Oh(n=>Math.log(n)),oSe=Ip(iy,bZ),aSe={kernelName:iy,backendName:"cpu",kernelFunc:oSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vZ(n,e,t,r){const i=cs(r,Ee(t));for(let s=0;s<i.length;++s){const o=s*e;let a=n[o];for(let l=0;l<e;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}i[s]=a}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wZ=Qi((n,e)=>Math.max(n,e)),lSe=Rs(oy,wZ),cSe={kernelName:oy,backendName:"cpu",kernelFunc:lSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xZ=Qi((n,e)=>Math.min(n,e)),uSe=Rs(ay,xZ),hSe={kernelName:ay,backendName:"cpu",kernelFunc:uSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kz=Qi((n,e)=>n*e),fSe=qz((n,e,t,r)=>({real:n*t-e*r,imag:n*r+e*t})),IN=Rs(cy,Kz,fSe),dSe={kernelName:cy,backendName:"cpu",kernelFunc:IN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Z(n,e,t){const r=Vf(-1,t);return Kz([],e,r,n,t)}function pSe(n){const{inputs:e,backend:t}=n,{x:r}=e;Yt(r,"neg");const i=t.data.get(r.dataId).values,[s,o]=_Z(i,r.shape,r.dtype);return t.makeTensorInfo(o,r.dtype,s)}const mSe={kernelName:ow,backendName:"cpu",kernelFunc:pSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SZ=Qi((n,e)=>n!==e?1:0),gSe=Rs(aw,SZ,null,"bool"),ySe={kernelName:aw,backendName:"cpu",kernelFunc:gSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yz(n,e,t,r,i){const s=e.length,o=Ee(e),a=Zt(e),l=Zt(i),c=cs(t,Ee(i));for(let u=0;u<o;++u){const h=Rg(u,s,a),f=new Array(h.length);for(let p=0;p<f.length;p++)f[p]=h[r[p]];const d=bu(f,s,l);c[d]=n[u]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ca(n){const{inputs:e,attrs:t,backend:r}=n,{x:i}=e,{perm:s}=t;Yt(i,"transpose");const o=i.shape.length,a=new Array(o);for(let h=0;h<a.length;h++)a[h]=i.shape[s[h]];const l=r.data.get(i.dataId).values,c=Yz(l,i.shape,i.dtype,s,a);return{dataId:r.write(c,a,i.dtype),shape:a,dtype:i.dtype}}const bSe={kernelName:Ld,backendName:"cpu",kernelFunc:Ca};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CZ(n,e,t,r){const[i,s]=Ji(n,r),o=As(e,"int32"),a=js(Ee(i),o),l=Ee(s);for(let c=0;c<a.length;++c){const u=c*l;let h=1;for(let f=0;f<l;++f)h*=t[u+f];a[c]=h}return{outVals:a,outShape:i,outDtype:o}}function vSe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:o}=r;Yt(i,"prod");const a=i.shape.length,l=An(s,i.shape),c=Lr(l,a);let u=l,h=i;const f=[];c!=null&&(h=Ca({inputs:{x:i},backend:t,attrs:{perm:c}}),f.push(h),u=ni(u.length,a));const d=t.data.get(h.dataId).values,{outVals:p,outShape:m,outDtype:g}=CZ(h.shape,h.dtype,d,u);let y=m;return o&&(y=Fi(m,l)),f.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.makeTensorInfo(y,g,p)}const wSe={kernelName:dw,backendName:"cpu",kernelFunc:vSe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xSe(n,e,t){n.forEach((r,i)=>{if(r<0||r>=t){const s=Rg(i,e.length,Zt(e)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${t})`)}})}function _Se(n,e){for(let t=0;t<n.length;++t){const r=n[t],i=t===n.length-1?e:n[t+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>i)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function SSe(n,e,t,r){const i=[];let s=0;const o=e.length-1+t.length,a=new Array(o).fill(null).map(()=>[0]);_Se(t,r);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const u=e[c+1];for(let h=1;h<l+1;++h)a[c].push(h*u)}for(let c=0;c<n.length;++c){let u=n[c],h=n[c]+1;for(let f=0;f<t.length;++f){const d=t[f],p=f+e.length-1;if(p>=0){const m=a[p],g=m[m.length-1]-d[u];for(let y=u;y<h;++y)a[p].push(d[y+1]+g)}u=d[u],h=d[h]}h!==u&&(i.push([u,h]),s+=h-u)}return{outSplits:a,valueSlices:i,numValues:s}}function CSe(n){const e=[];for(let t=0;t<n.length;++t){const r=n[t].length,i=Si("int32",r);e.push(i),n[t].forEach((s,o)=>i[o]=s)}return e}function iH(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let r=e;r<n.length;r++)t[e-1]*=n[r];return t}function kSe(n,e,t,r,i,s){const o=iH(e,2)[1],a=iH(s,2)[1];let l=0;for(const c of t)for(let u=c[0];u<c[1];++u){for(let h=0;h<r;++h)i[l*a+h]=n[u*o+h];++l}}function TSe(n,e,t,r,i){const s=e.slice();s[0]=i;const o=Si(t,Ee(s)),a=n.length,l=a===0?0:a/e[0];return kSe(n,e,r,l,o,s),[o,s]}function kZ(n,e,t,r,i,s,o,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(xSe(s,o,l),r.length===0)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:u,valueSlices:h,numValues:f}=SSe(s,o,n,c),d=CSe(u),p=TSe(t,r,i,h,f);return[d,p[0],p[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sH=2147483647;function TZ(n,e,t,r,i,s,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=i.length===0,c=o.length===0,u=[];a||u.push(e[0]),l||u.push(i[0]),c||u.push(o[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=u.length===0?1:u[0],f=Si("int32",h+1);f[0]=0;for(let g=0;g<h;++g){const y=a?n[0]:n[g],b=l?r[0]:r[g],_=c?s[0]:s[g];if(_===0)throw new Error("Requires delta != 0");let w;if(_>0&&b<y||_<0&&b>y)w=0;else if(w=Math.ceil(Math.abs((b-y)/_)),w>sH)throw new Error(`Requires ((limit - start) / delta) <= ${sH}`);f[g+1]=f[g]+w}const d=f[h],p=Si(t,d);let m=0;for(let g=0;g<h;++g){const y=f[g+1]-f[g];let b=a?n[0]:n[g];const _=c?s[0]:s[g];for(let w=0;w<y;++w)p[m++]=b,b+=_}return[f,p]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Jl=lu;class EI{constructor(e,t,r,i,s,o,a,l,c,u){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=i,this.valuesDType=s,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=EY(u),this.raggedRank=IY(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Jl.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Jl.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Jl.VALUE_ROWIDS:return EI.getMaxWidthValueRowID(t);case Jl.ROW_SPLITS:return EI.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Jl[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let r=0;for(let i=0;i<t-1;++i){const s=e[i+1]-e[i];s>r&&(r=s)}return r}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let r=0,i=e[0],s=0;for(let o=1;o<t;++o){const a=e[o];a!==i&&(i=a,s=Math.max(o-r,s),r=o)}return Math.max(t-r,s)}tensorShapeFromTensor(e,t,r=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return aH(e,r)}calculateOutputSize(e){const t=this.valuesShape,r=this.defaultValueShape;AY(r,t);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=TY(this.raggedRank,i,t);o[0]<0&&(o[0]=e);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(e,t,r){const i=Math.min(e,r),s=[];let o=0;for(let a=0;a<i;++a,o+=t)s.push(o);for(let a=i;a<e;++a)s.push(-1);return U(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,r,i){const s=e.length,o=[];for(let a=0;a<s-1;++a){const l=e[a+1]-e[a];let c=Math.min(i,l),u=t[a];u===-1&&(c=0);for(let h=0;h<c;++h)o.push(u),u+=r;for(let h=0;h<l-c;++h)o.push(-1)}if(s>0&&o.length!==e[s-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,r,i){const s=e.length,o=[];if(s===0)return[];let a=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let c=t[l];o.push(c);for(let u=1;u<s;++u){const h=e[u];if(h===l)c>=0&&(++a,a<i?c+=r:c=-1);else{if(a=0,l=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);c=t[h]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,r,i){const s=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case Jl.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,r,i);case Jl.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,r,i);default:throw new Error(`Unsupported partition type: ${Jl[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Jl.FIRST_DIM_SIZE:return e[0];case Jl.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Jl.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Jl[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),r=this.calculateOutputSize(t),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let l=i.length-2;l>=0;--l)i[l]=i[l+1]*r[l+1];const s=aH(r,!1),o=Si(this.valuesDType,Ee(s));if(i[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(t,i[0],r[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,i[c],r[c]);this.setOutput(this.raggedRank,l,o,s)}return[s,o]}setOutput(e,t,r,i){if(r.length===0)return;const s=this.values,o=r;let a=i.slice();a=a.slice(e+1);const l=Ee(a),c=t.length;let u=this.defaultValue;if(u.length!==l&&u.length!==1){const p=this.defaultValueShape;Se(()=>{const m=ve(u,p);u=Ab(m,a).dataSync()})}let h=0,f=0,d=0;for(let p=0;p<=c;++p){let m=p<c?t[p]:-1;if(m===d){++d;continue}if(f<d){const g=s.subarray(h*l),y=o.subarray(f*l),b=(d-f)*l;oH(y,g,b)}if(p>=c){const g=r.length;m=Math.floor(g/l)}if(m>d)if(this.defaultValue.length===1)o.subarray(d*l,m*l).fill(this.defaultValue[0]),d=m;else for(;m>d;){const g=o.slice(d*l);oH(g,u,l),++d}m<0?(h=p+1,f=d):(h=p,f=d,d=f+1)}}}function oH(n,e,t){for(let r=0;r<t;r++)n[r]=e[r]}function aH(n,e){const t=[];for(let r of n){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}t.push(r)}return t}function EZ(n,e,t,r,i,s,o,a,l,c){return new EI(n,e,t,r,i,s,o,a,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IZ(n,e,t,r){const i=n===e,s=n<e&&t<0,o=e<n&&t>1;if(i||s||o)return js(0,r);const a=Math.abs(Math.ceil((e-n)/t)),l=js(a,r);e<n&&t===1&&(t=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AZ=Oh(n=>1/Math.sqrt(n)),ESe=Ip(my,AZ),ISe={kernelName:my,backendName:"cpu",kernelFunc:ESe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fm(n,e,t,r,i,s,o,a,l,c){const u=[r/i,i],h=n.values,f=e.values;if(r===0)return Sn(t,e.dtype);const d=l instanceof ls?l:Sn(u,e.dtype);typeof l=="string"||typeof l=="number"?d.values.fill(l):typeof l=="boolean"&&d.values.fill(+l);for(let p=0;p<s;p++){const m=[];let g=0;for(let y=0;y<o;y++){const b=h[p*o+y];m.push(b),g+=b*a[y]}if(g<0||g>=r/i)throw new Error(`Invalid indices: ${m} does not index into ${t}`);for(let y=0;y<i;y++)c?d.values[g*i+y]+=f[p*i+y]:d.values[g*i+y]=e.rank===0?f[0]:f[p*i+y]}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ASe=Oh(n=>1/(1+Math.exp(-n))),MZ=$r(wy,n=>1/(1+Math.exp(-n))),MSe={kernelName:wy,backendName:"cpu",kernelFunc:MZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NZ(n,e,t,r,i){const s=Vz(r,e,t),o=Ee(t),a=Zt(r);if(s){const h=Uz(e,a);return i==="string"?n.slice(h,h+o):n.subarray(h,h+o)}const l=i==="string"?Cu(n):n,c=Sn(r,i,l),u=Sn(t,i);for(let h=0;h<u.size;++h){const f=u.indexToLoc(h),d=f.map((p,m)=>p+e[m]);u.set(c.get(...d),...f)}return i==="string"?XY(u.values):u.values}function cg(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{begin:s,size:o}=r;Yt(i,"slice");const[a,l]=oC(i,s,o);oN(i,a,l);const c=t.data.get(i.dataId).values,u=NZ(c,a,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,u)}const NSe={kernelName:vw,backendName:"cpu",kernelFunc:cg};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Z(n,e,t,r,i,s,o){const a=e[0],l=s[0],c=new Array(l),u=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error(OY(a));const g=Si(t,0),y=Si(i,0);return[g,[0,h],y,c,u]}let f=!0,d=0;const p=new Array(l).fill(0);for(let g=0;g<a;++g){const y=n[g*h];if(y<0)throw new Error(FY(g,y));if(y>=l)throw new Error(LY(g,y,l));++p[y],f=f&&y>=d,d=y}let m=!0;for(let g=0;g<l;++g){const y=p[g]===0;c[g]=y,m=m&&!y,p[g]=Math.max(p[g],1),g>0&&(p[g]+=p[g-1])}if(m&&f){const g=n,y=r;for(let b=0;b<a;++b)u[b]=b;return[g,[a,h],y,c,u]}else{const g=p[l-1],y=Si(t,g*h),b=Si(i,g),_=new Array(l).fill(0);for(let w=0;w<a;++w){const S=n[w*h],C=_[S],k=(S===0?0:p[S-1])+C;_[S]++;for(let A=0;A<h;++A)y[k*h+A]=n[w*h+A];b[k]=r[w],u[w]=k}for(let w=0;w<l;++w)if(_[w]===0){const C=w===0?0:p[w-1];y[C*h+0]=w;for(let k=1;k<h;++k)y[C*h+k]=0;b[C]=o}return[y,[g,h],b,c,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RZ(n,e,t,r,i){const s=Ee(r),o=e[0],a=i.length,l=[];let c=1,u=-1;for(let g=0;g<a;++g){const y=i[g];if(y===-1){if(u!==-1)throw new Error(zY(u,g));u=g,l.push(1)}else{if(y<0)throw new Error(BY(g,y));c*=y,l.push(y)}}if(u!==-1){if(c<=0)throw new Error(VY());const g=Math.trunc(s/c);if(c*g!==s)throw new Error(UY(r,l));l[u]=g}if(Ee(l)!==s)throw new Error(WY(r,l));const f=r.length,d=[];if(f>0){d[f-1]=1;for(let g=f-2;g>=0;--g)d[g]=d[g+1]*r[g+1]}const p=[];if(a>0){p[a-1]=1;for(let g=a-2;g>=0;--g)p[g]=p[g+1]*l[g+1]}const m=Si(t,o*a);for(let g=0;g<o;++g){let y=0;for(let b=0;b<f;++b)y+=n[g*f+b]*d[b];for(let b=0;b<a;++b)m[g*a+b]=Math.trunc(y/p[b]),y%=p[b]}return[m,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zz(n,e,t,r,i,s=!1,o=0){const a=r.length,l=[e[0],n.length/e[0]],c=l[1],h=a>0?i[a-1]+1:0;if(h<0)throw new Error(CD());const f=e.slice();f[0]=h;const d=f.reduce((_,w)=>_*w,1),p=Si(t,d);if(a===0)return h>0&&p.fill(o),[p,f];if(h<=0)throw new Error(CD());let m=0,g=1,y=0,b=i[m];for(;;){let _=0;if(g<a){if(_=i[g],b===_){++g;continue}if(b>=_)throw new Error(HY())}if(b<0||b>=h)throw new Error(GY(b,h));b>y&&p.fill(o,y*c,b*c);for(let w=m;w<g;++w){const S=r[w];if(S<0||S>=l[0])throw new Error(jY(w,r[w],l[0]));for(let C=0;C<c;C++)p[b*c+C]+=n[S*c+C]}if(s)for(let w=0;w<c;w++)p[b*c+w]/=g-m;if(m=g,++g,y=b+1,b=_,g>a)break}return y<h&&p.fill(o,y*c,h*c),[p,f]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Se=Oh(n=>Math.sqrt(n)),RSe=$r(_y,n=>Math.sqrt(n)),PSe={kernelName:_y,backendName:"cpu",kernelFunc:RSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PZ=Qi((n,e)=>{const t=n-e;return t*t}),DSe=Rs(Sy,PZ),OSe={kernelName:Sy,backendName:"cpu",kernelFunc:DSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DZ=Oh((n,e)=>{const{pattern:t,replaceGlobal:r,rewrite:i}=e;return n.replace(new RegExp(t,r?"g":""),i)}),FSe=Ip(P2,DZ),LSe={kernelName:P2,backendName:"cpu",kernelFunc:FSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OZ(n,e,t,r){const i=Sn(n,e.dtype);for(let s=0;s<i.size;s++){const o=i.indexToLoc(s),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*t[l]+r[l];i.set(e.get(...a),...o)}return i}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zSe{constructor(e,t,r,i,s,o){this.separator=vu(e),this.nGramWidths=t,this.leftPad=vu(r),this.rightPad=vu(i),this.padWidth=s,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,i,s,o){for(let a=0;a<s;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(s-(a+1))),h=o-(c+u),f=t+(c>0?0:a-l);let d=0;d+=c*this.leftPad.length;for(let b=0;b<h;++b)d+=e[f+b].length;d+=u*this.rightPad.length;const p=c+u+h-1;d+=p*this.separator.length,r[i+a]=new Uint8Array(d);const m=r[i+a];let g=0;const y=b=>b.forEach(_=>m[g++]=_);for(let b=0;b<c;++b)y(this.leftPad),y(this.separator);for(let b=0;b<h-1;++b)y(e[f+b]),y(this.separator);if(h>0){y(e[f+h-1]);for(let b=0;b<u;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<u-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){const r=e.length,i=t.length;if(i>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<i;++c){let u=t[c]>=l;if(u=u&&t[c]<=r,!u)throw new Error(`Invalid split value ${t[c]}, must be in [${l}, ${r}]`);l=t[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const s=i-1,o=Si("int32",i);if(r===0||i===0){const l=new Array(r);for(let c=0;c<=s;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=s;++l){const c=t[l]-t[l-1];let u=0;this.nGramWidths.forEach(h=>{u+=this.getNumNGrams(c,h)}),this.preserveShort&&c>0&&u===0&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[s]);for(let l=0;l<s;++l){const c=t[l];let u=o[l];if(this.nGramWidths.forEach(h=>{const f=t[l+1]-t[l],d=this.getNumNGrams(f,h);this.createNGrams(e,c,a,u,d,h),u+=d}),this.preserveShort&&u===o[l]){const h=t[l+1]-t[l];if(h===0)continue;const f=h+2*this.padWidth,d=1;this.createNGrams(e,c,a,u,d,f)}}return[a,o]}}function FZ(n,e,t,r,i,s,o,a){return new zSe(t,r,i,s,o,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BSe(n,e,t,r){if(!n.length)return;if(e.length===0){for(let s=0;s<n.length;++s)r.push(n.subarray(s,s+1));return}if(e.length===1){const s=e[0];let o=n.indexOf(s);for(;o!==-1;){const a=n.subarray(0,o);(!t||a.length!==0)&&r.push(a),n=n.subarray(o+1),o=n.indexOf(s)}(!t||n.length!==0)&&r.push(n);return}let i=0;for(let s=0;s<n.length+1;s++)if(s===n.length||e.indexOf(n[s])!==-1){const o=n.subarray(i,s);(!t||o.length!==0)&&r.push(o),i=s+1}}function LZ(n,e,t){const r=n.length,i=[];let s=0,o=0;const a=new Array(r);for(let f=0;f<r;++f){const d=i.length;BSe(n[f],e,t,i);const p=i.length-d;a[f]=p,s+=p,o=Math.max(o,p)}const l=Si("int32",s*2),c=new Array(s),u=[r,o];let h=0;for(let f=0;f<r;++f)for(let d=0;d<a[f];++d)l[h*2]=f,l[h*2+1]=d,c[h]=i[h],++h;return[l,c,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zZ(n,e){const t=Si("int32",n.length);for(let r=0;r<n.length;++r)t[r]=oX(n[r]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BZ=Qi((n,e)=>n-e),VSe=qz((n,e,t,r)=>({real:n-t,imag:e-r})),Jz=Rs(Cy,BZ,VSe),USe={kernelName:Cy,backendName:"cpu",kernelFunc:Jz};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VZ(n,e){const t=new Array(n.rank);for(let i=0;i<t.length;i++)t[i]=n.shape[i]*e[i];const r=Sn(t,n.dtype);for(let i=0;i<r.values.length;++i){const s=r.indexToLoc(i),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=s[l]%n.shape[l];const a=n.locToIndex(o);r.values[i]=n.values[a]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v1=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function UZ(n,e,t=0,r=n.length-1){for(;r>t;){if(r-t>600){const a=r-t+1,l=e-t+1,c=Math.log(a),u=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2),f=Math.max(t,Math.floor(e-l*u/a+h)),d=Math.min(r,Math.floor(e+(a-l)*u/a+h));UZ(n,e,f,d)}const i=n[e];let s=t,o=r;for(Sf(n,t,e),v1(n[r],i)>0&&Sf(n,t,r);s<o;){for(Sf(n,s,o),s++,o--;v1(n[s],i)<0;)s=s+1;for(;v1(n[o],i)>0;)o=o-1}v1(n[t],i)===0?Sf(n,t,o):(o=o+1,Sf(n,o,r)),o<=e&&(t=o+1),e<=o&&(r=o-1)}}function WZ(n,e,t,r,i){const s=e[e.length-1],[o,a]=[n.length/s,s],l=cs(t,o*r),c=cs("int32",o*r);for(let h=0;h<o;h++){const f=h*a,d=n.subarray(f,f+a);let p=new Array(d.length);d.forEach((b,_)=>p[_]={value:b,index:_}),r<p.length&&(UZ(p,r),p=p.slice(0,r)),i&&p.sort(v1);const m=h*r,g=l.subarray(m,m+r),y=c.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=p[b].value,y[b]=p[b].index}const u=e.slice();return u[u.length-1]=r,[Sn(u,t,l),Sn(u,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HZ(n,e,t,r){const i=An(e,t)[0],s=[1,t[0],1];for(let p=0;p<i;p++)s[0]*=t[p];s[1]=t[i];for(let p=i+1;p<t.length;p++)s[2]*=t[p];const o=new Map,a=new Int32Array(t[i]),l=new ls(s,r,n),c=[],u=s[0]===1&&s[2]===1;for(let p=0;p<t[i];p++){let m;if(u)m=n[p].toString();else{const y=[];for(let b=0;b<s[0];b++)for(let _=0;_<s[2];_++)y.push(l.get(b,p,_));m=y.join(",")}const g=o.get(m);if(g!=null)a[p]=g;else{const y=o.size;o.set(m,y),a[p]=y,c.push(p)}}const h=s.slice();h[1]=o.size;const f=new ls(h,r);c.forEach((p,m)=>{for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)f.set(l.get(g,p,y),g,m,y)});const d=t.slice();return d[i]=h[1],{outputValues:f.values,outputShape:d,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GZ=Object.freeze(Object.defineProperty({__proto__:null,addImpl:QY,bincountImpl:Xz,bincountReduceImpl:eZ,bitwiseAndImpl:tZ,castImpl:JY,ceilImpl:nZ,concatImpl:rZ,equalImpl:iZ,expImpl:oZ,expm1Impl:lZ,floorDivImpl:uZ,floorImpl:cZ,gatherNdImpl:hZ,gatherV2Impl:fZ,greaterEqualImpl:pZ,greaterImpl:dZ,lessEqualImpl:gZ,lessImpl:mZ,linSpaceImpl:yZ,logImpl:bZ,maxImpl:vZ,maximumImpl:wZ,minimumImpl:xZ,multiplyImpl:Kz,negImpl:_Z,notEqualImpl:SZ,prodImpl:CZ,raggedGatherImpl:kZ,raggedRangeImpl:TZ,raggedTensorToTensorImpl:EZ,rangeImpl:IZ,rsqrtImpl:AZ,scatterImpl:Fm,sigmoidImpl:ASe,simpleAbsImpl:ZY,sliceImpl:NZ,sparseFillEmptyRowsImpl:$Z,sparseReshapeImpl:RZ,sparseSegmentReductionImpl:Zz,sqrtImpl:$Se,squaredDifferenceImpl:PZ,staticRegexReplaceImpl:DZ,stridedSliceImpl:OZ,stringNGramsImpl:FZ,stringSplitImpl:LZ,stringToHashBucketFastImpl:zZ,subImpl:BZ,tileImpl:VZ,topKImpl:WZ,transposeImpl:Yz,uniqueImpl:HZ},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */NM("cpu",()=>new EN,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jZ=$r(qg,n=>n>=0?n:Math.exp(n)-1),WSe={kernelName:qg,backendName:"cpu",kernelFunc:jZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qZ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{alpha:s}=r;Yt([i],"leakyRelu");const o=Ee(i.shape),a=t.data.get(i.dataId).values,l=cs("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?s*a[c]:a[c];return t.makeTensorInfo(i.shape,"float32",l)}const HSe={kernelName:qv,backendName:"cpu",kernelFunc:qZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GSe=Qi((n,e)=>n<0?e*n:n);function XZ(n){const{inputs:e,backend:t}=n,{x:r,alpha:i}=e;Yt([r,i],"prelu");const s=t.data.get(r.dataId).values,o=t.data.get(i.dataId).values,[a,l]=GSe(r.shape,i.shape,s,o,"float32");return t.makeTensorInfo(l,"float32",a)}const jSe={kernelName:fw,backendName:"cpu",kernelFunc:XZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KZ=$r(fy,n=>Math.max(0,n)),qSe={kernelName:fy,backendName:"cpu",kernelFunc:KZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YZ=$r(dy,n=>Math.min(Math.max(0,n),6)),XSe={kernelName:dy,backendName:"cpu",kernelFunc:YZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function II(n,e,t,r,i){if(t==="linear")return Sh({inputs:{x:e},backend:n});if(t==="relu")return KZ({inputs:{x:e},backend:n});if(t==="elu")return jZ({inputs:{x:e},backend:n});if(t==="relu6")return YZ({inputs:{x:e},backend:n});if(t==="prelu")return XZ({inputs:{x:e,alpha:r},backend:n});if(t==="leakyrelu")return qZ({inputs:{x:e},backend:n,attrs:{alpha:i}});if(t==="sigmoid")return MZ({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ei(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{shape:s}=r,o=Ee(i.shape),a=bM(s,o),l=Ee(a);U(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(i.dataId);const c=t.data.get(i.dataId);if(c.complexTensorInfos!=null){const u=c.complexTensorInfos.real,h=c.complexTensorInfos.imag;u.shape=a,h.shape=a}return{dataId:i.dataId,shape:a,dtype:i.dtype}}const KSe={kernelName:pw,backendName:"cpu",kernelFunc:ei};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZZ(n){const{inputs:e,backend:t,attrs:r}=n,{a:i,b:s}=e,{transposeA:o,transposeB:a}=r;Yt([i,s],"matMul");const l=i.shape.length,c=s.shape.length,u=o?i.shape[l-2]:i.shape[l-1],h=a?s.shape[c-1]:s.shape[c-2],f=o?i.shape[l-1]:i.shape[l-2],d=a?s.shape[c-2]:s.shape[c-1],p=i.shape.slice(0,-2),m=s.shape.slice(0,-2),g=Ee(p),y=Ee(m),_=ln(i.shape.slice(0,-2),s.shape.slice(0,-2)).concat([f,d]);U(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${i.shape} and ${s.shape} and transposeA=${o} and transposeB=${a} must match.`);const w=o?[g,u,f]:[g,f,u],S=a?[y,d,h]:[y,h,d],C=ei({inputs:{x:i},backend:t,attrs:{shape:w}}),k=ei({inputs:{x:s},backend:t,attrs:{shape:S}}),A=o?C.shape[1]:C.shape[2],M=o?C.shape[2]:C.shape[1],E=a?k.shape[1]:k.shape[2],N=Math.max(g,y),O=t.data.get(C.dataId).values,R=t.data.get(k.dataId).values,D=Zt(C.shape),z=Zt(k.shape),[B,X,H]=o?[D[0],1,D[1]]:[D[0],D[1],1],[te,ge,ae]=a?[1,z[1],z[0]]:[z[1],1,z[0]],Ne=M*E,Te=Sn([N,M,E],C.dtype),De=Te.values,be=t.blockSize;for(let Ke=0;Ke<N;Ke++){const Oe=Ke%g,ot=Ke%y;for(let He=0;He<M;He+=be){const mt=Math.min(He+be,M);for(let ht=0;ht<E;ht+=be){const Ue=Math.min(ht+be,E);for(let Be=0;Be<A;Be+=be){const Ve=Math.min(Be+be,A);for(let ft=He;ft<mt;ft++)for(let Ye=ht;Ye<Ue;Ye++){let ee=0;for(let J=Be;J<Ve;J++){const it=O[Oe*B+ft*X+J*H],Ge=R[J*te+Ye*ge+ot*ae];ee+=it*Ge}De[Ke*Ne+(ft*E+Ye)]+=ee}}}}}return t.disposeIntermediateTensorInfo(C),t.disposeIntermediateTensorInfo(k),t.makeTensorInfo(_,Te.dtype,Te.values)}const YSe={kernelName:$v,backendName:"cpu",kernelFunc:ZZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZSe(n){const{inputs:e,backend:t,attrs:r}=n,{a:i,b:s,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;let f,d,p;const m=[];f=ZZ({inputs:{a:i,b:s},attrs:{transposeA:l,transposeB:c},backend:t}),o&&(d=Zb({inputs:{a:f,b:o},backend:t}),m.push(f),f=d),u&&(p=II(t,f,u,a,h),m.push(f),f=p);for(const y of m)t.disposeIntermediateTensorInfo(y);return f}const JSe={kernelName:Vb,backendName:"cpu",kernelFunc:ZSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QSe=$r(Pg,n=>Math.acos(n)),e2e={kernelName:Pg,backendName:"cpu",kernelFunc:QSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t2e=$r(Dg,n=>Math.acosh(n)),n2e={kernelName:Dg,backendName:"cpu",kernelFunc:t2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r2e(n){const{inputs:e,backend:t}=n,r=e;Yt(e,"addN");const i=r.map(a=>t.data.get(a.dataId).values),s=Sn(r[0].shape,r[0].dtype),o=s.values;for(let a=0;a<r.length;a++){const l=i[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return t.makeTensorInfo(s.shape,s.dtype,s.values)}const i2e={kernelName:Ev,backendName:"cpu",kernelFunc:r2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:o}=r;Yt(i,"all");const a=An(s,i.shape);let l=a;const c=Lr(l,i.shape.length);let u=i;c!=null&&(u=Ca({inputs:{x:i},backend:t,attrs:{perm:c}}),l=ni(l.length,i.shape.length)),hs("all",l,u.shape.length);const[h,f]=Ji(u.shape,l),d=Ee(f),p=js(Ee(h),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*d;let _=m[b];for(let w=0;w<d;++w){const S=m[b+w];_=_&&S}p[y]=_}c!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(h,u.dtype,p);if(o){const y=Fi(h,a),b=ei({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const o2e={kernelName:US,backendName:"cpu",kernelFunc:s2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:o}=r;Yt(i,"any");const a=An(s,i.shape);let l=a;const c=Lr(l,i.shape.length);let u=i;c!=null&&(u=Ca({inputs:{x:i},backend:t,attrs:{perm:c}}),l=ni(l.length,i.shape.length)),hs("any",l,u.shape.length);const[h,f]=Ji(u.shape,l),d=Ee(f),p=js(Ee(h),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*d;let _=m[b];for(let w=0;w<d;++w){const S=m[b+w];_=_||S}p[y]=_}c!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(h,u.dtype,p);if(o){const y=Fi(h,a),b=ei({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const l2e={kernelName:WS,backendName:"cpu",kernelFunc:a2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s}=r;Yt(i,"argMax");let o=An(s,i.shape);const a=Lr(o,i.shape.length);let l=i;const c=[];a!=null&&(l=Ca({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=ni(o.length,l.shape.length)),o=[o[0]],hs("argMax",o,l.shape.length);const[u,h]=Ji(l.shape,o),f=Ee(u),d=js(f,"int32"),p=Ee(h),m=t.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const y=g*p;let b=m[y],_=0;for(let w=0;w<p;++w){const S=m[y+w];S>b&&(b=S,_=w)}d[g]=_}return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(u,"int32",d)}const u2e={kernelName:Iv,backendName:"cpu",kernelFunc:c2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s}=r;Yt(i,"argMin");let o=An(s,i.shape);const a=Lr(o,i.shape.length);let l=i;const c=[];a!=null&&(l=Ca({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=ni(o.length,l.shape.length)),o=[o[0]],hs("argMin",o,l.shape.length);const[u,h]=Ji(l.shape,o),f=Ee(u),d=js(f,"int32"),p=Ee(h),m=t.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const y=g*p;let b=m[y],_=0;for(let w=0;w<p;++w){const S=m[y+w];S<b&&(b=S,_=w)}d[g]=_}return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(u,"int32",d)}const f2e={kernelName:Av,backendName:"cpu",kernelFunc:h2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d2e=$r(Og,n=>Math.asin(n)),p2e={kernelName:Og,backendName:"cpu",kernelFunc:d2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m2e=$r(Fg,n=>Math.asinh(n)),g2e={kernelName:Fg,backendName:"cpu",kernelFunc:m2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y2e=$r(Lg,n=>Math.atan(n)),b2e={kernelName:Lg,backendName:"cpu",kernelFunc:y2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v2e=Qi((n,e)=>Math.atan2(n,e)),w2e=Rs(Bg,v2e),x2e={kernelName:Bg,backendName:"cpu",kernelFunc:w2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _2e=$r(zg,n=>Math.atanh(n)),S2e={kernelName:zg,backendName:"cpu",kernelFunc:_2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qz(n,e,t,r,i,s){const o=i.strideHeight,a=i.strideWidth,l=i.dilationHeight,c=i.dilationWidth,u=i.effectiveFilterHeight,h=i.effectiveFilterWidth,f=i.padInfo.top,d=i.padInfo.left,p=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Sn(i.outShape,t),g=m.values,y=i.outShape[1]*i.outShape[2]*i.outShape[3],b=i.outShape[2]*i.outShape[3],_=i.outShape[3];for(let w=0;w<i.batchSize;++w){const S=w*y,C=w*r[0];for(let k=0;k<i.inChannels;++k)for(let A=0;A<i.outHeight;++A){const M=A*o-f,E=Math.max(0,M),N=Math.min(i.inHeight,u+M),O=S+A*b;for(let R=0;R<i.outWidth;++R){const D=R*a-d,z=Math.max(0,D),B=Math.min(i.inWidth,h+D);let X=p,H=0,te=0;for(let ae=E;ae<N;ae+=l){const Ne=C+ae*r[1];for(let Te=z;Te<B;Te+=c){const De=Ne+Te*r[2],be=n[De+k];s==="max"&&be>X?X=be:s==="avg"&&(H+=be,te++)}if(isNaN(X))break}const ge=O+R*_+k;g[ge]=s==="avg"?H/te:X}}}return m}function JZ(n,e,t,r,i=!1,s=!1){const o=Sn(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,h=r.effectiveFilterHeight,f=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,m=Sn(e,t,n);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){const _=b*a-d;let w=_;for(;w<0;)w+=c;const S=Math.min(r.inHeight,h+_);for(let C=0;C<r.outWidth;++C){const k=C*l-p;let A=k;for(;A<0;)A+=u;const M=Math.min(r.inWidth,f+k);let E=Number.NEGATIVE_INFINITY,N=-1;for(let O=w;O<S;O+=c){const R=O-_;for(let D=A;D<M;D+=u){const z=D-k,B=m.get(g,O,D,y);B>E&&(E=B,i?N=s?((g*r.inHeight+O)*r.inWidth+D)*r.inChannels+y:(O*r.inWidth+D)*r.inChannels+y:N=R*f+z)}}o.set(N,g,b,C,y)}}return o}function QZ(n,e,t,r,i,s){const o=i.strideDepth,a=i.strideHeight,l=i.strideWidth,c=i.dilationDepth,u=i.dilationHeight,h=i.dilationWidth,f=i.effectiveFilterDepth,d=i.effectiveFilterHeight,p=i.effectiveFilterWidth,m=i.padInfo.front,g=i.padInfo.top,y=i.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,_=Sn(i.outShape,t),w=_.values,S=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],C=i.outShape[2]*i.outShape[3]*i.outShape[4],k=i.outShape[3]*i.outShape[4],A=i.outShape[4];for(let M=0;M<i.batchSize;++M){const E=M*S,N=M*r[0];for(let O=0;O<i.inChannels;++O)for(let R=0;R<i.outDepth;++R){const D=R*o-m;let z=D;for(;z<0;)z+=c;const B=Math.min(i.inDepth,f+D),X=E+R*C;for(let H=0;H<i.outHeight;++H){const te=H*a-g;let ge=te;for(;ge<0;)ge+=u;const ae=Math.min(i.inHeight,d+te),Ne=X+H*k;for(let Te=0;Te<i.outWidth;++Te){const De=Te*l-y;let be=De;for(;be<0;)be+=h;const Ke=Math.min(i.inWidth,p+De),Oe=Ne+Te*A;let ot=b,He=0,mt=0;for(let Ue=z;Ue<B;Ue+=c){const Be=N+Ue*r[1];for(let Ve=ge;Ve<ae;Ve+=u){const ft=Be+Ve*r[2];for(let Ye=be;Ye<Ke;Ye+=h){const ee=ft+Ye*r[3],J=n[ee+O];if(s==="max"&&J>ot?ot=J:s==="avg"&&(He+=J,mt++),isNaN(ot))break}if(isNaN(ot))break}if(isNaN(ot))break}const ht=Oe+O;w[ht]=s==="avg"?He/Math.max(mt,1):ot}}}}return _}function C2e(n,e){const t=Sn(e.outShape,"int32"),r=e.strideDepth,i=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=e.padInfo.front,d=e.padInfo.top,p=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const b=y*r-f;let _=b;for(;_<0;)_+=o;const w=Math.min(e.inDepth,c+b);for(let S=0;S<e.outHeight;++S){const C=S*i-d;let k=C;for(;k<0;)k+=a;const A=Math.min(e.inHeight,u+C);for(let M=0;M<e.outWidth;++M){const E=M*s-p;let N=E;for(;N<0;)N+=l;const O=Math.min(e.inWidth,h+E);let R=Number.NEGATIVE_INFINITY,D=-1;for(let z=_;z<w;z+=o){const B=z-b;for(let X=k;X<A;X+=a){const H=X-C;for(let te=N;te<O;te+=l){const ge=te-E,ae=n.get(m,z,X,te,g);ae>=R&&(R=ae,D=B*u*h+H*u+ge)}}}t.set(D,m,y,S,M,g)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e;Yt(i,"avgPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U($s(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ko(i.shape,s,o,c,a,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&Rn(u.inShape,u.outShape))h=Sh({inputs:{x:i},backend:t});else{const f=t.data.get(i.dataId).values,d=Zt(i.shape),p=Qz(f,i.shape,i.dtype,d,u,"avg");h=t.makeTensorInfo(u.outShape,i.dtype,p.values)}return h}const T2e={kernelName:Mv,backendName:"cpu",kernelFunc:k2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;Yt(i,"avgPool3d");const u=Ll(i.shape,s,o,1,a,l,c),h=t.data.get(i.dataId).values,f=QZ(h,i.shape,i.dtype,Zt(i.shape),u,"avg");return t.makeTensorInfo(f.shape,"float32",f.values)}const I2e={kernelName:Nv,backendName:"cpu",kernelFunc:E2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A2e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;Yt([i,s],"avgPool3DGrad");const u=Ll(s.shape,o,a,1,l,c),h=u.strideDepth,f=u.strideHeight,d=u.strideWidth,p=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,_=u.dilationWidth,w=u.effectiveFilterDepth,S=u.effectiveFilterHeight,C=u.effectiveFilterWidth,k=w-1-u.padInfo.front,A=C-1-u.padInfo.left,M=S-1-u.padInfo.top,E=Sn(s.shape,"float32"),N=1/(p*m*g),O=t.bufferSync(i);for(let R=0;R<u.batchSize;++R)for(let D=0;D<u.inChannels;++D)for(let z=0;z<u.inDepth;++z)for(let B=0;B<u.inHeight;++B)for(let X=0;X<u.inWidth;++X){const H=z-k,te=B-M,ge=X-A;let ae=0;for(let Ne=0;Ne<w;Ne+=y){const Te=(H+Ne)/h;if(!(Te<0||Te>=u.outDepth||Math.floor(Te)!==Te))for(let De=0;De<S;De+=b){const be=(te+De)/f;if(!(be<0||be>=u.outHeight||Math.floor(be)!==be))for(let Ke=0;Ke<C;Ke+=_){const Oe=(ge+Ke)/d;if(Oe<0||Oe>=u.outWidth||Math.floor(Oe)!==Oe)continue;const ot=O.get(R,Te,be,Oe,D);ae+=ot}}}E.set(ae*N,R,z,B,X,D)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const M2e={kernelName:GS,backendName:"cpu",kernelFunc:A2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N2e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,o=s;Yt([i,s],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=ko(o.shape,a,l,1,c),h=u.strideHeight,f=u.strideWidth,d=u.filterHeight,p=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,_=b-1-u.padInfo.left,w=y-1-u.padInfo.top,S=Sn(o.shape,"float32"),C=1/(d*p),k=t.data.get(i.dataId).values,A=Sn(i.shape,"float32",k);for(let M=0;M<u.batchSize;++M)for(let E=0;E<u.inChannels;++E)for(let N=0;N<u.inHeight;++N)for(let O=0;O<u.inWidth;++O){const R=N-w,D=O-_;let z=0;for(let B=0;B<y;B+=m){const X=(R+B)/h;if(!(X<0||X>=u.outHeight||Math.floor(X)!==X))for(let H=0;H<b;H+=g){const te=(D+H)/f;if(te<0||te>=u.outWidth||Math.floor(te)!==te)continue;const ge=A.get(M,X,te,E);z+=ge}}S.set(z*C,M,N,O,E)}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const $2e={kernelName:HS,backendName:"cpu",kernelFunc:N2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,scale:s,offset:o,mean:a,variance:l}=e;U(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Yt([i,a,l,s,o],"batchNorm");let{varianceEpsilon:c}=r;c==null&&(c=.001);const u=t.data.get(i.dataId).values,h=t.data.get(a.dataId).values,f=t.data.get(l.dataId).values,d=s?t.data.get(s.dataId).values:new Float32Array([1]),p=o?t.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=p.length,y=d.length,b=f.length,_=h.length;let w=0,S=0,C=0,k=0;for(let A=0;A<u.length;++A)m[A]=p[w++]+(u[A]-h[S++])*d[C++]/Math.sqrt(f[k++]+c),w>=g&&(w=0),S>=_&&(S=0),C>=y&&(C=0),k>=b&&(k=0);return t.makeTensorInfo(i.shape,i.dtype,m)}const P2e={kernelName:Hv,backendName:"cpu",kernelFunc:R2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockShape:s,crops:o}=r;Yt([i],"batchToSpaceND");const a=s.reduce((y,b)=>y*b),l=Oy(i.shape,s,a),c=Fy(l.length,s.length),u=Ly(i.shape,s,a),h=fN(o,s.length),f=dN(u,o,s.length),d=ei({inputs:{x:i},backend:t,attrs:{shape:l}}),p=Ca({inputs:{x:d},backend:t,attrs:{perm:c}}),m=ei({inputs:{x:p},backend:t,attrs:{shape:u}}),g=cg({inputs:{x:m},backend:t,attrs:{begin:h,size:f}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}const O2e={kernelName:Rv,backendName:"cpu",kernelFunc:D2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,weights:s}=e,{size:o}=r,a=t.data.get(i.dataId).values,l=t.data.get(s.dataId).values,c=Xz(a,l,s.dtype,s.shape,o);return t.makeTensorInfo([o],s.dtype,c)}const L2e={kernelName:jS,backendName:"cpu",kernelFunc:F2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2e(n){const{inputs:e,backend:t}=n,{s0:r,s1:i}=e,s=t.data.get(r.dataId).values,o=t.data.get(i.dataId).values,a=ln(Array.from(s),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const B2e={kernelName:XS,backendName:"cpu",kernelFunc:z2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V2e=$r(Wg,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),U2e={kernelName:Wg,backendName:"cpu",kernelFunc:V2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W2e=n=>{const{x:e}=n.inputs,t=n.backend,r=new Float32Array(Ee(e.shape)),i=t.data.get(e.dataId),s=i.complexTensorInfos.real,o=i.complexTensorInfos.imag,a=t.data.get(s.dataId).values,l=t.data.get(o.dataId).values;for(let c=0;c<a.length;c++){const u=a[c],h=l[c];r[c]=Math.hypot(u,h)}return t.makeOutput(r,e.shape,"float32")},H2e={kernelName:Pv,backendName:"cpu",kernelFunc:W2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jb(n){const{inputs:e,backend:t}=n,{input:r}=e,i=t.data.get(r.dataId).complexTensorInfos.imag,s=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,s)}const G2e={kernelName:p2,backendName:"cpu",kernelFunc:Jb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qb(n){const{inputs:e,backend:t,attrs:r}=n,{axis:i}=r,s=An(i,e[0].shape)[0],o=e.map(m=>m.shape);cN(o,s);let a=va(e.map(m=>m.shape),s);if(Ee(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(m=>Ee(m.shape)>0);if(l.length===1)return Sh({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const m=l.map(w=>lg({inputs:{input:w},backend:t})),g=l.map(w=>Jb({inputs:{input:w},backend:t})),y=Qb({inputs:m,backend:t,attrs:{axis:s}}),b=Qb({inputs:g,backend:t,attrs:{axis:s}}),_=Va({inputs:{real:y,imag:b},backend:t});return m.forEach(w=>t.disposeIntermediateTensorInfo(w)),g.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),_}const c=l.map(m=>{const y=[-1,Ee(m.shape.slice(s))];return ei({inputs:{x:m},backend:t,attrs:{shape:y}})}),u=c.map(m=>({vals:t.data.get(m.dataId).values,shape:m.shape}));a=va(c.map(m=>m.shape),1);const h=c[0].shape[0]===1,f=rZ(u,a,e[0].dtype,h),d=va(l.map(m=>m.shape),s),p=t.makeTensorInfo(d,e[0].dtype,f);return c.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}const j2e={kernelName:Dv,backendName:"cpu",kernelFunc:Qb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r;Yt([i,s],"conv2d");const h=el(l),f=ti(i.shape,s.shape,o,c,a,u,!1,h),d=f.filterHeight,p=f.filterWidth,m=f.dilationHeight,g=f.dilationWidth,y=f.padInfo.left,b=f.padInfo.top,_=f.dataFormat==="channelsLast",w=new ls(f.outShape,i.dtype),S=Zt(i.shape),C=Zt(s.shape),k=S[0],A=_?S[1]:S[2],M=_?S[2]:1,E=_?1:S[1],N=w.strides[0],O=_?w.strides[1]:w.strides[2],R=_?w.strides[2]:1,D=_?1:w.strides[1],z=t.data.get(i.dataId).values,B=t.data.get(s.dataId).values,X=w.values;for(let H=0;H<f.batchSize;++H){const te=H*k,ge=H*N;for(let ae=0;ae<f.outHeight;++ae){const Ne=ge+ae*O,Te=ae*f.strideHeight-b;for(let De=0;De<d;++De){const be=Te+De*m;if(be<0||be>=f.inHeight)continue;const Ke=De*C[0],Oe=te+be*A;for(let ot=0;ot<f.outWidth;++ot){const He=Ne+ot*R,mt=ot*f.strideWidth-y;for(let ht=0;ht<p;++ht){const Ue=mt+ht*g;if(Ue<0||Ue>=f.inWidth)continue;const Be=Ke+ht*C[1],Ve=Oe+Ue*M;let ft=Be;for(let Ye=0;Ye<f.inChannels;++Ye){const ee=z[Ve+Ye*E];for(let J=0;J<f.outChannels;++J)X[He+J*D]+=ee*B[ft+J];ft+=f.outChannels}}}}}}return t.makeTensorInfo(w.shape,w.dtype,X)}const q2e={kernelName:Ov,backendName:"cpu",kernelFunc:eJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;Yt([i,s],"conv2dBackpropFilter");const h=el(l),f=ti(i.shape,u,o,1,a,c,!1,h),{strideHeight:d,strideWidth:p,filterHeight:m,filterWidth:g}=f,y=f.dataFormat==="channelsLast",b=new ls(f.filterShape,"float32"),_=f.padInfo.left,w=f.padInfo.top,S=t.data.get(i.dataId).values,C=t.data.get(s.dataId).values,k=new ls(i.shape,i.dtype,S),A=new ls(s.shape,s.dtype,C);for(let M=0;M<m;++M){const E=Math.max(0,Math.ceil((w-M)/d)),N=Math.min(f.outHeight,(f.inHeight+w-M)/d);for(let O=0;O<g;++O){const R=Math.max(0,Math.ceil((_-O)/p)),D=Math.min(f.outWidth,(f.inWidth+_-O)/p);for(let z=0;z<f.inChannels;++z)for(let B=0;B<f.outChannels;++B){let X=0;for(let H=0;H<f.batchSize;++H)for(let te=E;te<N;++te){const ge=M+te*d-w;for(let ae=R;ae<D;++ae){const Ne=O+ae*p-_;y?X+=k.get(H,ge,Ne,z)*A.get(H,te,ae,B):X+=k.get(H,z,ge,Ne)*A.get(H,B,te,ae)}}b.set(X,M,O,z,B)}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const K2e={kernelName:YS,backendName:"cpu",kernelFunc:X2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y2e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r;Yt([i,s],"conv2dBackpropInput");const h=Zt(s.shape),f=Zt(i.shape);let d=el(c);const p=ti(o,s.shape,a,1,l,u,!1,d),m=new ls(p.inShape,"float32"),g=m.values,y=t.data.get(i.dataId).values,b=t.data.get(s.dataId).values,[_,w,S]=h,{batchSize:C,filterHeight:k,filterWidth:A,inChannels:M,inHeight:E,inWidth:N,outChannels:O,outHeight:R,outWidth:D,strideHeight:z,strideWidth:B}=p;d=p.dataFormat;const X=k-1-p.padInfo.top,H=A-1-p.padInfo.left,te=d==="channelsLast",ge=m.strides[0],ae=te?m.strides[1]:m.strides[2],Ne=te?m.strides[2]:1,Te=te?1:m.strides[1],De=f[0],be=te?f[1]:f[2],Ke=te?f[2]:1,Oe=te?1:f[1];for(let ot=0;ot<C;++ot)for(let He=0;He<M;++He)for(let mt=0;mt<E;++mt){const ht=mt-X,Ue=Math.max(0,Math.ceil(ht/z)),Be=Math.min(R,(k+ht)/z);for(let Ve=0;Ve<N;++Ve){const ft=Ve-H,Ye=Math.max(0,Math.ceil(ft/B)),ee=Math.min(D,(A+ft)/B);let J=0;for(let Ge=Ue;Ge<Be;++Ge){const ye=Ge*z-ht;for(let Je=Ye;Je<ee;++Je){const bt=Je*B-ft,It=De*ot+be*Ge+Ke*Je,pt=_*(k-1-ye)+w*(A-1-bt)+S*He;for(let ce=0;ce<O;++ce){const rt=y[It+Oe*ce],Et=b[pt+ce];J+=rt*Et}}}const it=ge*ot+ae*mt+Ne*Ve+Te*He;g[it]=J}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const Z2e={kernelName:Fv,backendName:"cpu",kernelFunc:Y2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:o,pad:a,dilations:l}=r;Yt([i,s],"conv3d");const c=Fu(i.shape,s.shape,o,l,a),{filterDepth:u,filterHeight:h,filterWidth:f,dilationDepth:d,dilationHeight:p,dilationWidth:m,padInfo:g}=c,y=g.front,b=g.left,_=g.top,w=new ls(c.outShape,i.dtype),S=t.data.get(i.dataId).values,C=t.data.get(s.dataId).values,k=w.values,A=Zt(i.shape),M=Zt(s.shape);for(let E=0;E<c.batchSize;++E){const N=E*A[0],O=E*w.strides[0];for(let R=0;R<c.outDepth;++R){const D=O+R*w.strides[1],z=R*c.strideDepth-y;for(let B=0;B<u;++B){const X=z+B*d;if(X<0||X>=c.inDepth)continue;const H=B*M[0],te=N+X*A[1];for(let ge=0;ge<c.outHeight;++ge){const ae=D+ge*w.strides[2],Ne=ge*c.strideHeight-_;for(let Te=0;Te<h;++Te){const De=Ne+Te*p;if(De<0||De>=c.inHeight)continue;const be=H+Te*M[1],Ke=te+De*A[2];for(let Oe=0;Oe<c.outWidth;++Oe){const ot=ae+Oe*c.outChannels,He=Oe*c.strideWidth-b;for(let mt=0;mt<f;++mt){const ht=He+mt*m;if(ht<0||ht>=c.inWidth)continue;const Ue=be+mt*M[2],Be=Ke+ht*c.inChannels;let Ve=Ue;for(let ft=0;ft<c.inChannels;++ft){const Ye=S[Be+ft];for(let ee=0;ee<c.outChannels;++ee)k[ot+ee]+=Ye*C[Ve+ee];Ve+=c.outChannels}}}}}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const Q2e={kernelName:Lv,backendName:"cpu",kernelFunc:J2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:o,pad:a,filterShape:l}=r;Yt([i,s],"conv3dBackpropFilterV2");const c=Zt(i.shape),u=Zt(s.shape),h=Fu(i.shape,l,o,1,a),f=h.strideDepth,d=h.strideHeight,p=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new ls(h.filterShape,"float32"),_=b.values,[w,S,C,k]=b.strides,A=t.data.get(s.dataId).values,[M,E,N,O]=u,R=t.data.get(i.dataId).values,[D,z,B,X]=c,H=h.padInfo.front,te=h.padInfo.left,ge=h.padInfo.top;for(let ae=0;ae<m;++ae){const Ne=Math.max(0,Math.ceil((H-ae)/f)),Te=Math.min(h.outDepth,(h.inDepth+H-ae)/f),De=ae*w;for(let be=0;be<g;++be){const Ke=Math.max(0,Math.ceil((ge-be)/d)),Oe=Math.min(h.outHeight,(h.inHeight+ge-be)/d),ot=be*S+De;for(let He=0;He<y;++He){const mt=Math.max(0,Math.ceil((te-He)/p)),ht=Math.min(h.outWidth,(h.inWidth+te-He)/p),Ue=He*C+ot;for(let Be=0;Be<h.inChannels;++Be){const Ve=Be*k+Ue;for(let ft=0;ft<h.outChannels;++ft){let Ye=0;for(let ee=0;ee<h.batchSize;++ee){const J=ee*D,it=ee*M;for(let Ge=Ne;Ge<Te;++Ge){const Je=(ae+Ge*f-H)*z+J,bt=Ge*E+it;for(let It=Ke;It<Oe;++It){const ce=(be+It*d-ge)*B+Je,rt=It*N+bt;for(let Et=mt;Et<ht;++Et){const Ht=(He+Et*p-te)*X+ce,Mn=Et*O+rt;Ye+=R[Ht+Be]*A[Mn+ft]}}}}_[Ve+ft]=Ye}}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const tCe={kernelName:ZS,backendName:"cpu",kernelFunc:eCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nCe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{pad:o,strides:a,inputShape:l}=r;Yt([i],"conv3dBackpropInputV2");const c=Zt(i.shape),u=Zt(s.shape),h=Fu(l,s.shape,a,1,o),f=new ls(h.inShape,"float32"),d=f.values,[p,m,g,y]=f.strides,b=t.data.get(i.dataId).values,[_,w,S,C]=c,k=t.data.get(s.dataId).values,[A,M,E,N]=u,{batchSize:O,filterDepth:R,filterHeight:D,filterWidth:z,inChannels:B,inDepth:X,inHeight:H,inWidth:te,outChannels:ge,outDepth:ae,outHeight:Ne,outWidth:Te,strideDepth:De,strideHeight:be,strideWidth:Ke}=h,Oe=R-1-h.padInfo.front,ot=D-1-h.padInfo.top,He=z-1-h.padInfo.left;for(let mt=0;mt<O;++mt)for(let ht=0;ht<B;++ht)for(let Ue=0;Ue<X;++Ue){const Be=Ue-Oe,Ve=Math.max(0,Math.ceil(Be/De)),ft=Math.min(ae,(R+Be)/De);for(let Ye=0;Ye<H;++Ye){const ee=Ye-ot,J=Math.max(0,Math.ceil(ee/be)),it=Math.min(Ne,(D+ee)/be);for(let Ge=0;Ge<te;++Ge){const ye=Ge-He,Je=Math.max(0,Math.ceil(ye/Ke)),bt=Math.min(Te,(z+ye)/Ke);let It=0;for(let pt=Ve;pt<ft;++pt){const ce=pt*De-Be;for(let rt=J;rt<it;++rt){const Et=rt*be-ee;for(let yt=Je;yt<bt;++yt){const Ht=yt*Ke-ye,Mn=_*mt+w*pt+S*rt+C*yt,Cr=A*(R-1-ce)+M*(D-1-Et)+E*(z-1-Ht)+N*ht;for(let Bi=0;Bi<ge;++Bi){const Ai=b[Mn+Bi],Mi=k[Cr+Bi];It+=Ai*Mi}}}}d[p*mt+m*Ue+g*Ye+y*Ge+ht]=It}}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}const rCe={kernelName:JS,backendName:"cpu",kernelFunc:nCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iCe=$r(Hg,n=>Math.cos(n)),sCe={kernelName:Hg,backendName:"cpu",kernelFunc:iCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oCe=$r(Gg,n=>Math.cosh(n)),aCe={kernelName:Gg,backendName:"cpu",kernelFunc:oCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lCe(n){const{inputs:e,backend:t,attrs:r}=n,{image:i,boxes:s,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=r,[u,h,f,d]=i.shape,p=s.shape[0],[m,g]=a,y=Sn([p,m,g,d],"float32"),b=t.data.get(s.dataId).values,_=t.data.get(o.dataId).values,w=t.data.get(i.dataId).values,S=Zt(i.shape),C=Zt(y.shape);for(let k=0;k<p;k++){const A=k*4,M=b[A],E=b[A+1],N=b[A+2],O=b[A+3],R=_[k];if(R>=u)continue;const D=m>1?(N-M)*(h-1)/(m-1):0,z=g>1?(O-E)*(f-1)/(g-1):0;for(let B=0;B<m;B++){const X=m>1?M*(h-1)+B*D:.5*(M+N)*(h-1);if(X<0||X>h-1){for(let H=0;H<g;H++)for(let te=0;te<d;te++){const ge=te+H*C[2]+B*C[1]+k*C[0];y.values[ge]=c}continue}if(l==="bilinear"){const H=Math.floor(X),te=Math.ceil(X),ge=X-H;for(let ae=0;ae<g;ae++){const Ne=g>1?E*(f-1)+ae*z:.5*(E+O)*(f-1);if(Ne<0||Ne>f-1){for(let Ke=0;Ke<d;Ke++){const Oe=Ke+ae*C[2]+B*C[1]+k*C[0];y.values[Oe]=c}continue}const Te=Math.floor(Ne),De=Math.ceil(Ne),be=Ne-Te;for(let Ke=0;Ke<d;Ke++){let Oe=Ke+Te*S[2]+H*S[1]+R*S[0];const ot=w[Oe];Oe=Ke+De*S[2]+H*S[1]+R*S[0];const He=w[Oe];Oe=Ke+Te*S[2]+te*S[1]+R*S[0];const mt=w[Oe];Oe=Ke+De*S[2]+te*S[1]+R*S[0];const ht=w[Oe],Ue=ot+(He-ot)*be,Be=mt+(ht-mt)*be;Oe=Ke+ae*C[2]+B*C[1]+k*C[0],y.values[Oe]=Ue+(Be-Ue)*ge}}}else for(let H=0;H<g;++H){const te=g>1?E*(f-1)+H*z:.5*(E+O)*(f-1);if(te<0||te>f-1){for(let Ne=0;Ne<d;Ne++){const Te=Ne+H*C[2]+B*C[1]+k*C[0];y.values[Te]=c}continue}const ge=Math.round(te),ae=Math.round(X);for(let Ne=0;Ne<d;Ne++){const Te=Ne+ge*S[2]+ae*S[1]+R*S[0],De=Ne+H*C[2]+B*C[1]+k*C[0];y.values[De]=w[Te]}}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const cCe={kernelName:e2,backendName:"cpu",kernelFunc:lCe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,exclusive:o,reverse:a}=r;Yt(i,"cumprod");const l=Lr([s],i.shape.length);let c=i;l!=null&&(c=Ca({inputs:{x:i},backend:t,attrs:{perm:l}}));const u=ni(1,i.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=As(c.dtype,"int32"),f=wM(Ee(c.shape),h),d=t.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<d.length;y+=p)for(let b=0;b<p;b++){const _=m(y,b);if(b===0)f[_]=o?1:d[_];else{const w=m(y,b-1);f[_]=o?d[w]*f[w]:d[_]*f[w]}}const g=t.makeTensorInfo(c.shape,h,f);if(l!=null){const y=Ph(l),b=Ca({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(c),b}return g}const hCe={kernelName:QS,backendName:"cpu",kernelFunc:uCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,exclusive:o,reverse:a}=r;Yt(i,"cumsum");const l=Lr([s],i.shape.length);let c=i;l!=null&&(c=Ca({inputs:{x:i},backend:t,attrs:{perm:l}}));const u=ni(1,i.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=As(c.dtype,"int32"),f=js(Ee(c.shape),h),d=t.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<d.length;y+=p)for(let b=0;b<p;b++){const _=m(y,b);if(b===0)f[_]=o?0:d[_];else{const w=m(y,b-1);f[_]=o?d[w]+f[w]:d[_]+f[w]}}const g=t.makeTensorInfo(c.shape,h,f);if(l!=null){const y=Ph(l),b=Ca({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(c),b}return g}const dCe={kernelName:zv,backendName:"cpu",kernelFunc:fCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,weights:s}=e,{size:o,binaryOutput:a}=r;if(i.shape.length===1){const l=t.data.get(i.dataId).values,c=t.data.get(s.dataId).values,u=Xz(l,c,s.dtype,s.shape,o);return t.makeTensorInfo([o],s.dtype,u)}else if(i.shape.length===2){const l=t.bufferSync(i),c=t.bufferSync(s),u=eZ(l,c,o,a);return t.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const mCe={kernelName:t2,backendName:"cpu",kernelFunc:pCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockSize:s,dataFormat:o}=r;U(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=i.shape[0],l=i.shape[1],c=i.shape[2],u=i.shape[3],h=l*s,f=c*s,d=u/(s*s),p=t.data.get(i.dataId).values,m=new Float32Array(a*h*f*d);let g=0;for(let y=0;y<a;++y)for(let b=0;b<h;++b){const _=Math.floor(b/s),w=b%s;for(let S=0;S<f;++S){const C=Math.floor(S/s),k=S%s,A=(w*s+k)*d;for(let M=0;M<d;++M){const N=M+A+u*(C+c*(_+l*y));m[g++]=p[N]}}}return t.makeTensorInfo([a,h,f,d],i.dtype,m)}const yCe={kernelName:n2,backendName:"cpu",kernelFunc:gCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;Yt([i,s],"depthwiseConv2DNative");const u=Zt(i.shape),h=Zt(s.shape);let f=l;f==null&&(f=[1,1]),U($s(o,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${f}'`);const d=ti(i.shape,s.shape,o,f,a,c,!0),{filterHeight:p,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=d,_=b.left,w=b.top,S=d.outChannels/d.inChannels,C=new ls(d.outShape,i.dtype),k=t.data.get(i.dataId).values,A=t.data.get(s.dataId).values,M=C.values;for(let E=0;E<d.batchSize;++E){const N=E*u[0],O=E*C.strides[0];for(let R=0;R<d.outHeight;++R){const D=O+R*C.strides[1],z=R*d.strideHeight-w;for(let B=0;B<p;++B){const X=z+B*g;if(X<0||X>=d.inHeight)continue;const H=B*h[0],te=N+X*u[1];for(let ge=0;ge<d.outWidth;++ge){const ae=D+ge*C.strides[2],Ne=ge*d.strideWidth-_;for(let Te=0;Te<m;++Te){const De=Ne+Te*y;if(De<0||De>=d.inWidth)continue;const be=H+Te*h[1],Ke=te+De*d.inChannels;let Oe=ae,ot=be;for(let He=0;He<d.inChannels;++He){const mt=k[Ke+He];for(let ht=0;ht<S;++ht)M[Oe+ht]+=mt*A[ot+ht];Oe+=S,ot+=S}}}}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const bCe={kernelName:Bv,backendName:"cpu",kernelFunc:tJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r;Yt([i,s],"depthwiseConv2dNativeBackpropFilter");const h=ti(i.shape,u,o,a,l,c,!0),{strideHeight:f,strideWidth:d,filterHeight:p,filterWidth:m}=h,g=new ls(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,_=h.outChannels/h.inChannels,w=t.data.get(i.dataId).values,S=new ls(i.shape,i.dtype,w),C=t.data.get(s.dataId).values,k=new ls(s.shape,s.dtype,C);for(let A=0;A<p;++A){const M=Math.max(0,Math.ceil((b-A)/f)),E=Math.min(h.outHeight,(h.inHeight+b-A)/f);for(let N=0;N<m;++N){const O=Math.max(0,Math.ceil((y-N)/d)),R=Math.min(h.outWidth,(h.inWidth+y-N)/d);for(let D=0;D<h.outChannels;++D){const z=Math.trunc(D/_),B=D%_;let X=0;for(let H=0;H<h.batchSize;++H)for(let te=M;te<E;++te){const ge=A+te*f-b;for(let ae=O;ae<R;++ae){const Ne=N+ae*d-y;X+=S.get(H,ge,Ne,z)*k.get(H,te,ae,D)}}g.set(X,A,N,z,B)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const wCe={kernelName:r2,backendName:"cpu",kernelFunc:vCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xCe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r;Yt([i,s],"depthwiseConv2DNativeBackpropInput");const h=Zt(i.shape),f=Zt(s.shape),d=ti(u,s.shape,o,a,l,c,!0),p=new ls(d.inShape,"float32"),m=p.values,[g,y,b]=p.strides,_=t.data.get(i.dataId).values,[w,S,C]=h,k=t.data.get(s.dataId).values,[A,M,E]=f,{batchSize:N,filterHeight:O,filterWidth:R,inChannels:D,inHeight:z,inWidth:B,outChannels:X,outHeight:H,outWidth:te,strideHeight:ge,strideWidth:ae}=d,Ne=O-1-d.padInfo.top,Te=R-1-d.padInfo.left,De=X/D;for(let be=0;be<N;++be)for(let Ke=0;Ke<D;++Ke)for(let Oe=0;Oe<z;++Oe){const ot=Oe-Ne,He=Math.max(0,Math.ceil(ot/ge)),mt=Math.min(H,(O+ot)/ge);for(let ht=0;ht<B;++ht){const Ue=ht-Te,Be=Math.max(0,Math.ceil(Ue/ae)),Ve=Math.min(te,(R+Ue)/ae);let ft=0;for(let Ye=He;Ye<mt;++Ye){const ee=Ye*ge-ot;for(let J=Be;J<Ve;++J){const it=J*ae-Ue,Ge=w*be+S*Ye+C*J,ye=A*(O-1-ee)+M*(R-1-it)+E*Ke;for(let Je=0;Je<De;++Je){const bt=Ke*De+Je,It=_[Ge+bt],pt=k[ye+Je];ft+=It*pt}}}m[g*be+y*Oe+b*ht+Ke]=ft}}return t.makeTensorInfo(p.shape,p.dtype,p.values)}const _Ce={kernelName:i2,backendName:"cpu",kernelFunc:xCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SCe(n){const{inputs:e,backend:t}=n,{x:r}=e,i=Ee(r.shape),s=t.data.get(r.dataId).values,o=Sn([i,i],r.dtype),a=o.values;for(let c=0;c<s.length;c++)a[c*i+c]=s[c];const l=[...r.shape,...r.shape];return t.makeTensorInfo(l,o.dtype,o.values)}const CCe={kernelName:s2,backendName:"cpu",kernelFunc:SCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kCe={kernelName:Vv,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:i}=n,{strides:s,pad:o,dilations:a}=t,l=e,c=l.data.get(r.dataId).values,u=r.shape.length,h=l.data.get(i.dataId).values,f=i.shape.length,{batchSize:d,inHeight:p,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:_,strideHeight:w,strideWidth:S,filterHeight:C,filterWidth:k,dilationHeight:A,dilationWidth:M,outShape:E}=kp(r.shape,i.shape,s,o,"NHWC",a),N=Ee(E),O=E.length,R=Si(r.dtype,N);for(let z=0;z<d;++z)for(let B=0;B<y;++B){const X=B*w-_.top;for(let H=0;H<b;++H){const te=H*S-_.left;for(let ge=0;ge<g;++ge){let ae=Number.MIN_SAFE_INTEGER;for(let Te=0;Te<C;++Te){const De=X+Te*A;if(De>=0&&De<p)for(let be=0;be<k;++be){const Ke=te+be*M;if(Ke>=0&&Ke<m){const Oe=bu([z,De,Ke,ge],u,Zt(r.shape)),ot=bu([Te,be,ge],f,Zt(i.shape)),He=c[Oe]+h[ot];He>ae&&(ae=He)}}}const Ne=bu([z,B,H,ge],O,Zt(E));R[Ne]=ae}}}return{dataId:l.write(Sp(R,r.dtype),E,r.dtype),shape:E,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TCe={kernelName:d_,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:i,dy:s}=n,{strides:o,pad:a,dilations:l}=t,c=e,u=El(r.shape,c.data.get(r.dataId).values),h=El(i.shape,c.data.get(i.dataId).values),{batchSize:f,inHeight:d,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:_,strideWidth:w,filterHeight:S,filterWidth:C,dilationHeight:k,dilationWidth:A,outShape:M}=kp(r.shape,i.shape,o,a,"NHWC",l);U(s.rank===M.length,()=>`Error in ${d_}, dy must have the same rank as output ${M.length}, but got ${s.rank}`);const E=El(M,c.data.get(s.dataId).values),N=bL(i.shape,i.dtype);for(let R=0;R<f;++R)for(let D=0;D<g;++D){const z=D*_-b.top;for(let B=0;B<y;++B){const X=B*w-b.left;for(let H=0;H<m;++H){let te=Number.MIN_SAFE_INTEGER,ge=0,ae=0;for(let Ne=0;Ne<S;++Ne){const Te=z+Ne*k;if(Te>=0&&Te<d)for(let De=0;De<C;++De){const be=X+De*A;if(be>=0&&be<p){const Ke=u[R][Te][be][H]+h[Ne][De][H];Ke>te&&(te=Ke,ge=Ne,ae=De)}}}N[ge][ae][H]+=E[R][D][B][H]}}}return{dataId:c.write(Sp(N,r.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ECe={kernelName:f_,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:i,dy:s}=n,{strides:o,pad:a,dilations:l}=t,c=e,u=El(r.shape,c.data.get(r.dataId).values),h=El(i.shape,c.data.get(i.dataId).values),{batchSize:f,inHeight:d,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:_,strideWidth:w,filterHeight:S,filterWidth:C,dilationHeight:k,dilationWidth:A,outShape:M}=kp(r.shape,i.shape,o,a,"NHWC",l);U(s.rank===M.length,()=>`Error in ${f_}, dy must have the same rank as output ${M.length}, but got ${s.rank}`);const E=El(M,c.data.get(s.dataId).values),N=bL(r.shape,r.dtype);for(let R=0;R<f;++R)for(let D=0;D<g;++D){const z=D*_-b.top;for(let B=0;B<y;++B){const X=B*w-b.left;for(let H=0;H<m;++H){let te=Number.MIN_SAFE_INTEGER,ge=z<0?0:z,ae=X<0?0:X;for(let Ne=0;Ne<S;++Ne){const Te=z+Ne*k;if(Te>=0&&Te<d)for(let De=0;De<C;++De){const be=X+De*A;if(be>=0&&be<p){const Ke=u[R][Te][be][H]+h[Ne][De][H];Ke>te&&(te=Ke,ge=Te,ae=be)}}}N[R][ge][ae][H]+=E[R][D][B][H]}}}return{dataId:c.write(Sp(N,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ICe(n){const{inputs:e,backend:t,attrs:r}=n,{image:i}=e,{canvas:s,options:o}=r,{contextOptions:a,imageOptions:l}=o||{},c=(l==null?void 0:l.alpha)||1,u=(a==null?void 0:a.contextType)||"2d";if(u!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=s.getContext(u,(a==null?void 0:a.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${u} type.`);const[f,d]=i.shape.slice(0,2),p=i.shape.length===2?1:i.shape[2],m=t.data.get(i.dataId).values,g=i.dtype==="float32"?255:1,y=new Uint8ClampedArray(d*f*4);for(let _=0;_<f*d;++_){const w=[0,0,0,255*c];for(let C=0;C<p;C++){const k=m[_*p+C];if(i.dtype==="float32"){if(k<0||k>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${k}.`)}else if(i.dtype==="int32"&&(k<0||k>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${k}.`);p===1?(w[0]=k*g,w[1]=k*g,w[2]=k*g):w[C]=k*g}const S=_*4;y[S+0]=Math.round(w[0]),y[S+1]=Math.round(w[1]),y[S+2]=Math.round(w[2]),y[S+3]=Math.round(w[3])}s.width=d,s.height=f;const b=new ImageData(y,d,f);return h.putImageData(b,0,0),i}const ACe={kernelName:o2,backendName:"cpu",kernelFunc:ICe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cC(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:o}=r;Yt(i,"sum");let a;i.dtype==="bool"?a=ip({inputs:{x:i},backend:t,attrs:{dtype:"int32"}}):a=Sh({inputs:{x:i},backend:t});const l=a.shape.length,c=An(s,a.shape),u=Lr(c,l);let h=c,f=a;u!=null&&(f=Ca({inputs:{x:a},backend:t,attrs:{perm:u}}),h=ni(h.length,l)),hs("sum",h,f.shape.length);const[d,p]=Ji(f.shape,h),m=As(f.dtype,"int32");let g=TI(t,d,m);const y=Ee(p),b=t.data.get(g.dataId).values,_=t.data.get(f.dataId).values;for(let w=0;w<b.length;++w){const S=w*y;let C=0;for(let k=0;k<y;++k)C+=_[S+k];b[w]=C}if(o){const w=Fi(g.shape,c),S=g;g=ei({inputs:{x:g},backend:t,attrs:{shape:w}}),t.disposeIntermediateTensorInfo(S)}return t.disposeIntermediateTensorInfo(a),u!=null&&t.disposeIntermediateTensorInfo(f),g}const MCe={kernelName:ww,backendName:"cpu",kernelFunc:cC};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NCe(n){const{inputs:e,backend:t,attrs:r}=n,{equation:i}=r,s=e,{allDims:o,summedDims:a,idDims:l}=wN(i,s.length);_N(o.length,l,s);const{path:c,steps:u}=SN(a,l),h=u.length;let f=null,d=o.length;const p=[];for(let m=0;m<h;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=xN(d,l[g]);let _;CN(y)?_=s[g]:(_=Ca({inputs:{x:s[g]},backend:t,attrs:{perm:y}}),p.push(_));const w=_.shape.slice();for(let S=0;S<b.length;++S)w.splice(b[S],0,1);Rn(_.shape,w)||(_=ei({inputs:{x:_},backend:t,attrs:{shape:w}}),p.push(_)),f===null?f=_:(f=IN({inputs:{a:_,b:f},backend:t}),p.push(f))}m<h-1&&(c[m]>=0&&(f=cC({inputs:{x:f},backend:t,attrs:{axis:c[m]-(o.length-d),keepDims:!1}}),p.push(f)),d--)}for(const m of p)m!==f&&t.disposeIntermediateTensorInfo(m);return f}const $Ce={kernelName:a2,backendName:"cpu",kernelFunc:NCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RCe(n){const{inputs:e,backend:t}=n,{dy:r,y:i}=e;Yt([r,i],"eluGrad");const s=new Float32Array(Ee(i.shape)),o=t.data.get(i.dataId).values,a=t.data.get(r.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];c>=0?s[l]=a[l]:s[l]=a[l]*(c+1)}return t.makeTensorInfo(i.shape,"float32",s)}const PCe={kernelName:l2,backendName:"cpu",kernelFunc:RCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DCe=pN,OCe=mN,FCe=gN,LCe=yN,zCe=bN,BCe=vN,VCe=$r(Xg,n=>{const e=Math.sign(n),t=Math.abs(n),r=1/(1+DCe*t);return e*(1-((((BCe*r+zCe)*r+LCe)*r+FCe)*r+OCe)*r*Math.exp(-t*t))}),UCe={kernelName:Xg,backendName:"cpu",kernelFunc:VCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AI(n){const{inputs:e,backend:t,attrs:r}=n,{input:i}=e,{dim:s}=r,o=i.shape.length,a=i.shape.slice();let l=s;return s<0&&(U(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),ei({inputs:{x:i},backend:t,attrs:{shape:a}})}const WCe={kernelName:Wv,backendName:"cpu",kernelFunc:AI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HCe=Qi((n,e)=>n/e),eB=Rs(jg,HCe),kD={kernelName:jg,backendName:"cpu",kernelFunc:eB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nJ(n,e,t){const r=n.shape,i=r[0],s=r[1],o=t.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[i,s],u=Ee(c),h=cs("float32",u),f=cs("float32",u);for(let g=0;g<i;g++){const y=cg({inputs:{x:a},backend:t,attrs:{begin:[g,0],size:[1,s]}}),b=cg({inputs:{x:l},backend:t,attrs:{begin:[g,0],size:[1,s]}}),_=Va({inputs:{real:y,imag:b},backend:t}),{real:w,imag:S}=GCe(_,e,t),C=Su(w,S);for(let k=0;k<s;k++){const A=Gz(C,k);h[g*s+k]=A.real,f[g*s+k]=A.imag}t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(_)}const d=t.makeTensorInfo(c,"float32",h),p=t.makeTensorInfo(c,"float32",f),m=Va({inputs:{real:d,imag:p},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),m}function GCe(n,e,t){const r=Ee(n.shape),i=t.data.get(n.dataId),s=t.data.get(i.complexTensorInfos.real.dataId).values,o=t.data.get(i.complexTensorInfos.imag.dataId).values;if(jCe(r)){const a=TD(s,o,r,e,t),l=[n.shape[0],n.shape[1]];if(e){const c=t.makeTensorInfo(l,"float32",a.real),u=t.makeTensorInfo(l,"float32",a.imag),h=t.makeTensorInfo([],"float32",Vf(r,"float32")),f=Sh({inputs:{x:h},backend:t}),d=kD.kernelFunc({inputs:{a:c,b:h},backend:t}),p=kD.kernelFunc({inputs:{a:u,b:f},backend:t}),m=t.data.get(d.dataId).values,g=t.data.get(p.dataId).values;return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),{real:m,imag:g}}return a}else{const a=Su(s,o),l=qCe(a,r,e);return MY(l)}}function jCe(n){return(n&n-1)===0}function TD(n,e,t,r,i){if(t===1)return{real:n,imag:e};const s=Su(n,e),o=t/2,a=NY(s),l=a.real,c=a.imag,u=[l.length],h=i.makeTensorInfo(u,"float32",l),f=i.makeTensorInfo(u,"float32",c),d=Va({inputs:{real:h,imag:f},backend:i}),p=$Y(s),m=p.real,g=p.imag,y=[m.length],b=i.makeTensorInfo(y,"float32",m),_=i.makeTensorInfo(y,"float32",g),w=Va({inputs:{real:b,imag:_},backend:i}),S=TD(l,c,o,r,i),C=S.real,k=S.imag,A=[C.length],M=i.makeTensorInfo(A,"float32",C),E=i.makeTensorInfo(A,"float32",k),N=Va({inputs:{real:M,imag:E},backend:i}),O=TD(m,g,o,r,i),R=O.real,D=O.imag,z=[R.length],B=i.makeTensorInfo(z,"float32",R),X=i.makeTensorInfo(z,"float32",D),H=Va({inputs:{real:B,imag:X},backend:i}),te=PY(t,r),ge=[te.real.length],ae=i.makeTensorInfo(ge,"float32",te.real),Ne=i.makeTensorInfo(ge,"float32",te.imag),Te=Va({inputs:{real:ae,imag:Ne},backend:i}),De=IN({inputs:{a:Te,b:H},backend:i}),be=Zb({inputs:{a:N,b:De},backend:i}),Ke=Jz({inputs:{a:N,b:De},backend:i}),Oe=lg({inputs:{input:be},backend:i}),ot=lg({inputs:{input:Ke},backend:i}),He=Jb({inputs:{input:be},backend:i}),mt=Jb({inputs:{input:Ke},backend:i}),ht=Qb({inputs:[Oe,ot],backend:i,attrs:{axis:0}}),Ue=Qb({inputs:[He,mt],backend:i,attrs:{axis:0}}),Be=i.data.get(ht.dataId).values,Ve=i.data.get(Ue.dataId).values;return i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(w),i.disposeIntermediateTensorInfo(M),i.disposeIntermediateTensorInfo(E),i.disposeIntermediateTensorInfo(N),i.disposeIntermediateTensorInfo(B),i.disposeIntermediateTensorInfo(X),i.disposeIntermediateTensorInfo(H),i.disposeIntermediateTensorInfo(ae),i.disposeIntermediateTensorInfo(Ne),i.disposeIntermediateTensorInfo(Te),i.disposeIntermediateTensorInfo(De),i.disposeIntermediateTensorInfo(be),i.disposeIntermediateTensorInfo(Ke),i.disposeIntermediateTensorInfo(Oe),i.disposeIntermediateTensorInfo(He),i.disposeIntermediateTensorInfo(ot),i.disposeIntermediateTensorInfo(mt),i.disposeIntermediateTensorInfo(ht),i.disposeIntermediateTensorInfo(Ue),{real:Be,imag:Ve}}function qCe(n,e,t){const r=new Float32Array(e*2);for(let i=0;i<e;i++){let s=0,o=0;for(let a=0;a<e;a++){const l=DY(i*a,e,t),c=Gz(n,a);s+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}t&&(s/=e,o/=e),RY(r,s,o,i)}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XCe(n){const{inputs:e,backend:t}=n,{input:r}=e,i=Ee(r.shape),s=r.shape[r.shape.length-1],o=i/s,a=ei({inputs:{x:r},backend:t,attrs:{shape:[o,s]}}),l=nJ(a,!1,t),c=ei({inputs:{x:l},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const KCe={kernelName:c2,backendName:"cpu",kernelFunc:XCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tB(n){const{backend:e,attrs:t}=n,{shape:r,value:i,dtype:s}=t,o=s||xp(i),a=Si(o,Ee(r));return ZCe(a,i,o),e.makeTensorInfo(r,o,a)}const YCe={kernelName:u2,backendName:"cpu",kernelFunc:tB};function ZCe(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JCe={kernelName:h2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,i=t,s=cs(r.dtype,Ee(r.shape)),[o,a,l,c]=r.shape,u=i.data.get(r.dataId).values;for(let f=0;f<o;f++){const d=f*l*a*c;for(let p=0;p<a;p++){const m=p*(l*c);for(let g=0;g<l;g++){const y=g*c;for(let b=0;b<c;b++){const _=Math.round(l-g-1),w=d+m+y+b;let S=u[w];if(_>=0&&_<l){const C=_*c,k=d+m+C+b;S=u[k]}s[w]=S}}}}return{dataId:i.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r;let m=eJ({inputs:{x:i,filter:s},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f}});if(o){const g=m;if(u==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const y=ei({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});m=Zb({inputs:{a:m,b:y},backend:t}),t.disposeIntermediateTensorInfo(y)}else m=Zb({inputs:{a:m,b:o},backend:t});t.disposeIntermediateTensorInfo(g)}if(d){const g=m;if(u==="NCHW"&&d==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const y=ei({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});m=II(t,m,d,y,p),t.disposeIntermediateTensorInfo(y)}else m=II(t,m,d,a,p);t.disposeIntermediateTensorInfo(g)}return m}const eke={kernelName:Ub,backendName:"cpu",kernelFunc:QCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tke(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r;let m=tJ({inputs:{x:i,filter:s},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f}});if(o){const g=m;m=Zb({inputs:{a:m,b:o},backend:t}),t.disposeIntermediateTensorInfo(g)}if(d){const g=m;m=II(t,m,d,a,p),t.disposeIntermediateTensorInfo(g)}return m}const nke={kernelName:Wb,backendName:"cpu",kernelFunc:tke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rke(n){const{inputs:e,backend:t}=n,{params:r,indices:i}=e,s=Ee(r.shape),o=i.shape,a=o[o.length-1],[l,c,u,h]=sC(r,i);if(c===0)return t.makeTensorInfo(l,r.dtype,[]);const f=t.data.get(i.dataId).values,d=t.bufferSync(r),p=hZ(f,d,r.dtype,c,a,u,h,r.shape,s);return t.makeTensorInfo(l,r.dtype,p.values)}const ike={kernelName:f2,backendName:"cpu",kernelFunc:rke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ske(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,indices:s}=e,{axis:o,batchDims:a}=r;Yt([i,s],"gatherV2");const l=An(o,i.shape)[0],c=t.data.get(s.dataId).values,u=i.shape[l];for(let w=0;w<c.length;++w){const S=c[w];U(S<=u-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${u-1}]`)}let h=a;a==null&&(h=0);const f=Ee(s.shape),d=TN(i,s,l,h),p=ei({inputs:{x:i},backend:t,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),m=ei({inputs:{x:s},backend:t,attrs:{shape:[d.batchSize,f/d.batchSize]}}),g=[d.batchSize,d.outerSize,f/d.batchSize,d.sliceSize],y=t.bufferSync(m),b=t.bufferSync(p),_=fZ(b,y,g);return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.makeTensorInfo(d.outputShape,_.dtype,_.values)}const oke={kernelName:Gv,backendName:"cpu",kernelFunc:ske};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ake(n){const{inputs:e,backend:t}=n,{input:r}=e,i=Ee(r.shape),s=r.shape[r.shape.length-1],o=i/s,a=ei({inputs:{x:r},backend:t,attrs:{shape:[o,s]}}),l=nJ(a,!0,t),c=ei({inputs:{x:l},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const lke={kernelName:d2,backendName:"cpu",kernelFunc:ake};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cke=$r(ty,n=>Number.isFinite(n)?1:0,"bool"),uke={kernelName:ty,backendName:"cpu",kernelFunc:cke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hke=$r(ny,n=>Math.abs(n)===1/0?1:0,"bool"),fke={kernelName:ny,backendName:"cpu",kernelFunc:hke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dke=$r(ry,n=>Number.isNaN(n)?1:0,"bool"),pke={kernelName:ry,backendName:"cpu",kernelFunc:dke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mke(n){const{backend:e,attrs:t}=n,{start:r,stop:i,num:s}=t,o=yZ(r,i,s);return e.makeTensorInfo([o.length],"float32",o)}const gke={kernelName:m2,backendName:"cpu",kernelFunc:mke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yke=$r(sy,n=>Math.log1p(n)),bke={kernelName:sy,backendName:"cpu",kernelFunc:yke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vke=Qi((n,e)=>n&&e),wke=Rs(Yv,vke,null,"bool"),xke={kernelName:Yv,backendName:"cpu",kernelFunc:wke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ke=$r(Zv,n=>n?0:1,"bool"),Ske={kernelName:Zv,backendName:"cpu",kernelFunc:_ke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cke=Qi((n,e)=>n||e),kke=Rs(Jv,Cke,null,"bool"),Tke={kernelName:Jv,backendName:"cpu",kernelFunc:kke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eke(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{depthRadius:s,bias:o,alpha:a,beta:l}=r;Yt(i,"LRN");const c=i.shape[3],u=c-1,h=t.data.get(i.dataId).values,f=Ee(i.shape),d=new Float32Array(f);function p(m){const g=m%c;let y=m-g+Math.max(0,g-s);const b=m-g+Math.min(g+s,u);let _=0;for(;y<=b;y++){const w=h[y];_+=w*w}return _}for(let m=0;m<f;m++){const g=p(m),y=h[m]*Math.pow(o+a*g,-l);d[m]=y}return t.makeTensorInfo(i.shape,i.dtype,d)}const Ike={kernelName:Qv,backendName:"cpu",kernelFunc:Eke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ake(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,y:s,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=r;Yt(o,"LRNGrad");const h=Ee(o.shape),f=o.shape[3],d=t.data.get(o.dataId).values,p=t.data.get(i.dataId).values,m=t.data.get(s.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const _=b%f,w=b-_+Math.max(0,_-a),S=b-_+Math.min(f,_+a+1);let C=0;for(let k=w;k<S;k++)C+=Math.pow(p[k],2);C=c*C+l;for(let k=w;k<S;k++){let A=-2*c*u*p[k]*m[b]/C;b===k&&(A+=Math.pow(C,-u)),A*=d[b],g[k]+=A}}return t.makeTensorInfo(o.shape,i.dtype,g)}const Mke={kernelName:g2,backendName:"cpu",kernelFunc:Ake};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{reductionIndices:s,keepDims:o}=r,a=t;let l=i.shape;const c=l.length,u=An(s,l);let h=u;const f=Lr(h,c);let d=a.data.get(i.dataId).values;if(f!=null){const w=new Array(c);for(let S=0;S<w.length;S++)w[S]=l[f[S]];d=Yz(d,l,i.dtype,f,w),h=ni(h.length,c),l=w}Yt(i,"max"),hs("max",h,c);const[p,m]=Ji(l,h),g=Ee(m),y=vZ(d,g,p,i.dtype),b=a.write(y,p,i.dtype);let _=p;return o&&(_=Fi(p,u)),{dataId:b,shape:_,dtype:i.dtype}}const Nke={kernelName:ew,backendName:"cpu",kernelFunc:rJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ke(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e;Yt(i,"maxPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U($s(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ko(i.shape,s,o,c,a,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&Rn(u.inShape,u.outShape))h=Sh({inputs:{x:i},backend:t});else{const f=t.data.get(i.dataId).values,d=Zt(i.shape),p=Qz(f,i.shape,i.dtype,d,u,"max");h=t.makeTensorInfo(u.outShape,i.dtype,p.values)}return h}const Rke={kernelName:tw,backendName:"cpu",kernelFunc:$ke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pke(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;Yt(i,"maxPool3d");const u=Ll(i.shape,s,o,1,a,l,c),h=t.data.get(i.dataId).values,f=QZ(h,i.shape,i.dtype,Zt(i.shape),u,"max");return t.makeTensorInfo(f.shape,"float32",f.values)}const Dke={kernelName:nw,backendName:"cpu",kernelFunc:Pke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oke(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;Yt([i,s],"maxPool3DGrad");const u=Ll(s.shape,o,a,1,l,c),h=t.bufferSync(s),f=C2e(h,u),d=u.strideDepth,p=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,b=u.dilationWidth,_=u.effectiveFilterDepth,w=u.effectiveFilterHeight,S=u.effectiveFilterWidth,C=_-1-u.padInfo.front,k=S-1-u.padInfo.left,A=w-1-u.padInfo.top,M=Sn(s.shape,"float32"),E=t.bufferSync(i);for(let N=0;N<u.batchSize;++N)for(let O=0;O<u.inChannels;++O)for(let R=0;R<u.inDepth;++R)for(let D=0;D<u.inHeight;++D)for(let z=0;z<u.inWidth;++z){const B=R-C,X=D-A,H=z-k;let te=0;for(let ge=0;ge<_;ge+=g){const ae=(B+ge)/d;if(!(ae<0||ae>=u.outDepth||Math.floor(ae)!==ae))for(let Ne=0;Ne<w;Ne+=y){const Te=(X+Ne)/p;if(!(Te<0||Te>=u.outHeight||Math.floor(Te)!==Te))for(let De=0;De<S;De+=b){const be=(H+De)/m;if(be<0||be>=u.outWidth||Math.floor(be)!==be)continue;const Ke=_*w*S-1-f.get(N,ae,Te,be,O),Oe=ge*w*S+Ne*S+De,ot=Ke===Oe?1:0;if(ot===0)continue;const He=E.get(N,ae,Te,be,O);te+=He*ot}}}M.set(te,N,R,D,z,O)}return t.makeTensorInfo(M.shape,M.dtype,M.values)}const Fke={kernelName:b2,backendName:"cpu",kernelFunc:Oke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lke(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s,output:o}=e,a=s;Yt([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,f=ko(a.shape,l,c,1,u,h),d=t.data.get(a.dataId).values,p=Sn(f.outShape,a.dtype,JZ(d,a.shape,a.dtype,f).values),m=f.strideHeight,g=f.strideWidth,y=f.dilationHeight,b=f.dilationWidth,_=f.effectiveFilterHeight,w=f.effectiveFilterWidth,S=w-1-f.padInfo.left,C=_-1-f.padInfo.top,k=Sn(a.shape,"float32"),A=t.data.get(i.dataId).values,M=Sn(i.shape,"float32",A);for(let E=0;E<f.batchSize;++E)for(let N=0;N<f.inChannels;++N)for(let O=0;O<f.inHeight;++O)for(let R=0;R<f.inWidth;++R){const D=O-C,z=R-S;let B=0;for(let X=0;X<_;X+=y){const H=(D+X)/m;if(!(H<0||H>=f.outHeight||Math.floor(H)!==H))for(let te=0;te<w;te+=b){const ge=(z+te)/g;if(ge<0||ge>=f.outWidth||Math.floor(ge)!==ge)continue;const ae=_*w-1-p.get(E,H,ge,N),Ne=X*w+te,Te=ae===Ne?1:0;if(Te===0)continue;const De=M.get(E,H,ge,N);B+=De*Te}}k.set(B,E,O,R,N)}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const zke={kernelName:y2,backendName:"cpu",kernelFunc:Lke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bke(n,e,t,r,i){const s=Zt(e),o=Qz(n,e,t,s,i,"max"),a=JZ(n,e,t,i,!0,r);return[o.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vke={kernelName:v2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:i,strides:s,pad:o,includeBatchInIndex:a}=e,l=t;Yt(r,"MaxPoolWithArgmax");const c=l.data.get(r.dataId).values,u=ko(r.shape,i,s,[1,1],o),[h,f]=Bke(c,r.shape,r.dtype,a,u),d=l.write(h,u.outShape,r.dtype),p=l.write(f,u.outShape,r.dtype);return[{dataId:d,shape:u.outShape,dtype:r.dtype},{dataId:p,shape:u.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uke(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:o}=r,a=An(s,i.shape),c=Ji(i.shape,a)[1],u=Ee(c),h=[],f=t.makeTensorInfo([],"float32",new Float32Array([u]));h.push(f);const d=ip({inputs:{x:i},backend:t,attrs:{dtype:"float32"}});h.push(d);const p=eB({inputs:{a:d,b:f},backend:t});h.push(p);const m=cC({inputs:{x:p},backend:t,attrs:{axis:s,keepDims:o}});return h.forEach(g=>t.disposeIntermediateTensorInfo(g)),m}const Wke={kernelName:rw,backendName:"cpu",kernelFunc:Uke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hke(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:o}=r;Yt(i,"min");const a=An(s,i.shape);let l=a;const c=Lr(l,i.shape.length);let u=i;c!=null&&(u=Ca({inputs:{x:i},backend:t,attrs:{perm:c}}),l=ni(l.length,i.shape.length)),hs("min",l,u.shape.length);const[h,f]=Ji(u.shape,l),d=Ee(f),p=js(Ee(h),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*d;let _=m[b];for(let w=0;w<d;++w){const S=m[b+w];(Number.isNaN(S)||S<_)&&(_=S)}p[y]=_}c!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(h,u.dtype,p);if(o){const y=Fi(h,a),b=ei({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const Gke={kernelName:iw,backendName:"cpu",kernelFunc:Hke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jke(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{paddings:s,mode:o}=r;Yt(i,"mirrorPad");const a=s.map((_,w)=>_[0]+i.shape[w]+_[1]),l=s.map(_=>_[0]),c=s.map((_,w)=>_[0]+i.shape[w]),u=o==="reflect"?0:1,h=t.data.get(i.dataId).values,f=i.shape.length,d=Zt(i.shape),p=Ee(a),m=a.length,g=Zt(a),y=cs(i.dtype,p);for(let _=0;_<p;_++){let w=Rg(_,m,g);for(let C=0;C<m;C++)w[C]<l[C]?w[C]=l[C]*2-w[C]-u:w[C]>=c[C]&&(w[C]=(c[C]-1)*2-w[C]+u);w=w.map((C,k)=>C-l[k]);const S=bu(w,f,d);y[_]=h[S]}return{dataId:t.write(y,a,i.dtype),shape:a,dtype:i.dtype}}const qke={kernelName:sw,backendName:"cpu",kernelFunc:jke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xke=Qi((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),Kke=Rs(ly,Xke),Yke={kernelName:ly,backendName:"cpu",kernelFunc:Kke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iJ(n){const{inputs:e,backend:t,attrs:r}=n,{logits:i}=e,{dim:s}=r,o=i.shape.length;let a=s;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=An([a],i.shape),c=rJ({inputs:{x:i},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),u=Fi(c.shape,l),h=ei({inputs:{x:c},backend:t,attrs:{shape:u}}),f=Jz({inputs:{a:i,b:h},backend:t}),d=aZ({inputs:{x:f},backend:t}),p=cC({inputs:{x:d},backend:t,attrs:{axis:l,keepDims:!1}}),m=ei({inputs:{x:p},backend:t,attrs:{shape:u}}),g=eB({inputs:{a:d,b:m},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}const Zke={kernelName:Sw,backendName:"cpu",kernelFunc:iJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jke(n){const{inputs:e,backend:t,attrs:r}=n,{logits:i}=e,{numSamples:s,seed:o,normalized:a}=r;Yt(i,"multinomial");const l=a?i:iJ({inputs:{logits:i},backend:t,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=t.data.get(l.dataId).values,f=[c,s],d=js(Ee(f),"int32");for(let p=0;p<c;++p){const m=p*u,g=new Float32Array(u-1);g[0]=h[m];for(let _=1;_<g.length;++_)g[_]=g[_-1]+h[m+_];const y=Aw.alea(o.toString()),b=p*s;for(let _=0;_<s;++_){const w=y();d[b+_]=g.length;for(let S=0;S<g.length;S++)if(w<g[S]){d[b+_]=S;break}}}return a||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(f,"int32",d)}const Qke={kernelName:w2,backendName:"cpu",kernelFunc:Jke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eTe=tC;function tTe(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:i,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r;Yt(i,"NonMaxSuppression");const c=t.data.get(i.dataId).values,u=t.data.get(s.dataId).values,{selectedIndices:h}=eTe(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const nTe={kernelName:x2,backendName:"cpu",kernelFunc:tTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rTe=rN;function iTe(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:i,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r;Yt(i,"NonMaxSuppressionPadded");const u=t.data.get(i.dataId).values,h=t.data.get(s.dataId).values,{selectedIndices:f,validOutputs:d}=rTe(u,h,o,a,l,c);return[t.makeTensorInfo([f.length],"int32",new Int32Array(f)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}const sTe={kernelName:xM,backendName:"cpu",kernelFunc:iTe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oTe=nC;function aTe(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:i,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r;Yt(i,"NonMaxSuppressionWithScore");const u=t.data.get(i.dataId).values,h=t.data.get(s.dataId).values,f=o,d=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=oTe(u,h,f,d,p,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const lTe={kernelName:_2,backendName:"cpu",kernelFunc:aTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cTe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:i}=e,{dtype:s,depth:o,onValue:a,offValue:l}=r;Yt(i,"oneHot");const c=Ee(i.shape),u=new Float32Array(c*o);u.fill(l);const h=t.data.get(i.dataId).values;for(let f=0;f<c;++f)h[f]>=0&&h[f]<o&&(u[f*o+h[f]]=a);return t.makeTensorInfo([...i.shape,o],s,u)}const uTe={kernelName:cw,backendName:"cpu",kernelFunc:cTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MI(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const i=lg({inputs:{input:r},backend:t}),s=MI({inputs:{x:i},backend:t}),o=Jb({inputs:{input:r},backend:t}),a=MI({inputs:{x:o},backend:t}),l=Va({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return tB({backend:t,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const hTe={kernelName:Tw,backendName:"cpu",kernelFunc:MI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sJ(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const i=lg({inputs:{input:r},backend:t}),s=sJ({inputs:{x:i},backend:t}),o=Jb({inputs:{input:r},backend:t}),a=MI({inputs:{x:o},backend:t}),l=Va({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return tB({backend:t,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const fTe={kernelName:lw,backendName:"cpu",kernelFunc:sJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oJ(n){const{inputs:e,backend:t,attrs:r}=n,{axis:i}=r;if(e.length===1)return AI({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const s=e[0].shape,o=e[0].dtype;e.forEach(u=>{qs(s,u.shape,"All tensors passed to stack must have matching shapes"),U(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=AI({inputs:{input:u},backend:t,attrs:{dim:i}});return a.push(h),h}),c=Qb({inputs:l,backend:t,attrs:{axis:i}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const dTe={kernelName:uw,backendName:"cpu",kernelFunc:oJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{paddings:s,constantValue:o}=r;Yt(i,"pad");const a=s.map((b,_)=>b[0]+i.shape[_]+b[1]),l=s.map(b=>b[0]),c=t.data.get(i.dataId).values,u=Ee(i.shape),h=i.shape.length,f=Zt(i.shape),d=Ee(a),p=a.length,m=Zt(a),g=cs(i.dtype,d);o!==0&&g.fill(o);for(let b=0;b<u;b++){const w=Rg(b,h,f).map((C,k)=>C+l[k]),S=bu(w,p,m);g[S]=c[b]}return{dataId:t.write(g,a,i.dtype),shape:a,dtype:i.dtype}}const aJ={kernelName:hw,backendName:"cpu",kernelFunc:pTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mTe=Qi((n,e)=>Math.pow(n,e)),gTe=Rs(uy,mTe),yTe={kernelName:uy,backendName:"cpu",kernelFunc:gTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bTe(n){const{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:i,paramsDenseValues:s,indices:o}=e,a=i.map(g=>t.data.get(g.dataId).values),l=i.map(g=>g.shape),c=t.data.get(s.dataId).values,u=t.data.get(o.dataId).values,[h,f,d]=kZ(a,l,c,s.shape,s.dtype,u,o.shape),p=h.map(g=>t.makeTensorInfo([g.length],"int32",g)),m=t.makeTensorInfo(d,s.dtype,f);return p.concat([m])}const vTe={kernelName:_M,backendName:"cpu",kernelFunc:bTe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wTe(n){const{inputs:e,backend:t}=n,{starts:r,limits:i,deltas:s}=e,o=t.data.get(r.dataId).values,a=t.data.get(i.dataId).values,l=t.data.get(s.dataId).values,[c,u]=TZ(o,r.shape,r.dtype,a,i.shape,l,s.shape),h=t.makeTensorInfo([c.length],"int32",c),f=t.makeTensorInfo([u.length],r.dtype,u);return[h,f]}const xTe={kernelName:SM,backendName:"cpu",kernelFunc:wTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Te(n){const{inputs:e,backend:t,attrs:r}=n,{shape:i,values:s,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,c=t.data.get(i.dataId).values,u=t.data.get(s.dataId).values,h=t.data.get(o.dataId).values,f=a.map(g=>t.data.get(g.dataId).values),d=a.map(g=>g.shape),[p,m]=EZ(c,i.shape,u,s.shape,s.dtype,h,o.shape,f,d,l);return t.makeTensorInfo(p,s.dtype,m)}const STe={kernelName:CM,backendName:"cpu",kernelFunc:_Te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CTe(n){const{backend:e,attrs:t}=n,{start:r,stop:i,dtype:s,step:o}=t,a=IZ(r,i,o,s);return e.makeTensorInfo([a.length],s,a)}const kTe={kernelName:S2,backendName:"cpu",kernelFunc:CTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TTe=$r(hy,n=>1/n),ETe={kernelName:hy,backendName:"cpu",kernelFunc:TTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ITe(n){const{inputs:e,backend:t,attrs:r}=n,{images:i}=e,{alignCorners:s,halfPixelCenters:o,size:a}=r;Yt(i,"resizeBilinear");const l=Zt(i.shape),[c,u]=a,[h,f,d,p]=i.shape,m=t.data.get(i.dataId).values,g=new Float32Array(Ee([h,c,u,p])),y=[s&&c>1?f-1:f,s&&u>1?d-1:d],b=[s&&c>1?c-1:c,s&&u>1?u-1:u];let _=0;const w=y[0]/b[0],S=y[1]/b[1];for(let C=0;C<h;C++)for(let k=0;k<c;k++){let A;o?A=w*(k+.5)-.5:A=w*k;const M=Math.max(0,Math.floor(A)),E=A-M,N=Math.min(f-1,Math.ceil(A)),O=C*l[0]+M*l[1],R=C*l[0]+N*l[1];for(let D=0;D<u;D++){let z;o?z=S*(D+.5)-.5:z=S*D;const B=Math.max(0,Math.floor(z)),X=z-B,H=Math.min(d-1,Math.ceil(z)),te=O+B*l[2],ge=R+B*l[2],ae=O+H*l[2],Ne=R+H*l[2];for(let Te=0;Te<p;Te++){const De=m[te+Te],be=m[ge+Te],Ke=m[ae+Te],Oe=m[Ne+Te],ot=De+(Ke-De)*X,He=be+(Oe-be)*X,mt=ot+(He-ot)*E;g[_++]=mt}}}return t.makeTensorInfo([h,c,u,p],"float32",g)}const ATe={kernelName:gw,backendName:"cpu",kernelFunc:ITe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MTe(n){const{inputs:e,backend:t,attrs:r}=n,{images:i,dy:s}=e,{alignCorners:o}=r;Yt([s,i],"resizeBilinearGrad");const a=Zt(i.shape),[l,c,u,h]=i.shape,[,f,d]=s.shape,p=new Float32Array(l*c*u*h),m=[o&&f>1?c-1:c,o&&d>1?u-1:u],g=[o&&f>1?f-1:f,o&&d>1?d-1:d],y=m[0]/g[0],b=m[1]/g[1],_=t.data.get(s.dataId).values;let w=0;for(let S=0;S<l;S++){const C=S*a[0];for(let k=0;k<f;k++){const A=k*y,M=Math.floor(A),E=Math.min(Math.ceil(A),c-1),N=C+M*a[1],O=C+E*a[1],R=A-M,D=1-R;for(let z=0;z<d;z++){const B=z*b,X=Math.floor(B),H=Math.min(Math.ceil(B),u-1),te=B-X,ge=1-te,ae=N+X*a[2],Ne=N+H*a[2],Te=O+X*a[2],De=O+H*a[2],be=D*ge,Ke=D*te,Oe=R*ge,ot=R*te;for(let He=0;He<h;He++){const mt=_[w++];p[ae+He]+=mt*be,p[Ne+He]+=mt*Ke,p[Te+He]+=mt*Oe,p[De+He]+=mt*ot}}}}return t.makeTensorInfo([l,u,c,h],"float32",p)}const NTe={kernelName:T2,backendName:"cpu",kernelFunc:MTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Te(n){const{inputs:e,backend:t,attrs:r}=n,{images:i}=e,{alignCorners:s,halfPixelCenters:o,size:a}=r;Yt(i,"resizeNearestNeighbor");const l=Zt(i.shape),[c,u]=a,[h,f,d,p]=i.shape,m=t.data.get(i.dataId).values,g=new Float32Array(h*c*u*p),y=[s&&c>1?f-1:f,s&&u>1?d-1:d],b=[s&&c>1?c-1:c,s&&u>1?u-1:u],_=y[0]/b[0],w=y[1]/b[1];let S=0;for(let C=0;C<h;C++){const k=C*l[0];for(let A=0;A<c;A++){const M=o?_*(A+.5):_*A;let E=Math.min(f-1,s?Math.round(M):Math.floor(M));o&&(E=Math.max(0,E));const N=k+E*l[1];for(let O=0;O<u;O++){const R=o?w*(O+.5):w*O;let D=Math.min(d-1,s?Math.round(R):Math.floor(R));o&&(D=Math.max(0,D));const z=N+D*l[2];for(let B=0;B<p;B++){const X=m[z+B];g[S++]=X}}}}return t.makeTensorInfo([h,c,u,p],i.dtype,g)}const RTe={kernelName:mw,backendName:"cpu",kernelFunc:$Te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PTe(n){const{inputs:e,backend:t,attrs:r}=n,{images:i,dy:s}=e,{alignCorners:o}=r;Yt([s,i],"resizeNearestNeighborGrad");const a=Zt(i.shape),l=Zt(s.shape),[c,u,h,f]=i.shape,[,d,p]=s.shape,m=new Float32Array(c*u*h*f),g=t.data.get(s.dataId).values,y=[o&&d>1?u-1:u,o&&p>1?h-1:h],b=[o&&d>1?d-1:d,o&&p>1?p-1:p],_=y[0]/b[0],w=y[1]/b[1],S=1/_,C=1/w,k=Math.ceil(S)*2+2,A=Math.ceil(C)*2+2;for(let M=0;M<c;M++){const E=M*a[0];for(let N=0;N<u;N++){const O=E+N*a[1],R=Math.floor(N*S),D=Math.floor(R-k/2);for(let z=0;z<h;z++){const B=O+z*a[2],X=Math.floor(z*C),H=Math.floor(X-A/2);for(let te=0;te<f;te++){let ge=0;for(let ae=0;ae<k;ae++){const Ne=ae+D;if(Ne<0||Ne>=d)continue;const Te=E+Ne*l[1],De=Ne*_,be=Math.min(u-1,o?Math.round(De):Math.floor(De));if(N===be)for(let Ke=0;Ke<A;Ke++){const Oe=Ke+H;if(Oe<0||Oe>=p)continue;const ot=Te+Oe*l[2],He=Oe*w,mt=Math.min(h-1,o?Math.round(He):Math.floor(He));z===mt&&(ge+=g[ot+te])}}m[B+te]=ge}}}}return t.makeTensorInfo(i.shape,i.dtype,m)}const DTe={kernelName:k2,backendName:"cpu",kernelFunc:PTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{dims:s}=r;Yt(i,"reverse");const o=i.shape.length,a=An(s,i.shape);if(o===0)return Sh({inputs:{x:i},backend:t});const l=new ls(i.shape,i.dtype),c=t.bufferSync(i);for(let u=0;u<l.size;u++){const h=l.indexToLoc(u),f=h.slice();a.forEach(d=>f[d]=i.shape[d]-1-f[d]),l.set(c.get(...f),...h)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const FTe={kernelName:yw,backendName:"cpu",kernelFunc:OTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LTe={kernelName:z2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:i,fillValue:s,center:o}=e,a=t,l=cs(r.dtype,Ee(r.shape)),[c,u,h,f]=r.shape,[d,p]=hN(o,u,h),m=255,g=Math.sin(i),y=Math.cos(i),b=a.data.get(r.dataId).values;for(let w=0;w<c;w++){const S=w*h*u*f;for(let C=0;C<u;C++){const k=C*(h*f);for(let A=0;A<h;A++){const M=A*f;for(let E=0;E<f;E++){const N=[c,C,A,E],O=N[2],R=N[1];let D=(O-d)*y-(R-p)*g,z=(O-d)*g+(R-p)*y;D=Math.round(D+d),z=Math.round(z+p);let B=s;if(typeof s!="number"&&(E===3?B=m:B=s[E]),D>=0&&D<h&&z>=0&&z<u){const H=z*(h*f),te=D*f,ge=S+H+te+E;B=b[ge]}const X=S+k+M+E;l[X]=B}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zTe=$r(py,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),BTe={kernelName:py,backendName:"cpu",kernelFunc:zTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VTe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:i,updates:s}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Lu(s,i,o),f=!0,d=t.bufferSync(i),p=t.bufferSync(s),m=Fm(d,p,o,h,c,l,a,u,0,f);return t.makeTensorInfo(o,m.dtype,m.values)}const UTe={kernelName:E2,backendName:"cpu",kernelFunc:VTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WTe(n,e){let t=0,r=n.length,i=0;for(;t<r;)i=Math.floor((t+r)/2),n[i]<e?t=i+1:r=i;return r}function HTe(n,e){let t=0,r=n.length,i=0;for(;t<r;)i=Math.floor((t+r)/2),n[i]<=e?t=i+1:r=i;return r}function GTe(n,e,t,r,i,s){const o=Si("int32",t*i);for(let a=0;a<t;++a){const l=n.slice(a*r,(a+1)*r),c=a*i;for(let u=0;u<i;++u)o[c+u]=s==="left"?WTe(l,e[u+c]):HTe(l,e[u+c])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jTe(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:i,values:s}=e,{side:o}=r,a=t.data.get(i.dataId).values,l=t.data.get(s.dataId).values,c=GTe(a,l,i.shape[0],i.shape[1],s.shape[1],o);return t.makeTensorInfo(s.shape,"int32",c)}const qTe={kernelName:A2,backendName:"cpu",kernelFunc:jTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XTe(n){const{inputs:e,backend:t}=n,{condition:r,t:i,e:s}=e;Yt([r,i,s],"select");const o=r.shape.length,a=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,c=t.data.get(s.dataId).values,u=As(i.dtype,s.dtype),h=js(Ee(i.shape),u);let f=0;const d=o===0||o>1||i.shape.length===1?1:Ee(i.shape.slice(1));for(let p=0;p<a.length;p++)for(let m=0;m<d;m++)a[p]===1?h[f++]=l[p]:h[f++]=c[p];return t.makeTensorInfo(i.shape,u,h)}const KTe={kernelName:bw,backendName:"cpu",kernelFunc:XTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YTe=aC,ZTe=lC,JTe=$r(gy,n=>n>=0?ZTe*n:YTe*(Math.exp(n)-1)),QTe={kernelName:gy,backendName:"cpu",kernelFunc:JTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eEe=$r(vy,n=>n<0?-1:n>0?1:0),tEe={kernelName:vy,backendName:"cpu",kernelFunc:eEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nEe=$r(yy,n=>Math.sin(n)),rEe={kernelName:yy,backendName:"cpu",kernelFunc:nEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iEe=$r(by,n=>Math.sinh(n)),sEe={kernelName:by,backendName:"cpu",kernelFunc:iEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oEe=11920928955078125e-23,lH=Math.log(oEe)+2,aEe=$r(xy,n=>{const e=n>-lH,t=n<lH,r=Math.exp(n);let i;return t?i=r:e?i=n:i=Math.log(1+r),i}),lEe={kernelName:xy,backendName:"cpu",kernelFunc:aEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockShape:s,paddings:o}=r;Yt([i],"spaceToBatchND");const a=Ee(s),l=[[0,0]];l.push(...o);for(let C=1+s.length;C<i.shape.length;++C)l.push([0,0]);const c=aJ.kernelFunc({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),u=Oy(c.shape,s,a,!1),h=Fy(u.length,s.length,!1),f=Ly(c.shape,s,a,!1),m=ei({inputs:{x:c},backend:t,attrs:{shape:u}}),b=Ca({inputs:{x:m},backend:t,attrs:{perm:h}}),S=ei({inputs:{x:b},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(b),S}const uEe={kernelName:xw,backendName:"cpu",kernelFunc:cEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hEe(n){const{inputs:e,backend:t}=n,{indices:r,values:i,denseShape:s,defaultValue:o}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${i.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.data.get(r.dataId).values,l=t.data.get(i.dataId).values,c=t.data.get(s.dataId).values,u=t.data.get(o.dataId).values[0],[h,f,d,p,m]=$Z(a,r.shape,r.dtype,l,i.dtype,c,u);return[t.makeTensorInfo(f,r.dtype,h),t.makeTensorInfo([f[0]],i.dtype,d),t.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),t.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const fEe={kernelName:kM,backendName:"cpu",kernelFunc:hEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dEe(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:i,newShape:s}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(t.data.get(i.dataId).values),a=t.data.get(r.dataId).values,l=Array.from(t.data.get(s.dataId).values),[c,u,h]=RZ(a,r.shape,r.dtype,o,l);return[t.makeTensorInfo(u,r.dtype,c),t.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}const pEe={kernelName:TM,backendName:"cpu",kernelFunc:dEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mEe(n){const{inputs:e,backend:t}=n,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(r.dataId).values,a=t.data.get(i.dataId).values,l=t.data.get(s.dataId).values,[c,u]=Zz(o,r.shape,r.dtype,a,l,!0);return t.makeTensorInfo(u,r.dtype,c)}const gEe={kernelName:M2,backendName:"cpu",kernelFunc:mEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yEe(n){const{inputs:e,backend:t}=n,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(r.dataId).values,a=t.data.get(i.dataId).values,l=t.data.get(s.dataId).values,[c,u]=Zz(o,r.shape,r.dtype,a,l);return t.makeTensorInfo(u,r.dtype,c)}const bEe={kernelName:N2,backendName:"cpu",kernelFunc:yEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vEe(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:i,sparseValues:s,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:f}=Lu(s,i,a),d=!1,p=t.bufferSync(i);let m;switch(s.dtype){case"bool":{const g=t.bufferSync(s),y=!!t.data.get(o.dataId).values[0];m=Fm(p,g,a,f,u,c,l,h,y,d);break}case"float32":{const g=t.bufferSync(s),y=t.data.get(o.dataId).values[0];m=Fm(p,g,a,f,u,c,l,h,y,d);break}case"int32":{const g=t.bufferSync(s),y=t.data.get(o.dataId).values[0];m=Fm(p,g,a,f,u,c,l,h,y,d);break}case"string":{const g=t.bufferSync(s),y=Sc(t.data.get(o.dataId).values[0]);m=Fm(p,g,a,f,u,c,l,h,y,d);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return t.makeTensorInfo(a,m.dtype,m.values)}const wEe={kernelName:$2,backendName:"cpu",kernelFunc:vEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{numOrSizeSplits:s,axis:o}=r,a=An(o,i.shape)[0],l=kN(i,s,a),c=new Array(i.shape.length).fill(0),u=i.shape.slice();return l.map(h=>{const f=[...u];f[a]=h;const d=cg({inputs:{x:i},backend:t,attrs:{begin:c,size:f}});return c[a]+=h,d})}const _Ee={kernelName:_w,backendName:"cpu",kernelFunc:xEe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SEe={kernelName:R2,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,r=e;Yt(t,"square");const i=r.data.get(t.dataId).values,s=new Float32Array(i.length);for(let a=0;a<i.length;++a){const l=i[a];s[a]=l*l}return{dataId:r.write(s,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CEe=$r(Iy,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),kEe={kernelName:Iy,backendName:"cpu",kernelFunc:CEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{begin:s,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:f}=r;Yt(i,"stridedSlice");const{finalShapeSparse:d,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:_,strides:w}=lN(i.shape,s,o,a,l,c,u,h,f);let S;if(m)S=ei({inputs:{x:i},backend:t,attrs:{shape:p}});else if(g||y){U(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const C=aN(b,_,w),k=cg({inputs:{x:i},backend:t,attrs:{begin:b,size:C}});S=ei({inputs:{x:k},backend:t,attrs:{shape:p}}),t.disposeIntermediateTensorInfo(k)}else{const C=t.bufferSync(i),k=OZ(d,C,w,b);S=t.makeTensorInfo(p,k.dtype,k.values)}return S}const EEe={kernelName:D2,backendName:"cpu",kernelFunc:TEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IEe(n){const{inputs:e,backend:t,attrs:r}=n,{separator:i,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,f=t.data.get(u.dataId).values,d=t.data.get(h.dataId).values,[p,m]=FZ(f,d,i,s,o,a,l,c);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(h.shape,"int32",m)]}const AEe={kernelName:O2,backendName:"cpu",kernelFunc:IEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MEe(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:i}=r,{input:s,delimiter:o}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.data.get(s.dataId).values,l=t.data.get(o.dataId).values[0],[c,u,h]=LZ(a,l,i),f=u.length;return[t.makeTensorInfo([f,2],"int32",c),t.makeTensorInfo([f],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const NEe={kernelName:EM,backendName:"cpu",kernelFunc:MEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ee(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:i}=r,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(s.dataId).values,a=zZ(o,i);return t.makeTensorInfo(s.shape,"int32",a)}const REe={kernelName:IM,backendName:"cpu",kernelFunc:$Ee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PEe=$r(ky,n=>Math.tan(n)),DEe={kernelName:ky,backendName:"cpu",kernelFunc:PEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OEe=$r(Ty,n=>Math.tanh(n)),FEe={kernelName:Ty,backendName:"cpu",kernelFunc:OEe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LEe(n){const{inputs:e,backend:t}=n,{tensor:r,indices:i,updates:s}=e,{sliceRank:o,numUpdates:a,sliceSize:l,strides:c,outputSize:u}=Lu(s,i,r.shape),h=!1,f=t.bufferSync(i),d=t.bufferSync(s),p=t.bufferSync(r),m=Fm(f,d,r.shape,u,l,a,o,c,p,h);return t.makeTensorInfo(r.shape,m.dtype,m.values)}const zEe={kernelName:I2,backendName:"cpu",kernelFunc:LEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{reps:s}=r;Yt(i,"tile");const o=VZ(t.bufferSync(i),s);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const VEe={kernelName:Ey,backendName:"cpu",kernelFunc:BEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{k:s,sorted:o}=r;Yt(i,"topk");const a=t.data.get(i.dataId).values,[l,c]=WZ(a,i.shape,i.dtype,s,o);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(c.shape,c.dtype,c.values)]}const WEe={kernelName:F2,backendName:"cpu",kernelFunc:UEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HEe(n){const{inputs:e,attrs:t,backend:r}=n,{image:i,transforms:s}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=t,[u,h,f,d]=i.shape,[p,m]=c??[h,f],g=[u,p,m,d],y=Zt(i.shape),b=y[0],_=y[1],w=y[2],S=Zt(g),C=S[0],k=S[1],A=S[2],M=cs(i.dtype,Ee(g));M.fill(l);const E=r.data.get(i.dataId).values,N=r.data.get(s.dataId).values;for(let R=0;R<u;++R){const D=s.shape[0]===1?N:N.subarray(R*8,R*8+8);for(let z=0;z<p;++z)for(let B=0;B<m;++B)for(let X=0;X<d;++X){let H;const te=D[6]*B+D[7]*z+1;if(te===0)continue;const ge=(D[0]*B+D[1]*z+D[2])/te,ae=(D[3]*B+D[4]*z+D[5])/te,Ne=cH(ge,f,a),Te=cH(ae,h,a);switch(o){case"nearest":H=YEe(E,h,f,b,_,w,R,Te,Ne,X,l);break;case"bilinear":H=ZEe(E,h,f,b,_,w,R,Te,Ne,X,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const De=R*C+z*k+B*A+X;M[De]=H}return r.makeTensorInfo(g,i.dtype,M)}return{dataId:r.write(M,g,i.dtype),shape:i.shape,dtype:i.dtype}}const GEe={kernelName:L2,backendName:"cpu",kernelFunc:HEe};function cH(n,e,t){switch(t){case"reflect":return jEe(n,e);case"wrap":return qEe(n,e);case"nearest":return KEe(n,e);case"constant":default:return XEe(n)}}function jEe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const r=2*e;t<r&&(t=r*Math.trunc(-t/r)+t),t=t<-e?t+r:-t-1}else if(t>e-1)if(e<=1)t=0;else{const r=2*e;t-=r*Math.trunc(t/r),t>=e&&(t=r-t-1)}return Zd(0,t,e-1)}function qEe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const r=e-1;t+=e*(Math.trunc(-t/r)+1)}else if(t>e-1)if(e<=1)t=0;else{const r=e-1;t-=e*Math.trunc(t/r)}return Zd(0,t,e-1)}function XEe(n,e){return n}function KEe(n,e){return Zd(0,n,e-1)}function w1(n,e,t,r,i,s,o,a,l,c,u){const h=o*r+a*i+l*s+c;return 0<=a&&a<e&&0<=l&&l<t?n[h]:u}function YEe(n,e,t,r,i,s,o,a,l,c,u){const h=Math.round(a),f=Math.round(l);return w1(n,e,t,r,i,s,o,h,f,c,u)}function ZEe(n,e,t,r,i,s,o,a,l,c,u){const h=Math.floor(a),f=Math.floor(l),d=h+1,p=f+1,m=(p-l)*w1(n,e,t,r,i,s,o,h,f,c,u)+(l-f)*w1(n,e,t,r,i,s,o,h,p,c,u),g=(p-l)*w1(n,e,t,r,i,s,o,d,f,c,u)+(l-f)*w1(n,e,t,r,i,s,o,d,p,c,u);return(d-a)*m+(a-h)*g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JEe(n){const{inputs:e,attrs:t,backend:r}=n,{axis:i}=t,{x:s}=e;Yt(s,"unique");const o=r.data.get(s.dataId).values,{outputValues:a,outputShape:l,indices:c}=HZ(o,i,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}const QEe={kernelName:AM,backendName:"cpu",kernelFunc:JEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eIe(n){const{inputs:e,backend:t,attrs:r}=n,{value:i}=e;let{axis:s}=r;s<0&&(s+=i.shape.length);const o=i.shape.length,a=i.shape[s],l=new Array(o-1);let c=0;for(let d=0;d<o;d++)d!==s&&(l[c++]=i.shape[d]);const u=new Array(o).fill(0),h=i.shape.slice();h[s]=1;const f=new Array(a);for(let d=0;d<f.length;d++){u[s]=d;const p=cg({inputs:{x:i},backend:t,attrs:{begin:u,size:h}});f[d]=ei({inputs:{x:p},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(p)}return f}const tIe={kernelName:Cw,backendName:"cpu",kernelFunc:eIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nIe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,segmentIds:s}=e,{numSegments:o}=r;Yt(i,"unsortedSegmentSum");const a=i.shape.length,l=s.shape.length,c=[],u=[],h=a-l;let f=s;for(let p=0;p<h;++p){const m=AI({inputs:{input:f},backend:t,attrs:{dim:p+1}});f=m,u.push(m)}for(let p=0;p<o;++p){const m=Vf(p,"int32"),g=t.makeTensorInfo([],"int32",m),y=sZ({inputs:{a:g,b:f},backend:t}),b=ip({inputs:{x:y},backend:t,attrs:{dtype:"float32"}}),_=IN({inputs:{a:b,b:i},backend:t}),w=cC({inputs:{x:_},backend:t,attrs:{axis:0,keepDims:!1}});c.push(w),u.push(g),u.push(y),u.push(b),u.push(_),u.push(w)}const d=oJ({inputs:c,backend:t,attrs:{axis:0}});return u.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const rIe={kernelName:kw,backendName:"cpu",kernelFunc:nIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iIe=[JSe,R_e,e2e,n2e,z_e,i2e,o2e,l2e,u2e,f2e,p2e,g2e,b2e,x2e,S2e,T2e,I2e,M2e,$2e,YSe,P2e,O2e,L2e,V_e,B2e,F_e,W_e,U2e,P_e,H2e,j2e,q2e,K2e,Z2e,Q2e,tCe,rCe,sCe,aCe,cCe,hCe,dCe,mCe,yCe,bCe,wCe,_Ce,CCe,kCe,TCe,ECe,ACe,$Ce,WSe,PCe,H_e,UCe,G_e,WCe,q_e,KCe,YCe,JCe,K_e,Z_e,eke,nke,ike,oke,Q_e,tSe,D_e,lke,G2e,uke,fke,pke,HSe,rSe,sSe,gke,aSe,bke,xke,Ske,Tke,Ike,Mke,Nke,cSe,Rke,Dke,Fke,zke,Vke,Wke,Gke,hSe,qke,Yke,Qke,dSe,mSe,nTe,sTe,lTe,ySe,uTe,fTe,dTe,aJ,yTe,jSe,wSe,vTe,xTe,STe,kTe,O_e,kD,ETe,qSe,XSe,KSe,ATe,NTe,RTe,DTe,FTe,LTe,BTe,ISe,UTe,qTe,KTe,QTe,MSe,tEe,rEe,sEe,NSe,Zke,lEe,uEe,fEe,pEe,gEe,bEe,wEe,_Ee,PSe,SEe,OSe,LSe,kEe,EEe,AEe,NEe,REe,USe,MCe,DEe,FEe,zEe,VEe,WEe,GEe,bSe,QEe,tIe,rIe,hTe];for(const n of iIe)B2(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mm={},Hk={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function sIe(n,e){Mm[n]=e}function ku(n,e){if(!(n in Mm)||e!=null){const r=aIe(n,e);if(r!==null)Mm[n]=r;else return console.log("Could not get context for WebGL version",n),null}const t=Mm[n];return t==null||t.isContextLost()?(delete Mm[n],ku(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Mm[n])}function oIe(n){if(!Ie().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function aIe(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??oIe(n);return t.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Mm[n]},!1),Ie().getBool("SOFTWARE_WEBGL_ENABLED")&&(Hk.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Hk)||t.getContext("experimental-webgl",Hk):t.getContext("webgl2",Hk)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var k_;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(k_||(k_={}));var Cl;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Cl||(Cl={}));var oo;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(oo||(oo={}));function uC(n,e){return[e,n]}function lIe(n,e){return n*e}function Gk(n){const e=Ee(n),t=Math.ceil(e/4);return mI(t)}function $w(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function cIe(n,e){const[t,r]=$w(n,e);return t*r*4}function nB(n,e){const t=n;let r,i,s,o,a,l,c,u,h,f;return Ie().getNumber("WEBGL_VERSION")===2?(r=t.R32F,i=t.R16F,s=t.RGBA16F,o=t.RGBA32F,a=t.RED,c=4,u=1,h=t.HALF_FLOAT,f=t.FLOAT,l=t.RGBA8):(r=n.RGBA,i=n.RGBA,s=n.RGBA,o=t.RGBA,a=n.RGBA,c=4,u=4,h=e!=null?e.HALF_FLOAT_OES:null,f=n.FLOAT,l=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:f}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bt(n,e){const t=e();return Ie().getBool("DEBUG")&&uIe(n),t}function uIe(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+pIe(n,e))}const hIe=596e-10,fIe=65504;function dIe(n){return!!(Ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||hIe<Math.abs(n)&&Math.abs(n)<fIe)}function pIe(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function jk(n,e){return Gf(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function mIe(n,e){const t=Gf(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Bt(n,()=>n.shaderSource(t,e)),Bt(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function gIe(n,e){const t=Gf(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Bt(n,()=>n.shaderSource(t,e)),Bt(n,()=>n.compileShader(t)),Ie().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw lJ(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const yIe=/ERROR: [0-9]+:([0-9]+):/g;function lJ(n,e){const t=yIe.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const r=+t[1],i=n.split(`
`),s=i.length.toString().length+2,o=i.map((h,f)=>Wm((f+1).toString(),s)+h);let a=0;for(let h=0;h<o.length;h++)a=Math.max(o[h].length,a);const l=o.slice(0,r-1),c=o.slice(r-1,r),u=o.slice(r);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Wm(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function bIe(n){return Gf(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function vIe(n,e){if(Bt(n,()=>n.linkProgram(e)),!Ie().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function s3(n,e){if(Bt(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function wIe(n,e){const t=Gf(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Bt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Bt(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function xIe(n,e){const t=Gf(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Bt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Bt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function _Ie(n){return Gf(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function SIe(n,e){const t=Ie().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const r=`[${n}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>t||e>t){const r=`[${n}x${e}]`,i=`[${t}x${t}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+i+".")}}function CIe(n){return Gf(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function uH(n,e,t,r,i,s,o){const a=n.getAttribLocation(e,t);return a===-1?!1:(Bt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),Bt(n,()=>n.vertexAttribPointer(a,i,n.FLOAT,!1,s,o)),Bt(n,()=>n.enableVertexAttribArray(a)),!0)}function kIe(n,e,t){MIe(n,t),Bt(n,()=>n.activeTexture(n.TEXTURE0+t)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function TIe(n,e,t){return Gf(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function EIe(n,e,t){return n.getUniformLocation(e,t)}function IIe(n,e,t,r){Bt(n,()=>kIe(n,e,r)),Bt(n,()=>n.uniform1i(t,r))}function o3(n,e,t){Bt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Bt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function hH(n,e){Bt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Bt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function qk(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+AIe(n,e))}function AIe(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Gf(n,e,t){const r=Bt(n,()=>e());if(r==null)throw new Error(t);return r}function MIe(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+n.TEXTURE0;if(r<n.TEXTURE0||r>t){const i=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${i}.`)}}function ev(n,e=2){return Ee(n.slice(0,n.length-e))}function tv(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Xk(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[ev(n),...tv(n)]),e}function NIe(n,e=!1){let t=Ie().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Ie().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&Ie().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=t/2),e&&(t=t*2,r=r*2,n=n.map((a,l)=>l>=n.length-2?yM(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Bf(n).newShape);let i=Ee(n),s=null;n.length<=1&&i<=t?s=[1,i]:n.length===2&&n[0]<=t&&n[1]<=t?s=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?s=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?s=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?s=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(s=[n[0],n[1]*n[2]*n[3]]);const o=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(s==null||o)if(e){const a=ev(n);let l=2,c=2;n.length&&([l,c]=tv(n)),i=a*(l/2)*(c/2),s=mI(i).map(u=>u*2)}else s=mI(i);return s}function Kk(n){return n%2===0}function NI(n,e){if(n=n.slice(-2),e=e.slice(-2),Rn(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],r=e[e.length-1];if(t===r||Kk(t)&&Kk(r)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Kk(n[0])&&Kk(e[0])}let a3,l3;function $Ie(n){if(a3==null){const e=ku(n);a3=e.getParameter(e.MAX_TEXTURE_SIZE)}return a3}function RIe(n){if(l3==null){const e=ku(n);l3=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,l3)}function PIe(n){if(n===0)return 0;let e;const t=ku(n);return pc(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:pc(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function pc(n,e){return n.getExtension(e)!=null}function fH(n){try{if(ku(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function DIe(n){if(n===0)return!1;const e=ku(n);if(n===1){if(!pc(e,"OES_texture_float"))return!1}else if(!pc(e,"EXT_color_buffer_float"))return!1;return ED(e)}function OIe(n){if(n===0)return!1;const e=ku(n);if(n===1){if(!pc(e,"OES_texture_float")||!pc(e,"WEBGL_color_buffer_float"))return!1}else{if(pc(e,"EXT_color_buffer_float"))return ED(e);const r="EXT_color_buffer_half_float";if(pc(e,r)){const i=e.getExtension(r);return FIe(e,i)}return!1}return ED(e)}function ED(n){const e=nB(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const r=1,i=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,r,i,0,e.textureFormatFloat,e.textureTypeFloat,null);const s=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,s),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(s),o}function FIe(n,e){const t=nB(n,e),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r);const i=1,s=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,i,s,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(o),a}function LIe(n){return n!==2?!1:ku(n).fenceSync!=null}function hC(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&U(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jt=Ie();Jt.registerFlag("HAS_WEBGL",()=>Jt.getNumber("WEBGL_VERSION")>0);Jt.registerFlag("WEBGL_VERSION",()=>fH(2)?2:fH(1)?1:0);Jt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Jt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Jt.get("WEBGL_VERSION")===2);Jt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Jt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Jt.registerFlag("WEBGL_PACK",()=>Jt.getBool("HAS_WEBGL"));Jt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Jt.getBool("WEBGL_PACK"));Jt.registerFlag("WEBGL_PACK_CLIP",()=>Jt.getBool("WEBGL_PACK"));Jt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Jt.getBool("WEBGL_PACK"));Jt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Jt.getBool("WEBGL_PACK"));Jt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Jt.getBool("WEBGL_PACK"));Jt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Jt.getBool("WEBGL_PACK"));Jt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Jt.getBool("WEBGL_PACK"));Jt.registerFlag("WEBGL_PACK_REDUCE",()=>Jt.getBool("WEBGL_PACK"));Jt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Jt.getBool("WEBGL_PACK"));Jt.registerFlag("WEBGL_CONV_IM2COL",()=>Jt.getBool("WEBGL_PACK"));Jt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Jt.getBool("WEBGL_PACK"));Jt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>$Ie(Jt.getNumber("WEBGL_VERSION")));Jt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>RIe(Jt.getNumber("WEBGL_VERSION")));Jt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Jt.getNumber("WEBGL_VERSION");return n===0?0:PIe(n)});Jt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Jt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!CL());Jt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>DIe(Jt.getNumber("WEBGL_VERSION")));Jt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Jt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Jt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Jt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>OIe(Jt.getNumber("WEBGL_VERSION")));Jt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>LIe(Jt.getNumber("WEBGL_VERSION")));Jt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Jt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Jt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Jt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>CL()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Jt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Jt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Jt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Jt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Jt.registerFlag("WEBGL_EXP_CONV",()=>!1);Jt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Jt.getBool("IS_TEST"));Jt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Jt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Jt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Jt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ra(){let n,e,t,r,i,s,o,a,l,c;return Ie().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",r="in",i="texture",s="outputColor",o="out vec4 outputColor;",a=Ie().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",r="varying",i="texture2D",s="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:r,texture2D:i,output:s,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zy(n,e,t="index"){const r=Zt(e);return r.map((i,s)=>{const o=`int ${n[s]} = ${t} / ${i}`,a=s===r.length-1?`int ${n[s+1]} = ${t} - ${n[s]} * ${i}`:`index -= ${n[s]} * ${i}`;return`${o}; ${a};`}).join("")}function AN(n,e,t="index"){const r=Zt(e);return r.map((i,s)=>{const o=`int ${n[s]} = ${t} / outShapeStrides[${s}]`,a=s===r.length-1?`int ${n[s+1]} = ${t} - ${n[s]} * outShapeStrides[${s}]`:`index -= ${n[s]} * outShapeStrides[${s}]`;return`${o}; ${a};`}).join("")}function zIe(n,e){const t=n.length,r=n.map(s=>`${e}[${s}]`),i=new Array(t-1);i[t-2]=r[t-1];for(let s=t-3;s>=0;--s)i[s]=`(${i[s+1]} * ${r[s+1]})`;return i}function BIe(n,e,t="index"){const r=n.map((s,o)=>o),i=zIe(r,e);return i.map((s,o)=>{const a=`int ${n[o]} = ${t} / ${i[o]}`,l=o===i.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${i[o]}`:`index -= ${n[o]} * ${i[o]}`;return`${a}; ${l};`}).join("")}function rB(n){const e=Zt(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function iB(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const cJ=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:uJ}=KY;function VIe(n,e,t){const r=[];if(n.forEach(d=>{const p=Ee(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),t.enableShapeUniforms){const{uniformShape:m}=sB(t.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});const i=r.join(`
`),s=n.map(d=>UIe(d,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,a=ra(),l=GIe(a);let c,u,h=XIe(a);return e.isPacked?(c=WIe(e.logicalShape,o,t.enableShapeUniforms),u=qIe(a)):(c=HIe(e.logicalShape,o,t.enableShapeUniforms),u=jIe(a)),t.packedInputs&&(h+=JIe),[h,l,u,i,c,s,t.userCode].join(`
`)}function Rw(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return uAe(n,e);case 1:return fAe(n,e);case 2:return pAe(n,e);case 3:return gAe(n,e);case 4:return bAe(n,e);case 5:return vAe(n);case 6:return wAe(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function hJ(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return cAe(n);case 1:return hAe(n,e);case 2:return dAe(n,e);case 3:return mAe(n,e);default:return yAe(n,e)}}function UIe(n,e,t=!1,r){let i="";t?i+=hJ(n,r):i+=Rw(n,r);const s=n.shapeInfo.logicalShape,o=e.logicalShape;return s.length<=o.length&&(t?i+=xAe(n,e):i+=_Ae(n,e)),i}function WIe(n,e,t){switch(n.length){case 0:return fJ();case 1:return QIe(n,e,t);case 2:return aAe(n,e,t);case 3:return tAe(n,e,t);default:return rAe(n,e,t)}}function HIe(n,e,t){switch(n.length){case 0:return fJ();case 1:return eAe(n,e,t);case 2:return lAe(n,e,t);case 3:return nAe(n,e,t);case 4:return iAe(n,e,t);case 5:return sAe(n,e);case 6:return oAe(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function GIe(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function jIe(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function qIe(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function XIe(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${KIe}
    ${YIe}
    ${ZIe}
  `}const KIe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,YIe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,ZIe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,JIe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function fJ(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function QIe(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function eAe(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function tAe(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(n[2]/2),s=i*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function nAe(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${AN(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const r=zy(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function rAe(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(n[n.length-1]/2),s=i*Math.ceil(n[n.length-2]/2);let o=s,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+a,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${n.length}(${l});
    }
  `}function iAe(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${AN(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const r=zy(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function sAe(n,e){const t=zy(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function oAe(n,e){const t=zy(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function aAe(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Rn(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const i=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function lAe(n,e,t){return Rn(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function By(n){return`offset${n}`}function cAe(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),r=ra();return`
    vec4 ${t}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function uAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[i,s]=n.shapeInfo.texShape;if(i===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=By(t);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function hAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),i=n.shapeInfo.texShape,s=ra();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${s.texture2D}(${t}, uv);
    }
  `}function fAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Pw(n)}
      }
    `;const i=n.shapeInfo.texShape,s=i[0],o=i[1];if(o===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=By(t);return o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function dAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape,o=s[0],a=s[1],l=ra();if(s!=null&&Rn(t,s))return e?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(t[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function pAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape;if(s!=null&&Rn(t,s)){if(e)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const f=s[0],d=s[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:o,keptDims:a}=Bf(t),l=o;if(l.length<t.length){const f=Dw(n,l),d=["row","col"];return`
      ${Rw(f,e)}
      float ${i}(int row, int col) {
        return ${i}(${Ow(d,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Pw(n)}
      }
    `;const c=s[0],u=s[1],h=By(r);return u===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function mAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){const f=t.slice(1),d=[1,2],p=Dw(n,f),m=["b","row","col"];return`
        ${hJ(p,e)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${Ow(m,d)});
        }
      `}const a=ra();if(e)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;const l=o[0],c=o[1],u=Math.ceil(t[2]/2),h=u*Math.ceil(t[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${h}, ${u}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function gAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t[1]*t[2],o=t[2],{newShape:a,keptDims:l}=Bf(t),c=a;if(c.length<t.length){const m=Dw(n,c),g=["row","col","depth"];return`
        ${Rw(m,e)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${Ow(g,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${o}, 1)));
        ${Pw(n)}
      }
    `;const u=n.shapeInfo.texShape,h=u[0],f=u[1],d=n.shapeInfo.flatOffset;if(f===s&&d==null)return e?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${h}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(f===o&&d==null)return e?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `;const p=By(r);return e?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${p};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${o} + depth + ${p};
        vec2 uv = uvFromFlat(${h}, ${f}, index);
        return sampleTexture(${r}, uv);
      }
  `}function yAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),i=ra();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${t}, uv);
    }
  `;const s=n.shapeInfo.logicalShape,o=s.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],h=Math.ceil(s[o-1]/2);let f=h*Math.ceil(s[o-2]/2),d="int b, int row, int col",p=`b * ${f} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<o-1;m++)d=`int b${m}, `+d,f*=s[o-m-1],p=`b${m} * ${f} + `+p;return`
    vec4 ${r}(${d}) {
      int index = ${p};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${i.texture2D}(${t}, uv);
    }
  `}function bAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t[3],o=t[2]*s,a=t[1]*o,{newShape:l,keptDims:c}=Bf(t);if(l.length<t.length){const b=Dw(n,l),_=["row","col","depth","depth2"];return`
      ${Rw(b,e)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${Ow(_,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${s}, 1)));
        ${Pw(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],d=h[1],p=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(d===a&&u==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${p}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(d===s&&u==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;const y=By(r);return e?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${p}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${f}, ${d}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function vAe(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),i=e[4],s=e[3]*i,o=e[2]*s,a=e[1]*o,{newShape:l,keptDims:c}=Bf(e);if(l.length<e.length){const m=Dw(n,l),g=["row","col","depth","depth2","depth3"];return`
      ${Rw(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Ow(g,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${s}, ${i})) +
          depth3;
        ${Pw(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],d=h[1];if(d===a&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${s}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(d===i&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;const p=By(t);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${s} +
          depth2 * ${i} + depth3 + ${p};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${t}, uv);
    }
  `}function wAe(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:i,keptDims:s}=Bf(e);if(i.length<e.length){const g=Dw(n,i),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Rw(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Ow(y,s)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,c=e[2]*l,u=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Pw(n)}
      }
    `;const h=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,d=f[0],p=f[1];if(p===u&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===o&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const m=By(t);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${m};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Pw(n){const e=n.name,t=Ee(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function xAe(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),i="get"+r+"AtOutCoords",s=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=uJ(n.shapeInfo.logicalShape,e.logicalShape),l=Fr(o),c=o-s;let u;const h=["x","y","z","w","u","v"];s===0?u="":o<2&&a.length>=1?u="coords = 0;":u=a.map(b=>`coords.${h[b+c]} = 0;`).join(`
`);let f="";o<2&&s>0?f="coords":f=n.shapeInfo.logicalShape.map((b,_)=>`coords.${h[_+c]}`).join(", ");let d="return outputValue;";const m=Ee(n.shapeInfo.logicalShape)===1,y=Ee(e.logicalShape)===1;if(s===1&&!m&&!y)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)o===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(a.length){const b=s-2,_=s-1;a.indexOf(b)>-1&&a.indexOf(_)>-1?d="return vec4(outputValue.x);":a.indexOf(b)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(_)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${i}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${f});
      ${d}
    }
  `}function _Ae(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),i="get"+r+"AtOutCoords",s=e.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&Rn(o,s))return`
      float ${i}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=Fr(l),u=uJ(n.shapeInfo.logicalShape,e.logicalShape),h=l-a;let f;const d=["x","y","z","w","u","v"];a===0?f="":l<2&&u.length>=1?f="coords = 0;":f=u.map(m=>`coords.${d[m+h]} = 0;`).join(`
`);let p="";return l<2&&a>0?p="coords":p=n.shapeInfo.logicalShape.map((m,g)=>`coords.${d[g+h]}`).join(", "),`
    float ${i}() {
      ${c} coords = getOutputCoords();
      ${f}
      return get${r}(${p});
    }
  `}function Fr(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function sB(n,e,t){const{newShape:r,keptDims:i}=Bf(e),s=e.length,o=n&&s===3&&e[0]===1,a=o?e.slice(1):r,l=!n&&s>1&&!Rn(e,t)&&r.length<s||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:i}}function Dw(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Ow(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SAe(n,e,t,r){const i=t.map((u,h)=>{const f={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(f.flatOffset=u.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:f}}),s=i.map(u=>u.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=VIe(i,o,e),l=gIe(n.gl,a),c=n.createProgram(l);return Ie().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:o},dJ(n,e,c)))}function dJ(n,e,t){const r=[],i=[];let s,o,a,l=null,c=null;c=n.getUniformLocation(t,"NAN",!1),Ie().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const u=!1;for(const h of e.variableNames){const f={name:h,uniform:n.getUniformLocation(t,h,u),offset:n.getUniformLocation(t,`offset${h}`,u)};e.enableShapeUniforms&&(f.shape=n.getUniformLocation(t,`${h}Shape`,u),f.texShape=n.getUniformLocation(t,`${h}TexShape`,u)),r.push(f)}if(e.enableShapeUniforms&&(s=n.getUniformLocation(t,"outShape",u),a=n.getUniformLocation(t,"outShapeStrides",u),o=n.getUniformLocation(t,"outTexShape",u)),e.customUniforms)for(const h of e.customUniforms)i.push(n.getUniformLocation(t,h.name,u));return{variablesLocations:r,customUniformLocations:i,infLoc:l,nanLoc:c,outShapeLocation:s,outShapeStridesLocation:a,outTexShapeLocation:o}}function dH(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,r)=>{const i=t.logicalShape,s=e[r],o=s.shape;if(!Rn(i,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${o} must match`);if(t.isUniform&&s.isUniform)return;const a=t.texShape,l=s.isUniform?null:s.texData.texShape;if(!Rn(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function CAe(n,e,t,r,i){e.program.enableShapeUniforms||(dH(e.inShapeInfos,t),dH([e.outShapeInfo],[r]));const s=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):n.setOutputMatrixTexture(s.texture,o[0],o[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),Ie().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const c=t[l],{uniform:u,offset:h,shape:f,texShape:d}=e.variablesLocations[l];if(f){const{uniformShape:p}=sB(e.program.packedInputs,c.shape,c.texData.texShape);switch(p.length){case 1:n.gl.uniform1iv(f,new Int32Array(p));break;case 2:n.gl.uniform2iv(f,new Int32Array(p));break;case 3:n.gl.uniform3iv(f,new Int32Array(p));break;case 4:n.gl.uniform4iv(f,new Int32Array(p));break}}if(d&&n.gl.uniform2i(d,c.texData.texShape[0],c.texData.texShape[1]),u!=null){if(c.isUniform){if(Ee(c.shape)<2)n.gl.uniform1f(u,c.uniformValues[0]);else{let p=c.uniformValues;p instanceof Float32Array||(p=new Float32Array(p)),n.gl.uniform1fv(u,p)}continue}c.texData.slice!=null&&h!=null&&n.gl.uniform1i(h,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,u,l)}}const a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const l=Zt(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&i)for(let l=0;l<e.program.customUniforms.length;++l){const c=e.program.customUniforms[l],u=e.customUniformLocations[l],h=i[l];if(c.type==="float")n.gl.uniform1fv(u,h);else if(c.type==="vec2")n.gl.uniform2fv(u,h);else if(c.type==="vec3")n.gl.uniform3fv(u,h);else if(c.type==="vec4")n.gl.uniform4fv(u,h);else if(c.type==="int")n.gl.uniform1iv(u,h);else if(c.type==="ivec2")n.gl.uniform2iv(u,h);else if(c.type==="ivec3")n.gl.uniform3iv(u,h);else if(c.type==="ivec4")n.gl.uniform4iv(u,h);else throw Error(`uniform type ${c.type} is not supported yet.`)}n.executeProgram()}function kAe(n,e,t){let r="";e.concat(t).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:h}=sB(n.packedInputs,o.shape,l);let f="",d="",p="";if(u.length===1&&n.packedInputs){const S=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];f=`${S[0]>1}_${S[1]>1}`}else if(u.length===2&&!n.packedInputs)d=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!n.packedInputs){const S=Zt(u);p=`${S[0]===l[1]}_${S[S.length-1]===l[1]}`}const m=o.shape.length,g=u.length===2&&Rn(o.shape,l),y=Ee(o.shape)===1,b=Pf(o.shape,t.shape),_=!n.packedInputs&&m===t.shape.length&&Rn(l,t.texData.texShape),w=n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${_}_${c?h:""}_${u.length}_${y}_${b}_${g}_${f}_${d}_${p}_${w}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;r+=`${o.shape}_${l}_${a}`}});const i=n.userCode;let s=n.constructor.name;return s+="_"+r+"_"+i+`${Ie().getNumber("WEBGL_VERSION")}`,s}function To(n){return Ie().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TAe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=k_.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ra();this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?AN(["r","c","d"],e):zy(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EAe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=k_.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ra();this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?AN(["r","c","d"],e):zy(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IAe{constructor(e){this.variableNames=["A"],this.outTexUsage=Cl.DOWNLOAD;const t=ra();this.outputShape=e,this.userCode=`
      ${cJ}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AAe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Cl.DOWNLOAD;const t=ra();this.outputShape=e,this.userCode=`
      ${cJ}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MAe={R:0,G:1,B:2,A:3};class pH{constructor(e,t=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=ra();this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let o="";for(let a=0;a<r.length;a++){const l=r[a];o+=`
          if(offset == ${a}) {
            result = values[${MAe[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?iB():rB(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${i.texture2D}(A, uv);
          ${o}
        }
        ${i.output} = vec4(${s}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NAe{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ra();this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);let i="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;i+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?iB():rB(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${r.output} = ${s};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ae(n){const e=ra(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return mIe(n,t)}function RAe(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return wIe(n,e)}function PAe(n){const e=new Uint16Array([0,1,2,2,1,3]);return xIe(n,e)}function fC(n,e,t,r,i,s){SIe(e,t);const o=_Ie(n),a=n.TEXTURE_2D;return Bt(n,()=>n.bindTexture(a,o)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),Ie().getNumber("WEBGL_VERSION")===1?Bt(n,()=>n.texImage2D(a,0,r,e,t,0,i,s,null)):Bt(n,()=>n.texStorage2D(a,1,r,e,t)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function pJ(n){return n.internalFormatFloat}function DAe(n,e,t,r){const[i,s]=uC(e,t);return fC(n,i,s,pJ(r),r.textureFormatFloat,n.FLOAT)}function mJ(n){return n.internalFormatHalfFloat}function OAe(n,e,t,r){const[i,s]=uC(e,t);return fC(n,i,s,mJ(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function gJ(n){return n.downloadTextureFormat}function FAe(n,e,t,r){const[i,s]=uC(e,t);return fC(n,i,s,gJ(r),n.RGBA,n.UNSIGNED_BYTE)}function yJ(n){return n.internalFormatPackedFloat}function LAe(n,e,t,r){const[i,s]=$w(e,t);return fC(n,i,s,yJ(r),n.RGBA,n.FLOAT)}function bJ(n){return n.internalFormatPackedHalfFloat}function zAe(n,e,t,r){const[i,s]=$w(e,t);return fC(n,i,s,bJ(r),n.RGBA,r.textureTypeHalfFloat)}function BAe(n,e,t){return Bt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),uH(n,e,"clipSpacePos",t,3,20,0)&&uH(n,e,"uv",t,2,20,12)}function VAe(n,e,t,r,i,s){Bt(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,a,l;i instanceof Uint8Array?(o=new Uint8Array(t*r*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(t*r*4),a=n.FLOAT,l=s.internalFormatPackedFloat),o.set(i),Ie().getNumber("WEBGL_VERSION")===2?Bt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,r,n.RGBA,a,o)):Bt(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,r,0,n.RGBA,a,o)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function UAe(n,e,t){Bt(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?Ie().getNumber("WEBGL_VERSION")===2?Bt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Bt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):Ie().getNumber("WEBGL_VERSION")===2?Bt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Bt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function WAe(n,e,t,r){const i=n.createBuffer();Bt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,i));const a=4*4*e*t;return Bt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),Bt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Bt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),i}function HAe(n,e,t){const r=n,i=new Float32Array(t);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}function GAe(n,e,t,r){const[i,s]=uC(e,t),o=4,a=new Uint8Array(lIe(e*t,o));return Bt(n,()=>n.readPixels(0,0,i,s,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function jAe(n,e,t,r,i,s,o,a){const l=n,c=new Float32Array(cIe(s,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function qAe(n,e,t){const r=new Float32Array(e*t*4);return Bt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c3{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=Ie().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,sIe(t,e)):this.gl=ku(t),e=this.gl,Ie().getNumber("WEBGL_VERSION")===2){const s=e;this.createVertexArray=()=>Bt(s,()=>s.createVertexArray()),this.bindVertexArray=o=>Bt(s,()=>s.bindVertexArray(o)),this.deleteVertexArray=o=>Bt(s,()=>s.deleteVertexArray(o)),this.getVertexArray=()=>Bt(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(e!=null){const s=e.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Bt(e,()=>s.createVertexArrayOES()),this.bindVertexArray=o=>Bt(e,()=>s.bindVertexArrayOES(o)),this.deleteVertexArray=o=>Bt(e,()=>s.deleteVertexArrayOES(o)),this.getVertexArray=()=>Bt(e,()=>e.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Ie().getNumber("WEBGL_VERSION")===1){const s="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=jk(this.gl,s),pc(this.gl,o))this.textureHalfFloatExtension=jk(this.gl,o);else if(Ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),pc(this.gl,i))this.colorBufferHalfFloatExtension=jk(this.gl,i);else if(Ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",pc(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(pc(this.gl,i))this.colorBufferHalfFloatExtension=this.gl.getExtension(i);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=RAe(this.gl),this.indexBuffer=PAe(this.gl),this.framebuffer=CIe(this.gl),this.textureConfig=nB(this.gl,this.textureHalfFloatExtension)}get debug(){return Ie().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Bt(e,()=>e.finish()),Bt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Bt(e,()=>e.deleteFramebuffer(this.framebuffer)),Bt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Bt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Bt(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),DAe(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),OAe(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),FAe(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),UAe(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,i){this.throwIfDisposed(),VAe(this.gl,e,t,r,i,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),zAe(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),LAe(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(hH(this.gl,this.framebuffer),this.outputTexture=null),Bt(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>GAe(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,i,s,o){return jAe(this.gl,e,t,r,i,s,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return HAe(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);const i=WAe(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if(Ie().getBool("WEBGL_FENCE_API_ENABLED")){const i=e,s=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const o=i.clientWaitSync(s,0,0);return o===i.ALREADY_SIGNALED||o===i.CONDITION_SATISFIED},t=s}else Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>qAe(this.gl,t,r))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=$Ae(t));const r=bIe(t);Bt(t,()=>t.attachShader(r,this.vertexShader)),Bt(t,()=>t.attachShader(r,e)),vIe(t,r);const i=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&s3(t,i),i}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Bt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),BAe(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Bt(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&s3(this.gl,this.program),Bt(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?TIe(this.gl,e,t):EIe(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Bt(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),IIe(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();const[i,s]=$w(t,r);this.setOutputMatrixTextureDriver(e,i,s)}setOutputMatrixWriteRegion(e,t,r,i){this.setOutputMatrixWriteRegionDriver(r,e,i,t)}setOutputPackedMatrixWriteRegion(e,t,r,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&s3(this.gl,this.program),qk(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Bt(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Bt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=jk(this.gl,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,i=this.getQueryTimerExtensionWebGL2(),s=r.createQuery();return r.beginQuery(i.TIME_ELAPSED_EXT,s),s}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await nD(()=>this.disposed||this.isQueryAvailable(e,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const r=this.gl,i=this.getQueryTimerExtensionWebGL2(),s=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),i=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=XAe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in Ie().platform&&(r=Ie().platform.setTimeoutCustom.bind(Ie().platform)),nD(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),o3(this.gl,e,this.framebuffer),this.debug&&qk(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(o3(this.gl,this.outputTexture,this.framebuffer),this.debug&&qk(this.gl)):hH(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();const i=this.gl;o3(i,e,this.framebuffer),this.debug&&qk(i),this.outputTexture=e,Bt(i,()=>i.viewport(0,0,t,r)),Bt(i,()=>i.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,i){this.throwIfDisposed(),Bt(this.gl,()=>this.gl.scissor(e,t,r,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function XAe(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:KAe,bincountImpl:vJ,bincountReduceImpl:YAe,bitwiseAndImpl:ZAe,castImpl:JAe,ceilImpl:QAe,concatImpl:eMe,equalImpl:tMe,expImpl:nMe,expm1Impl:rMe,floorImpl:iMe,gatherNdImpl:sMe,gatherV2Impl:oMe,greaterImpl:aMe,greaterEqualImpl:lMe,lessImpl:cMe,lessEqualImpl:uMe,linSpaceImpl:hMe,logImpl:fMe,maxImpl:dMe,maximumImpl:pMe,minimumImpl:mMe,multiplyImpl:gMe,negImpl:yMe,notEqualImpl:bMe,prodImpl:vMe,raggedGatherImpl:wMe,raggedRangeImpl:xMe,raggedTensorToTensorImpl:_Me,rangeImpl:SMe,rsqrtImpl:CMe,scatterImpl:kMe,sigmoidImpl:TMe,simpleAbsImpl:wJ,sliceImpl:EMe,sparseFillEmptyRowsImpl:IMe,sparseReshapeImpl:AMe,sparseSegmentReductionImpl:xJ,sqrtImpl:MMe,staticRegexReplaceImpl:NMe,stridedSliceImpl:$Me,stringNGramsImpl:RMe,stringSplitImpl:PMe,stringToHashBucketFastImpl:DMe,subImpl:OMe,tileImpl:FMe,topKImpl:LMe,transposeImpl:oB,uniqueImpl:zMe}=GZ;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _J(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Go(n,e){return e===1?[n]:_J(n,e)}function BMe(n,e){if(n===1)return"rc";let t="";for(let r=0;r<n;r++)t+=e[r],r<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VMe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=To(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Go("rc",this.rank),r=Fr(this.rank),i=this.getOutOfBoundsCondition(t),s=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){let s=`${r===0?"r":"rp1"}, ${i===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)s=`${e[e.length-1-o]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],i=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${i};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SJ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);let r="";for(let i=0;i<4;i++){let s="thisRC = rc;";i%2===1&&(s+="thisRC.z += 1;"),i>1&&(s+="thisRC.y += 1;"),r+=`
        ${s}
        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i>0?"}":""}
      `}this.userCode=`
      ${UMe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?iB():rB(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function UMe(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?BIe(["r","c","d"],"inputShape"):zy(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let WMe=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,r){const i=gH(t,r),s=yH(e,i,r);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const o=mH(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[s].pop();return this.usedTextures[s].push(l),l}let a;return i===oo.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):i===oo.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):i===oo.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):i===oo.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):i===oo.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,r,i){if(this.freeTextures==null)return;const s=gH(r,i),o=yH(t,s,i);o in this.freeTextures||(this.freeTextures[o]=[]);const a=mH(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,i),l=Ie().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c&&c.indexOf(e);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[u]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function HMe(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function mH(n,e,t,r,i){const s=GMe(e,r);let o;if(i){const[l,c]=$w(n[0],n[1]);o=l*c}else{const[l,c]=uC(n[0],n[1]);o=l*c}const a=HMe(t,s);return o*a}function GMe(n,e){switch(n){case oo.PACKED_2X2_FLOAT32:return yJ(e);case oo.PACKED_2X2_FLOAT16:return bJ(e);case oo.UNPACKED_FLOAT32:return pJ(e);case oo.UNPACKED_FLOAT16:return mJ(e);case oo.PACKED_4X1_UNSIGNED_BYTE:return gJ(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function jMe(n){return Ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?oo.PACKED_2X2_FLOAT32:oo.UNPACKED_FLOAT32:n?oo.PACKED_2X2_FLOAT16:oo.UNPACKED_FLOAT16}function gH(n,e){if(n===Cl.UPLOAD)return oo.PACKED_2X2_FLOAT32;if(n===Cl.RENDER||n==null)return jMe(e);if(n===Cl.DOWNLOAD||n===Cl.PIXELS)return oo.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function yH(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fh=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const Pc="if (isnan(x)) return x;",qMe="return x;",bH="return abs(x);",XMe="return (x >= 0.0) ? x : (exp(x) - 1.0);",KMe=Pc+`
  return (x < 0.0) ? 0.0 : x;
`,YMe=Pc+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,xd="return x;",ZMe="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JMe="return x;",QMe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,eNe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,tNe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,nNe="return 1.0 / (1.0 + exp(-1.0 * x));";class Ed{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rNe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);const t=e.length,r=Go("rc",t),i=Fr(t),s=BMe(t,r),o=r.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iNe=ZM,sNe=1e-7,oNe=1e-4,Yk={};function aNe(n){return n in Yk||(Yk[n]={}),Yk[n]}const lNe=Ie().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),cNe=600;function uNe(){return Ie().global.screen==null?1024:Ie().global.screen.height*Ie().global.screen.width*window.devicePixelRatio*cNe/1024/1024}class MN extends VS{nextDataId(){return MN.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ie().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof c3)t=e;else{const r=ku(Ie().getNumber("WEBGL_VERSION"),e);t=new c3(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=ku(Ie().getNumber("WEBGL_VERSION"));t=new c3(r),this.binaryCache=aNe(Ie().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new WMe(this.gpgpu),this.numMBBeforeWarning=uNe(),this.texData=new gM(this,wo())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,r,i,s,o){const a=this.makeTensorInfo(t,r),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[i,s]},l.texShape=[i,s];const c=Xk(t),u=new pH(c,!1,o),h=this.runWebGLProgram(u,[a],r,[[i,s]]);return h.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(e,t,r){if((Ie().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ie().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:t,dtype:r,values:e,usage:Cl.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,r,i,s){if(Ie().getBool("DEBUG")&&this.checkNumericalProblems(t),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:i,values:t,usage:Cl.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:r,dtype:i,complexTensorInfos:s,slice:o,shape:a,isPacked:l}=t;if(o!=null){let f;l?f=new Ed(a,xd):f=new fh(a,xd);const d=this.runWebGLProgram(f,[{dataId:e,shape:a,dtype:i}],i),p=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),p}if(r!=null)return this.convertAndCacheOnCPU(e);if(i==="string")return r;const c=this.activeTimers!=null;let u;c&&(u=io());let h;if(i==="complex64"){const f=this.readSync(s.real.dataId),d=this.readSync(s.imag.dataId);h=Su(f,d)}else h=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=io()-u),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const p=this.pendingRead.get(e);return new Promise(m=>p.push(m))}const t=this.texData.get(e),{values:r,shape:i,slice:s,dtype:o,complexTensorInfos:a,isPacked:l}=t;if(s!=null){let p;l?p=new Ed(i,xd):p=new fh(i,xd);const m=this.runWebGLProgram(p,[{dataId:e,shape:i,dtype:o}],o),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(r!=null)return this.convertAndCacheOnCPU(e);if(Ie().getBool("DEBUG")&&!Ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Ie().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(o!=="complex64"&&Ie().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const p=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(p.texture.texture,...Gk(i))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(o==="complex64"){const p=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),m=p[0],g=p[1];h=Su(m,g)}else if(c==null)h=this.getValuesFromTexture(e);else{const p=Ee(i);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,p)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){const p=this.gpgpu.gl;Bt(p,()=>p.deleteBuffer(c))}const f=this.convertAndCacheOnCPU(e,h),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(p=>p(f)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&wo().removeDataId(e,this),this.pendingDeletes--),f}readToGPU(e,t={}){const r=this.texData.get(e),{values:i,shape:s,slice:o,dtype:a,isPacked:l,texture:c}=r;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let d;l?d=new Ed(s,xd):d=new fh(s,xd);const p=this.runWebGLProgram(d,[{dataId:e,shape:s,dtype:a}],a),m=this.readToGPU(p,t);return this.disposeIntermediateTensorInfo(p),m}if(c==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),h=wo().makeTensorFromTensorInfo(u),f=this.texData.get(u.dataId);return Object.assign({tensorRef:h},f.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(i=>Sc(i));return Sn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Sn(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const r=e[t];if(!dIe(r))throw Ie().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:r,isPacked:i}=this.texData.get(e),s=Ee(t);if(Ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),d=this.texData.get(f.dataId),p=this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture,...Gk(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(f),p}const o=Ie().getBool("WEBGL_PACK")&&i===!0,a=o?Xk(t):t,l=o?new AAe(a):new IAe(a),c=this.runWebGLProgram(l,[{shape:a,dtype:r,dataId:e}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,r=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=r,i=!0):this.activeTimers.push(r),this.activeTimers=r,e();const s=Cc(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=Cc(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,i&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(s);a.kernelMs=yL(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:io(),endMs:null}}endTimer(e){return Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=io(),e)}async getQueryTime(e){if(Ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:r,texShape:i,usage:s,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(i,r),this.textureManager.releaseTexture(t,i,s,o)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=lNe){return Ie().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&Ee(r.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){xl("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return iNe(e.shape,t)}packedUnaryOp(e,t,r){const i=new Ed(e.shape,t),s=this.compileAndRun(i,[e],r);return wo().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const i=wJ(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,bH,e.dtype);const t=new fh(e.shape,bH),r=this.compileAndRun(t,[e]);return wo().makeTensorFromTensorInfo(r)}makeTensorInfo(e,t,r){let i;if(t==="string"&&r!=null&&r.length>0&&du(r[0])){const s=r.map(o=>vu(o));i=this.write(s,e,t)}else i=this.write(r,e,t);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:t}}makeOutput(e,t,r){return wo().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,r),this)}unpackTensor(e){const t=new rNe(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new VMe(e.shape),r=!0;return this.runWebGLProgram(t,[e],e.dtype,null,r)}packedReshape(e,t){const r=[ev(e.shape),...tv(e.shape)],i={dtype:e.dtype,shape:r,dataId:e.dataId},s=[ev(t),...tv(t)],o=new SJ(s,r),a=!0,l=[r],c=this.runWebGLProgram(o,[i],e.dtype,l,a);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const r=this.texData.get(e),{isPacked:i,shape:s,dtype:o}=r;if(t!=null){const f=Ee(s),d=t[0]*t[1]*4;U(f<=d,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=Xk(s);let l;i?l=new EAe(a):l=new TAe(a);const c=!0,u=[t??Gk(a)],h=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,u,c,t);return{dtype:o,shape:s,dataId:h.dataId}}runWebGLProgram(e,t,r,i,s=!1,o){const a=this.makeTensorInfo(e.outputShape,r),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===k_.DENSE){const y=o??Gk(e.outputShape);l.texShape=y.map(b=>b*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Ee(a.shape)===0)return l.values=cs(a.dtype,0),a;const c=[],u=t.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!e.packedInputs&&Ee(y.shape)<=Ie().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!e.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),c.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!NI(b.shape,y.shape)){const _=y,w=y.shape;y.shape=b.shape,y=this.packedReshape(y,w),c.push(y),b=this.texData.get(y.dataId),_.shape=w}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:l,isUniform:!1},f=kAe(e,u,h),d=this.getAndSaveBinary(f,()=>SAe(this.gpgpu,e,u,h)),p=this.activeTimers!=null;let m;p&&(m=this.startTimer()),Ie().get("ENGINE_COMPILE_ONLY")||CAe(this.gpgpu,d,u,h,i),c.forEach(y=>this.disposeIntermediateTensorInfo(y)),p&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const g=Ie().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=io();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!Ie().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&s===!1){const y=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),y}return a}compileAndRun(e,t,r,i,s=!1){return r=r||t[0].dtype,this.runWebGLProgram(e,t,r,i,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Ie().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Se(()=>{if(!Ie().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Ie().getBool("DEBUG");Ie().set("DEBUG",!1);const t=this.abs(Qt(1e-8)).dataSync()[0];if(Ie().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?sNe:oNe}uploadToGPU(e){const t=this.texData.get(e),{shape:r,dtype:i,values:s,texture:o,usage:a,isPacked:l}=t;if(o!=null)return;const c=this.activeTimers!=null;let u;c&&(u=io());let h=t.texShape;if(h==null&&(h=NIe(r,l),t.texShape=h),s!=null){const f=Xk(r);let d,p=h[1],m=h[0];const g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!g)&&([p,m]=$w(h[0],h[1])),l?d=new NAe(f,g):d=new pH(f,g);const y=g?[m,p]:h,b=this.makeTensorInfo(y,i),_=this.texData.get(b.dataId);g?_.usage=Cl.PIXELS:_.usage=Cl.UPLOAD,_.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),p,m,s);const w=[[m,p]],S=!0,C=this.runWebGLProgram(d,[b],i,w,S),k=this.texData.get(C.dataId);t.texShape=k.texShape,t.isPacked=k.isPacked,t.usage=k.usage,Ie().get("ENGINE_COMPILE_ONLY")?this.disposeData(C.dataId):(t.texture=k.texture,t.values=null,this.texData.delete(C.dataId)),this.disposeIntermediateTensorInfo(b),c&&(this.uploadWaitMs+=io()-u)}else{const f=this.acquireTexture(h,a,i,l);t.texture=f}}convertAndCacheOnCPU(e,t){const r=this.texData.get(e),{dtype:i}=r;return t!=null&&(r.values=hNe(t,i)),r.values}acquireTexture(e,t,r,i){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,i)}computeBytes(e,t){return e[0]*e[1]*h_(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const r=new Promise(i=>{try{this.checkCompletion_(t),i(!0)}catch(s){throw s}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Wz(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(lJ(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:r,infLoc:i,nanLoc:s,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:l}=dJ(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=r,e.infLoc=i,e.nanLoc=s,e.outShapeLocation=o,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,r){e.channels=e.channels||"RGBA";const{texture:i,height:s,width:o,channels:a}=e,l=wo().backend;if(!l.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(i,t,r,s,o,a);return wo().makeTensorFromDataId(c,t,r,l)}}MN.nextDataId=0;function hNe(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<t.length;++r)t[r]=Math.round(n[r]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kL()&&NM("webgl",()=>new MN,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aB=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let ug=class{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=ln(t,r),this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vy=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Fw{constructor(e,t,r,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ln(t,r);const s=this.outputShape.length;this.enableShapeUniforms=To(s);let o="";if(i)if(s===0||Ee(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Fr(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Go("coords",s);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qa(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const fNe={kernelName:ey,backendName:"webgl",kernelFunc:qa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ap(n){const{inputs:e,backend:t}=n,{real:r,imag:i}=e,s=t.makeTensorInfo(r.shape,"complex64"),o=t.texData.get(s.dataId),a=qa({inputs:{x:r},backend:t}),l=qa({inputs:{x:i},backend:t});return o.complexTensorInfos={real:a,imag:l},s}const dNe={kernelName:KS,backendName:"webgl",kernelFunc:Ap};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CJ="return (a < 0.) ? b * a : a;",kJ=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function pNe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{alpha:s}=r,o=t.makeTensorInfo([],"float32",Vf(s,"float32")),a=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fw(kJ,i.shape,o.shape):new ug(CJ,i.shape,o.shape),l=t.runWebGLProgram(a,[i,o],"float32");return t.disposeIntermediateTensorInfo(o),l}const mNe={kernelName:qv,backendName:"webgl",kernelFunc:pNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TJ="return (a < 0.) ? b * a : a;",EJ=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function gNe(n){const{inputs:e,backend:t}=n,{x:r,alpha:i}=e,s=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fw(EJ,r.shape,i.shape):new ug(TJ,r.shape,i.shape);return t.runWebGLProgram(s,[r,i],"float32")}const yNe={kernelName:fw,backendName:"webgl",kernelFunc:gNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lw="if (isnan(x)) return x;";function mr({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:r}){return({inputs:i,backend:s})=>{const{x:o}=i,a=s,l=r||o.dtype;if(a.shouldExecuteOnCPU([o])&&t!=null){const h=a.texData.get(o.dataId),f=t(h.values,l);return a.makeTensorInfo(o.shape,l,f)}const c=Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let u;return c?u=new Ed(o.shape,e):u=new fh(o.shape,n),a.runWebGLProgram(u,[o],l)}}function uo({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:i,dtype:s}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(r&&l.dtype==="complex64"){const p=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[g,y]=[[p.complexTensorInfos.real,m.complexTensorInfos.real],[p.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(_=>{const[w,S]=_,C={dataId:w.dataId,dtype:w.dtype,shape:l.shape},k={dataId:S.dataId,dtype:S.dtype,shape:c.shape},A=new ug(n,l.shape,c.shape);return u.runWebGLProgram(A,[C,k],As(w.dtype,S.dtype))}),b=Ap({inputs:{real:g,imag:y},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(y),b}const h=s||As(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&i!=null){const p=u.texData.get(l.dataId).values,m=u.texData.get(c.dataId).values,g=l.dtype==="string"?Cu(p):p,y=l.dtype==="string"?Cu(m):m,[b,_]=i(l.shape,c.shape,g,y,h),w=u.makeTensorInfo(_,h),S=u.texData.get(w.dataId);return S.values=b,w}const f=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let d;return f?d=new Fw(e,l.shape,c.shape,t):d=new ug(n,l.shape,c.shape),u.runWebGLProgram(d,[l,c],h)}}function T_(n,e=!1){if(n==="linear")return e?JMe:qMe;if(n==="relu")return e?eNe:KMe;if(n==="elu")return e?QMe:XMe;if(n==="relu6")return e?tNe:YMe;if(n==="prelu")return e?EJ:TJ;if(n==="leakyrelu")return e?kJ:CJ;if(n==="sigmoid")return e?nNe:ZMe;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let IJ=class{constructor(e,t,r,i=!1,s=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=To(this.outputShape.length);const u=i?e[1]:e[2],h=Math.ceil(u/2),f=i?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",p=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";a&&(l?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let _="rc.x",w="rc.x";e[0]<t[0]?_=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(w=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${_};
        int batchB = ${w};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${m[0]});
          result += (${p[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vH={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let wH=class{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ln(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xH="return a * b;";function lB(n){const{inputs:e,backend:t}=n,{a:r,b:i}=e,s=As(r.dtype,i.dtype);if(r.dtype==="complex64"){const a=t.texData.get(r.dataId),l=t.texData.get(i.dataId),c=new wH(vH.REAL,r.shape,i.shape),u=new wH(vH.IMAG,r.shape,i.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:i.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:i.shape}],f=t.runWebGLProgram(c,h,"float32"),d=t.runWebGLProgram(u,h,"float32"),p=Ap({inputs:{real:f,imag:d},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),p}if(t.shouldExecuteOnCPU([r,i])){const a=t.texData.get(r.dataId),l=t.texData.get(i.dataId),[c,u]=gMe(r.shape,i.shape,a.values,l.values,s),h=t.makeTensorInfo(u,s),f=t.texData.get(h.dataId);return f.values=c,h}let o;return Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new Fw(xH,r.shape,i.shape):o=new ug(xH,r.shape,i.shape),t.runWebGLProgram(o,[r,i],s)}const bNe={kernelName:cy,backendName:"webgl",kernelFunc:lB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vNe(n,e,t){const r=[ev(n.shape),...tv(n.shape)],i={dtype:n.dtype,shape:r,dataId:n.dataId},s=[ev(e),...tv(e)],o=new SJ(s,r),a=!0,l=[r],c=t.runWebGLProgram(o,[i],n.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mt(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{shape:s}=r,o=t,a=Ee(i.shape),l=bM(s,a),c=Ee(l);U(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(i.dataId);return u.isPacked&&!NI(i.shape,l)&&!(u.texture!==null&&NI(u.shape,l))?vNe(i,l,o):(o.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype})}const wNe={kernelName:pw,backendName:"webgl",kernelFunc:Mt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _H{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:i,inSize:s,outSize:o}=e;this.outputShape=[i,o];const a=Math.floor(r/4)*4,l=r%4;let c="sumValue += dot(values, ones);";if(t!=null){const h=1/t;c=`sumValue += dot(values * ${eg(h)?h.toPrecision(2):h}, ones);`}let u="";s%r>0&&(u=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xNe=class{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:i,inSize:s,outSize:o}=e;this.outputShape=[i,o];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const u=Math.floor(r/4)*4,h=r%4;let f=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(a="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(a="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let p="";s%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${h===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${h===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${c});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ne(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],r=uN(t);e.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return e}function Uy(n,e,t,r){const i=_Ne(n.shape);let s=n;for(let o=0;o<i.length;o++){const{inSize:a,windowSize:l,outSize:c}=i[o];let u,h;t==="mean"?u=o===0?new _H({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new _H({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):u=new xNe({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},t),h=s,s=r.runWebGLProgram(u,[s],e),h.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(h)}return s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SNe=class{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[t[o]];this.outputShape=r,this.rank=r.length;const i=Fr(this.rank),s=CNe(t);this.userCode=`
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function CNe(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let i=0;i<n.length;i++)r[n[i]]=t[i];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kNe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let u=0;u<r.length;u++)r[u]=e[t[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=Fr(this.rank),s=_J("rc",this.rank),o=new Array(this.rank);for(let u=0;u<t.length;u++)o[t[u]]=s[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${s[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NN(n,e,t){const r=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kNe(n.shape,e):new SNe(n.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TNe(n,e,t,r){const i=e,s=n.shape.length,o=An(i,n.shape);let a=o;const l=Lr(a,s),c=l!=null;let u=n;c&&(u=NN(n,l,r),a=ni(a.length,s)),hs("sum",a,s);const[h,f]=Ji(u.shape,a);let d=h;t&&(d=Fi(h,o));const p=Ee(f),g=Ee(n.shape)/p,y=Mt({inputs:{x:u},attrs:{shape:[g,p]},backend:r}),b=U2(n.dtype),_=Uy(y,b,"sum",r),w=Mt({inputs:{x:_},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(_),c&&r.disposeIntermediateTensorInfo(u),w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $N(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:o}=r;return TNe(i,s,o,t)}const ENe={kernelName:ww,backendName:"webgl",kernelFunc:$N};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qo(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{perm:s}=r,o=t,a=i.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=i.shape[s[u]];let c;if(o.shouldExecuteOnCPU([i])){const h=o.texData.get(i.dataId).values,f=oB(h,i.shape,i.dtype,s,l);c=o.makeTensorInfo(l,i.dtype);const d=o.texData.get(c.dataId);d.values=f}else c=NN(i,s,o);return c}const INe={kernelName:Ld,backendName:"webgl",kernelFunc:Qo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AJ=1e3;function $I({a:n,b:e,transposeA:t,transposeB:r,backend:i,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,h=t?n.shape[c-2]:n.shape[c-1],f=r?e.shape[u-1]:e.shape[u-2],d=t?n.shape[c-1]:n.shape[c-2],p=r?e.shape[u-2]:e.shape[u-1],m=n.shape.slice(0,-2),g=e.shape.slice(0,-2),y=Ee(m),b=Ee(g),w=ln(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,p]);U(h===f,()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const S=t?[y,h,d]:[y,d,h],C=r?[b,p,f]:[b,f,p],k=Mt({inputs:{x:n},backend:i,attrs:{shape:S}}),A=Mt({inputs:{x:e},backend:i,attrs:{shape:C}}),M=[k,A],E=Math.max(y,b),N=t?k.shape[1]:k.shape[2],O=s!=null,R=o!=null,D=l==="leakyrelu",z=l!=null?T_(l,!0):null,B=O||R||D||z!=null;let X;if((d===1||p===1)&&N>AJ&&B===!1){let te=k,ge=A;t&&(te=Qo({inputs:{x:k},backend:i,attrs:{perm:[0,2,1]}}),M.push(te)),r&&(ge=Qo({inputs:{x:A},backend:i,attrs:{perm:[0,2,1]}}),M.push(ge));const ae=p!==1,Ne=p===1;let Te=te;ae&&(Te=Mt({inputs:{x:te},backend:i,attrs:{shape:[E,N,1]}}),M.push(Te));const De=p===1?2:1;let be=ge;Ne&&(be=Mt({inputs:{x:ge},backend:i,attrs:{shape:[E,1,N]}}),M.push(be));const Ke=lB({inputs:{a:Te,b:be},backend:i});X=$N({inputs:{x:Ke},backend:i,attrs:{axis:De,keepDims:!0}}),M.push(Ke)}else{const te=As(n.dtype,e.dtype),ge=new IJ(S,C,[E,d,p],t,r,O,z,R,D),ae=[k,A];if(s!=null&&ae.push(s),R&&ae.push(o),D){const Ne=i.makeTensorInfo([],"float32",Vf(a,"float32"));ae.push(Ne),M.push(Ne)}X=i.runWebGLProgram(ge,ae,te)}const H=Mt({inputs:{x:X},backend:i,attrs:{shape:w}});M.push(X);for(const te of M)i.disposeIntermediateTensorInfo(te);return H}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ANe(n){const{inputs:e,backend:t,attrs:r}=n,{a:i,b:s,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;return $I({a:i,b:s,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}const MNe={kernelName:Vb,backendName:"webgl",kernelFunc:ANe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SH="return abs(x);";function NNe(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const s=t.texData.get(r.dataId),o=wJ(s.values);return t.makeTensorInfo(r.shape,r.dtype,o)}let i;return Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Ed(r.shape,SH):i=new fh(r.shape,SH),t.runWebGLProgram(i,[r],r.dtype)}const $Ne={kernelName:Tv,backendName:"webgl",kernelFunc:NNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RNe=Pc+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,PNe=mr({opSnippet:RNe}),DNe={kernelName:Pg,backendName:"webgl",kernelFunc:PNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ONe=Pc+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,FNe=mr({opSnippet:ONe}),LNe={kernelName:Dg,backendName:"webgl",kernelFunc:FNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CH="return a + b;",zNe=uo({opSnippet:CH,packedOpSnippet:CH,supportsComplex:!0,cpuKernelImpl:KAe}),BNe={kernelName:_p,backendName:"webgl",kernelFunc:zNe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VNe{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,o)=>`T${o}`);const r=[];this.variableNames.forEach(s=>{r.push(`float v${s} = get${s}AtOutCoords();`)});const i=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let UNe=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,o)=>`T${o}`);const r=[];this.variableNames.forEach(s=>{r.push(`vec4 v${s} = get${s}AtOutCoords();`)});const i=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $E(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return qa({inputs:{x:r[0]},backend:t});if(r.length>Ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=$E({inputs:r.slice(0,l),backend:t}),u=$E({inputs:r.slice(l),backend:t});return $E({inputs:[c,u],backend:t})}const i=r.map(l=>l.dtype).reduce((l,c)=>As(l,c)),s=r.map(l=>l.shape),a=Ie().getBool("WEBGL_PACK")?new UNe(r[0].shape,s):new VNe(r[0].shape,s);return t.runWebGLProgram(a,r,i)}const WNe={kernelName:Ev,backendName:"webgl",kernelFunc:$E};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HNe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:o}=r,a=i.shape.length,l=An(s,i.shape);let c=l;const u=Lr(c,a);let h=i;u!=null&&(h=Qo({inputs:{x:i},backend:t,attrs:{perm:u}}),c=ni(c.length,a)),hs("all",c,a);const[f,d]=Ji(h.shape,c),p=Ee(d),m=Mt({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),g=Uy(m,m.dtype,"all",t);let y;if(o){const b=Fi(f,l);y=Mt({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=Mt({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(h),y}const GNe={kernelName:US,backendName:"webgl",kernelFunc:HNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jNe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:o}=r,a=i.shape.length,l=An(s,i.shape);let c=l;const u=Lr(c,a);let h=i;u!=null&&(h=Qo({inputs:{x:i},backend:t,attrs:{perm:u}}),c=ni(c.length,a)),hs("any",c,a);const[f,d]=Ji(h.shape,c),p=Ee(d),m=Mt({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),g=Uy(m,m.dtype,"any",t);let y;if(o){const b=Fi(f,l);y=Mt({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=Mt({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(h),y}const qNe={kernelName:WS,backendName:"webgl",kernelFunc:jNe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let XNe=class{constructor(e,t,r){this.variableNames=["A"];const{windowSize:i,batchSize:s,outSize:o}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o];const a=t==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KNe{constructor(e,t,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,U(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const s=e[e.length-1],o=Math.ceil(s/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),i||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=Fr(l),u=Go("coords",l);let h,f;if(o===1){f=l+1;const A=Fr(f);h=`
        ${A} sourceLocR = ${A}(${u.join()}, 0);
        ++${u[l-1]};
        ${A} sourceLocG = ${A}(${u.join()}, 0);
        ++${u[l-2]};
        ${A} sourceLocA = ${A}(${u.join()}, 0);
        --${u[l-1]};
        ${A} sourceLocB = ${A}(${u.join()}, 0);
        --${u[l-2]};`}else f=l,h=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;const d=["x","y","z","w","u","v"].slice(0,f),p="."+d[f-1],m=d.map(A=>"int "+A),g=Go("sourceLocR",f-1).concat("inIdx.r"),y=Go("sourceLocG",f-1).concat("inIdx.g"),b=Go("sourceLocB",f-1).concat("inIdx.b"),_=Go("sourceLocA",f-1).concat("inIdx.a"),w=r==="max"?"greaterThan":"lessThan",S=i?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${_.join()})));`,C=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${_.join()}) : 0.)`,k=i?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${C};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${S}
          vec4 candidate = ${C};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MJ(n,e,t,r=null){let i=e.shape[0],s=e.shape[1];r!=null&&(i=r.shape[0],s=r.shape[1]);const o=uN(s),a={windowSize:o,inSize:s,batchSize:i,outSize:Math.ceil(s/o)},l=new XNe(a,t,r==null),c=[e];r!=null&&c.push(r);const u=n.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;const h=MJ(n,e,t,u);return n.disposeIntermediateTensorInfo(u),h}function NJ(n,e,t,r=null){const i=r!=null?r.shape:e.shape,s=i[i.length-1],o=uN(s),a=new KNe(i,o,t,r==null),l=r==null?[e]:[e,r],c=n.runWebGLProgram(a,l,"int32");if(c.shape.length===e.shape.length){const u=NJ(n,e,t,c);return n.disposeIntermediateTensorInfo(c),u}return c}function $J(n,e,t,r){const i=[t];if(hs("arg"+r.charAt(0).toUpperCase()+r.slice(1),i,e.shape.length),!Ie().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const s=[],o=n.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=n.unpackTensor(e),s.push(l));const[c,u]=Ji(l.shape,i),h=Ee(u),f=Mt({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});s.push(f);const d=MJ(n,f,r);s.push(d);const p=Mt({inputs:{x:d},backend:n,attrs:{shape:c}});return s.forEach(m=>n.disposeIntermediateTensorInfo(m)),p}return NJ(n,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YNe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s}=r;let o=An(s,i.shape);const a=Lr(o,i.shape.length);let l=i;const c=[];a!=null&&(l=Qo({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=ni(o.length,l.shape.length)),hs("argMax",[o[0]],l.shape.length);const u=$J(t,l,o[0],"max");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const ZNe={kernelName:Iv,backendName:"webgl",kernelFunc:YNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JNe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s}=r;let o=An(s,i.shape);const a=Lr(o,i.shape.length);let l=i;const c=[];a!=null&&(l=Qo({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=ni(o.length,l.shape.length)),hs("argMin",[o[0]],l.shape.length);const u=$J(t,l,o[0],"min");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const QNe={kernelName:Av,backendName:"webgl",kernelFunc:JNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e$e=Pc+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,t$e=mr({opSnippet:e$e}),n$e={kernelName:Og,backendName:"webgl",kernelFunc:t$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r$e=Pc+"return log(x + sqrt(x * x + 1.0));",i$e=mr({opSnippet:r$e}),s$e={kernelName:Fg,backendName:"webgl",kernelFunc:i$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o$e=Pc+`
  return atan(x);
`,a$e=mr({opSnippet:o$e}),l$e={kernelName:Lg,backendName:"webgl",kernelFunc:a$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c$e=aB+`
  return atan(a, b);
`,u$e=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vy+`
  return result;
`,h$e=uo({opSnippet:c$e,packedOpSnippet:u$e}),f$e={kernelName:Bg,backendName:"webgl",kernelFunc:h$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d$e=Pc+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,p$e=mr({opSnippet:d$e}),m$e={kernelName:zg,backendName:"webgl",kernelFunc:p$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let E_=class{constructor(e,t,r,i=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const m=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(m||(b="-1.0 / 1e-20"),r){const A=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${d}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${A} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i?s?g:y:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const _="max";let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / max(count, 1.0)");const S=Math.floor(o/4)*4,C=o%4,k=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${_}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${d}, ${p});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${S}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${S};
          if (${C===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${C===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${C===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${w});
      }
    `}},cB=class{constructor(e,t,r,i=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,c=e.strideWidth,u=e.dilationDepth,h=e.dilationHeight,f=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const _=t==="avg";let w="0.0";if(_||(w="-1.0 / 1e-20"),r){const E=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${E} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let C=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(C="avgValue / max(count, 1.0)");const k=Math.floor(o/4)*4,A=o%4,M=`
      if (${_}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${M}
            }

            int xC = xCCorner + ${k};
            if (${A===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${A===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${A===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${M}
            }
          }
        }
        setOutput(${C});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e;hC(i,"avgPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U($s(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ko(i.shape,s,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&Rn(u.inShape,u.outShape))return qa({inputs:{x:i},backend:t});const h=new E_(u,"avg",!1);return t.runWebGLProgram(h,[i],"float32")}const y$e={kernelName:Mv,backendName:"webgl",kernelFunc:g$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r,u=[1,1,1],h=Ll(i.shape,s,o,u,a,l,c),f=new cB(h,"avg",!1);return t.runWebGLProgram(f,[i],"float32")}const v$e={kernelName:Nv,backendName:"webgl",kernelFunc:b$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let w$e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,i=e.strideHeight,s=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=l-1-e.padInfo.top,h=c-1-e.padInfo.left,f=1/(t*r);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},x$e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,i=e.filterWidth,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterDepth,f=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=h-1-e.padInfo.front,m=f-1-e.padInfo.top,g=d-1-e.padInfo.left,y=1/(t*r*i);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _$e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=[1,1,1],f=Ll(o.shape,a,l,h,c,u),d=new x$e(f);return t.runWebGLProgram(d,[i],o.dtype)}const S$e={kernelName:GS,backendName:"webgl",kernelFunc:_$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C$e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,o=s;hC([i,s],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=ko(o.shape,a,l,1,c),h=new w$e(u);return t.runWebGLProgram(h,[i],o.dtype)}const k$e={kernelName:HS,backendName:"webgl",kernelFunc:C$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T$e(n){const{inputs:e,backend:t,attrs:r}=n,{a:i,b:s}=e,{transposeA:o,transposeB:a}=r;return $I({a:i,b:s,transposeA:o,transposeB:a,backend:t})}const E$e={kernelName:$v,backendName:"webgl",kernelFunc:T$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let I$e=class{constructor(e,t,r,i,s,o){this.outputShape=[],this.variableNames=["x","mean","variance"],ln(e,t),ln(e,r);let a="0.0";i!=null&&(ln(e,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";s!=null&&(ln(e,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A$e{constructor(e,t,r,i,s,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ln(e,t),ln(e,r);let a="vec4(0.0)";i!=null&&(ln(e,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";s!=null&&(ln(e,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M$e=({inputs:n,backend:e,attrs:t})=>{const{x:r,mean:i,variance:s,offset:o,scale:a}=n;U(i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const c=[r,i,s];let u=null;o!=null&&(u=o.shape,c.push(o));let h=null;a!=null&&(h=a.shape,c.push(a));const f=Ie().getBool("WEBGL_PACK_NORMALIZATION")?new A$e(r.shape,i.shape,s.shape,u,h,l):new I$e(r.shape,i.shape,s.shape,u,h,l);return e.runWebGLProgram(f,c,c[0].dtype)},N$e={kernelName:Hv,backendName:"webgl",kernelFunc:M$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $$e=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Fr(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=R$e(this.rank);let i;const s=e.map((o,a)=>`sourceLoc.${ID[a]} = start[${a}] + coords.${ID[a]};`);i=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${i}
        setOutput(getSource(${r}));
      }
    `}};const ID=["x","y","z","w","u","v"];function R$e(n){if(n===1)return"sourceLoc";if(n<=6)return ID.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class P$e{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Fr(this.rank),r=Go("coords",this.rank),i=Go("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${i.slice(-2).join()})`,o=`getChannel(getSource(${i.join()}), ${s})`,a=`
      result.x = ${o};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${i[this.rank-1]};
        result.y = ${o};
        --${i[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${i[this.rank-2]};
        result.z = ${o};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${i[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,h)=>`start[${h}]`).join()});`:e.map((u,h)=>`${i[h]} = ${r[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D$e(n,e,t,r){const i=r.texData.get(n.dataId),s=r.makeTensorInfo(t,n.dtype),o=r.texData.get(s.dataId);Object.assign(o,i),o.refCount=1,o.shape=t,o.dtype=n.dtype;let a=Uz(e,Zt(n.shape));i.slice&&(a+=i.slice.flatOffset),o.slice={flatOffset:a,origDataId:i.slice&&i.slice.origDataId||n.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),s}function zw(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{begin:s,size:o}=r,[a,l]=oC(i,s,o);if(oN(i,a,l),Ee(l)===0)return t.makeTensorInfo(l,i.dtype,[]);if(t.shouldExecuteOnCPU([i])||i.dtype==="string"){const h=t.texData.get(i.dataId),f=EMe(h.values,a,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,f)}const{isPacked:c}=t.texData.get(i.dataId),u=Vz(i.shape,a,l);if(c||!u){const h=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new P$e(l):new $$e(l),f=[a];return t.runWebGLProgram(h,[i],i.dtype,f)}return t.uploadToGPU(i.dataId),D$e(i,a,l,t)}const O$e={kernelName:vw,backendName:"webgl",kernelFunc:zw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F$e=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockShape:s,crops:o}=r;U(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=s.reduce((b,_)=>b*_),l=Oy(i.shape,s,a),c=Fy(l.length,s.length),u=Ly(i.shape,s,a),h=fN(o,s.length),f=dN(u,o,s.length),d=[],p=Mt({inputs:{x:i},backend:t,attrs:{shape:l}}),m=Qo({inputs:{x:p},backend:t,attrs:{perm:c}}),g=Mt({inputs:{x:m},backend:t,attrs:{shape:u}}),y=zw({inputs:{x:g},backend:t,attrs:{begin:h,size:f}});return d.push(p),d.push(m),d.push(g),d.forEach(b=>t.disposeIntermediateTensorInfo(b)),y},L$e={kernelName:Rv,backendName:"webgl",kernelFunc:F$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,weights:s}=e,{size:o}=r,a=t.readSync(i.dataId),l=t.readSync(s.dataId),c=vJ(a,l,s.dtype,s.shape,o);return t.makeTensorInfo([o],s.dtype,c)}const B$e={kernelName:jS,backendName:"webgl",kernelFunc:z$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V$e=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,U$e=`
  return float(int(a.r) & int(b.r));
`;function W$e(n){const{inputs:e,backend:t}=n,{a:r,b:i}=e,s=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=Ie().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([r,i])||o===1){const l=t.texData.get(r.dataId).values,c=t.texData.get(i.dataId).values,[u,h]=ZAe(r.shape,i.shape,l,c,r.dtype),f=t.makeTensorInfo(h,r.dtype),d=t.texData.get(f.dataId);return d.values=u,f}let a;return s?a=new Fw(V$e,r.shape,i.shape,!1):a=new ug(U$e,r.shape,i.shape),t.runWebGLProgram(a,[r,i],r.dtype)}const H$e={kernelName:qS,backendName:"webgl",kernelFunc:W$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G$e(n){const{inputs:e,backend:t}=n,{s0:r,s1:i}=e,s=t.readSync(r.dataId),o=t.readSync(i.dataId),a=ln(Array.from(s),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const j$e={kernelName:XS,backendName:"webgl",kernelFunc:G$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q$e="return float(a != b);",RJ=uo({opSnippet:q$e,cpuKernelImpl:bMe,dtype:"bool"}),X$e={kernelName:aw,backendName:"webgl",kernelFunc:RJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dC(n){const{inputs:e,backend:t}=n,{input:r}=e,i=t.texData.get(r.dataId);return qa({inputs:{x:i.complexTensorInfos.real},backend:t})}const K$e={kernelName:C2,backendName:"webgl",kernelFunc:dC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y$e="return float(int(x));";function Z$e(n,e){const t=new fh(n.shape,Y$e),r=e.runWebGLProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AD(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{dtype:s}=r;if(s==="complex64"){if(i.dtype==="complex64")return qa({inputs:{x:i},backend:t});const o=pi(i.shape),a=AD({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),l=Ap({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(a),l}if(i.dtype==="complex64"){const o=dC({inputs:{input:i},backend:t}),a=AD({inputs:{x:o},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(o),a}if(!vM(i.dtype,s)){const o=qa({inputs:{x:i},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:s}}if(t.shouldExecuteOnCPU([i])){const o=t.texData.get(i.dataId).values,[a,l,c]=JAe(o,i.shape,i.dtype,s);return t.makeTensorInfo(a,l,c)}if(s==="int32")return Z$e(i,t);if(s==="bool"){const o=t.makeTensorInfo([],"bool",cs("bool",1)),l=RJ({inputs:{a:i,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${s}`)}const J$e={kernelName:Vg,backendName:"webgl",kernelFunc:AD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kH="return ceil(x);",Q$e=mr({opSnippet:kH,packedOpSnippet:kH,cpuKernelImpl:QAe}),eRe={kernelName:Ug,backendName:"webgl",kernelFunc:Q$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tRe=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nRe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{clipValueMin:s,clipValueMax:o}=r;let a;Ie().getBool("WEBGL_PACK_CLIP")?a=new nRe(i.shape):a=new tRe(i.shape);const l=[[s],[o]];return t.runWebGLProgram(a,[i],i.dtype,l)}const iRe={kernelName:Wg,backendName:"webgl",kernelFunc:rRe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sRe=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TH(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function oRe(n){const{inputs:e,backend:t}=n,{x:r}=e,i=t.texData.get(r.dataId),s=new sRe(r.shape),o=[TH(r,i.complexTensorInfos.real),TH(r,i.complexTensorInfos.imag)];return t.runWebGLProgram(s,o,o[0].dtype)}const aRe={kernelName:Pv,backendName:"webgl",kernelFunc:oRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lRe=class{constructor(e){this.outputShape=[],this.outputShape=va(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const a=t[o-1];r.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const i=t.length,s=t[t.length-1];r.push(`else setOutput(getT${i}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cRe{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=va(e,t);const r=this.outputShape,i=r.length,s=Fr(i),o=Go("coords",i),a=["x","y","z","w","u","v"].slice(0,i);this.variableNames=e.map((m,g)=>`T${g}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let m=1;m<l.length;m++)l[m]=l[m-1]+e[m][t];const c=a[t],u=a.slice(-2),h=a.join();let f=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${u.join()}));
        }`;for(let m=1;m<l.length;m++){const g=l[m-1];f+=`
        if (${c} < ${l[m]}  && ${c} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${Zk(a,c,g)}),
            vec2(${Zk(u,c,g)}));
        }`}const d=l.length,p=l[l.length-1];f+=`
        return getChannel(
          getT${d}(${Zk(a,c,p)}),
          vec2(${Zk(u,c,p)}));`,this.userCode=`
      float getValue(${a.map(m=>"int "+m)}) {
        ${f}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[i-1]} = ${o[i-1]} + 1;
        if (${o[i-1]} < ${r[i-1]}) {
          result.g = getValue(${o});
        }

        ${o[i-2]} = ${o[i-2]} + 1;
        if (${o[i-2]} < ${r[i-2]}) {
          result.a = getValue(${o});
        }

        ${o[i-1]} = ${o[i-1]} - 1;
        if (${o[i-2]} < ${r[i-2]} &&
            ${o[i-1]} < ${r[i-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function Zk(n,e,t){const r=n.indexOf(e);return n.map((s,o)=>o===r?`${s} - ${t}`:s).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RN(n){const{inputs:e,backend:t}=n,{input:r}=e,i=t.texData.get(r.dataId);return qa({inputs:{x:i.complexTensorInfos.imag},backend:t})}const uRe={kernelName:p2,backendName:"webgl",kernelFunc:RN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x1(n,e,t){const r=n[0].dtype;if(r==="complex64"){const d=n.map(b=>dC({inputs:{input:b},backend:t})),p=n.map(b=>RN({inputs:{input:b},backend:t})),m=x1(d,e,t),g=x1(p,e,t),y=Ap({inputs:{real:m,imag:g},backend:t});return d.forEach(b=>t.disposeIntermediateTensorInfo(b)),p.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),y}let i=t.shouldExecuteOnCPU(n);if(r==="string"&&(i=!0),i){const d=n.map(w=>{const C=[-1,Ee(w.shape.slice(e))];return Mt({inputs:{x:w},backend:t,attrs:{shape:C}})}),p=d.map(w=>({vals:t.readSync(w.dataId),shape:w.shape})),m=va(d.map(w=>w.shape),1),g=d[0].shape[0]===1,y=eMe(p,m,r,g),b=va(n.map(w=>w.shape),e),_=t.makeTensorInfo(b,r,y);return d.forEach(w=>t.disposeIntermediateTensorInfo(w)),_}const s=n.filter(d=>Ee(d.shape)>0),o=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){const d=o?new fh(n[0].shape,xd):new Ed(n[0].shape,xd);return t.runWebGLProgram(d,n,r)}const a=Ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){const d=[];for(let m=0;m<s.length;m+=a){const g=s.slice(m,m+a);d.push(x1(g,e,t))}const p=x1(d,e,t);for(const m of d)t.disposeIntermediateTensorInfo(m);return p}if(o){const d=new cRe(s.map(p=>p.shape),e);return t.runWebGLProgram(d,s,r)}const{tensors2D:l,outShape:c}=hRe(s,e,t),u=new lRe(l.map(d=>d.shape)),h=t.runWebGLProgram(u,l,r);l.forEach(d=>t.disposeIntermediateTensorInfo(d));const f=Mt({inputs:{x:h},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(h),f}function hRe(n,e,t){const r=va(n.map(s=>s.shape),e);return{tensors2D:n.map(s=>Mt({inputs:{x:s},attrs:{shape:[-1,Ee(s.shape.slice(e))]},backend:t})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PJ(n){const{inputs:e,backend:t,attrs:r}=n,{axis:i}=r,s=An(i,e[0].shape)[0],o=e.map(c=>c.shape);cN(o,s);const a=va(e.map(c=>c.shape),s);if(Ee(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>Ee(c.shape)>0);return l.length===1?qa({inputs:{x:l[0]},backend:t}):x1(l,s,t)}const fRe={kernelName:Dv,backendName:"webgl",kernelFunc:PJ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DJ{constructor(e,t=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,h=e.dilationWidth,f=e.filterHeight,d=e.filterWidth,p=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,_=g?3:1;let w="",S="";r&&(i?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:w=`
          float activation(float x) {
            ${r}
          }
        `,S="result = activation(result);");const C=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${_}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${C}
        ${S}
        setOutput(result);
      }
    `}}class dRe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,r=e.padInfo.top,i=e.padInfo.left,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.filterDepth,f=e.filterHeight,d=e.filterWidth,p=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${r}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OJ{constructor(e,t=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=To(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,u=e.filterWidth,h=u;let f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<u;g++)f+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;f+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<u;g++)f+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(h+1)/2;g++){const y=g*2;if(f+=`
           xC = xCCorner + ${y*l};
           `,a===1){if(y<u&&(o%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?f+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<u)){const b=o%2===0?yM(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:f+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):b===1?f+=`
                     xC${y+1} = xTexelC${y};
                     `:f+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<u&&(o%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<u&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<u&&(f+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<u&&(f+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<u&&(f+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let d="",p="";r&&(i?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:s?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:d=`vec4 activation(vec4 x) {
           ${r}
         }`,p="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${p}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pRe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);const{dataFormat:r}=t,i=ra(),s=r==="channelsLast",o=s?1:2,a=s?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let u=0;u<=1;u++)for(let h=0;h<=1;h++)c+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${i.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RI(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function FJ({x:n,filter:e,convInfo:t,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=r.texData.get(n.dataId),u=t.inChannels,h=l[0]*l[1]*l[2],f=t.outChannels,d=t.dataFormat==="channelsLast",p=!1,m=!1;let g;const y=[];if(s!=null){const w=RI(s.shape,d);w!=null&&(s=Mt({inputs:{x:s},backend:r,attrs:{shape:w}}),y.push(s))}if(i!=null){const w=RI(i.shape,d);w!=null&&(i=Mt({inputs:{x:i},backend:r,attrs:{shape:w}}),y.push(i))}if(!((h===1||f===1)&&u>AJ)&&c.isPacked&&d&&c.texture!=null&&l[2]%2!==0&&Rn(c.shape.slice(-3),l.slice(-3))){const w=l[0]*l[1]*(l[2]+1),S={dataId:n.dataId,shape:[1,w,t.inChannels],dtype:n.dtype},C=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,U(NI(c.shape,S.shape),()=>`packed reshape ${c.shape} to ${S.shape} isn't free`);const k=Mt({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});y.push(k);const A=$I({a:S,b:k,backend:r,transposeA:p,transposeB:m,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),M=r.texData.get(A.dataId);U(M.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=C,M.shape=t.outShape,g=qa({inputs:{x:A},backend:r}),g.shape=t.outShape,y.push(A)}else{const w=t.outHeight*t.outWidth,S=Mt({inputs:{x:n},backend:r,attrs:{shape:d?[t.batchSize,w,t.inChannels]:[t.batchSize,t.inChannels,w]}}),C=Mt({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),k=$I({a:d?S:C,b:d?C:S,transposeA:!d,transposeB:m,backend:r,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o});g=Mt({inputs:{x:k},backend:r,attrs:{shape:t.outShape}}),y.push(S),y.push(C),y.push(k)}for(const w of y)r.disposeIntermediateTensorInfo(w);return g}function LJ({x:n,filter:e,convInfo:t,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:f,dataFormat:d}=t,p=d==="channelsLast",m=l*c*u,g=f*h,y=[t.batchSize,m,g],b=!0,_=!1,w=[];if(s!=null){const H=RI(s.shape,p);H!=null&&(s=Mt({inputs:{x:s},backend:r,attrs:{shape:H}}),w.push(s))}if(i!=null){const H=RI(i.shape,p);H!=null&&(i=Mt({inputs:{x:i},backend:r,attrs:{shape:H}}),w.push(i))}const S=Mt({inputs:{x:e},backend:r,attrs:{shape:[1,m,Ee(e.shape)/m]}});w.push(S);const C=new pRe(y,t),k=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],A=r.runWebGLProgram(C,[n],"float32",k),M=Mt({inputs:{x:A},backend:r,attrs:{shape:y}});w.push(A),w.push(M);const E=i!=null,N=s!=null,O=a==="leakyrelu",R=a?T_(a,!0):null,D=new IJ(p?M.shape:S.shape,p?S.shape:M.shape,p?[t.batchSize,g,t.outChannels]:[t.batchSize,t.outChannels,g],b,_,E,R,N,O),z=p?[M,S]:[S,M];if(i&&z.push(i),N&&z.push(s),O){const H=r.makeTensorInfo([],"float32",Vf(o,"float32"));z.push(H),w.push(H)}const B=r.runWebGLProgram(D,z,"float32"),X=Mt({inputs:{x:B},backend:r,attrs:{shape:t.outShape}});w.push(B);for(const H of w)r.disposeIntermediateTensorInfo(H);return X}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,h=el(l),f=ti(i.shape,s.shape,o,c,a,u,!1,h);let d;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))d=FJ({x:i,filter:s,convInfo:f,backend:t});else if(f.strideWidth<=2&&h==="channelsLast"&&Ie().getBool("WEBGL_EXP_CONV")){const m=new OJ(f),g=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];d=t.runWebGLProgram(m,[i,s],"float32",g)}else if(Ie().getBool("WEBGL_CONV_IM2COL"))d=LJ({x:i,filter:s,convInfo:f,backend:t});else{const m=new DJ(f);d=t.runWebGLProgram(m,[i,s],"float32")}const p=Mt({inputs:{x:d},backend:t,attrs:{shape:f.outShape}});return t.disposeIntermediateTensorInfo(d),p}const gRe={kernelName:Ov,backendName:"webgl",kernelFunc:mRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let yRe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,i=e.padInfo.top,s=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},bRe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,i=e.strideHeight,s=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=r-1-e.padInfo.left,c=o?1:2,u=o?2:3,h=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},vRe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,r=e.strideHeight,i=e.strideWidth,s=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},wRe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,i=e.filterWidth,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,c=r-1-e.padInfo.top,u=i-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,h=el(l),f=ti(i.shape,u,o,1,a,c,!1,h),d=new yRe(f);return t.runWebGLProgram(d,[i,s],"float32")}const _Re={kernelName:YS,backendName:"webgl",kernelFunc:xRe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SRe{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=To(this.outputShape.length);const t=e.filterHeight,r=e.filterWidth,i=t-1-e.padInfo.top,s=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CRe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,h=el(c),f=ti(o,s.shape,a,1,l,u,!1,h);if(Ie().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const d=[[f.strideHeight,f.strideWidth]],p=new SRe(f);return t.runWebGLProgram(p,[i,s],"float32",d)}else{const d=new bRe(f);return t.runWebGLProgram(d,[i,s],"float32")}}const kRe={kernelName:Fv,backendName:"webgl",kernelFunc:CRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:o,pad:a,dilations:l}=r,c=Fu(i.shape,s.shape,o,l,a),u=new dRe(c);return t.runWebGLProgram(u,[i,s],"float32")}const ERe={kernelName:Lv,backendName:"webgl",kernelFunc:TRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:o,pad:a,filterShape:l}=r,c=Fu(i.shape,l,o,1,a),u=new vRe(c);return t.runWebGLProgram(u,[i,s],"float32")}const ARe={kernelName:ZS,backendName:"webgl",kernelFunc:IRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MRe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{pad:o,strides:a,inputShape:l}=r,c=Fu(l,s.shape,a,1,o),u=new wRe(c);return t.runWebGLProgram(u,[i,s],"float32")}const NRe={kernelName:JS,backendName:"webgl",kernelFunc:MRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Re=Lw+`
  return cos(x);
`,RRe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Vy}
  return result;
`,PRe=mr({opSnippet:$Re,packedOpSnippet:RRe}),DRe={kernelName:Hg,backendName:"webgl",kernelFunc:PRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ORe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,FRe=mr({opSnippet:ORe}),LRe={kernelName:Gg,backendName:"webgl",kernelFunc:FRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zRe=class{constructor(e,t,r,i,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=e,[u]=t,[h,f]=r;this.outputShape=[u,h,f,c];const d=i==="bilinear"?1:0,[p,m]=[`${a-1}.0`,`${l-1}.0`],[g,y,b]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[_,w,S]=f>1?[`${(l-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${_});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${w};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${S};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BRe=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:i,boxes:s,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=r,u=new zRe(i.shape,s.shape,a,l,c);return t.runWebGLProgram(u,[i,s,o],"float32")},VRe={kernelName:e2,backendName:"webgl",kernelFunc:BRe};var I_;(function(n){n.Prod="*",n.Sum="+"})(I_||(I_={}));let EH=class{constructor(e,t,r,i){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,o=this.op===I_.Prod?"1.0":"0.0",a=r?o:`getX(${IH(s,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";r?(c=i?`end != ${l-1}`:"end != 0",u=i?"end + 1":"end - 1"):(c=i?`end + pow2 < ${l}`:"end >= pow2",u=i?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Fr(s)} coords = getOutputCoords();
        int end = ${AH(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${u};
          ${AH(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${IH(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function IH(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function AH(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zJ(n,e,t,r,i,s){const o=e.shape.length,a=Lr([r],o);let l=e;a!=null&&(l=Qo({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=ni(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const u=l.shape[c];let h=qa({inputs:{x:l},backend:t});for(let f=0;f<=Math.ceil(Math.log2(u))-1;f++){const d=new EH(n,l.shape,!1,s),p=[[f]],m=h;h=t.runWebGLProgram(d,[h],h.dtype,p),t.disposeIntermediateTensorInfo(m)}if(i){const f=new EH(n,l.shape,i,s),d=h;h=t.runWebGLProgram(f,[h],h.dtype),t.disposeIntermediateTensorInfo(d)}if(a!=null){const f=Ph(a),d=Qo({inputs:{x:h},backend:t,attrs:{perm:f}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),d}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function URe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,exclusive:o,reverse:a}=r;return zJ(I_.Prod,i,t,s,o,a)}const WRe={kernelName:QS,backendName:"webgl",kernelFunc:URe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,exclusive:o,reverse:a}=r;return zJ(I_.Sum,i,t,s,o,a)}const GRe={kernelName:zv,backendName:"webgl",kernelFunc:HRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,weights:s}=e,{size:o,binaryOutput:a}=r;if(i.shape.length===1){const l=t.readSync(i.dataId),c=t.readSync(s.dataId),u=vJ(l,c,s.dtype,s.shape,o);return t.makeTensorInfo([o],s.dtype,u)}else if(i.shape.length===2){const l=t.bufferSync(i),c=t.bufferSync(s),u=YAe(l,c,o,a);return t.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const qRe={kernelName:t2,backendName:"webgl",kernelFunc:jRe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let XRe=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockSize:s,dataFormat:o}=r,a=i.shape[0],l=o==="NHWC"?i.shape[1]:i.shape[2],c=o==="NHWC"?i.shape[2]:i.shape[3],u=o==="NHWC"?i.shape[3]:i.shape[1],h=l*s,f=c*s,d=u/(s*s),p=o==="NHWC"?[a,h,f,d]:[a,d,h,f],m=new XRe(p,s,o);return t.runWebGLProgram(m,[i],i.dtype)}const YRe={kernelName:n2,backendName:"webgl",kernelFunc:KRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BJ=class{constructor(e,t=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=To(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let c="",u="";r&&(i?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:c=`
          float activation(float x) {
            ${r}
          }
        `,u="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${u}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VJ{constructor(e,t=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=To(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,h=e.filterWidth,f=h;let d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<h;y++)d+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;d+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let y=0;y<h;y++)d+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(f+1)/2;y++){const b=y*2;if(d+=`
          xC = xCCorner + ${b*c};
          `,l===1){if(b<h&&(a%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,c===1&&b>0?d+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<h)){const _=a%2===0?yM(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${_};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,c>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:d+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):_===1?d+=`
                    xC${b+1} = xTexelC${b};
                    `:d+=`
                    xCOffset = xC + ${_};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<h&&(a%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<h&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<h&&(d+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<h&&(d+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<h&&(d+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let p="",m="";r&&(i?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:p=`vec4 activation(vec4 x) {
          ${r}
        }`,m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;let u=l;u==null&&(u=[1,1]),U($s(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const h=ti(i.shape,s.shape,o,u,a,c,!0);let f;Ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?f=new VJ(h):f=new BJ(h);const d=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(f,[i,s],"float32",d)}const JRe={kernelName:Bv,backendName:"webgl",kernelFunc:ZRe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let QRe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,i=e.padInfo.top,s=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},e3e=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,i=e.strideHeight,s=e.strideWidth,o=t-1-e.padInfo.top,a=r-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,h=ti(i.shape,u,o,a,l,c,!0),f=new QRe(h);return t.runWebGLProgram(f,[i,s],"float32")}const n3e={kernelName:r2,backendName:"webgl",kernelFunc:t3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r3e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,h=ti(u,s.shape,o,a,l,c,!0),f=new e3e(h);return t.runWebGLProgram(f,[i,s],"float32")}const i3e={kernelName:i2,backendName:"webgl",kernelFunc:r3e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let s3e=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o3e(n){const{inputs:e,backend:t}=n,{x:r}=e,i=[...r.shape,...r.shape],s=Ee(r.shape),o=Mt({inputs:{x:r},backend:t,attrs:{shape:[s]}}),a=new s3e(s),l=t.runWebGLProgram(a,[o],o.dtype),c=Mt({inputs:{x:l},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const a3e={kernelName:s2,backendName:"webgl",kernelFunc:o3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let l3e=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:r,padInfo:i,strideHeight:s,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=e,{top:h,left:f}=i;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${o});
      const ivec2 pads = ivec2(${h}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:o,pad:a,dilations:l}=r,c=kp(i.shape,s.shape,o,a,"NHWC",l);let u;const h=new l3e(c);u=t.runWebGLProgram(h,[i,s],"float32");const f=Mt({inputs:{x:u},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(u),f}const u3e={kernelName:Vv,backendName:"webgl",kernelFunc:c3e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h3e(n){const{inputs:e,backend:t,attrs:r}=n,{equation:i}=r,s=e,{allDims:o,summedDims:a,idDims:l}=wN(i,s.length);_N(o.length,l,s);const{path:c,steps:u}=SN(a,l),h=u.length;let f=null,d=o.length;const p=[];for(let m=0;m<h;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=xN(d,l[g]);let _;CN(y)?_=s[g]:(_=Qo({inputs:{x:s[g]},backend:t,attrs:{perm:y}}),p.push(_));const w=_.shape.slice();for(let S=0;S<b.length;++S)w.splice(b[S],0,1);Rn(_.shape,w)||(_=Mt({inputs:{x:_},backend:t,attrs:{shape:w}}),p.push(_)),f===null?f=_:(f=lB({inputs:{a:_,b:f},backend:t}),p.push(f))}m<h-1&&(c[m]>=0&&(f=$N({inputs:{x:f},backend:t,attrs:{axis:c[m]-(o.length-d),keepDims:!1}}),p.push(f)),d--)}for(const m of p)m!==f&&t.disposeIntermediateTensorInfo(m);return f}const f3e={kernelName:a2,backendName:"webgl",kernelFunc:h3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d3e="return (x >= 0.0) ? x : (exp(x) - 1.0);",p3e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,m3e=mr({opSnippet:d3e,packedOpSnippet:p3e}),g3e={kernelName:qg,backendName:"webgl",kernelFunc:m3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y3e="return (b >= 0.0) ? a : a * (b + 1.0);",b3e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,v3e=n=>{const{inputs:e,backend:t}=n,{dy:r,y:i}=e,s=Ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fw(b3e,r.shape,i.shape):new ug(y3e,r.shape,i.shape);return t.runWebGLProgram(s,[r,i],r.dtype)},w3e={kernelName:l2,backendName:"webgl",kernelFunc:v3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x3e=`
  return vec4(equal(a, b));
`,_3e="return float(a == b);",S3e=uo({opSnippet:_3e,packedOpSnippet:x3e,dtype:"bool",cpuKernelImpl:tMe}),C3e={kernelName:Uv,backendName:"webgl",kernelFunc:S3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k3e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${pN};
  float a1 = ${mN};
  float a2 = ${gN};
  float a3 = ${yN};
  float a4 = ${bN};
  float a5 = ${vN};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,T3e=mr({opSnippet:k3e}),E3e={kernelName:Xg,backendName:"webgl",kernelFunc:T3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I3e=Lw+`
  return exp(x);
`,A3e=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,UJ=mr({opSnippet:I3e,packedOpSnippet:A3e,cpuKernelImpl:nMe,dtype:"float32"}),M3e={kernelName:Kg,backendName:"webgl",kernelFunc:UJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MD(n){const{inputs:e,attrs:t,backend:r}=n,{dim:i}=t,{input:s}=e,o=s.shape.length,a=s.shape.slice();let l=i;return i<0&&(U(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),Mt({inputs:{x:s},backend:r,attrs:{shape:a}})}const N3e={kernelName:Wv,backendName:"webgl",kernelFunc:MD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MH="return exp(x) - 1.0;",$3e=mr({opSnippet:MH,packedOpSnippet:MH,cpuKernelImpl:rMe}),R3e={kernelName:Yg,backendName:"webgl",kernelFunc:$3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let NH=class{constructor(e,t,r){this.variableNames=["real","imag"];const i=t[1];this.outputShape=t;const s=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${i}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WJ(n,e,t){const r=t.texData.get(n.dataId),i=Ee(n.shape),s=n.shape[n.shape.length-1],o=i/s,a=Mt({inputs:{x:n},backend:t,attrs:{shape:[o,s]}}),l=a.shape,c=new NH("real",l,e),u=new NH("imag",l,e),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],f=t.runWebGLProgram(c,h,"float32"),d=t.runWebGLProgram(u,h,"float32"),p=Ap({inputs:{real:f,imag:d},backend:t});t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d);const m=Mt({inputs:{x:p},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(p),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P3e(n){const{inputs:e,backend:t}=n,{input:r}=e;return WJ(r,!1,t)}const D3e={kernelName:c2,backendName:"webgl",kernelFunc:P3e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let O3e=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pC(n){const{backend:e,attrs:t}=n,{shape:r,value:i}=t;let{dtype:s}=t;if(s=s||xp(i),s==="string"){const o=Si(s,Ee(r));return o.fill(i),e.makeTensorInfo(r,s,o)}else{const o=new O3e(r,i),a=[[i]];return e.runWebGLProgram(o,[],s,a)}}const F3e={kernelName:u2,backendName:"webgl",kernelFunc:pC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let L3e=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z3e={kernelName:h2,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,i=new L3e(t.shape);return r.runWebGLProgram(i,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $H="return floor(x);",B3e=mr({opSnippet:$H,packedOpSnippet:$H,cpuKernelImpl:iMe}),V3e={kernelName:Zg,backendName:"webgl",kernelFunc:B3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U3e=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,W3e=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,H3e=uo({opSnippet:U3e,packedOpSnippet:W3e,dtype:"int32"}),G3e={kernelName:Jg,backendName:"webgl",kernelFunc:H3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let j3e=class{constructor(e){this.variableNames=["A"];const t=ra(),[r,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q3e{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=ra(),[r,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X3e={kernelName:p_,backendName:"webgl",kernelFunc:K3e};let E0,u3=Ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function K3e(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:i}=e;const{numChannels:s}=r,o=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[l,c]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],u=[c,l],h=[c,l,s];if(a||o){const m=Ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(E0==null||m!==u3)&&(u3=m,E0=document.createElement("canvas").getContext("2d",{willReadFrequently:u3})),E0.canvas.width=l,E0.canvas.height=c,E0.drawImage(i,0,0,l,c),i=E0.canvas}const f=t.makeTensorInfo(u,"int32");t.texData.get(f.dataId).usage=Cl.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(f.dataId),i);const d=Ie().getBool("WEBGL_PACK")?new q3e(h):new j3e(h),p=t.runWebGLProgram(d,[f],"int32");return t.disposeData(f.dataId),p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r,m=el(u),g=ti(i.shape,s.shape,l,h,c,f,!1,m);let y;const b=[],_=o!=null,w=a!=null,S=d==="leakyrelu",C=()=>{const A=[i,s],M=(E,N)=>{if(N==="NCHW"&&E.shape.length===1&&E.shape[0]!==1){const O=Mt({inputs:{x:E},backend:t,attrs:{shape:[E.shape[0],1,1]}});return b.push(O),O}return E};if(_&&A.push(M(o,u)),w&&A.push(M(a,u)),S){const E=t.makeTensorInfo([],"float32",Vf(p,"float32"));A.push(E),b.push(E)}return A};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=FJ({x:i,filter:s,convInfo:g,backend:t,bias:o,activation:d,preluActivationWeights:a,leakyreluAlpha:p});else if(g.strideWidth<=2&&m==="channelsLast"&&Ie().getBool("WEBGL_EXP_CONV")){const A=d?T_(d,!0):null,M=new OJ(g,_,A,w,S),E=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=C();y=t.runWebGLProgram(M,N,"float32",E)}else if(Ie().getBool("WEBGL_CONV_IM2COL"))y=LJ({x:i,filter:s,convInfo:g,backend:t,bias:o,activation:d,preluActivationWeights:a,leakyreluAlpha:p});else{const A=d?T_(d,!1):null,M=new DJ(g,_,A,w,S),E=C();y=t.runWebGLProgram(M,E,"float32")}const k=Mt({inputs:{x:y},backend:t,attrs:{shape:g.outShape}});return b.push(y),b.forEach(A=>t.disposeIntermediateTensorInfo(A)),k}const Z3e={kernelName:Ub,backendName:"webgl",kernelFunc:Y3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:f,leakyreluAlpha:d}=r,p=[];let m=u;m==null&&(m=[1,1]),U($s(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=ti(i.shape,s.shape,l,m,c,h,!0),y=Ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=f?T_(f,y):null,_=[i,s],w=o!=null,S=a!=null,C=f==="leakyrelu";if(w&&_.push(o),S&&_.push(a),C){const E=t.makeTensorInfo([],"float32",Vf(d,"float32"));_.push(E),p.push(E)}let k;y?k=new VJ(g,w,b,S,C):k=new BJ(g,w,b,S,C);const A=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],M=t.runWebGLProgram(k,_,"float32",A);return p.forEach(E=>t.disposeIntermediateTensorInfo(E)),M}const Q3e={kernelName:Wb,backendName:"webgl",kernelFunc:J3e};let ePe=class{constructor(e,t,r,i){this.sliceDim=e,this.strides=t,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=r;const s=Fr(r.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tPe(n){const{inputs:e,backend:t}=n,{params:r,indices:i}=e,s=i.shape,o=s[s.length-1],a=Ee(r.shape),[l,c,u,h]=sC(r,i),f=Mt({inputs:{x:i},backend:t,attrs:{shape:[c,o]}}),d=Mt({inputs:{x:r},backend:t,attrs:{shape:[Ee(r.shape)/u,u]}});if(t.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const y=t.readSync(i.dataId),b=t.bufferSync(r),_=sMe(y,b,r.dtype,c,o,u,h,r.shape,a);return t.makeTensorInfo(l,r.dtype,_.values)}const p=new ePe(o,h,[c,u],r.shape),m=t.runWebGLProgram(p,[d,f],d.dtype),g=Mt({inputs:{x:m},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(m),g}const nPe={kernelName:f2,backendName:"webgl",kernelFunc:tPe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rPe=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const r=Fr(this.rank),i=iPe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `}};function iPe(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<n.length;i++)i===2?r.push("index"):r.push(`${t[i]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,indices:s}=e,{axis:o,batchDims:a}=r,l=An(o,i.shape)[0];if(Ie().get("DEBUG")){const b=t.readSync(s.dataId),_=i.shape[l];for(let w=0;w<b.length;++w){const S=b[w];U(S<=_-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${_-1}]`)}}const c=TN(i,s,l,a),u=Ee(s.shape),h=[],f=Mt({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=Mt({inputs:{x:s},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(f),h.push(d);const p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([i,s])||i.dtype==="string"){const b=t.bufferSync(d),_=t.bufferSync(f),w=oMe(_,b,p);return h.forEach(S=>t.disposeIntermediateTensorInfo(S)),t.makeTensorInfo(c.outputShape,w.dtype,w.values)}const m=new rPe(f.shape,p),g=t.runWebGLProgram(m,[f,d],f.dtype);h.push(g);const y=Mt({inputs:{x:g},backend:t,attrs:{shape:c.outputShape}});return h.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const sPe={kernelName:Gv,backendName:"webgl",kernelFunc:HJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oPe="return float(a > b);",aPe=`
  return vec4(greaterThan(a, b));
`,lPe=uo({opSnippet:oPe,packedOpSnippet:aPe,cpuKernelImpl:aMe,dtype:"bool"}),cPe={kernelName:jv,backendName:"webgl",kernelFunc:lPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uPe="return float(a >= b);",hPe=`
  return vec4(greaterThanEqual(a, b));
`,fPe=uo({opSnippet:uPe,packedOpSnippet:hPe,dtype:"bool",cpuKernelImpl:lMe}),dPe={kernelName:Qg,backendName:"webgl",kernelFunc:fPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pPe(n){const{inputs:e,backend:t}=n,{input:r}=e;return WJ(r,!0,t)}const mPe={kernelName:d2,backendName:"webgl",kernelFunc:pPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gPe="return float(!isnan(x) && !isinf(x));",yPe=mr({opSnippet:gPe,dtype:"bool"}),bPe={kernelName:ty,backendName:"webgl",kernelFunc:yPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vPe="return float(isinf(x));",wPe=mr({opSnippet:vPe,dtype:"bool"}),xPe={kernelName:ny,backendName:"webgl",kernelFunc:wPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Pe="return float(isnan(x));",SPe=mr({opSnippet:_Pe,dtype:"bool"}),CPe={kernelName:ry,backendName:"webgl",kernelFunc:SPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kPe="return float(a < b);",TPe=`
  return vec4(lessThan(a, b));
`,EPe=uo({opSnippet:kPe,packedOpSnippet:TPe,cpuKernelImpl:cMe,dtype:"bool"}),IPe={kernelName:Xv,backendName:"webgl",kernelFunc:EPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const APe="return float(a <= b);",MPe=`
  return vec4(lessThanEqual(a, b));
`,NPe=uo({opSnippet:APe,packedOpSnippet:MPe,cpuKernelImpl:uMe,dtype:"bool"}),$Pe={kernelName:Kv,backendName:"webgl",kernelFunc:NPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RPe(n){const{backend:e,attrs:t}=n,{start:r,stop:i,num:s}=t,o=hMe(r,i,s);return e.makeTensorInfo([o.length],"float32",o)}const PPe={kernelName:m2,backendName:"webgl",kernelFunc:RPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DPe=Lw+`
  return x < 0.0 ? 0./0. : log(x);
`,OPe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,FPe=mr({opSnippet:DPe,packedOpSnippet:OPe,cpuKernelImpl:fMe}),LPe={kernelName:iy,backendName:"webgl",kernelFunc:FPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zPe=Lw+`
  return log(1.0 + x);
`,BPe=mr({opSnippet:zPe}),VPe={kernelName:sy,backendName:"webgl",kernelFunc:BPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UPe="return float(a >= 1.0 && b >= 1.0);",WPe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,HPe=uo({opSnippet:UPe,packedOpSnippet:WPe,dtype:"bool"}),GPe={kernelName:Yv,backendName:"webgl",kernelFunc:HPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jPe="return float(!(x >= 1.0));",qPe=mr({opSnippet:jPe}),XPe={kernelName:Zv,backendName:"webgl",kernelFunc:qPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KPe="return float(a >= 1.0 || b >= 1.0);",YPe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,ZPe=uo({opSnippet:KPe,packedOpSnippet:YPe,dtype:"bool"}),JPe={kernelName:Jv,backendName:"webgl",kernelFunc:ZPe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let QPe=class{constructor(e,t,r,i,s){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${i}) * sum`;s===.5?l=`inversesqrt(${c})`:s===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eDe{constructor(e,t,r,i,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${i}) * sum`;s===.5?l=`inversesqrt(${c})`:s===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tDe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{depthRadius:s,bias:o,alpha:a,beta:l}=r,c=Ie().getBool("WEBGL_PACK_NORMALIZATION")?new eDe(i.shape,s,o,a,l):new QPe(i.shape,s,o,a,l);return t.runWebGLProgram(c,[i],i.dtype)},nDe={kernelName:Qv,backendName:"webgl",kernelFunc:tDe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rDe=class{constructor(e,t,r,i,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=i,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iDe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:i,y:s,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=r,h=new rDe(i.shape,a,l,c,u);return t.runWebGLProgram(h,[i,s,o],i.dtype)},sDe={kernelName:g2,backendName:"webgl",kernelFunc:iDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oDe(n,e,t,r){const i=Ee(e),o=Ee(n.shape)/i,a=Mt({inputs:{x:n},attrs:{shape:[o,i]},backend:r}),l=Uy(a,n.dtype,"max",r),c=Mt({inputs:{x:l},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{reductionIndices:s,keepDims:o}=r,a=i.shape.length,l=An(s,i.shape);let c=l;const u=Lr(c,a),h=u!=null,f=t.shouldExecuteOnCPU([i]);let d=i;if(h){if(f){const _=t.texData.get(d.dataId).values,w=new Array(a);for(let k=0;k<w.length;k++)w[k]=i.shape[u[k]];const S=oB(_,i.shape,i.dtype,u,w);d=t.makeTensorInfo(w,i.dtype);const C=t.texData.get(d.dataId);C.values=S}else d=NN(i,u,t);c=ni(c.length,a)}hs("max",c,a);const[p,m]=Ji(d.shape,c);let g=p;o&&(g=Fi(p,l));let y;if(f){const _=t.texData.get(d.dataId).values,w=dMe(_,Ee(m),g,i.dtype);y=t.makeTensorInfo(g,i.dtype);const S=t.texData.get(y.dataId);S.values=w}else y=oDe(d,m,g,t);return h&&t.disposeIntermediateTensorInfo(d),y}const aDe={kernelName:ew,backendName:"webgl",kernelFunc:GJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lDe=aB+`
  return max(a, b);
`,cDe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vy+`
  return result;
`,uDe=uo({opSnippet:lDe,packedOpSnippet:cDe,cpuKernelImpl:pMe}),hDe={kernelName:oy,backendName:"webgl",kernelFunc:uDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fDe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e;hC(i,"maxPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U($s(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ko(i.shape,s,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&Rn(u.inShape,u.outShape))return qa({inputs:{x:i},backend:t});const h=new E_(u,"max",!1);return t.runWebGLProgram(h,[i],i.dtype)}const dDe={kernelName:tw,backendName:"webgl",kernelFunc:fDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pDe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{filterSize:s,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],h=Ll(i.shape,s,o,u,a,c,l),f=new cB(h,"max",!1);return t.runWebGLProgram(f,[i],i.dtype)}const mDe={kernelName:nw,backendName:"webgl",kernelFunc:pDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gDe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,r=e.strideWidth,i=e.dilationHeight,s=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=s-1-e.padInfo.top,l=o-1-e.padInfo.left,c=s*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},yDe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,r=e.strideHeight,i=e.strideWidth,s=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,h=l-1-e.padInfo.front,f=c-1-e.padInfo.top,d=u-1-e.padInfo.left,p=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${f}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bDe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=[1,1,1],f=Ll(o.shape,a,l,h,c,u),d=new cB(f,"max",!0),p=t.runWebGLProgram(d,[o],o.dtype),m=new yDe(f),g=t.runWebGLProgram(m,[i,p],o.dtype);return t.disposeIntermediateTensorInfo(p),g}const vDe={kernelName:b2,backendName:"webgl",kernelFunc:bDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wDe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s,output:o}=e,a=s;hC([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,f=ko(a.shape,l,c,1,u,h),d=!0,p=new E_(f,"max",d),m=t.runWebGLProgram(p,[a],a.dtype),g=new gDe(f),y=t.runWebGLProgram(g,[i,m],a.dtype);return t.disposeIntermediateTensorInfo(m),y}const xDe={kernelName:y2,backendName:"webgl",kernelFunc:wDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _De(n,e,t,r){let i=new E_(t,"max",!1);const s=r.runWebGLProgram(i,[n],"float32");i=new E_(t,"max",!0,!0,e);const o=r.runWebGLProgram(i,[n],"float32");return[s,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SDe={kernelName:v2,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:i,strides:s,pad:o,includeBatchInIndex:a}=e,l=t;U(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];U($s(s,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`);const u=ko(r.shape,i,s,c,o),[h,f]=_De(r,a,u,l);return[h,f]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CDe(n,e,t,r){const i=Ee(e),o=Ee(n.shape)/i,a=Mt({inputs:{x:n},attrs:{shape:[o,i]},backend:r}),l=Uy(a,"float32","mean",r),c=Mt({inputs:{x:l},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kDe={kernelName:rw,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{keepDims:i,axis:s}=e,o=t,a=r.shape.length,l=An(s,r.shape);let c=l;const u=Lr(c,a),h=u!=null,f=o.shouldExecuteOnCPU([r]),d=[];let p=r;if(h){if(f){const w=o.texData.get(p.dataId).values,S=new Array(a);for(let A=0;A<S.length;A++)S[A]=r.shape[u[A]];const C=oB(w,r.shape,r.dtype,u,S);p=o.makeTensorInfo(S,r.dtype);const k=o.texData.get(p.dataId);k.values=C}else p=NN(r,u,o);d.push(p),c=ni(c.length,a)}hs("sum",c,a);const[m,g]=Ji(p.shape,c);let y=m;i&&(y=Fi(m,l));const b=CDe(p,g,y,o);for(const _ of d)o.disposeIntermediateTensorInfo(_);return b}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TDe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:o}=r,a=i.shape.length,l=An(s,i.shape);let c=l;const u=Lr(c,a);let h=i;u!=null&&(h=Qo({inputs:{x:i},backend:t,attrs:{perm:u}}),c=ni(c.length,i.shape.length)),hs("min",c,a);const[f,d]=Ji(h.shape,c),p=Ee(d),m=Mt({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),g=Uy(m,m.dtype,"min",t);let y;if(o){const b=Fi(f,l);y=Mt({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=Mt({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(h),y}const EDe={kernelName:iw,backendName:"webgl",kernelFunc:TDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IDe=aB+`
  return min(a, b);
`,ADe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vy+`
  return result;
`,MDe=uo({opSnippet:IDe,packedOpSnippet:ADe,cpuKernelImpl:mMe}),NDe={kernelName:ay,backendName:"webgl",kernelFunc:MDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $De=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((u,h)=>u[0]+e[h]+u[1]);const i=e.length,s=Fr(i),o=t.map(u=>u[0]).join(","),a=t.map((u,h)=>u[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),c=r==="reflect"?0:1;if(i===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${o});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RDe{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((p,m)=>p[0]+e[m]+p[1]);const i=e.length,s=Fr(i),o=t.map(p=>p[0]).join(","),a=t.map((p,m)=>p[0]+e[m]).join(","),l=Go("rc",i),c=Go("source",i),u=`${l[i-1]} < ${this.outputShape[i-1]}`,h=i===1?"source":`vec2(${c.slice(-2).join()})`,f=r==="reflect"?0:1;let d="";if(i===1){const p=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[i-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
      `}else{const p=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[i-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
        rc = outputLoc;
        ${l[i-2]} += 1;
        if(${l[i-2]} < ${this.outputShape[i-2]}) {
          ${p}
          result[2] = getChannel(getX(${c.join()}), ${h});
          ${l[i-1]} += 1;
          if(${u}) {
            ${p}
            result[3] = getChannel(getX(${c.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${o});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PDe=({inputs:n,backend:e,attrs:t})=>{const{x:r}=n,{paddings:i,mode:s}=t,o=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new RDe(r.shape,i,s):new $De(r.shape,i,s);return e.runWebGLProgram(o,[r],r.dtype)},DDe={kernelName:sw,backendName:"webgl",kernelFunc:PDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ODe=`if (b == 0.0) return NAN;
  return mod(a, b);`,FDe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Vy+`
  return result;
`,LDe=uo({opSnippet:ODe,packedOpSnippet:FDe}),zDe={kernelName:ly,backendName:"webgl",kernelFunc:LDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BDe=class{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VDe=`
if (a == b) {
  return 1.0;
};
return a / b;`,UDe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,jJ=uo({opSnippet:VDe,packedOpSnippet:UDe,checkOutOfBounds:!0}),WDe={kernelName:jg,backendName:"webgl",kernelFunc:jJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RH="return a - b;",qJ=uo({opSnippet:RH,packedOpSnippet:RH,supportsComplex:!0,cpuKernelImpl:OMe}),HDe={kernelName:Cy,backendName:"webgl",kernelFunc:qJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XJ(n){const{inputs:e,backend:t,attrs:r}=n,{logits:i}=e,{dim:s}=r,o=An([s],i.shape),a=GJ({inputs:{x:i},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),l=Fi(a.shape,o),c=Mt({inputs:{x:a},backend:t,attrs:{shape:l}}),u=qJ({inputs:{a:i,b:c},backend:t}),h=UJ({inputs:{x:u},backend:t}),f=$N({inputs:{x:h},backend:t,attrs:{axis:o,keepDims:!1}}),d=Mt({inputs:{x:f},backend:t,attrs:{shape:l}}),p=jJ({inputs:{a:h,b:d},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),p}const GDe={kernelName:Sw,backendName:"webgl",kernelFunc:XJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jDe(n){const{inputs:e,backend:t,attrs:r}=n,{logits:i}=e,{numSamples:s,seed:o,normalized:a}=r,l=a?i:XJ({inputs:{logits:i},backend:t,attrs:{dim:i.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new BDe(c,u,s),f=[[o]],d=t.runWebGLProgram(h,[l],"int32",f);return a||t.disposeIntermediateTensorInfo(l),d}const qDe={kernelName:w2,backendName:"webgl",kernelFunc:jDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XDe=Pc+`
  return -x;
`,KDe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function YDe(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const s=t.texData.get(r.dataId),[o,a]=yMe(s.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,o)}let i;return Ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Ed(r.shape,KDe):i=new fh(r.shape,XDe),t.runWebGLProgram(i,[r],r.dtype)}const ZDe={kernelName:ow,backendName:"webgl",kernelFunc:YDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JDe=tC;function QDe(n){xl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:i,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,c=t.readSync(i.dataId),u=t.readSync(s.dataId),{selectedIndices:h}=JDe(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const eOe={kernelName:x2,backendName:"webgl",kernelFunc:QDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tOe=rN;function nOe(n){xl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:i,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r,u=t.readSync(i.dataId),h=t.readSync(s.dataId),{selectedIndices:f,validOutputs:d}=tOe(u,h,o,a,l,c);return[t.makeTensorInfo([f.length],"int32",new Int32Array(f)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}const rOe={kernelName:xM,backendName:"webgl",kernelFunc:nOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iOe=nC;function sOe(n){xl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:i,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=t.readSync(i.dataId),h=t.readSync(s.dataId),f=o,d=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=iOe(u,h,f,d,p,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const oOe={kernelName:_2,backendName:"webgl",kernelFunc:sOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let aOe=class{constructor(e,t,r,i){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${r}),
                      float(index == coords.y)));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lOe=n=>{const{inputs:e,backend:t,attrs:r}=n,{indices:i}=e,{dtype:s,depth:o,onValue:a,offValue:l}=r,c=Ee(i.shape),u=new aOe(c,o,a,l),h=Mt({inputs:{x:i},backend:t,attrs:{shape:[c]}}),f=t.runWebGLProgram(u,[h],s);t.disposeIntermediateTensorInfo(h);const d=[...i.shape,o],p=Mt({inputs:{x:f},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(f),p},cOe={kernelName:cw,backendName:"webgl",kernelFunc:lOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PI(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const i=dC({inputs:{input:r},backend:t}),s=PI({inputs:{x:i},backend:t}),o=RN({inputs:{input:r},backend:t}),a=PI({inputs:{x:o},backend:t}),l=Ap({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return pC({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const uOe={kernelName:Tw,backendName:"webgl",kernelFunc:PI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KJ(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const i=dC({inputs:{input:r},backend:t}),s=KJ({inputs:{x:i},backend:t}),o=RN({inputs:{input:r},backend:t}),a=PI({inputs:{x:o},backend:t}),l=Ap({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return pC({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const hOe={kernelName:lw,backendName:"webgl",kernelFunc:KJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fOe(n){const{inputs:e,backend:t,attrs:r}=n,{axis:i}=r;if(e.length===1)return MD({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const s=e[0].shape,o=e[0].dtype;e.forEach(u=>{qs(s,u.shape,"All tensors passed to stack must have matching shapes"),U(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=MD({inputs:{input:u},backend:t,attrs:{dim:i}});return a.push(h),h}),c=PJ({inputs:l,backend:t,attrs:{axis:i}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const dOe={kernelName:uw,backendName:"webgl",kernelFunc:fOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pOe=class{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,u)=>c[0]+e[u]+c[1]);const i=e.length,s=Fr(i),o=t.map(c=>c[0]).join(","),a=t.map((c,u)=>c[0]+e[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);if(i===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${o});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mOe{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((m,g)=>m[0]+e[g]+m[1]);const i=e.length,s=Fr(i),o=t.map(m=>m[0]).join(","),a=t.map((m,g)=>m[0]+e[g]).join(","),l=Go("rc",i),c=Go("source",i),u=`${l[i-1]} < ${this.outputShape[i-1]}`,h=i===1?"source":`vec2(${c.slice(-2).join()})`,f=[`${s} rc = outputLoc;`,`${l[i-1]} += 1;
       if(${u}) {
      `,i===1?"":`}
       rc = outputLoc;
       ${l[i-2]} += 1;
       if(${l[i-2]} < ${this.outputShape[i-2]}) {`,i===1?"":`  ${l[i-1]} += 1;
         if(${u}) {`],d=i===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let m=0,g=i===1?2:4;m<g;m++)p+=`
        ${f[m]}
        if (${d}) {
          result[${m}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${m}] = getChannel(getX(${c.join()}), ${h});
        }
      `;p+=i===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${o});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YJ=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{paddings:s,constantValue:o}=r;if(Ee(i.shape)===0){const c=s.map((u,h)=>u[0]+i.shape[h]+u[1]);return pC({backend:t,attrs:{shape:c,value:o,dtype:i.dtype}})}const a=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mOe(i.shape,s,o):new pOe(i.shape,s,o),l=[[o]];return t.runWebGLProgram(a,[i],i.dtype,l)},gOe={kernelName:hw,backendName:"webgl",kernelFunc:YJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yOe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,bOe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Vy+`
  return result;
`,vOe=uo({opSnippet:yOe,packedOpSnippet:bOe}),wOe={kernelName:uy,backendName:"webgl",kernelFunc:vOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xOe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:o}=r,a=i.shape.length,l=[],c=An(s,i.shape);let u=c;const h=Lr(u,a);let f=i;h!=null&&(f=Qo({inputs:{x:i},backend:t,attrs:{perm:h}}),u=ni(u.length,a),l.push(f)),hs("prod",u,a);let d;if(t.shouldExecuteOnCPU([f])){const p=t.texData.get(f.dataId).values,{outVals:m,outShape:g,outDtype:y}=vMe(f.shape,f.dtype,p,u);d=t.makeTensorInfo(g,y,m)}else{const[p,m]=Ji(f.shape,u),g=Ee(m),y=Mt({inputs:{x:f},backend:t,attrs:{shape:[-1,g]}}),b=U2(i.dtype),_=Uy(y,b,"prod",t);d=Mt({inputs:{x:_},backend:t,attrs:{shape:p}}),l.push(y),l.push(_)}if(o){l.push(d);const p=Fi(d.shape,c);d=Mt({inputs:{x:d},backend:t,attrs:{shape:p}})}return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const _Oe={kernelName:dw,backendName:"webgl",kernelFunc:xOe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SOe(n){const{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:i,paramsDenseValues:s,indices:o}=e,{outputRaggedRank:a}=r,l=i.map(y=>t.readSync(y.dataId)),c=i.map(y=>y.shape),u=t.readSync(s.dataId),h=t.readSync(o.dataId),[f,d,p]=wMe(l,c,u,s.shape,s.dtype,h,o.shape,a),m=f.map(y=>t.makeTensorInfo([y.length],"int32",y)),g=t.makeTensorInfo(p,s.dtype,d);return m.concat([g])}const COe={kernelName:_M,backendName:"webgl",kernelFunc:SOe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kOe(n){const{inputs:e,backend:t}=n,{starts:r,limits:i,deltas:s}=e,o=t.readSync(r.dataId),a=t.readSync(i.dataId),l=t.readSync(s.dataId),[c,u]=xMe(o,r.shape,r.dtype,a,i.shape,l,s.shape),h=t.makeTensorInfo([c.length],"int32",c),f=t.makeTensorInfo([u.length],r.dtype,u);return[h,f]}const TOe={kernelName:SM,backendName:"webgl",kernelFunc:kOe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EOe(n){const{inputs:e,backend:t,attrs:r}=n,{shape:i,values:s,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,c=t.readSync(i.dataId),u=t.readSync(s.dataId),h=t.readSync(o.dataId),f=a.map(g=>t.readSync(g.dataId)),d=a.map(g=>g.shape),[p,m]=_Me(c,i.shape,u,s.shape,s.dtype,h,o.shape,f,d,l);return t.makeTensorInfo(p,s.dtype,m)}const IOe={kernelName:CM,backendName:"webgl",kernelFunc:EOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZJ=n=>{const{backend:e,attrs:t}=n,{start:r,stop:i,step:s,dtype:o}=t,a=SMe(r,i,s,o);return e.makeTensorInfo([a.length],o,a)},AOe={kernelName:S2,backendName:"webgl",kernelFunc:ZJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MOe="return 1.0 / x;",NOe=mr({opSnippet:MOe}),$Oe={kernelName:hy,backendName:"webgl",kernelFunc:NOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ROe=Pc+`
  return (x < 0.0) ? 0.0 : x;
`,POe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,DOe=mr({opSnippet:ROe,packedOpSnippet:POe}),OOe={kernelName:fy,backendName:"webgl",kernelFunc:DOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FOe=Pc+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,LOe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,zOe=mr({opSnippet:FOe,packedOpSnippet:LOe}),BOe={kernelName:dy,backendName:"webgl",kernelFunc:zOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let VOe=class{constructor(e,t,r,i,s){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[i&&t>1?a-1:a,i&&r>1?l-1:l],h=[i&&t>1?t-1:t,i&&r>1?r-1:r];let f;s?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UOe{constructor(e,t,r,i,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[i&&t>1?a-1:a,i&&r>1?l-1:l],h=[i&&t>1?t-1:t,i&&r>1?r-1:r];let f;s?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WOe(n){const{inputs:e,backend:t,attrs:r}=n,{images:i}=e,{alignCorners:s,halfPixelCenters:o,size:a}=r,[l,c]=a,u=Ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new UOe(i.shape,l,c,s,o):new VOe(i.shape,l,c,s,o);return t.runWebGLProgram(u,[i],"float32")}const HOe={kernelName:gw,backendName:"webgl",kernelFunc:WOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let GOe=class{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,s]=t,[,o,a]=e,l=[r&&o>1?i-1:i,r&&a>1?s-1:s],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],f=1/u,d=1/h,p=Math.ceil(f)*2+2,m=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jOe(n){const{inputs:e,backend:t,attrs:r}=n,{images:i,dy:s}=e,{alignCorners:o}=r,a=new GOe(s.shape,i.shape,o);return t.runWebGLProgram(a,[s],s.dtype)}const qOe={kernelName:T2,backendName:"webgl",kernelFunc:jOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let XOe=class{constructor(e,t,r,i,s){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[i&&t>1?a-1:a,i&&r>1?l-1:l],h=[i&&t>1?t-1:t,i&&r>1?r-1:r],f=i?"0.5":"0.0";let d;s?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KOe{constructor(e,t,r,i,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[i&&t>1?a-1:a,i&&r>1?l-1:l],h=[i&&t>1?t-1:t,i&&r>1?r-1:r],f=i?"0.5":"0.0";let d;s?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YOe(n){const{inputs:e,backend:t,attrs:r}=n,{images:i}=e,{alignCorners:s,halfPixelCenters:o,size:a}=r,[l,c]=a,u=Ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new KOe(i.shape,l,c,s,o):new XOe(i.shape,l,c,s,o);return t.runWebGLProgram(u,[i],i.dtype)}const ZOe={kernelName:mw,backendName:"webgl",kernelFunc:YOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let JOe=class{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,s]=t,[,o,a]=e,l=[r&&o>1?i-1:i,r&&a>1?s-1:s],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],f=1/u,d=1/h,p=Math.ceil(f)*2+2,m=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QOe(n){const{inputs:e,backend:t,attrs:r}=n,{images:i,dy:s}=e,{alignCorners:o}=r,a=new JOe(s.shape,i.shape,o);return t.runWebGLProgram(a,[s],s.dtype)}const eFe={kernelName:k2,backendName:"webgl",kernelFunc:QOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tFe=class{constructor(e,t){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const i=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,s=e.map((a,l)=>i(l)).join(","),o=Fr(r);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nFe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const i=Go("rc",r),s=`${i[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${i[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Fr(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(i.slice())};
          if(${s}){
            result.g = ${c(i.slice())};
          }
          if(${o}) {
            result.b = ${u(i.slice())};
            if(${s}) {
              result.a = ${h(i.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(p){return f(p)}function c(p){return p[r-1]="("+p[r-1]+" + 1)",f(p)}function u(p){return p[r-2]="("+p[r-2]+" + 1)",f(p)}function h(p){return p[r-1]="("+p[r-1]+" + 1)",p[r-2]="("+p[r-2]+" + 1)",f(p)}function f(p){const m=e.map((b,_)=>d(_,p)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function d(p,m){return t.indexOf(p)!==-1&&e[p]!==1?`${e[p]} - ${m[p]} - 1`:`${m[p]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rFe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{dims:s}=r,o=i.shape.length,a=An(s,i.shape);if(o===0)return qa({inputs:{x:i},backend:t});const l=Ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new nFe(i.shape,a):new tFe(i.shape,a);return t.runWebGLProgram(l,[i],i.dtype)}const iFe={kernelName:yw,backendName:"webgl",kernelFunc:rFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sFe=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],i=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oFe={kernelName:z2,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:i,fillValue:s,center:o}=e,a=t,l=new sFe(r.shape,s),[c,u]=hN(o,r.shape[1],r.shape[2]),h=[[c,u,Math.sin(i),Math.cos(i)]];return a.runWebGLProgram(l,[r],r.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aFe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,lFe=mr({opSnippet:aFe}),cFe={kernelName:py,backendName:"webgl",kernelFunc:lFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uFe="return inversesqrt(x);",hFe=mr({opSnippet:uFe,cpuKernelImpl:CMe}),fFe={kernelName:my,backendName:"webgl",kernelFunc:hFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uB=class{constructor(e,t,r,i,s,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=Fr(s.length),u=Fr(o.length);let h="";r===1?h="i":r===2&&(h="i, j");const f=`getIndices(${h})`;let d="";i===1?d="i":i===2&&(d="i, coords[1]");const p=`getUpdates(${d})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${f});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dFe{constructor(e,t,r,i,s,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const c=Fr(s.length),u=Fr(o.length);let h="";r===1?h="i":r===2&&(h="i, j");const f=`getIndices(${h})`;let d="";i===1?d="i":i===2&&(d="i, coords[1]");const p=`getUpdates(${d})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${f});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pFe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:i,updates:s}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Lu(s,i,o),f=[h/c,c];if(h===0)return t.makeTensorInfo(o,i.dtype);const d=Mt({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),p=Mt({inputs:{x:s},backend:t,attrs:{shape:[l,c]}}),m=t.makeTensorInfo([],"float32",new Float32Array([0]));let g;Ie().getBool("WEBGL_PACK")?g=new dFe(l,a,d.shape.length,p.shape.length,u,f):g=new uB(l,a,d.shape.length,p.shape.length,u,f);const y=t.runWebGLProgram(g,[p,d,m],p.dtype),b=Mt({inputs:{x:y},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(m),b}const mFe={kernelName:E2,backendName:"webgl",kernelFunc:pFe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gFe=class{constructor(e,t,r,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const s="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=Ie().getNumber("WEBGL_VERSION")===2?s:o,l=i==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yFe(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:i,values:s}=e,{side:o}=r,a=new gFe(i.shape[0],i.shape[1],s.shape[1],o),l=[[i.shape[1]]];return t.runWebGLProgram(a,[i,s],"int32",l)}const bFe={kernelName:A2,backendName:"webgl",kernelFunc:yFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vFe=class{constructor(e,t,r){this.variableNames=["c","a","b"],this.outputShape=t;let i,s;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)s="resRC",i="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<t.length;u++)c.push(`${a[u]}`),u<e&&l.push(`${a[u]}`);i=l.join(),s=c.join()}const o=Fr(r);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wFe(n){const{inputs:e,backend:t}=n,{condition:r,t:i,e:s}=e,o=new vFe(r.shape.length,i.shape,i.shape.length);return t.runWebGLProgram(o,[r,i,s],As(i.dtype,s.dtype))}const xFe={kernelName:bw,backendName:"webgl",kernelFunc:wFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Fe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${aC};
  float scale = ${lC};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,SFe=mr({opSnippet:_Fe}),CFe={kernelName:gy,backendName:"webgl",kernelFunc:SFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kFe=Lw+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,TFe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,EFe=mr({opSnippet:kFe,packedOpSnippet:TFe,cpuKernelImpl:TMe}),IFe={kernelName:wy,backendName:"webgl",kernelFunc:EFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AFe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,MFe=mr({opSnippet:AFe}),NFe={kernelName:vy,backendName:"webgl",kernelFunc:MFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Fe=Lw+`
  return sin(x);
`,RFe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Vy}
  return result;
`,PFe=mr({opSnippet:$Fe,packedOpSnippet:RFe}),DFe={kernelName:yy,backendName:"webgl",kernelFunc:PFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OFe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,FFe=mr({opSnippet:OFe}),LFe={kernelName:by,backendName:"webgl",kernelFunc:FFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zFe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,BFe=mr({opSnippet:zFe}),VFe={kernelName:xy,backendName:"webgl",kernelFunc:BFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UFe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockShape:s,paddings:o}=r;U(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=s.reduce((y,b)=>y*b),l=[[0,0]];l.push(...o);for(let y=1+s.length;y<i.shape.length;++y)l.push([0,0]);const c=[],u=YJ({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),h=Oy(u.shape,s,a,!1),f=Fy(h.length,s.length,!1),d=Ly(u.shape,s,a,!1),p=Mt({inputs:{x:u},backend:t,attrs:{shape:h}}),m=Qo({inputs:{x:p},backend:t,attrs:{perm:f}}),g=Mt({inputs:{x:m},backend:t,attrs:{shape:d}});return c.push(u),c.push(p),c.push(m),c.forEach(y=>t.disposeIntermediateTensorInfo(y)),g},WFe={kernelName:xw,backendName:"webgl",kernelFunc:UFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HFe(n){const{inputs:e,backend:t}=n,{indices:r,values:i,denseShape:s,defaultValue:o}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${i.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.readSync(r.dataId),l=t.readSync(i.dataId),c=t.readSync(s.dataId),u=t.readSync(o.dataId)[0],[h,f,d,p,m]=IMe(a,r.shape,r.dtype,l,i.dtype,c,u);return[t.makeTensorInfo(f,r.dtype,h),t.makeTensorInfo([f[0]],i.dtype,d),t.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),t.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const GFe={kernelName:kM,backendName:"webgl",kernelFunc:HFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jFe(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:i,newShape:s}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(t.readSync(i.dataId)),a=t.readSync(r.dataId),l=Array.from(t.readSync(s.dataId)),[c,u,h]=AMe(a,r.shape,r.dtype,o,l);return[t.makeTensorInfo(u,r.dtype,c),t.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}const qFe={kernelName:TM,backendName:"webgl",kernelFunc:jFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XFe(n){const{inputs:e,backend:t}=n,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);const o=t.readSync(r.dataId),a=t.readSync(i.dataId),l=t.readSync(s.dataId),[c,u]=xJ(o,r.shape,r.dtype,a,l,!0);return t.makeTensorInfo(u,r.dtype,c)}const KFe={kernelName:M2,backendName:"webgl",kernelFunc:XFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YFe(n){const{inputs:e,backend:t}=n,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);const o=t.readSync(r.dataId),a=t.readSync(i.dataId),l=t.readSync(s.dataId),[c,u]=xJ(o,r.shape,r.dtype,a,l);return t.makeTensorInfo(u,r.dtype,c)}const ZFe={kernelName:N2,backendName:"webgl",kernelFunc:YFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JFe(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:i,sparseValues:s,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:f}=Lu(s,i,a),d=!1;if(s.dtype==="string"){const y=t.bufferSync(i),b=t.bufferSync(s),_=Sc(t.readSync(o.dataId)[0]),w=kMe(y,b,a,f,u,c,l,h,_,d);return t.makeTensorInfo(a,w.dtype,w.values)}const p=new uB(c,l,i.shape.length,s.shape.length,h,[f,1],d),m=t.runWebGLProgram(p,[s,i,o],s.dtype),g=Mt({inputs:{x:m},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(m),g}const QFe={kernelName:$2,backendName:"webgl",kernelFunc:JFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eLe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{numOrSizeSplits:s,axis:o}=r,a=An(o,i.shape)[0],l=kN(i,s,a),c=i.shape.length,u=new Array(c).fill(0),h=i.shape.slice();return l.map(f=>{const d=[...h];d[a]=f;const p=zw({inputs:{x:i},backend:t,attrs:{begin:u,size:d}});return u[a]+=f,p})}const tLe={kernelName:_w,backendName:"webgl",kernelFunc:eLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PH="return sqrt(x);",nLe=mr({opSnippet:PH,packedOpSnippet:PH,cpuKernelImpl:MMe}),rLe={kernelName:_y,backendName:"webgl",kernelFunc:nLe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iLe="return x * x;",sLe=mr({opSnippet:iLe}),oLe={kernelName:R2,backendName:"webgl",kernelFunc:sLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DH="return (a - b) * (a - b);",aLe=uo({opSnippet:DH,packedOpSnippet:DH}),lLe={kernelName:Sy,backendName:"webgl",kernelFunc:aLe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cLe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");const s=t.readSync(i.dataId),o=Cu(s),a=NMe(o,"string",r);return t.makeTensorInfo(i.shape,"string",a)}const uLe={kernelName:P2,backendName:"webgl",kernelFunc:cLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hLe({inputs:n,attrs:e,backend:t}){const{x:r}=n,i=Pc+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new fh(r.shape,i);return t.runWebGLProgram(s,[r],r.dtype)}const fLe={kernelName:Iy,backendName:"webgl",kernelFunc:hLe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let dLe=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;const i=r.length,s=Fr(r.length),o=Fr(r.length);let a="";if(i===1)a="coords * strides + begin";else{let l=0;a=r.map((c,u)=>(l++,r.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pLe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{begin:s,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:f}=r,{finalShapeSparse:d,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:_,strides:w}=lN(i.shape,s,o,a,l,c,u,h,f);let S;if(m)S=Mt({inputs:{x:i},backend:t,attrs:{shape:p}});else if(g||y){U(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const k=aN(b,_,w),A=zw({inputs:{x:i},backend:t,attrs:{begin:b,size:k}});S=Mt({inputs:{x:A},backend:t,attrs:{shape:p}}),t.disposeIntermediateTensorInfo(A)}else if(t.shouldExecuteOnCPU([i])){const A=t.readSync(i.dataId),M=Sn(i.shape,i.dtype,A),E=$Me(d,M,w,b);S=t.makeTensorInfo(p,i.dtype,E.values)}else{const A=new dLe(b,w,d);S=t.runWebGLProgram(A,[i],i.dtype)}const C=Mt({inputs:{x:S},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(S),C}const mLe={kernelName:D2,backendName:"webgl",kernelFunc:pLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gLe(n){const{inputs:e,backend:t,attrs:r}=n,{separator:i,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,f=t.readSync(u.dataId),d=t.readSync(h.dataId),[p,m]=RMe(f,d,i,s,o,a,l,c);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(h.shape,"int32",m)]}const yLe={kernelName:O2,backendName:"webgl",kernelFunc:gLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bLe(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:i}=r,{input:s,delimiter:o}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.readSync(s.dataId),l=t.readSync(o.dataId)[0],[c,u,h]=PMe(a,l,i),f=u.length;return[t.makeTensorInfo([f,2],"int32",c),t.makeTensorInfo([f],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const vLe={kernelName:EM,backendName:"webgl",kernelFunc:bLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wLe(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:i}=r,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(s.dataId),a=DMe(o,i);return t.makeTensorInfo(s.shape,"int32",a)}const xLe={kernelName:IM,backendName:"webgl",kernelFunc:wLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Le="return tan(x);",SLe=mr({opSnippet:_Le}),CLe={kernelName:ky,backendName:"webgl",kernelFunc:SLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kLe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,TLe=mr({opSnippet:kLe}),ELe={kernelName:Ty,backendName:"webgl",kernelFunc:TLe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ILe(n){const{inputs:e,backend:t,attrs:r}=n,{tensor:i,indices:s,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Lu(o,s,i.shape),f=[h/c,c];if(h===0)return t.makeTensorInfo(i.shape,s.dtype);const d=Mt({inputs:{x:s},backend:t,attrs:{shape:[l,a]}}),p=Mt({inputs:{x:o},backend:t,attrs:{shape:[l,c]}}),m=Mt({inputs:{x:i},backend:t,attrs:{shape:f}}),g=new uB(l,a,d.shape.length,p.shape.length,u,f,!1,!0),y=t.runWebGLProgram(g,[p,d,m],m.dtype),b=Mt({inputs:{x:y},backend:t,attrs:{shape:i.shape}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}const ALe={kernelName:I2,backendName:"webgl",kernelFunc:ILe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MLe=class{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[o]*t[o];this.outputShape=r,this.rank=r.length;const i=Fr(this.rank),s=NLe(e);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function NLe(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let i=0;i<n.length;i++)r.push(`imod(${t[i]}, ${n[i]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{reps:s}=r;if(i.dtype==="string"||i.shape.length>5){const l=t.readSync(i.dataId),c=i.dtype==="string"?l.map(f=>Sc(f)):l,u=Sn(i.shape,i.dtype,c),h=FMe(u,s);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new MLe(i.shape,s);return t.runWebGLProgram(o,[i],i.dtype)}const $Le={kernelName:Ey,backendName:"webgl",kernelFunc:JJ};let RLe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},PLe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function em(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function OH(n){let e=1;for(;e<n;)e*=2;return e}function DLe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{k:s,sorted:o}=r,a=Ie().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Ie().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=i.shape,u=c[c.length-1];if(t.shouldExecuteOnCPU([i])||u<a||s>l){const E=t.readSync(i.dataId),[N,O]=LMe(E,c,i.dtype,s,o);return[t.makeTensorInfo(N.shape,N.dtype,N.values),t.makeTensorInfo(O.shape,O.dtype,O.values)]}if(s===0)return c[c.length-1]=0,[t.makeTensorInfo(c,i.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(u===1)return[i,pC({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const h=t.texData.get(i.dataId),f=h!==null&&h.isPacked,d=f?t.unpackTensor(i):i,m=Ee(c)/u,g=Mt({inputs:{x:d},attrs:{shape:[m,u]},backend:t});f&&em(t,d);const y=OH(s),b=OH(u);let _=null;const w=()=>_===null?[g,g]:[g,_],S=(E,N,O)=>{const R=w(),D=new RLe(O),B=[[u],[_===null?1:0],[Number.NEGATIVE_INFINITY],[E],[N]],X=_;_=t.runWebGLProgram(D,R,"int32",B),em(t,X)};for(let E=1;E<y;E*=2){const N=E*2;for(let O=E;O>=1;O/=2)S(N,O,[m,b])}for(let E=b;E>y;E/=2){const N=w(),O=new PLe([m,E/2]),D=[[u],[_===null?1:0],[y]],z=_;_=t.runWebGLProgram(O,N,"int32",D),em(t,z);const B=y/2,X=B*2;for(let H=B;H>=1;H/=2)S(X,H,_.shape)}let C=_;_=zw({inputs:{x:_},backend:t,attrs:{begin:0,size:[m,s]}}),em(t,C);let k=HJ({inputs:{x:g,indices:_},backend:t,attrs:{axis:1,batchDims:1}});em(t,g);const A=c.slice(0,-1);A.push(s),C=_,_=Mt({inputs:{x:_},attrs:{shape:A},backend:t}),em(t,C);const M=k;return k=Mt({inputs:{x:k},attrs:{shape:A},backend:t}),em(t,M),[k,_]}const OLe={kernelName:F2,backendName:"webgl",kernelFunc:DLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FLe=class{constructor(e,t,r,i,s,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=r==="nearest"?1:2;let l;switch(i){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LLe(n){const{inputs:e,backend:t,attrs:r}=n,{image:i,transforms:s}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=r,[u,h,f,d]=i.shape,[p,m]=c??[h,f],g=[u,p,m,d],y=new FLe(h,f,o,a,l,g);return t.runWebGLProgram(y,[i,s],"float32")}const zLe={kernelName:L2,backendName:"webgl",kernelFunc:LLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BLe(n){const{inputs:e,attrs:t,backend:r}=n,{axis:i}=t,{x:s}=e;hC(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(s.dataId),{outputValues:a,outputShape:l,indices:c}=zMe(o,i,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}const VLe={kernelName:AM,backendName:"webgl",kernelFunc:BLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ULe(n){const{inputs:e,backend:t,attrs:r}=n,{value:i}=e;let{axis:s}=r;s<0&&(s+=i.shape.length);const o=i,a=o.shape.length,l=i.shape[s],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==s&&(c[u++]=o.shape[m]);const h=[],f=new Array(a).fill(0),d=o.shape.slice();d[s]=1;const p=new Array(l);for(let m=0;m<p.length;m++){f[s]=m;const g=zw({inputs:{x:o},backend:t,attrs:{begin:f,size:d}}),y=Mt({inputs:{x:g},backend:t,attrs:{shape:c}});p[m]=y,h.push(g)}return h.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}const WLe={kernelName:Cw,backendName:"webgl",kernelFunc:ULe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HLe{constructor(e,t){this.variableNames=["x","segmentIds"];const r=e.windowSize,i=e.batchSize,s=e.inSize,o=e.numSegments,a=o*Math.ceil(s/r);this.outputShape=[i,a];const l="0.0",c="sumValue",u=Math.floor(r/4)*4,h=r%4,f=`
        sumValue += dot(values, segFilter);
    `;let d="";s%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let p="";s%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GLe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,segmentIds:s}=e,{numSegments:o}=r,a=i.shape.length,l=[];let c=0;const u=Lr([c],a);let h=i;u!=null&&(h=Qo({inputs:{x:i},backend:t,attrs:{perm:u}}),l.push(h),c=ni(1,a)[0]);const f=jz(h.shape,c,o),d=Ee([h.shape[c]]),p=Mt({inputs:{x:h},backend:t,attrs:{shape:[-1,d]}});l.push(p);const m=U2(i.dtype),g=(w,S,C,k,A)=>{const M=w.shape[0],E=w.shape[1],N=qY(E,A),O={windowSize:N,inSize:E,batchSize:M,numSegments:A},R=new HLe(O,S),D=t.compileAndRun(R,[w,C],k);if(l.push(D),D.shape[1]===A)return D;const z=ZJ({backend:t,attrs:{start:0,stop:A,step:1,dtype:"float32"}}),B=JJ({inputs:{x:z},backend:t,attrs:{reps:[E/N]}});return l.push(z),l.push(B),g(D,S,B,k,A)},y=g(p,"unsortedSegmentSum",s,m,o),b=Mt({inputs:{x:y},backend:t,attrs:{shape:f}});let _=b;if(u!=null){l.push(b);const w=Ph(u);_=Qo({inputs:{x:_},backend:t,attrs:{perm:w}})}return l.forEach(w=>t.disposeIntermediateTensorInfo(w)),_}const jLe={kernelName:kw,backendName:"webgl",kernelFunc:GLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qLe=[MNe,$Ne,DNe,LNe,BNe,WNe,GNe,qNe,ZNe,QNe,n$e,s$e,l$e,f$e,m$e,y$e,v$e,S$e,k$e,E$e,N$e,L$e,B$e,H$e,j$e,J$e,eRe,iRe,dNe,aRe,fRe,gRe,_Re,kRe,ERe,ARe,NRe,DRe,LRe,VRe,WRe,GRe,qRe,YRe,JRe,n3e,i3e,a3e,u3e,f3e,g3e,w3e,C3e,E3e,M3e,N3e,R3e,D3e,F3e,z3e,V3e,G3e,X3e,Z3e,Q3e,nPe,sPe,cPe,dPe,fNe,mPe,uRe,bPe,xPe,CPe,mNe,IPe,$Pe,PPe,LPe,VPe,GPe,XPe,JPe,nDe,sDe,aDe,hDe,dDe,mDe,vDe,xDe,SDe,kDe,EDe,NDe,DDe,zDe,qDe,bNe,ZDe,eOe,rOe,oOe,X$e,cOe,hOe,dOe,gOe,wOe,yNe,_Oe,COe,TOe,IOe,AOe,K$e,WDe,$Oe,OOe,BOe,wNe,HOe,qOe,ZOe,eFe,iFe,oFe,cFe,fFe,mFe,bFe,xFe,CFe,IFe,NFe,DFe,LFe,O$e,GDe,VFe,WFe,GFe,qFe,KFe,ZFe,QFe,tLe,rLe,oLe,lLe,uLe,fLe,mLe,yLe,vLe,xLe,HDe,ENe,CLe,ELe,ALe,$Le,OLe,zLe,INe,VLe,WLe,jLe,uOe];for(const n of qLe)B2(n);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zl=Ie();zl.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);zl.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);zl.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);zl.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);zl.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);zl.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);zl.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);zl.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);zl.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);zl.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);zl.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);zl.registerFlag("WEBGPU_PRINT_SHADER",()=>"");zl.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XLe{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KLe{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,r=!1,i=!0){let s;const o=FH(e,t);return i?(this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.freeBuffers.get(o).length>0?(s=this.freeBuffers.get(o).pop(),this.numFreeBuffers--):(s=this.device.createBuffer({size:e,usage:t,mappedAtCreation:r}),this.numBytesAllocated+=e)):(s=this.device.createBuffer({size:e,usage:t,mappedAtCreation:r}),this.numBytesAllocated+=e),this.usedBuffers.has(o)||this.usedBuffers.set(o,[]),this.usedBuffers.get(o).push(s),this.numUsedBuffers++,this.numBytesUsed+=e,s}releaseBuffer(e,t=!0){if(this.freeBuffers.size===0)return;const r=e.size,i=e.usage,s=FH(r,i),o=this.usedBuffers.get(s),a=o.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");o[a]=o[o.length-1],o.pop(),this.numUsedBuffers--,this.numBytesUsed-=r,t?(this.freeBuffers.get(s).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=r)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function FH(n,e){return`${n}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YLe{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,r,i){const s=zH(r),o=e*t*s,a=LH(e,t,r,i);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=o,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const c=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(c),c}this.numBytesAllocated+=o;const l=this.device.createTexture({size:[e,t],format:r,usage:i});return this.usedTextures.get(a).push(l),l}releaseTexture(e){if(this.freeTextures.size===0)return;const t=e.width,r=e.height,i=e.format,s=e.usage,o=LH(t,r,i,s);this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.freeTextures.get(o).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(o),l=a.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(l,1);const c=zH(i),u=t*r*c;this.numBytesUsed-=u}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function LH(n,e,t,r){return`${n}_${e}_${t}_${r}`}function zH(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZLe(n,e){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const t=n.length,r="xyzwuv",i=n.map(o=>`${e}.${r[o]}`),s=new Array(t-1);s[t-2]=i[t-1];for(let o=t-3;o>=0;--o)s[o]=`(${s[o+1]} * ${i[o+1]})`;return s}const Mp=(n,e,t)=>t==="int32"?`atomicAdd(${n}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var nv;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(nv||(nv={}));const JLe=(n,e,t,r,i)=>{const s={dtype:r.dtype,shape:r.shape},o=eze(t,s,e),a=n.createShaderModule({code:o,label:e.constructor.name});let l=Ie().get("WEBGPU_PRINT_SHADER");if(l!==""){l=l.toLowerCase();const c=l.split(",");(l==="all"||c.some(u=>e.shaderKey.toLowerCase().includes(u)))&&(console.group(e.shaderKey),console.debug(o),console.groupEnd())}return i?n.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},Un=(n,e="f32")=>{switch(n){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component ${e} is not supported.`)}};function Ki(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Af(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function kt(...n){let e;switch(n.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function BH(n,e){let t;return t=`
     ${QLe(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,t}function QLe(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function eze(n,e,t){const r=[],i=t.workgroupSize[0]*t.workgroupSize[1]*t.workgroupSize[2];if(t.outputComponent=t.outputComponent?t.outputComponent:1,r.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${QJ(t)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${i}u +
                localIndex);
        `}
      }
    `),t.pixelsOpType!=null){const p=t.pixelsOpType===nv.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${Nm(e.dtype,t.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${Nm(n[0].dtype,t.outputComponent)}>;`,m=e.shape.length===3?"vec2<i32>":"i32";r.push(`
        struct Uniform {
          outShapeStrides : ${m},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${p}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const g=UH(t);return[VH,r.join(`
`),RE(e.shape),t.getUserCode(),BH(g,t)].join(`
`)}let s,o,a="struct Uniforms { NAN : f32, INFINITY : f32, ";t.variableNames.forEach((p,m)=>{const g=Ki(n[m].shape.length);a+=`${p.charAt(0).toLowerCase()+p.slice(1)}Shape : ${g}, `,s=n[m].shape.length-1,o=Ki(s),a+=`${p.charAt(0).toLowerCase()+p.slice(1)}ShapeStrides: ${o}, `});const l=Ki(e.shape.length);a+=`outShape : ${l}, `,s=e.shape.length-1,o=Ki(s),a+=`
         outShapeStrides: ${o}, `,t.size&&(a+="size : i32, "),t.uniforms&&(a+=t.uniforms),a+="};",a=cze(a),r.push(a),t.atomic?r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Nm(e.dtype,t.outputComponent)}>;
    `),t.variableNames.forEach((p,m)=>{r.push(`
      @group(0) @binding(${1+m}) var<storage, read> ${p}: array<${t.variableComponents?Nm(n[m].dtype,t.variableComponents[m]):Nm(n[m].dtype,t.outputComponent)}>;
        `)}),a!==""&&r.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const c=oze(e.shape,t.dispatchLayout),u=[VH,r.join(`
`)+nze,RE(e.shape),c,aze(e.shape.length)];t.atomic||u.push(lze(e.shape,e.dtype,t.outputComponent)),t.variableNames.forEach((p,m)=>{u.push(`${RE(n[m].shape,p)}`)});const h=n.map((p,m)=>sze(p,e.shape,t.variableComponents?t.variableComponents[m]:t.outputComponent,t.dispatchLayout.x.length===e.shape.length)).join(`
`);u.push(h),u.push(t.getUserCode());const f=UH(t);return u.push(BH(f,t)),u.join(`
`)}function tze(n,e,t){let r=n.shaderKey;if(n.pixelsOpType!=null)return r;const i=[],s=[];e.forEach(u=>{i.push(u.shape),s.push(u.dtype)}),i.push(t.shape),s.push(t.dtype);const o=e.map(u=>Pf(u.shape,t.shape)),a=e.map(u=>Rn(u.shape,t.shape)).join("_"),l=o.map(u=>u.join("_")).join(";"),c=QJ(n)?"flatDispatch":"";return r+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+i.map(u=>u.length).join(",")+s.join(",")+n.variableNames.join(",")+l+a+c,r}const VH=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,nze=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function RE(n,e=""){const t=n.length,r=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",i=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(t<=1)return`fn ${r}(index : i32) -> i32 { return index; }`;const s=Zt(n),o=Ki(t),a=[];for(let c=0;c<t;c++)a.push(`d${c}`);if(s.length===1)return`    fn ${r}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${i}; let d1 = index - d0 * uniforms.${i};
      return vec2<i32>(d0, d1);
    }`;let l;return l="var index2 = index;"+s.map((c,u)=>{const h=`let ${a[u]} = index2 / uniforms.${i}.${Af(u)}`,f=u===s.length-1?`let ${a[u+1]} = index2 - ${a[u]} * uniforms.${i}.${Af(u)}`:`index2 = index2 - ${a[u]} * uniforms.${i}.${Af(u)}`;return`${h}; ${f};`}).join(""),`
    fn ${r}(index : i32) -> ${o} {
      ${l}
      return ${o}(${a.join(",")});
    }
  `}function rze(n,e){const t=n.name,r=n.shape.length,i=Ki(r),s="get"+t.charAt(0).toUpperCase()+t.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=o.map(u=>`${u} : i32`).join(", ");if(r<1)return`
      fn ${s}() -> ${Un(e)} {
        return ${Un(e)}(${t}[0]);
      }
    `;const l=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`;let c=`${r}D`;return r===0&&(c="1D"),`
    fn ${s}(${a}) -> ${Un(e)} {
      return ${Un(e)}(${t}[getIndexFromCoords${c}(${i}(${o.join(",")}),
        ${l})${e===1?"":` / ${e}`}]);
    }
   `}function ize(n,e,t,r){const i=n.name,s=i.charAt(0).toUpperCase()+i.slice(1),o="get"+s+"ByOutput",a=n.shape.length,l=e.length,c=Ki(l);if(Rn(n.shape,e)&&r)return`
    fn ${o}Index(globalIndex : i32) -> ${Un(t)} {
      return ${Un(t)}(${i}[globalIndex]);
    }

    fn ${o}Coords(coords : ${c}) -> ${Un(t)} {
      return ${Un(t)}(${i}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${t===1?"":` / ${t}`}]);
    }
    `;const u=Pf(n.shape,e),h=l-a;let f="";if(a===0)return`
    fn ${o}Index(globalIndex : i32) -> ${Un(t)}{
      return get${s}();
    }

    fn ${o}Coords(coords : ${c}) -> ${Un(t)}{
      return get${s}();
    }
  `;l<2&&u.length>=1?f="coords = 0;":f=u.map(g=>`coords.${Af(g+h)} = 0;`).join(`
`);let d="";if(l<2&&a>0)d="coords";else if(l>1){const g=Ki(a),y=n.shape.map((b,_)=>`coords.${Af(_+h)}`).join(", ");d=`${g}(${y})`}else d="coords";const p=`uniforms.${i.charAt(0).toLowerCase()+i.slice(1)}Shape`,m=`${a}D`;return`
  fn ${o}Index(globalIndex : i32) -> ${Un(t)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${f}
    return ${Un(t)}(${i}[getIndexFromCoords${m}(${d}, ${p})${t===1?"":` / ${t}`}]);
  }

  fn ${o}Coords(coordsIn : ${c}) -> ${Un(t)} {
    var coords = coordsIn;
    ${f}
    return ${Un(t)}(${i}[getIndexFromCoords${m}(${d}, ${p})${t===1?"":` / ${t}`}]);
  }
`}function sze(n,e,t,r){let i=rze(n,t);return n.shape.length<=e.length&&(i+=ize(n,e,t,r)),i}function oze(n,e){const{x:t,y:r=[],z:i=[]}=e,s=n.length,o=t.length+r.length+i.length;if(o!==s)return"";if(t.length===s)return`fn getOutputCoords() -> ${Ki(s)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const l=[t,r,i];for(let f=0;f<l.length;f++){const d=l[f];if(d.length!==0)if(d.length===1)a+=`let d${d[0]} = i32(globalId[${f}]);`;else{const p=ZLe(d,"uniforms.outShape");a+=`var index${f} = i32(globalId[${f}]);`;for(let m=0;m<p.length;m++)a+=`let d${d[m]} = index${f} / ${p[m]};`,m===p.length-1?a+=`let d${d[m+1]} = index${f} - d${d[m]} * ${p[m]};`:a+=`index${f} = index${f} - d${d[m]} * ${p[m]};`}}const c=[];for(let f=0;f<o;f++)c.push(`d${f}`);const u=Ki(o);let h=`fn getOutputCoords() -> ${u} {
  ${a}
`;return c.length===0?h+=`return ${u}(0); }`:h+=`return ${u}(${c.join(",")}); }`,h}function aze(n){let e="";switch(n){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:U(!1,()=>`Unsupported ${n}D shape`);break}return e}function QJ(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function Nm(n,e=1){if(n==="float32")return Un(e,"f32");if(n==="int32"||n==="bool")return Un(e,"i32");throw new Error(`type ${n} is not supported.`)}function lze(n,e,t){const r=n.length,i=Nm(e,t);let s=`fn setOutputAtIndex(flatIndex : i32, value : ${Un(t)}) {
      result[flatIndex] = ${i}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${Un(t,"i32")}) {
      result[flatIndex] = ${i}(value);
    }
    `;if(r>=2){const o=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=Ki(r);s+=`
      fn setOutputAtCoords(${o.map(l=>`${l} : i32`).join(", ")}, value : ${Un(t)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndex(flatIndex${t===1?"":` / ${t}`}, value);
      }
      fn setOutputAtCoordsI32(${o.map(l=>`${l} : i32`).join(", ")}, value : ${Un(t,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndexI32(flatIndex${t===1?"":` / ${t}`}, value);
      }
    `}return s}function cze(n){const e=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(e,r=>"@align(16) "+r);const t=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(t,(r,i,s)=>`vec${i}, @align(16) ${s}`),n}function UH(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hm=n=>{let e=1;for(let t=0;t<n.length;t++)e*=n[t];return e};function Tt(n,e,t=[1,1,1],r=[1,1,1]){const[i,s,o]=[Math.ceil(Hm(n.x.map(a=>e[a]))/(t[0]*r[0])),n.y?Math.ceil(Hm(n.y.map(a=>e[a]))/(t[1]*r[1])):1,n.z?Math.ceil(Hm(n.z.map(a=>e[a]))/(t[2]*r[2])):1];return[i,s,o]}function uze(n,e,t,r=!1){const i=[8,8,1],s=[4,4,1];return r||(n<=8&&(s[1]=1),e<=16&&t<=16&&(i[0]=4)),{workgroupSize:i,elementsPerThread:s}}function eQ(n,e,t=!1){if(t)return[8,8,1];const r=Hm(n.x.map(s=>e[s])),i=Hm(n.y.map(s=>e[s]));return r<=4?[4,16,1]:i<=4?[16,4,1]:[16,16,1]}function tQ(n,e,t=!1){if(t)return[4,4,1];const r=Hm(n.x.map(s=>e[s])),i=Hm(n.y.map(s=>e[s]));return r<=4?[1,2,1]:i<=4?[2,1,1]:[2,2,1]}function Ot(n){return{x:n.map((e,t)=>t)}}function WH(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function nQ(){return(typeof window<"u"||typeof WorkerGlobalScope<"u")&&!!navigator.gpu}function rQ(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&U(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var ih;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(ih||(ih={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hze=Ie().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),fze=(n,e)=>{const t=n.limits.maxComputeWorkgroupsPerDimension,r=e.dispatchLayout,i=e.dispatch;if(i.every(o=>o<=t))return i;U(i[0]>t&&r.y===void 0&&r.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let s=Math.ceil(Math.sqrt(i[0]));return s>t?(s=Math.ceil(Math.cbrt(i[0])),U(s<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[s,s,s]):[s,s,1]};class Bw extends VS{nextDataId(){return Bw.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!nQ())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new XLe(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new KLe(this.device),this.textureManager=new YLe(this.device),this.tensorMap=new gM(this,wo()),Ie().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;const r=this.tensorMap.get(e);return t?r.refCount=0:r.refCount--,r.refCount>0?!1:(r.complexTensorInfos!=null&&(this.disposeData(r.complexTensorInfos.real.dataId),this.disposeData(r.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(!(!t||!t.resource)){if(t.external){t.resource=null;return}t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource),t.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){const t=this.tensorMap.get(e);t.refCount--}}write(e,t,r){if(r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.tensorMap.set(i,{dtype:r,shape:t,values:e,refCount:1}),i}move(e,t,r,i,s){if(i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:i,shape:r,values:t,refCount:s})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(t){throw new Error(t.message)}Object.keys(this.pipelineCache).map((t,r)=>{this.pipelineCache[t]=e[r]})}async getBufferData(e){if(Ie().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,r=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),await r.mapAsync(GPUMapMode.READ);const i=r.getMappedRange().slice(0);return r.unmap(),r!=null&&this.bufferManager.releaseBuffer(r),Ie().getBool("WEBGPU_USE_PROFILE_TOOL")&&(U(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),i}convertAndCacheOnCPU(e,t){const r=this.tensorMap.get(e);return r.values=t,r.values}readSync(e){const t=this.tensorMap.get(e),{values:r,complexTensorInfos:i}=t;if(r!=null||t.dtype==="string")return r;if(t.dtype==="complex64"){const m=this.readSync(i.real.dataId),g=this.readSync(i.imag.dataId),y=q1(Su(m,g).buffer,"float32");return this.convertAndCacheOnCPU(e,y),y}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const s=["opaque","premultiplied"],o=t.resource,a=o.size;U(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const l=a/4,c=new ArrayBuffer(a),u=256,h=256,f=s.map(m=>new OffscreenCanvas(u,h)),d=new OffscreenCanvas(u,h);this.endComputePassEncoder(),f.map((m,g)=>{const y=m.getContext("webgpu");return y.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:s[g]}),y.getCurrentTexture()}).map((m,g)=>{const y=u*4,b=(A,M,E)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:o,bytesPerRow:y,offset:E},{texture:m},{width:A,height:M}),this.submitQueue();const N=d.getContext("2d",{willReadFrequently:!0});N.clearRect(0,0,A,M),N.drawImage(f[g],0,0);const O=N.getImageData(0,0,A,M).data,R=s[g],D=new Uint8ClampedArray(c,E,A*M*4);for(let z=0;z<D.length;z+=4)if(R==="premultiplied")D[z+3]=O[z+3];else{const B=O[z];D[z]=O[z+2],D[z+1]=O[z+1],D[z+2]=B}},_=Math.floor(l/(u*h));let w=u,S=h,C=0;for(let A=0;A<_;A++)b(w,S,C),C+=u*h*4;const k=l%(u*h);S=Math.floor(k/u),S>0&&(b(w,S,C),C+=S*(u*4)),w=k%u,w>0&&b(w,1,C)});const p=q1(c,t.dtype);return this.convertAndCacheOnCPU(e,p),p}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:r}=t;if(r!=null)return r;let i;if(t.dtype==="complex64"){const s=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),o=s[0],a=s[1];i=Su(o,a)}else{const s=await this.getBufferData(t.resource);i=q1(s,t.dtype)}return this.convertAndCacheOnCPU(e,i),i}copyBuffer(e){const t=e.size,r=e.usage,i=this.bufferManager.acquireBuffer(t,r);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,i,0,t),this.submitQueue(),i}createTensorFromGPUData(e,t,r){let i=e.buffer;if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const s={id:this.nextDataId()};this.tensorMap.set(s,{dtype:r,shape:t,values:null,refCount:1,external:e.zeroCopy});const o=this.tensorMap.get(s),a=WH(o.dtype)*Ee(o.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(i=this.copyBuffer(i)),o.resource=i,wo().makeTensorFromDataId(s,t,r,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:r,dtype:i,shape:s,resource:o}=t;if(i==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(o==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=o,l=a.size,c=a.usage,u=this.bufferManager.acquireBuffer(l,c);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,u,0,l),this.submitQueue();const h=this.makeTensorInfo(s,i),f=wo().makeTensorFromTensorInfo(h),d=this.tensorMap.get(h.dataId);return d.resource=u,{tensorRef:f,buffer:u}}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(i=>Sc(i));return Sn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Sn(e.shape,e.dtype,t)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,r=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=r,i=!0):this.activeTimers.push(r),this.activeTimers=r,e();const s=Cc(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),o=Cc(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=t,i&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(s);return a.kernelMs=yL(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,t,r){return t==="string"&&r!=null&&r.length>0&&du(r[0])&&(r=r.map(s=>vu(s))),{dataId:this.write(r,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const r=this.tensorMap.get(e.dataId).resource;return r instanceof GPUBuffer?{buffer:r}:r instanceof GPUTexture?r.createView():r}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resource!=null)return;const r=WH(t.dtype)*Ee(t.shape);let i;const s=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(i=this.bufferManager.acquireBuffer(r,s,!0),i.mapState==="unmapped"){const o=this.bufferManager.acquireBuffer(r,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=o.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),o.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,i,0,r),this.stagingPendingDisposal.push(o)}else{const o=i.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(o).set(t.values):new Float32Array(o).set(t.values),i.unmap()}t.values=null}else i=this.bufferManager.acquireBuffer(r,s);t.resource=i}makeUniforms(e){let t=0,r=0;const i=[];let s=1;e.forEach(l=>{l.data.length===0&&(l.data=[1]);let c;switch(l.data.length){case 1:c=4;break;case 2:c=8;break;case 3:c=16;break;case 4:c=16;break;case 5:c=16;break;case 6:c=16;break;default:U(!1,()=>`Unsupported ${l.data.length}D shape`)}(r===5||r===6)&&(c=16),c>s&&(s=c),t=Math.ceil(t/c)*c,r=l.data.length,i.push(t),t+=l.data.length*4}),t=Math.ceil(t/s)*s;const o=new ArrayBuffer(t);e.forEach((l,c)=>{const u=i[c];l.type==="int32"?new Int32Array(o,u,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(o,u,l.data.length).set(l.data):new Float32Array(o,u,l.data.length).set(l.data)});const a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,o,0,t),this.uniformPendingDisposal.push(a),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,r,i,s){if(s||(s=this.makeTensorInfo(e.outputShape,r)),Ee(s.shape)===0)return this.tensorMap.get(s.dataId).values=cs(s.dtype,0),s;this.uploadToGPU(s.dataId),e.dispatch=fze(this.device,e);const o=t.map((l,c)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:e.variableNames[c]}});e.shaderKey=tze(e,o,s);const a=Ie().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=JLe(this.device,e,o,s,a)),e.pipeline=this.pipelineCache[e.shaderKey],a||this.recordAndSubmit(e,s,t,i),s}recordAndSubmit(e,t,r,i){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let s=[],o=[];const a="int32";if(e.pixelsOpType==null){s.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),o=r.concat(t).map(d=>d.shape);const f="int32";o.map(d=>{s.push({type:f,data:d});const p=Zt(d);s.push({type:f,data:p})})}else{const f=Zt(t.shape);s.push({type:a,data:f})}if(e.size){const f=Ee(e.outputShape);s.push({type:a,data:[e.outputComponent?f/e.outputComponent:f]})}i&&(s=[...s,...i]);const l=[this.tensorToBinding(t),...r.map(f=>this.tensorToBinding(f)),this.makeUniforms(s)];r.forEach(f=>{this.commandQueueOwnedIds.add(f.dataId)}),this.commandQueueOwnedIds.add(t.dataId);const c=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:l.map((f,d)=>({binding:d,resource:f}))}),u=this.activeTimers!=null;this.ensureCommandEncoderReady();const h={};u&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),h.timestampWrites=[{querySet:this.querySet,queryIndex:0,location:"beginning"},{querySet:this.querySet,queryIndex:1,location:"end"}],this.computePassEncoder=this.commandEncoder.beginComputePass(h)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(h)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,c),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(u||Ie().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===nv.DRAW)&&(this.endComputePassEncoder(),u?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),r=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),r}shouldExecuteOnCPU(e,t=hze){return Ie().getBool("WEBGPU_CPU_FORWARD")&&e.every(r=>this.tensorMap.get(r.dataId).resource==null&&Ee(r.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}Bw.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */nQ()&&NM("webgpu",async()=>{const n={powerPreference:Ie().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(n),t={},r=[];e.features.has("timestamp-query")&&r.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&r.push(["bgra8unorm-storage"]),t.requiredFeatures=r;const i=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:i.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:i.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:i.maxStorageBufferBindingSize,maxBufferSize:i.maxBufferSize,maxComputeWorkgroupSizeX:i.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:i.maxComputeInvocationsPerWorkgroup};const s=await e.requestDevice(t),o=await e.requestAdapterInfo();return new Bw(s,o)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var vn;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(vn||(vn={}));const dze="let resultTemp = a + b;",pze="let resultTemp = atan2(a, b);",mze="let resultTemp = areal * breal - aimag * bimag;",gze="let resultTemp = areal * bimag + aimag * breal;",yze="let resultTemp = a / b;",bze="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",vze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,wze=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,xze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,_ze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,Sze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,Cze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,kze="return f32(a >= 1.0 && b >= 1.0);",Tze=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,Eze="return f32(a >= 1.0 || b >= 1.0);",Ize=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,Aze="let resultTemp = max(a, b);",Mze="let resultTemp = min(a, b);",Nze=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,$ze=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,Rze="let resultTemp = a * b;",Pze=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,Dze=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,Oze=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,Fze=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,Lze="if (a < 0.0) { return b * a; }  return a;",zze=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,Bze="let resultTemp = (a - b) * (a - b);",Vze="let resultTemp = a - b;";function hB(n,e){let t;do{switch(n){case vn.ATAN2:t=pze;break;case vn.MAX:t=Aze;break;case vn.MIN:t=Mze;break;case vn.MOD:t=e?$ze:Nze;break;case vn.NOT_EQUAL:t=e?Dze:Pze;break;case vn.POW:t=e?Fze:Oze;break;default:continue}let r,i,s;return e?(r="isnanVec4",i="vec4<f32>",s="vec4<bool>"):(r="isnan",i="f32",s="bool"),`
      let aIsNaN = ${r}(a);
      let aPostLegalization = select(a, ${i}(42), aIsNaN);
      let bIsNaN = ${r}(b);
      let bPostLegalization = select(b, ${i}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t}
        return select(
            resultTemp, ${i}(valueForNaN),
            ${s}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case vn.ADD:t=dze;break;case vn.COMPLEX_MULTIPLY_IMAG:t=gze;break;case vn.COMPLEX_MULTIPLY_REAL:t=mze;break;case vn.DIV:t=yze;break;case vn.ELU_DER:t=bze;break;case vn.EQUAL:t=vze;break;case vn.FLOOR_DIV:t=wze;break;case vn.GREATER:t=xze;break;case vn.GREATER_EQUAL:t=_ze;break;case vn.LESS:t=Sze;break;case vn.LESS_EQUAL:t=Cze;break;case vn.LOGICAL_AND:return e?Tze:kze;case vn.LOGICAL_OR:return e?Ize:Eze;case vn.MUL:t=Rze;break;case vn.PRELU:return e?zze:Lze;case vn.SQUARED_DIFFERENCE:t=Bze;break;case vn.SUB:t=Vze;break}return`
    ${t}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var vt;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})(vt||(vt={}));const Uze="return abs(a);",Wze=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,Hze=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,Gze=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,jze="return asinh(a);",qze=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,Xze=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,Kze="return ceil(a);",Yze="return cos(a);",Zze=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,Jze="return exp(a) - 1.0;",Qze="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",eBe=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,tBe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${pN};
  let a1 = ${mN};
  let a2 = ${gN};
  let a3 = ${yN};
  let a4 = ${bN};
  let a5 = ${vN};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,nBe="return exp(a);",rBe="return floor(a);",iBe="return f32(!isnan(a) && !isinf(a));",sBe="return f32(isinf(a));",oBe="return f32(isnan(a));",aBe="return a;",lBe=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,cBe=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,uBe="return f32(!(a >= 1.0));",hBe="return -a;",fBe="if (a < 0.0) { return uniforms.alpha * a; } return a;",dBe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,pBe="return 1.0 / a;",mBe="return select(a, 0.0, a < 0.0);",gBe="return clamp(a, 0.0, 6.0);",yBe="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",bBe=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,vBe="return round(a);",wBe="return inverseSqrt(a);",xBe=`
  if (a >= 0.0) {
    return ${lC} * a;
  } else {
    return ${aC} * (exp(a) - 1.0);
  }
`,_Be="return 1.0 / (1.0 + exp(-1.0 * a));",SBe="return sign(a);",CBe="return sin(a);",kBe=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,TBe=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,EBe="return sqrt(a);",IBe="return a * a;",ABe=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,MBe="return tan(a);",NBe=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,$Be="return f32(i32((a)));";function bm(n,e){switch(n){case vt.ABS:return Uze;case vt.ACOS:return Wze;case vt.ACOSH:return Hze;case vt.ASIN:return Gze;case vt.ASINH:return jze;case vt.ATAN:return qze;case vt.ATANH:return Xze;case vt.COS:return Yze;case vt.COSH:return Zze;case vt.CEIL:return Kze;case vt.ELU:return e?eBe:Qze;case vt.ERF:return tBe;case vt.EXP:return nBe;case vt.EXPM1:return Jze;case vt.FLOOR:return rBe;case vt.IS_FINITE:return iBe;case vt.IS_INF:return sBe;case vt.IS_NAN:return oBe;case vt.LINEAR:return aBe;case vt.LOG:return lBe;case vt.LOG1P:return cBe;case vt.LOGICAL_NOT:return uBe;case vt.NEG:return hBe;case vt.LEAKYRELU:return e?dBe:fBe;case vt.RECIPROCAL:return pBe;case vt.RELU:return e?bBe:mBe;case vt.RELU6:return e?yBe:gBe;case vt.ROUND:return vBe;case vt.RSQRT:return wBe;case vt.SELU:return xBe;case vt.SIGMOID:return _Be;case vt.SIGN:return SBe;case vt.SIN:return CBe;case vt.SINH:return kBe;case vt.SOFTPLUS:return TBe;case vt.SQRT:return EBe;case vt.SQUARE:return IBe;case vt.STEP:return ABe;case vt.TAN:return MBe;case vt.TANH:return NBe;case vt.TO_INT:return $Be;default:throw new Error(`BinaryType ${n} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jf(n,e=!1,t=!1,r=3){if(n===null)return"";let i="";if(n==="linear")i=bm(vt.LINEAR);else if(n==="relu")i=bm(vt.RELU,t);else if(n==="elu")i=bm(vt.ELU,t);else if(n==="relu6")i=bm(vt.RELU6,t);else if(n==="prelu")i=hB(vn.PRELU,t);else if(n==="sigmoid")i=bm(vt.SIGMOID,t);else if(n==="leakyrelu")i=bm(vt.LEAKYRELU,t);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const o=Un(t?4:1);let a="";return e?a=`
      fn activation(a : ${o}, coords : vec${r}<i32>) -> ${o} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${i}
      }`:a=`
      fn activation(a : ${o}, coords : vec${r}<i32>) -> ${o} {
        ${i}
      }`,a}function Wy(n,e){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iQ(n,e,t=!1,r=!1,i=!1,s=1){U(n&&s===1||!n,()=>`transposeA ${n} is not compatible with component size ${s}`);const o=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${Un(s)} {
    var value = ${Un(s)}(0.0);
    ${t&&i?o:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${o}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${Un(s)} {
    var value = ${Un(s)}(0.0);
    ${a}
    return value;
  }
  `}function fB(n,e,t,r,i=!1,s=!1,o=!1,a=1){return`
  ${iQ(t,r,i,s,o,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${Un(a)}) {
    ${i&&s?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Wy(n,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const RBe=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,PBe=(n,e,t,r)=>{if(n)return`
      for (var k = 0; k < ${r}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${t}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let i="",s="";for(let o=0;o<e;o++)i+=`let BCached${o} = mm_Bsub[k * ${e} + ${o}][tileCol];`,s+=`acc[i] = fma(BCached${o}, vec4<f32>(ACached[${o}]), acc[i]);`;return`
      for (var k = 0; k < ${r/e}; k++) {
        ${i}
        for (var i = 0; i < ${t}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${s}
        }
      }`}};function PN(n,e,t=!1,r=32,i=!1,s=32,o=!1){const a=e[1]*n[1],l=e[0]*n[0],c=t?a:r,u=t?r:a,h=c/e[0],f=r/e[1],d=n[1],p=n[0];return U((t&&h===4&&n[1]===4||!t&&(h===3||h===4))&&c%e[0]===0&&r%e[1]===0&&n[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${h} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${h} must be 3 or 4.
      tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${h}<f32>, ${c/h}>, ${u}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/n[0]}>, ${r}>;

  ${kt()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${d};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${d};
    let globalCol = i32(globalId.x) * ${p};
    let batch = ${i?"0":"i32(globalId.z)"};
    let batchA = ${i||!o?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${i||!o?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${i?`${Math.ceil(s/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
    var kStart = ${i?`i32(globalId.z) * ${s}`:"0"};

    var acc: array<vec4<f32>, ${d}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${f};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${RBe(t,h)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${f}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${PBe(t,h,d,r)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const HH=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,DBe=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function DN(n,e,t=!1,r=32,i=!1,s=32,o=!1,a=!1){const l=n[1]*e[1],c=n[0]*e[0],u=t?l:r,h=t?r:l;U(h%e[1]===0&&u%e[0]===0&&r%e[1]===0,()=>`tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${u} must be divisible by workgroupSize[0]${e[0]}, tileInner ${r} must be divisible by workgroupSize[1]${e[1]}`);const f=h/e[1],d=u/e[0],p=r/e[1],m=n[1],g=n[0],y=o?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${c};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
            ${HH(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${g}>;
        for (var k = 0; k < ${r}; k++) {
          for (var inner = 0; inner < ${g}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${m}; innerRow++) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${g}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${m};
  let tileCol = i32(localId.x) * ${g};

  let globalRow = i32(globalId.y) * ${m};
  let globalCol = i32(globalId.x) * ${g};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${f};
  let tileColA = i32(localId.x) * ${d};
  let tileRowB = i32(localId.y) * ${p};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
      for (var innerCol = 0; innerCol < ${d}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${HH(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
      for (var innerCol = 0; innerCol < ${g}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${r};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${g}>;
    for (var k = 0; k < ${r}; k++) {
      for (var inner = 0; inner < ${g}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        ${DBe(t)}
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${m}; innerRow++) {
    for (var innerCol = 0; innerCol < ${g}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${u}>, ${h}>;
    var<workgroup> mm_Bsub : array<array<f32, ${c}>, ${r}>;

    ${kt()} {
      let batch = ${i?"0":"i32(globalId.z)"};
      let batchA = ${i||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${i||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${i?`${Math.ceil(s/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
      var kStart = ${i?`i32(globalId.z) * ${s}`:"0"};

      var acc : array<array<f32, ${g}>, ${m}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${y}
    }
  `}const OBe=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function FBe(n,e=!1){U(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const t=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${kt()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${OBe(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t/4}; k++) {
          let rowB = t * ${t} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class LBe{constructor(e,t,r=!1,i=!1,s=null,o=null,a=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const c=r?e[1]:e[2];if(this.isVec4=(c%4===0&&!r||t[1]%4===0&&r)&&t[2]%4===0&&!i,this.outputComponent=this.isVec4?4:1,this.isVectorA=t[1]===1&&!r,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const f=uze(t[1],c,t[2],r);this.workgroupSize=f.workgroupSize,this.elementsPerThread=f.elementsPerThread}this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const u=s!=null,h=a!=null;u&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=r,this.transposeB=i,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],c),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${r}_${i}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,r){const i=this.workgroupSize[1]*this.elementsPerThread[1],s=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=s;const o=e%i===0,a=t%s===0,l=r%this.tileInner===0;return[o,a,l]}getUserCode(){return`
      ${jf(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${fB(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?PN(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?FBe(this.workgroupSize,this.transposeA):DN(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zBe(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${kt()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class BBe{constructor(e,t=!1,r=!1,i=null,s=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=i!=null,l=o!=null;a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=r,this.addBias=a,this.activation=s,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${t}_${r}`}getUserCode(){return`
      ${jf(this.activation,this.hasPreluActivationWeights)}
      ${fB(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${zBe(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VBe(n){const e=n[1],t=n[0],r=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${r}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${kt()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${r};
    globalRowB = globalRowB + ${r};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${r};
      globalRowB = globalRowB + ${r};

      for (var k = 0; k < ${r}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class UBe{constructor(e,t,r,i=!1,s=!1,o=null,a=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=r,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(r[2]/this.workgroupSize[0]),Math.ceil(r[1]/this.workgroupSize[1]),r[0]];const c=o!=null;c&&this.variableNames.push("bias");const u=l!=null;u&&this.variableNames.push("preluActivationWeights"),this.transposeA=i,this.transposeB=s,this.addBias=c,this.activation=a,this.hasPreluActivationWeights=u,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${i}_${s}`}getUserCode(){return`
      ${jf(this.activation,this.hasPreluActivationWeights)}
      ${fB(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${VBe(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WBe{constructor(e,t,r=!1,i=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,U(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const s=(r&&this.outputShape[1]%4===0||!r&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=s?4:1,s||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Tt(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=r,this.transposeB=i,this.shaderKey=`matMulSplitK_${r}_${i}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${iQ(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${Un(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Mp("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?PN(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):DN(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class HBe{constructor(e,t=null,r=null,i=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=i!=null,this.activation=r,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${r}`}getUserCode(){return`
    ${jf(this.activation,this.hasPreluActivationWeights)}
    ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Wy(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GBe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wa(n){const{backend:e,attrs:t}=n,{shape:r,value:i}=t;let{dtype:s}=t;if(s=s||xp(i),s==="string"){const o=Si(s,Ee(r));return o.fill(i),e.makeTensorInfo(r,s,o)}else{const o=new GBe(r),a=[{type:"float32",data:[i]}];return e.runWebGPUProgram(o,[],s,a)}}const jBe={kernelName:u2,backendName:"webgpu",kernelFunc:wa};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xt(n){const{inputs:e,attrs:t}=n,{x:r}=e,{shape:i}=t,s=Ee(r.shape),o=bM(i,s),a=Ee(o);return U(s===a,()=>`The new shape (${o}) has ${a} elements and the old shape (${r.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}const qBe={kernelName:pw,backendName:"webgpu",kernelFunc:Xt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ON({a:n,b:e,transposeA:t,transposeB:r,backend:i,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,h=t?n.shape[c-2]:n.shape[c-1],f=r?e.shape[u-1]:e.shape[u-2],d=t?n.shape[c-1]:n.shape[c-2],p=r?e.shape[u-2]:e.shape[u-1],m=n.shape.slice(0,-2),g=e.shape.slice(0,-2),y=Ee(m),b=Ee(g),w=ln(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,p]);U(h===f,()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const S=t?[y,h,d]:[y,d,h],C=r?[b,p,f]:[b,f,p],k=Xt({inputs:{x:n},backend:i,attrs:{shape:S}}),A=Xt({inputs:{x:e},backend:i,attrs:{shape:C}}),M=[k,A],E=Math.max(y,b),N=[k,A],O=[{type:"int32",data:[d]},{type:"int32",data:[p]},{type:"int32",data:[h]}];let R,D;const z=[E,d,p];let B=Ie().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(B<0){const H=Ie().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),te=H>0?H:i.thresholdToIncreaseWorkgroups,ge=E*Math.ceil(d/32)*Math.ceil(p/32);ge<=te||d<=8&&ge<=te*2?E*d*p<=128?B=ih.MatMulReduceProgram:E===1&&f>=2e3?B=ih.MatMulSplitKProgram:B=ih.MatMulSmallOutputSizeProgram:B=ih.MatMulPackedProgram}switch(B){case ih.MatMulReduceProgram:R=new BBe(z,t,r,s,l,o);break;case ih.MatMulSplitKProgram:{if(D=wa({backend:i,attrs:{shape:z,value:0,dtype:n.dtype}}),R=new WBe(z,f,t,r),s||l){D=i.runWebGPUProgram(R,N,n.dtype,O,D);const te=new HBe(D.shape,s,l,o);let ge=null;const ae=[D];s&&ae.push(s),o&&ae.push(o),l==="leakyrelu"&&(ge=[{type:"float32",data:[a]}],te.uniforms+=" alpha : f32,");const Ne=i.runWebGPUProgram(te,ae,D.dtype,ge);M.push(D);const Te=Xt({inputs:{x:Ne},backend:i,attrs:{shape:w}});M.push(Ne);for(const De of M)i.disposeData(De.dataId);return Te}break}case ih.MatMulSmallOutputSizeProgram:R=new UBe(S,C,z,t,r,s,l,o);break;case ih.MatMulPackedProgram:const H=i.adapterInfo.isIntel();R=new LBe(S,z,t,r,s,l,o,H);break;default:throw new Error(`Unsupported MatMulProgramType ${B}.`)}s&&N.push(s),o&&N.push(o),l==="leakyrelu"&&(O.push({type:"float32",data:[a]}),R.uniforms+=" alpha : f32,"),D=i.runWebGPUProgram(R,N,n.dtype,O,D);const X=Xt({inputs:{x:D},backend:i,attrs:{shape:w}});M.push(D);for(const H of M)i.disposeData(H.dataId);return X}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XBe(n){const{inputs:e,backend:t,attrs:r}=n,{a:i,b:s,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;return ON({a:i,b:s,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}const KBe={kernelName:Vb,backendName:"webgpu",kernelFunc:XBe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GH{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=ln(t,r),this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${hB(this.op,!1)}
      }

      ${kt("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DI{constructor(e,t,r){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=ln(t,r),this.dispatchLayout=Ot(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&r.length>1&&t[0]<128,this.useSharedMemoryWithB=r.length<=1&&t.length>1&&r[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?r[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const i=t.length>0&&t[t.length-1]%4===0,s=r.length>0&&r[r.length-1]%4===0;i&&s?(this.outputComponent=4,this.variableComponents=[4,4]):i&&(tD(r)||r[r.length-1]===1)||s&&(tD(t)||t[t.length-1]===1)?(this.outputComponent=4,this.variableComponents=i?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=this.outputComponent===4?"vec4<f32>":"f32",r=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${hB(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const i=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",s=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${i}];`:`let a = sharedBuf[${i}];
          let b = getBByOutputIndex(index);`;e=`
        ${r}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${kt("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${s}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${r}
       ${kt("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xa(n){const{inputs:e}=n,{x:t}=e;return n.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const YBe={kernelName:ey,backendName:"webgpu",kernelFunc:Xa};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hy(n){const{inputs:e,backend:t}=n,{real:r,imag:i}=e,s=t.makeTensorInfo(r.shape,"complex64"),o=t.tensorMap.get(s.dataId),a=Xa({inputs:{x:r},backend:t}),l=Xa({inputs:{x:i},backend:t});return o.complexTensorInfos={real:a,imag:l},s}const ZBe={kernelName:KS,backendName:"webgpu",kernelFunc:Hy};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vw{constructor(e,t,r=""){this.variableNames=["A"],this.size=!0;const i=128;this.workgroupSize=[i,1,1],this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,r!==""&&(this.uniforms=r),this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${bm(this.op,!1)}
      }
      ${kt("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gr({opType:n,cpuKernelImpl:e,dtype:t}){return({inputs:r,backend:i})=>{const{x:s}=r,o=i,a=t||s.dtype;if(o.shouldExecuteOnCPU([s])&&e!=null){const c=o.tensorMap.get(s.dataId),u=e(c.values,a);return o.makeTensorInfo(s.shape,a,u)}const l=new Vw(s.shape,n);return o.runWebGPUProgram(l,[s],a)}}function Xs({opType:n,cpuKernelImpl:e,supportsComplex:t=!1,dtype:r}){return({inputs:i,backend:s})=>{const{a:o,b:a}=i,l=s;if(t&&o.dtype==="complex64"){const h=l.tensorMap.get(o.dataId),f=l.tensorMap.get(a.dataId);let d,p;if(n!==vn.MUL)[d,p]=[[h.complexTensorInfos.real,f.complexTensorInfos.real],[h.complexTensorInfos.imag,f.complexTensorInfos.imag]].map(g=>{const[y,b]=g,_={dataId:y.dataId,dtype:y.dtype,shape:o.shape},w={dataId:b.dataId,dtype:b.dtype,shape:a.shape},S=new DI(n,o.shape,a.shape);return l.runWebGPUProgram(S,[_,w],As(y.dtype,b.dtype))});else{const g=new GH(vn.COMPLEX_MULTIPLY_REAL,o.shape,a.shape),y=new GH(vn.COMPLEX_MULTIPLY_IMAG,o.shape,a.shape),b=[{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:o.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:f.complexTensorInfos.real.dataId,dtype:f.complexTensorInfos.real.dtype,shape:a.shape},{dataId:f.complexTensorInfos.imag.dataId,dtype:f.complexTensorInfos.imag.dtype,shape:a.shape}];d=l.runWebGPUProgram(g,b,"float32"),p=l.runWebGPUProgram(y,b,"float32")}const m=Hy({inputs:{real:d,imag:p},backend:l});return l.disposeData(d.dataId),l.disposeData(p.dataId),m}const c=r||As(o.dtype,a.dtype);if((o.dtype==="string"||a.dtype==="string"||l.shouldExecuteOnCPU([o,a]))&&e!=null){const h=l.tensorMap.get(o.dataId).values,f=l.tensorMap.get(a.dataId).values,d=o.dtype==="string"?Cu(h):h,p=o.dtype==="string"?Cu(f):f,[m,g]=e(o.shape,a.shape,d,p,c);return l.makeTensorInfo(g,c,m)}const u=new DI(n,o.shape,a.shape);return l.runWebGPUProgram(u,[o,a],c)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:JBe,castImpl:QBe,ceilImpl:e4e,concatImpl:t4e,equalImpl:n4e,expImpl:r4e,expm1Impl:i4e,floorImpl:s4e,floorDivImpl:o4e,gatherNdImpl:a4e,gatherV2Impl:l4e,greaterEqualImpl:c4e,greaterImpl:u4e,lessEqualImpl:h4e,lessImpl:f4e,logImpl:d4e,maxImpl:p4e,maximumImpl:m4e,minimumImpl:g4e,multiplyImpl:y4e,negImpl:b4e,notEqualImpl:v4e,prodImpl:w4e,rangeImpl:x4e,rsqrtImpl:_4e,scatterImpl:S4e,simpleAbsImpl:C4e,sliceImpl:k4e,stridedSliceImpl:T4e,stringNGramsImpl:E4e,subImpl:I4e,tileImpl:A4e,topKImpl:M4e,transposeImpl:N4e,uniqueImpl:tIt}=GZ;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $4e=gr({opType:vt.ABS,cpuKernelImpl:C4e}),R4e={kernelName:Tv,backendName:"webgpu",kernelFunc:$4e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P4e=gr({opType:vt.ACOS}),D4e={kernelName:Pg,backendName:"webgpu",kernelFunc:P4e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O4e=gr({opType:vt.ACOSH}),F4e={kernelName:Dg,backendName:"webgpu",kernelFunc:O4e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L4e=Xs({opType:vn.ADD,cpuKernelImpl:JBe,supportsComplex:!0}),z4e={kernelName:_p,backendName:"webgpu",kernelFunc:L4e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B4e{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,r)=>`T${r}`),this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(i=>{e.push(`let v${i} = get${i}ByOutputCoords(coords);`)});const t=this.variableNames.map(i=>`v${i}`).join(" + ");return`
      ${kt("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V4e(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return Xa({inputs:{x:r[0]},backend:t});const i=r.map(a=>a.dtype).reduce((a,l)=>As(a,l)),s=r.map(a=>a.shape),o=new B4e(s);return t.runWebGPUProgram(o,r,i)}const U4e={kernelName:Ev,backendName:"webgpu",kernelFunc:V4e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class W4e{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[t[i]];this.outputShape=r,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){U(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${kt()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H4e{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[t[i]];this.outputShape=r,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=Ki(this.outputShape.length),t=sQ(this.newDim);return`
      ${kt("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}}function sQ(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=new Array(e);for(let r=0;r<n.length;r++)t[n[r]]=`coords.${Af(r)}`;return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ch(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{perm:s}=r,o=t,a=i.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=i.shape[s[u]];if(t.shouldExecuteOnCPU([i])){const h=o.tensorMap.get(i.dataId).values,f=N4e(h,i.shape,i.dtype,s,l);return t.makeTensorInfo(l,i.dtype,f)}if(i.shape.length===2&&Rn(s,[1,0])){const u=new W4e(i.shape,s);return o.runWebGPUProgram(u,[i],i.dtype)}const c=new H4e(i.shape,s);return o.runWebGPUProgram(c,[i],i.dtype)}const G4e={kernelName:Ld,backendName:"webgpu",kernelFunc:Ch};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j4e{constructor(e,t,r){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[i]=Ji(this.inputShape,[1]);this.outputShape=i.length===0?[1]:i,e.inSize>=32768&&r>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const r=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const i=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${r}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${kt("index")} {
         let outputIndex = index / ${r};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${r}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${r}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${r}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${i}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q4e={mean:"float32",all:"bool",any:"bool"};function Gy(n,e,t,r,i){const s=n.shape.length,o=[],a=An(e,n.shape);let l=a;const c=Lr(l,s);let u=n;c!=null&&(u=Ch({inputs:{x:n},attrs:{perm:c},backend:i}),l=ni(l.length,s),o.push(u)),hs(r,l,s);const[h,f]=Ji(u.shape,l);let d=h;t&&(d=Fi(h,a));let p;if((r==="max"||r==="prod")&&i.shouldExecuteOnCPU([u])){const m=i.tensorMap.get(u.dataId).values;switch(r){case"max":const g=p4e(m,Ee(f),d,n.dtype);p=i.makeTensorInfo(d,n.dtype,g);break;case"prod":const{outVals:y,outShape:b,outDtype:_}=w4e(u.shape,u.dtype,m,l);p=i.makeTensorInfo(b,_,y);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}else{const m=Ee(f),y=Ee(u.shape)/m,b={windowSize:m,inSize:m,batchSize:y,outSize:1},_=q4e[r]||U2(n.dtype),w=[{type:"int32",data:[m]}],S=new j4e(b,r,i.device.limits.maxComputeWorkgroupSizeX),C=i.runWebGPUProgram(S,[u],_,w);o.push(C),p=Xt({inputs:{x:C},attrs:{shape:d},backend:i})}return o.forEach(m=>i.disposeData(m.dataId)),p}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X4e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{keepDims:s,axis:o}=r;return Gy(i,o,s,"all",t)}const K4e={kernelName:US,backendName:"webgpu",kernelFunc:X4e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y4e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{keepDims:s,axis:o}=r;return Gy(i,o,s,"any",t)}const Z4e={kernelName:WS,backendName:"webgpu",kernelFunc:Y4e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oQ{constructor(e,t,r){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const i=[t];this.op=r==="min"?"<":">";const[s,o]=Ji(e,i);this.outputShape=s.length===0?[1]:s,this.dispatchLayout=Ot(this.outputShape),Ee(o)<32?(this.type="plain",this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Tt(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${Af(this.inputShape.length-1)}`,r=()=>{let i="";if(this.outputShape.length===1)this.inputShape.length!==1&&(i+="outputCoords,");else for(let s=0;s<this.outputShape.length;s++)i+=`outputCoords.${Af(s)},`;return i};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${kt("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${r()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${kt("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${r()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${r()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J4e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s}=r;let o=An(s,i.shape);const a=Lr(o,i.shape.length);let l=i;const c=[];a!=null&&(l=Ch({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=ni(o.length,l.shape.length)),hs("argMax",[o[0]],l.shape.length);const u=new oQ(l.shape,o[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],f=t.runWebGPUProgram(u,[l],"int32",h);return c.forEach(d=>t.disposeData(d.dataId)),f}const Q4e={kernelName:Iv,backendName:"webgpu",kernelFunc:J4e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s}=r;let o=An(s,i.shape);const a=Lr(o,i.shape.length);let l=i;const c=[];a!=null&&(l=Ch({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=ni(o.length,l.shape.length)),hs("argMin",[o[0]],l.shape.length);const u=new oQ(l.shape,o[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],f=t.runWebGPUProgram(u,[l],"int32",h);return c.forEach(d=>t.disposeData(d.dataId)),f}const tVe={kernelName:Av,backendName:"webgpu",kernelFunc:eVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nVe=gr({opType:vt.ASIN}),rVe={kernelName:Og,backendName:"webgpu",kernelFunc:nVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iVe=gr({opType:vt.ASINH}),sVe={kernelName:Fg,backendName:"webgpu",kernelFunc:iVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oVe=gr({opType:vt.ATAN}),aVe={kernelName:Lg,backendName:"webgpu",kernelFunc:oVe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lVe=Xs({opType:vn.ATAN2}),cVe={kernelName:Bg,backendName:"webgpu",kernelFunc:lVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uVe=gr({opType:vt.ATANH}),hVe={kernelName:zg,backendName:"webgpu",kernelFunc:uVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fVe{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A_{constructor(e,t,r=!1,i=!1,s=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=r,this.flattenPositions=i,this.includeBatchIndex=s,this.shaderKey=`pool2D_${t}_${r}_${i}_${s}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}class dB{constructor(e,t,r=!1,i=!1,s=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=r,this.flattenPositions=i,this.includeBatchIndex=s,this.shaderKey=`pool3D_${t}_${r}_${i}_${s}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{reductionIndices:s,keepDims:o}=r;return Gy(i,s,o,"max",t)}const dVe={kernelName:ew,backendName:"webgpu",kernelFunc:aQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{keepDims:s,axis:o}=r;return Gy(i,o,s,"mean",t)}const pVe={kernelName:rw,backendName:"webgpu",kernelFunc:lQ};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cQ(n,e,t,r){if(e.filterWidth===1&&e.filterHeight===1&&Rn(e.inShape,e.outShape))return Xa({inputs:{x:n},backend:r});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const o=n.shape.length,a=Xt({inputs:{x:n},backend:r,attrs:{shape:[n.shape[o-3]*n.shape[o-2],n.shape[o-1]]}});let l;t==="avg"?l=lQ({inputs:{x:a},backend:r,attrs:{axis:0,keepDims:!1}}):(U(t==="max",()=>`Invalid pool type ${t}`),l=aQ({inputs:{x:a},backend:r,attrs:{reductionIndices:0,keepDims:!1}}));const c=Xt({inputs:{x:l},backend:r,attrs:{shape:e.outShape}});return r.disposeData(a.dataId),r.disposeData(l.dataId),c}let i;const s=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?i=new fVe(e):(t==="avg"?i=new A_(e,"avg"):(U(t==="max",()=>`Invalid pool type ${t}`),i=new A_(e,"max")),s.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),r.runWebGPUProgram(i,[n],n.dtype,s)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=r,c=1,u=ko(i.shape,s,o,c,a,l);return cQ(i,u,"avg",t)}const gVe={kernelName:Mv,backendName:"webgpu",kernelFunc:mVe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{filterSize:s,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],h=Ll(i.shape,s,o,u,a,c,l),f=new dB(h,"avg"),d=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return t.runWebGPUProgram(f,[i],i.dtype,d)}const bVe={kernelName:Nv,backendName:"webgpu",kernelFunc:yVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vVe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class wVe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xVe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=Ll(o.shape,a,l,1,c,u),f=new wVe(h),d=1/(h.filterDepth*h.filterHeight*h.filterWidth),p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[d]}];return t.runWebGPUProgram(f,[i],o.dtype,p)}const _Ve={kernelName:GS,backendName:"webgpu",kernelFunc:xVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SVe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,o=s;rQ([i,s],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=ko(o.shape,a,l,1,c),h=new vVe(u),f=1/(u.filterHeight*u.filterWidth),d=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.effectiveFilterHeight-1-u.padInfo.top,u.effectiveFilterWidth-1-u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"float32",data:[f]}];return t.runWebGPUProgram(h,[i],o.dtype,d)}const CVe={kernelName:HS,backendName:"webgpu",kernelFunc:SVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kVe(n){const{inputs:e,backend:t,attrs:r}=n,{a:i,b:s}=e,{transposeA:o,transposeB:a}=r;return ON({a:i,b:s,transposeA:o,transposeB:a,backend:t})}const TVe={kernelName:$v,backendName:"webgpu",kernelFunc:kVe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EVe{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Ki(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Ki(this.rank),t=IVe(this.rank);let r;return this.start.length===1?r=this.outputShape.map((s,o)=>"sourceLoc = uniforms.start + coords;"):r=this.outputShape.map((s,o)=>`sourceLoc.${ND[o]} = uniforms.start.${Af(o)} + coords.${ND[o]};`),`
      ${kt("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${r.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}}const ND=["x","y","z","w","u","v"];function IVe(n){if(n===1)return"sourceLoc";if(n<=6)return ND.slice(0,n).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uw(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{begin:s,size:o}=r,[a,l]=oC(i,s,o);if(oN(i,a,l),t.shouldExecuteOnCPU([i])||i.dtype==="string"){const h=t.tensorMap.get(i.dataId),f=k4e(h.values,a,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,f)}if(Ee(l)===0)return t.makeTensorInfo(l,i.dtype,[]);const c=new EVe(a,l),u=[{type:"int32",data:a}];return t.runWebGPUProgram(c,[i],i.dtype,u)}const AVe={kernelName:vw,backendName:"webgpu",kernelFunc:Uw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MVe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockShape:s,crops:o}=r;U(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=s.reduce((b,_)=>b*_),l=Oy(i.shape,s,a),c=Fy(l.length,s.length),u=Ly(i.shape,s,a),h=fN(o,s.length),f=dN(u,o,s.length),d=[],p=Xt({inputs:{x:i},backend:t,attrs:{shape:l}}),m=Ch({inputs:{x:p},backend:t,attrs:{perm:c}}),g=Xt({inputs:{x:m},backend:t,attrs:{shape:u}}),y=Uw({inputs:{x:g},backend:t,attrs:{begin:h,size:f}});return d.push(p),d.push(m),d.push(g),d.forEach(b=>t.disposeData(b.dataId)),y},NVe={kernelName:Rv,backendName:"webgpu",kernelFunc:MVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Ve=`
  fn bincount_write(index: i32, value: f32) {
    ${Mp("&result[index]","value","float32")}
  }
`,RVe=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class uQ{constructor(e,t,r=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=r,r&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?RVe:$Ve}
  ${kt("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,weights:s}=e,{size:o}=r,a=Ee(i.shape),c=Ee(s.shape)>0,u=[o],h=s.dtype,f=wa({backend:t,attrs:{shape:u,value:0,dtype:h}}),d=new uQ([a],c),p=[{type:"int32",data:[o]}],m=c?[i,s]:[i];return t.runWebGPUProgram(d,m,h,p,f)}const DVe={kernelName:jS,backendName:"webgpu",kernelFunc:PVe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OVe{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${kt("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FVe(n){const{inputs:e,backend:t}=n,{s0:r,s1:i}=e;if(t.shouldExecuteOnCPU([r,i])){const u=t.tensorMap.get(r.dataId),h=t.tensorMap.get(i.dataId),f=u.values,d=h.values,p=ln(Array.from(f),Array.from(d));return t.makeTensorInfo([p.length],"int32",Int32Array.from(p))}const s=Ee(r.shape),o=Ee(i.shape),a=Math.max(s,o),l=new OVe(a),c=[{type:"int32",data:[s]},{type:"int32",data:[o]}];return t.runWebGPUProgram(l,[r,i],"int32",c)}const LVe={kernelName:XS,backendName:"webgpu",kernelFunc:FVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hQ=Xs({opType:vn.NOT_EQUAL,dtype:"bool",cpuKernelImpl:v4e}),zVe={kernelName:aw,backendName:"webgpu",kernelFunc:hQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mC(n){const{inputs:e,backend:t}=n,{input:r}=e,i=t.tensorMap.get(r.dataId);return Xa({inputs:{x:i.complexTensorInfos.real},backend:t})}const BVe={kernelName:C2,backendName:"webgpu",kernelFunc:mC};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VVe(n,e){const t=new Vw(n.shape,vt.TO_INT),r=e.runWebGPUProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $D(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{dtype:s}=r;if(s==="complex64"){if(i.dtype==="complex64")return Xa({inputs:{x:i},backend:t});const o=pi(i.shape),a=$D({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),l=Hy({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeData(a.dataId),l}if(i.dtype==="complex64"){const o=mC({inputs:{input:i},backend:t}),a=$D({inputs:{x:o},backend:t,attrs:{dtype:s}});return t.disposeData(o.dataId),a}if(!vM(i.dtype,s)){const o=Xa({inputs:{x:i},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:s}}if(t.shouldExecuteOnCPU([i])){const o=t.tensorMap.get(i.dataId).values,[a,l,c]=QBe(o,i.shape,i.dtype,s);return t.makeTensorInfo(a,l,c)}if(s==="int32")return VVe(i,t);if(s==="bool"){const o=t.makeTensorInfo([],"bool",cs("bool",1)),l=hQ({inputs:{a:i,b:o},backend:t});return t.disposeData(o.dataId),l}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${s}`)}const UVe={kernelName:Vg,backendName:"webgpu",kernelFunc:$D};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WVe=gr({opType:vt.CEIL,cpuKernelImpl:e4e}),HVe={kernelName:Ug,backendName:"webgpu",kernelFunc:WVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GVe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${kt("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jVe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${kt("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{clipValueMin:s,clipValueMax:o}=r;let a;const l=[{type:"float32",data:[s]},{type:"float32",data:[o]}];return Ee(i.shape)%4===0?a=new GVe(i.shape):a=new jVe(i.shape),t.runWebGPUProgram(a,[i],i.dtype,l)}const XVe={kernelName:Wg,backendName:"webgpu",kernelFunc:qVe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KVe{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jH(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function YVe(n){const{inputs:e,backend:t}=n,{x:r}=e,i=t.tensorMap.get(r.dataId),s=new KVe(r.shape),o=[jH(r,i.complexTensorInfos.real),jH(r,i.complexTensorInfos.imag)];return t.runWebGPUProgram(s,o,o[0].dtype)}const ZVe={kernelName:Pv,backendName:"webgpu",kernelFunc:YVe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JVe{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=va(e,1),this.variableNames=e.map((t,r)=>`T${r}`),this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let s=1;s<this.offsetLength;s++)e.push(`else if (yC < uniforms.offset${[s]}){ setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${s-1})); }`);const r=this.offsetLength,i=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${r}(yR, yC - uniforms.offset${i})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${kt("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FN(n){const{inputs:e,backend:t}=n,{input:r}=e,i=t.tensorMap.get(r.dataId);return Xa({inputs:{x:i.complexTensorInfos.imag},backend:t})}const QVe={kernelName:p2,backendName:"webgpu",kernelFunc:FN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _1(n,e,t){const r=n[0].dtype;if(r==="complex64"){const p=n.map(_=>mC({inputs:{input:_},backend:t})),m=n.map(_=>FN({inputs:{input:_},backend:t})),g=_1(p,e,t),y=_1(m,e,t),b=Hy({inputs:{real:g,imag:y},backend:t});return p.forEach(_=>t.disposeData(_.dataId)),m.forEach(_=>t.disposeData(_.dataId)),t.disposeData(g.dataId),t.disposeData(y.dataId),b}let i=t.shouldExecuteOnCPU(n);if(r==="string"&&(i=!0),i){const p=n.map(S=>{const k=[-1,Ee(S.shape.slice(e))];return Xt({inputs:{x:S},backend:t,attrs:{shape:k}})}),m=p.map(S=>({vals:t.readSync(S.dataId),shape:S.shape})),g=va(p.map(S=>S.shape),1),y=p[0].shape[0]===1,b=t4e(m,g,r,y),_=va(n.map(S=>S.shape),e),w=t.makeTensorInfo(_,r,b);return p.forEach(S=>t.disposeData(S.dataId)),w}const s=t.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>s){const p=[];for(let g=0;g<n.length;g+=s){const y=n.slice(g,g+s);p.push(_1(y,e,t))}const m=_1(p,e,t);for(const g of p)t.disposeData(g.dataId);return m}const{tensors2D:o,outShape:a}=eUe(n,e,t),l=o.map(p=>p.shape),c=new JVe(l),u=[],h=new Array(l.length-1);if(h.length>0){h[0]=l[0][1],u.push({type:"int32",data:[h[0]]});for(let p=1;p<h.length;p++)h[p]=h[p-1]+l[p][1],u.push({type:"int32",data:[h[p]]})}const f=t.runWebGPUProgram(c,o,o[0].dtype,u);o.forEach(p=>t.disposeData(p.dataId));const d=Xt({inputs:{x:f},backend:t,attrs:{shape:a}});return t.disposeData(f.dataId),d}function eUe(n,e,t){const r=va(n.map(s=>s.shape),e);return{tensors2D:n.map(s=>Xt({inputs:{x:s},backend:t,attrs:{shape:[Ee(s.shape.slice(0,e)),Ee(s.shape.slice(e))]}})),outShape:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fQ(n){const{inputs:e,backend:t,attrs:r}=n,{axis:i}=r,s=An(i,e[0].shape)[0],o=e.map(c=>c.shape);cN(o,s);const a=va(e.map(c=>c.shape),s);if(Ee(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>Ee(c.shape)>0);return l.length===1?Xa({inputs:{x:l[0]},backend:t}):_1(l,s,t)}const tUe={kernelName:Dv,backendName:"webgpu",kernelFunc:fQ};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nUe(n,e,t,r,i=!1,s=null,o=!1,a=4,l=4,c=4){const u=M=>{switch(M){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${M} is not supported.`)}},h=M=>{switch(M){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${M} is not supported.`)}},f=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,d=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,p=n?"uniforms.xShape[1]":"uniforms.xShape[2]",m=n?"uniforms.xShape[2]":"uniforms.xShape[3]",g=n?"row":"col",y=n?"col":"row",b=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${g} / outWidth;
      let outCol = ${g} % outWidth;

      let WRow = ${y} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${y} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${y} % inChannels;
      var resData = ${Un(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${m}) {
        ${f}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${u(a)}
      }
      return resData;`,_=n?e&&r?`
      ${b}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${b}
      }
      return ${Un(a)}(0.0);`:r&&t?`
      ${b}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${b}
      }
      return ${Un(a)}(0.0);`,w=`${h(l)}`,S=Un(c),C=Un(n?a:l),k=Un(n?l:a);return`
      ${jf(s,o,c===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${C} {
        ${n?_:w}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${k} {
        ${n?w:_}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${S}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${d}
        ${Wy(i,s)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class rUe{constructor(e,t,r,i,s=!1,o=null,a=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=eQ(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=tQ(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),s&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],s&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=s,this.activation=o,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=r%this.tileBOuter===0,this.fitInner=i%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?PN(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):DN(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${nUe(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iUe{constructor(e,t=!1,r=null,i=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=r,this.hasPreluActivationWeights=i,t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${jf(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Wy(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${kt("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sUe{constructor(e,t){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,r=this.isChannelsLast?"coords[1]":"coords[2]",i=this.isChannelsLast?"coords[2]":"coords[1]",s=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${kt("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${r};
        let col = ${i};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${s};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OI(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function oUe({x:n,filter:e,convInfo:t,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const l=t.dataFormat==="channelsLast",c=!l,u=!1,h=l&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",f=[];let d,p;if(h){const y=t.inHeight*t.inWidth*t.inChannels;d=Xt({inputs:{x:n},backend:r,attrs:{shape:[1,t.batchSize,y]}}),p=Xt({inputs:{x:e},backend:r,attrs:{shape:[1,y,t.outChannels]}})}else d=Xt({inputs:{x:n},backend:r,attrs:{shape:l?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),p=Xt({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(f.push(d),f.push(p),s!=null){const y=OI(s.shape,l);y!=null&&(s=Xt({inputs:{x:s},backend:r,attrs:{shape:y}}),f.push(s))}if(i!=null){const y=OI(i.shape,l);y!=null&&(i=Xt({inputs:{x:i},backend:r,attrs:{shape:y}}),f.push(i))}const m=ON({a:l?d:p,b:l?p:d,transposeA:c,transposeB:u,backend:r,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),g=Xt({inputs:{x:m},backend:r,attrs:{shape:t.outShape}});f.push(m);for(const y of f)r.disposeData(y.dataId);return g}function aUe({x:n,filter:e,convInfo:t,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,strideWidth:h,strideHeight:f,padInfo:d,outWidth:p,outHeight:m,dilationWidth:g,dilationHeight:y,dataFormat:b}=t,_=b==="channelsLast",w=l*c*u,S=m*p,C=_?[t.batchSize,S,w]:[t.batchSize,w,S],k=new sUe(C,_),A=[{type:"int32",data:[d.top,d.left]},{type:"int32",data:[f,h]},{type:"int32",data:[y,g]},{type:"int32",data:[p]},{type:"int32",data:[u*l]},{type:"int32",data:[u]}],M=r.runWebGPUProgram(k,[n],n.dtype,A),E=[];E.push(M);const N=Xt({inputs:{x:e},backend:r,attrs:{shape:[1,w,-1]}});if(E.push(N),s!=null){const B=OI(s.shape,_);B!=null&&(s=Xt({inputs:{x:s},backend:r,attrs:{shape:B}}),E.push(s))}if(i!=null){const B=OI(i.shape,_);B!=null&&(i=Xt({inputs:{x:i},backend:r,attrs:{shape:B}}),E.push(i))}const D=ON({a:_?M:N,b:_?N:M,transposeA:!_,transposeB:!1,backend:r,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),z=Xt({inputs:{x:D},backend:r,attrs:{shape:t.outShape}});E.push(D);for(const B of E)r.disposeData(B.dataId);return z}function dQ({x:n,filter:e,convInfo:t,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const l=i!=null,c=s!=null,u=t.dataFormat==="channelsLast",h=u&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",f=Ie().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!f&&(h||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return oUe({x:n,filter:e,convInfo:t,backend:r,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o});const d=Ie().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),p=d>-1?d:r.thresholdToIncreaseWorkgroups,m=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if(Ie().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||m<=p)return aUe({x:n,filter:e,convInfo:t,backend:r,bias:i,preluActivationWeights:s,leakyreluAlpha:o,activation:a});let g;const y=[t.padInfo.top,t.padInfo.left],b=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...y]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(f)g=new iUe(t,l,a,c);else{const C=u?t.outHeight*t.outWidth:t.outChannels,k=u?t.outChannels:t.outHeight*t.outWidth,A=t.filterHeight*t.filterWidth*t.inChannels;b.push({type:"int32",data:[C]},{type:"int32",data:[k]},{type:"int32",data:[A]});const M=r.adapterInfo.isIntel();g=new rUe(t,C,k,A,l,a,c,M)}const _=[],w=[n,e];l&&(!u&&i.shape.length===1&&(i=Xt({inputs:{x:i},backend:r,attrs:{shape:[i.shape[0],1,1]}}),_.push(i)),w.push(i)),c&&(!u&&s.shape.length===1&&(s=Xt({inputs:{x:s},backend:r,attrs:{shape:[s.shape[0],1,1]}}),_.push(s)),w.push(s)),a==="leakyrelu"&&(b.push({type:"float32",data:[o]}),g.uniforms+=" alpha : f32,");const S=r.runWebGPUProgram(g,w,n.dtype,b);for(const C of _)r.disposeData(C.dataId);return S}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lUe(n){const{inputs:e,attrs:t,backend:r}=n,{x:i,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=t,h=el(l),f=ti(i.shape,s.shape,o,c,a,u,!1,h);return dQ({x:i,filter:s,convInfo:f,backend:r})}const cUe={kernelName:Ov,backendName:"webgpu",kernelFunc:lUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uUe{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,r=this.isChannelsLast?3:1,i=`
    ${kt()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${i}
    `:`
    ${kt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${r}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class hUe{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${kt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class fUe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${kt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class dUe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${kt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,h=el(l),f=ti(i.shape,u,o,1,a,c,!1,h),d=new hUe(f),p=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.inHeight]},{type:"int32",data:[f.inWidth]}];return t.runWebGPUProgram(d,[i,s],i.dtype,p)}const mUe={kernelName:YS,backendName:"webgpu",kernelFunc:pUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gUe(n=4){const e=s=>{switch(s){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${s} is not supported.`)}},r=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Un(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Un(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${Un(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${Un(n)} {
    ${r}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${Un(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(n)}
    }
    return ${Un(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${Un(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class yUe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,U(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=eQ(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=tQ(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?PN(this.elementsPerThread,this.workgroupSize):DN(this.elementsPerThread,this.workgroupSize);return`
    ${gUe(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bUe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,h=el(c),f=ti(o,s.shape,a,1,l,u,!1,h),d=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize,f.outHeight,f.outWidth,f.outChannels]}];let p;if(Ie().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||f.dataFormat!=="channelsLast")p=new uUe(f);else{p=new yUe(f);const m=f.inHeight*f.inWidth,g=f.inChannels,y=f.filterHeight*f.filterWidth*f.outChannels;d.push({type:"uint32",data:[m]},{type:"uint32",data:[g]},{type:"uint32",data:[y]})}return t.runWebGPUProgram(p,[i,s],"float32",d)}const vUe={kernelName:Fv,backendName:"webgpu",kernelFunc:bUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wUe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:o,pad:a,dilations:l}=r,c=Fu(i.shape,s.shape,o,l,a),u=[c.padInfo.front,c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationDepth,c.dilationHeight,c.dilationWidth]}],f=new wUe(c),d=As(i.dtype,s.dtype);return t.runWebGPUProgram(f,[i,s],d,h)}const _Ue={kernelName:Lv,backendName:"webgpu",kernelFunc:xUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:o,pad:a,filterShape:l}=r,c=Fu(i.shape,l,o,1,a),u=new fUe(c),h=[{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inDepth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return t.runWebGPUProgram(u,[i,s],s.dtype,h)}const CUe={kernelName:ZS,backendName:"webgpu",kernelFunc:SUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kUe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{strides:o,pad:a,inputShape:l}=r,c=Fu(l,s.shape,o,1,a),u=new dUe(c),h=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterDepth-1-c.padInfo.front,c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels]}];return t.runWebGPUProgram(u,[i,s],i.dtype,h)}const TUe={kernelName:JS,backendName:"webgpu",kernelFunc:kUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EUe=gr({opType:vt.COS}),IUe={kernelName:Hg,backendName:"webgpu",kernelFunc:EUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AUe=gr({opType:vt.COSH}),MUe={kernelName:Gg,backendName:"webgpu",kernelFunc:AUe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NUe{constructor(e,t,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[s]=t;this.outputShape=[s,r[0],r[1],e],this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=i==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[r,i,s]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[o,a,l]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${r});
        let width_ratio = f32(${o});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${i};
        let width_scale = ${a};
        let in_y = ${s};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Ue=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:i,boxes:s,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=r,u=new NUe(i.shape[3],s.shape,a,l),h=[{type:"float32",data:[c]}];return t.runWebGPUProgram(u,[i,s,o],"float32",h)},RUe={kernelName:e2,backendName:"webgpu",kernelFunc:$Ue};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var M_;(function(n){n.Prod="*",n.Sum="+"})(M_||(M_={}));class qH{constructor(e,t,r,i){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=r,this.reverse=i,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===M_.Prod?"1.0":"0.0",r=this.exclusive?t:`getX(${XH(e,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1];let s="",o="";return this.exclusive?(s=this.reverse?`end != ${i-1}`:"end != 0",o=this.reverse?"end + 1":"end - 1"):(s=this.reverse?`end + pow2 < ${i}`:"end >= pow2",o=this.reverse?"end + pow2":"end - pow2"),`
      ${kt("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${KH(e,"coords",this.op)};
         var val = ${r};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${s}) {
           let idx = ${o};
           ${KH(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${XH(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function XH(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function KH(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pQ(n,e,t,r,i,s){const o=e.shape.length,a=Lr([r],o);let l=e;a!=null&&(l=Ch({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=ni(1,o)[0];if(c!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const u=l.shape[c];let h=Xa({inputs:{x:l},backend:t});for(let f=0;f<=Math.ceil(Math.log2(u))-1;f++){const d=new qH(n,l.shape,!1,s),p=h,m=[{type:"float32",data:[f]}];h=t.runWebGPUProgram(d,[h],h.dtype,m),t.disposeData(p.dataId)}if(i){const f=new qH(n,l.shape,i,s),d=h,p=[{type:"float32",data:[0]}];h=t.runWebGPUProgram(f,[h],h.dtype,p),t.disposeData(d.dataId)}if(a!=null){const f=Ph(a),d=Ch({inputs:{x:h},backend:t,attrs:{perm:f}});return t.disposeData(h.dataId),t.disposeData(l.dataId),d}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,exclusive:o,reverse:a}=r;return pQ(M_.Prod,i,t,s,o,a)}const DUe={kernelName:QS,backendName:"webgpu",kernelFunc:PUe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,exclusive:o,reverse:a}=r;return pQ(M_.Sum,i,t,s,o,a)}const FUe={kernelName:zv,backendName:"webgpu",kernelFunc:OUe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,weights:s}=e,{size:o,binaryOutput:a}=r,l=i.shape.length===1,u=Ee(s.shape)>0,h=s.dtype,f=l?[i.shape[0]]:[i.shape[0],i.shape[1]],d=l?[o]:[i.shape[0],o],p=wa({backend:t,attrs:{shape:d,value:0,dtype:h}}),m=new uQ(f,u,a),g=[{type:"int32",data:[o]}],y=u?[i,s]:[i];return t.runWebGPUProgram(m,y,h,g,p)}const zUe={kernelName:t2,backendName:"webgpu",kernelFunc:LUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BUe{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockSize:s,dataFormat:o}=r,a=i.shape[0],l=o==="NHWC"?i.shape[1]:i.shape[2],c=o==="NHWC"?i.shape[2]:i.shape[3],u=o==="NHWC"?i.shape[3]:i.shape[1],h=l*s,f=c*s,d=u/(s*s),p=o==="NHWC"?[a,h,f,d]:[a,d,h,f],m=[{type:"int32",data:[s]}],g=new BUe(p,o);return t.runWebGPUProgram(g,[i],i.dtype,m)}const UUe={kernelName:n2,backendName:"webgpu",kernelFunc:VUe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WUe{constructor(e,t,r,i=!1,s=null,o=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.addBias=i,this.activation=s,this.hasPreluActivation=o,this.filterHeight=t,this.filterWidth=r,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],r=this.workgroupSize[1]+this.filterHeight-1,i=this.workgroupSize[0]+this.filterWidth-1;return`
      ${jf(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${i}>, ${r}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${kt()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${i}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Wy(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mQ{constructor(e,t=!1,r=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const s=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=Ot(s),this.dispatch=Tt(this.dispatchLayout,s,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),U(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivation=i,this.shaderKey=`depthwiseVec4_${r}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,r=this.convInfo.strideWidth;return`
      ${jf(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${kt("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${r}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${r} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Wy(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gQ{constructor(e,t=!1,r=null,i=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivation=i,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${jf(this.activation,this.hasPreluActivation,!1,4)}

      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Wy(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,h=el(l);let f=c;f==null&&(f=[1,1]);const d=ti(i.shape,s.shape,o,f,a,u,!0,h),p=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inHeight,d.inWidth]}],m=d.dataFormat==="channelsLast";let g;return!m&&d.inHeight>16&&d.inWidth>16&&d.strideHeight===1&&d.strideWidth===1&&d.dilationWidth===1&&d.dilationHeight===1&&d.inChannels===d.outChannels?g=new WUe(d.outShape,d.filterHeight,d.filterWidth):m&&d.outHeight>4&&d.outWidth>4&&d.strideWidth<=2&&d.inChannels===d.outChannels&&d.dilationHeight===1&&d.dilationWidth===1&&d.inChannels%4===0?(g=new mQ(d),p.push({type:"int32",data:[g.virtualWidth]})):(g=new gQ(d),p.push({type:"int32",data:[d.filterHeight]},{type:"int32",data:[d.filterWidth]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]})),t.runWebGPUProgram(g,[i,s],i.dtype,p)}const GUe={kernelName:Bv,backendName:"webgpu",kernelFunc:HUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jUe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class qUe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,h=ti(i.shape,u,o,a,l,c,!0),f=new jUe(h),d=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return t.runWebGPUProgram(f,[i,s],"float32",d)}const KUe={kernelName:r2,backendName:"webgpu",kernelFunc:XUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YUe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,h=ti(u,s.shape,o,a,l,c,!0),f=new qUe(h),d=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return t.runWebGPUProgram(f,[i,s],i.dtype,d)}const ZUe={kernelName:i2,backendName:"webgpu",kernelFunc:YUe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JUe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QUe(n){const{inputs:e,backend:t}=n,{x:r}=e,i=[...r.shape,...r.shape],s=Ee(r.shape),o=Xt({inputs:{x:r},backend:t,attrs:{shape:[s]}}),a=new JUe(s),l=t.runWebGPUProgram(a,[o],o.dtype),c=Xt({inputs:{x:l},backend:t,attrs:{shape:i}});return t.disposeData(o.dataId),t.disposeData(l.dataId),c}const eWe={kernelName:s2,backendName:"webgpu",kernelFunc:QUe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tWe{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${kt("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:o,pad:a,dilations:l}=r,c=kp(i.shape,s.shape,o,a,"NHWC",l),u=[c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],f=new tWe(c);return t.runWebGPUProgram(f,[i,s],i.dtype,h)}const rWe={kernelName:Vv,backendName:"webgpu",kernelFunc:nWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iWe{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(e.outShape),this.dispatch=Tt(this.dispatchLayout,e.outShape,this.workgroupSize),t!=="float32"&&t!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${kt("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Mp("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class sWe{constructor(e,t,r){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ot(e.outShape),this.dispatch=Tt(this.dispatchLayout,e.outShape,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${r} type.`);this.type=r,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${kt("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Mp("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s,dy:o}=e,{strides:a,pad:l,dilations:c}=r,u=kp(i.shape,s.shape,a,l,"NHWC",c),h=s.dtype,f=new sWe(u,s.shape,h),d=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[Ee(u.outShape)]}],p=wa({backend:t,attrs:{shape:s.shape,value:0,dtype:h}});return t.runWebGPUProgram(f,[i,s,o],h,d,p)}const aWe={kernelName:d_,backendName:"webgpu",kernelFunc:oWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s,dy:o}=e,{strides:a,pad:l,dilations:c}=r,u=kp(i.shape,s.shape,a,l,"NHWC",c),h=i.dtype,f=new iWe(u,h),d=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[Ee(u.outShape)]}],p=wa({backend:t,attrs:{shape:u.inShape,value:0,dtype:h}});return t.runWebGPUProgram(f,[i,s,o],h,d,p)}const cWe={kernelName:f_,backendName:"webgpu",kernelFunc:lWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uWe{constructor(e,t,r){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=nv.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=r,this.shaderKey=`draw_${t}_${r}`}getUserCode(){let e;const t=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${kt("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hWe(n){const{inputs:e,backend:t,attrs:r}=n,{image:i}=e,{canvas:s,options:o}=r,[a,l]=i.shape.slice(0,2),{imageOptions:c}=o||{},u=(c==null?void 0:c.alpha)||1,h=t.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",f=[a,l],d=new uWe(f,i.dtype,h);s.width=l,s.height=a;const p="webgpu";let m=s.getContext(p),g;m||(g=new OffscreenCanvas(l,a),m=g.getContext(p));const y=i.shape.length===3?i.shape[2]:1;m.configure({device:t.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const b="int32",_=t.makeTensorInfo(f,b),w=t.tensorMap.get(_.dataId);w.resource=m.getCurrentTexture(),w.external=!0;const S=[{type:"uint32",data:[y]},{type:"float32",data:[u]}];if(t.runWebGPUProgram(d,[i],b,S,_),g){const C=s.getContext("2d");if(!C)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");C.drawImage(g,0,0)}return t.disposeData(_.dataId),i}const fWe={kernelName:o2,backendName:"webgpu",kernelFunc:hWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yQ=Xs({opType:vn.MUL,cpuKernelImpl:y4e,supportsComplex:!0}),dWe={kernelName:cy,backendName:"webgpu",kernelFunc:yQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:o}=r;return Gy(i,s,o,"sum",t)}const pWe={kernelName:ww,backendName:"webgpu",kernelFunc:bQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mWe(n){const{inputs:e,backend:t,attrs:r}=n,{equation:i}=r,s=e,{allDims:o,summedDims:a,idDims:l}=wN(i,s.length);_N(o.length,l,s);const{path:c,steps:u}=SN(a,l),h=u.length;let f=null,d=o.length;const p=[];for(let m=0;m<h;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=xN(d,l[g]);let _;CN(y)?_=s[g]:(_=Ch({inputs:{x:s[g]},backend:t,attrs:{perm:y}}),p.push(_));const w=_.shape.slice();for(let S=0;S<b.length;++S)w.splice(b[S],0,1);Rn(_.shape,w)||(_=Xt({inputs:{x:_},backend:t,attrs:{shape:w}}),p.push(_)),f===null?f=_:(f=yQ({inputs:{a:_,b:f},backend:t}),p.push(f))}m<h-1&&(c[m]>=0&&(f=bQ({inputs:{x:f},backend:t,attrs:{axis:c[m]-(o.length-d),keepDims:!1}}),p.push(f)),d--)}for(const m of p)m!==f&&t.disposeData(m.dataId);return f}const gWe={kernelName:a2,backendName:"webgpu",kernelFunc:mWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yWe=gr({opType:vt.ELU}),bWe={kernelName:qg,backendName:"webgpu",kernelFunc:yWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vWe=n=>{const{inputs:e,backend:t}=n,{dy:r,y:i}=e,s=new DI(vn.ELU_DER,r.shape,i.shape);return t.runWebGPUProgram(s,[r,i],r.dtype)},wWe={kernelName:l2,backendName:"webgpu",kernelFunc:vWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xWe=Xs({opType:vn.EQUAL,dtype:"bool",cpuKernelImpl:n4e}),_We={kernelName:Uv,backendName:"webgpu",kernelFunc:xWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SWe=gr({opType:vt.ERF}),CWe={kernelName:Xg,backendName:"webgpu",kernelFunc:SWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kWe=gr({opType:vt.EXP,cpuKernelImpl:r4e,dtype:"float32"}),TWe={kernelName:Kg,backendName:"webgpu",kernelFunc:kWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RD(n){const{inputs:e,attrs:t,backend:r}=n,{dim:i}=t,{input:s}=e,o=s.shape.length,a=s.shape.slice();let l=i;return i<0&&(U(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),Xt({inputs:{x:s},backend:r,attrs:{shape:a}})}const EWe={kernelName:Wv,backendName:"webgpu",kernelFunc:RD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IWe=gr({opType:vt.EXPM1,cpuKernelImpl:i4e}),AWe={kernelName:Yg,backendName:"webgpu",kernelFunc:IWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YH{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vQ(n,e,t){const r=t.tensorMap.get(n.dataId),i=Ee(n.shape),s=n.shape[n.shape.length-1],o=i/s,a=[],l=Xt({inputs:{x:n},backend:t,attrs:{shape:[o,s]}});a.push(l);const c=l.shape,u=new YH("real",c),h=new YH("imag",c),f=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],d=e?2*Math.PI:-2*Math.PI,p=e?c[1]:1,m=[{type:"float32",data:[d]},{type:"float32",data:[p]}],g=t.runWebGPUProgram(u,f,"float32",m);a.push(g);const y=t.runWebGPUProgram(h,f,"float32",m);a.push(y);const b=Hy({inputs:{real:g,imag:y},backend:t});a.push(b);const _=Xt({inputs:{x:b},backend:t,attrs:{shape:n.shape}});return a.forEach(w=>t.disposeData(w.dataId)),_}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MWe(n){const{inputs:e,backend:t}=n,{input:r}=e;return vQ(r,!1,t)}const NWe={kernelName:c2,backendName:"webgpu",kernelFunc:MWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $We{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RWe={kernelName:h2,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,i=new $We(t.shape);return r.runWebGPUProgram(i,[t],t.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PWe=gr({opType:vt.FLOOR,cpuKernelImpl:s4e}),DWe={kernelName:Zg,backendName:"webgpu",kernelFunc:PWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OWe=Xs({opType:vn.FLOOR_DIV,cpuKernelImpl:o4e,dtype:"int32"}),FWe={kernelName:Jg,backendName:"webgpu",kernelFunc:OWe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LWe{constructor(e,t,r=!1){this.pixelsOpType=nv.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=r,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${kt("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zWe={kernelName:p_,backendName:"webgpu",kernelFunc:BWe};let I0,h3=Ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function BWe(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:i}=e;const{numChannels:s}=r;if(i==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&i instanceof OffscreenCanvas,c=typeof ImageBitmap<"u"&&i instanceof ImageBitmap,[u,h]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],f=[h,u,s],d=!1,p=o||a;if(c||l||p){let b;{if(p){const R=Ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(I0==null||R!==h3)&&(h3=R,I0=document.createElement("canvas").getContext("2d",{willReadFrequently:h3})),I0.canvas.width=u,I0.canvas.height=h,I0.drawImage(i,0,0,u,h),i=I0.canvas}const E=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,N="rgba8unorm",O=t.textureManager.acquireTexture(f[1],f[0],N,E);t.queue.copyExternalImageToTexture({source:i},{texture:O},[f[1],f[0]]),b=O}const _=Ee(f),w=Zt(f),S=new LWe(f,s,d),C=[{type:"uint32",data:[_]},{type:"uint32",data:[s]},{type:"uint32",data:[...w]}],k=t.makeTensorInfo([h,u],"int32"),A=t.tensorMap.get(k.dataId);A.resource=b;const M=t.runWebGPUProgram(S,[k],"int32",C);return t.disposeData(k.dataId),M}const m=i.data;let g=m;if(s!=null&&s!==4){g=new Uint8Array(i.width*i.height*s);const b=m.length;let _=0;for(let w=0;w<b;w++)w%4<s&&(g[_++]=m[w])}const y=t.makeTensorInfo(f,"int32",new Int32Array(g));return t.uploadToGPU(y.dataId),y}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VWe{constructor(e,t,r,i,s){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],ln(e,t),ln(e,r),this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),i!=null&&(ln(e,i),this.variableNames.push("offset")),s!=null&&(ln(e,s),this.variableNames.push("scale")),this.offsetShape=i,this.scaleShape=s,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${kt("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UWe={kernelName:Hv,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r,scale:i,offset:s,mean:o,variance:a}=n,{varianceEpsilon:l}=e,c=t,u=[r,o,a];let h=null;s!=null&&(h=s.shape,u.push(s));let f=null;i!=null&&(f=i.shape,u.push(i));const d=new VWe(r.shape,o.shape,a.shape,h,f),p=[{type:"float32",data:[l]}];return c.runWebGPUProgram(d,u,r.dtype,p)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r,m=el(u),g=ti(i.shape,s.shape,l,h,c,f,!1,m);return dQ({x:i,filter:s,convInfo:g,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:p,activation:d})}const HWe={kernelName:Ub,backendName:"webgpu",kernelFunc:WWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:f,leakyreluAlpha:d}=r;let p=u;p==null&&(p=[1,1]),U($s(l,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${p}'`);const m=ti(i.shape,s.shape,l,p,c,h,!0),g=[i,s],y=o!=null,b=a!=null;y&&g.push(o),b&&g.push(a);const _=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inHeight,m.inWidth]}];let w;return m.outHeight>4&&m.outWidth>4&&m.strideWidth<=2&&m.inChannels===m.outChannels&&m.dilationHeight===1&&m.dilationWidth===1&&m.inChannels%4===0?(w=new mQ(m,y,f,b),_.push({type:"int32",data:[w.virtualWidth]})):(w=new gQ(m,y,f,b),_.push({type:"int32",data:[m.filterHeight]},{type:"int32",data:[m.filterWidth]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]})),f==="leakyrelu"&&(_.push({type:"float32",data:[d]}),w.uniforms+=" alpha : f32,"),t.runWebGPUProgram(w,g,"float32",_)}const jWe={kernelName:Wb,backendName:"webgpu",kernelFunc:GWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qWe{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Ki(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XWe(n){const{inputs:e,backend:t}=n,{params:r,indices:i}=e,s=i.shape,o=s[s.length-1],a=Ee(r.shape),[l,c,u,h]=sC(r,i),f=Xt({inputs:{x:i},backend:t,attrs:{shape:[c,o]}}),d=Xt({inputs:{x:r},backend:t,attrs:{shape:[Ee(r.shape)/u,u]}});if(t.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const b=t.readSync(i.dataId),_=t.bufferSync(r),w=a4e(b,_,r.dtype,c,o,u,h,r.shape,a);return t.makeTensorInfo(l,r.dtype,w.values)}const p=new qWe(o,[c,u]),m=[{type:"int32",data:[o]},{type:"int32",data:h}],g=t.runWebGPUProgram(p,[d,f],d.dtype,m),y=Xt({inputs:{x:g},backend:t,attrs:{shape:l}});return t.disposeData(f.dataId),t.disposeData(d.dataId),t.disposeData(g.dataId),y}const KWe={kernelName:f2,backendName:"webgpu",kernelFunc:XWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YWe{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=ZWe(this.aShape);return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function ZWe(n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let r=0;r<n.length;r++)r===2?t.push("indexZ"):t.push(`${e[r]}`);return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,indices:s}=e,{axis:o,batchDims:a}=r,l=An(o,i.shape)[0],c=TN(i,s,l,a),u=Ee(s.shape),h=[],f=Xt({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=Xt({inputs:{x:s},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(f),h.push(d);const p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([i,s])){const _=t.tensorMap.get(d.dataId).values,w=Sn(d.shape,d.dtype,_),C=t.tensorMap.get(f.dataId).values,k=Sn(f.shape,f.dtype,C),A=l4e(k,w,p);return h.forEach(M=>t.disposeData(M.dataId)),t.makeTensorInfo(c.outputShape,A.dtype,A.values)}const m=new YWe(f.shape,p),g=t.runWebGPUProgram(m,[f,d],f.dtype);h.push(g);const y=Xt({inputs:{x:g},backend:t,attrs:{shape:c.outputShape}});return h.forEach(b=>t.disposeData(b.dataId)),y}const JWe={kernelName:Gv,backendName:"webgpu",kernelFunc:wQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QWe=Xs({opType:vn.GREATER,cpuKernelImpl:u4e,dtype:"bool"}),eHe={kernelName:jv,backendName:"webgpu",kernelFunc:QWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tHe=Xs({opType:vn.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:c4e}),nHe={kernelName:Qg,backendName:"webgpu",kernelFunc:tHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rHe(n){const{inputs:e,backend:t}=n,{input:r}=e;return vQ(r,!0,t)}const iHe={kernelName:d2,backendName:"webgpu",kernelFunc:rHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sHe=gr({opType:vt.IS_FINITE,dtype:"bool"}),oHe={kernelName:ty,backendName:"webgpu",kernelFunc:sHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aHe=gr({opType:vt.IS_INF,dtype:"bool"}),lHe={kernelName:ny,backendName:"webgpu",kernelFunc:aHe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cHe=gr({opType:vt.IS_NAN,dtype:"bool"}),uHe={kernelName:ry,backendName:"webgpu",kernelFunc:cHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{alpha:s}=r,o=[{type:"float32",data:[s]}],a=new Vw(i.shape,vt.LEAKYRELU,"alpha : f32,");return t.runWebGPUProgram(a,[i],"float32",o)}const fHe={kernelName:qv,backendName:"webgpu",kernelFunc:hHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dHe=Xs({opType:vn.LESS,dtype:"bool",cpuKernelImpl:f4e}),pHe={kernelName:Xv,backendName:"webgpu",kernelFunc:dHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mHe=Xs({opType:vn.LESS_EQUAL,dtype:"bool",cpuKernelImpl:h4e}),gHe={kernelName:Kv,backendName:"webgpu",kernelFunc:mHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yHe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bHe(n){const{backend:e,attrs:t}=n,{start:r,stop:i,num:s}=t,o=(i-r)/(s-1),a=new yHe(s),l=[{type:"float32",data:[r]},{type:"float32",data:[o]}];return e.runWebGPUProgram(a,[],"float32",l)}const vHe={kernelName:m2,backendName:"webgpu",kernelFunc:bHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wHe=gr({opType:vt.LOG,cpuKernelImpl:d4e}),xHe={kernelName:iy,backendName:"webgpu",kernelFunc:wHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _He=gr({opType:vt.LOG1P}),SHe={kernelName:sy,backendName:"webgpu",kernelFunc:_He};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CHe=Xs({opType:vn.LOGICAL_AND,dtype:"bool"}),kHe={kernelName:Yv,backendName:"webgpu",kernelFunc:CHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const THe=gr({opType:vt.LOGICAL_NOT}),EHe={kernelName:Zv,backendName:"webgpu",kernelFunc:THe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IHe=Xs({opType:vn.LOGICAL_OR}),AHe={kernelName:Jv,backendName:"webgpu",kernelFunc:IHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xQ=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class MHe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${xQ}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class NHe{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,U(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Tt(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${kt()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${xQ}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $He(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{depthRadius:s,bias:o,alpha:a,beta:l}=r;let c;s>16?c=new MHe(i.shape):c=new NHe(i.shape,s);const u=[{type:"int32",data:[s]},{type:"float32",data:[o]},{type:"float32",data:[a]},{type:"float32",data:[l]}];return t.runWebGPUProgram(c,[i],i.dtype,u)}const RHe={kernelName:Qv,backendName:"webgpu",kernelFunc:$He};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PHe{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,y:s,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=r,h=new PHe(i.shape),f=[{type:"int32",data:[a]},{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[u]}];return t.runWebGPUProgram(h,[i,s,o],i.dtype,f)}const OHe={kernelName:g2,backendName:"webgpu",kernelFunc:DHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FHe=Xs({opType:vn.MAX,cpuKernelImpl:m4e}),LHe={kernelName:oy,backendName:"webgpu",kernelFunc:FHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=r,c=1,u=ko(i.shape,s,o,c,a,l);return cQ(i,u,"max",t)}const BHe={kernelName:tw,backendName:"webgpu",kernelFunc:zHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{filterSize:s,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],h=Ll(i.shape,s,o,u,a,c,l),f=new dB(h,"max"),d=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return t.runWebGPUProgram(f,[i],i.dtype,d)}const UHe={kernelName:nw,backendName:"webgpu",kernelFunc:VHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WHe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class HHe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GHe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=[1,1,1],f=Ll(o.shape,a,l,h,c,u),d=new dB(f,"max",!0);let p=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.front,f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inDepth,f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]}];const m=t.runWebGPUProgram(d,[o],"int32",p),g=new HHe(f);p=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterDepth-1-f.padInfo.front,f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outDepth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]}];const y=t.runWebGPUProgram(g,[i,m],o.dtype,p);return t.disposeData(m.dataId),y}const jHe={kernelName:b2,backendName:"webgpu",kernelFunc:GHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qHe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s,output:o}=e,a=s;rQ([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,f=ko(a.shape,l,c,1,u,h),d=new A_(f,"max",!0);let p=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterHeight,f.effectiveFilterWidth]}];const m=t.runWebGPUProgram(d,[a],"int32",p),g=new WHe(f);p=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]}];const y=t.runWebGPUProgram(g,[i,m],a.dtype,p);return t.disposeData(m.dataId),y}const XHe={kernelName:y2,backendName:"webgpu",kernelFunc:qHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KHe(n){const{inputs:e,backend:t,attrs:r}=n,{filterSize:i,strides:s,pad:o,includeBatchInIndex:a}=r,{x:l}=e;U(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const c=[1,1];U($s(s,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`);const u=ko(l.shape,i,s,c,o),h=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]}];let f=new A_(u,"max",!1);const d=t.runWebGPUProgram(f,[l],l.dtype,h);f=new A_(u,"max",!0,!0,a);const p=t.runWebGPUProgram(f,[l],"int32",h);return[d,p]}const YHe={kernelName:v2,backendName:"webgpu",kernelFunc:KHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:o}=r;return Gy(i,s,o,"min",t)}const JHe={kernelName:iw,backendName:"webgpu",kernelFunc:ZHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QHe=Xs({opType:vn.MIN,cpuKernelImpl:g4e}),eGe={kernelName:ay,backendName:"webgpu",kernelFunc:QHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tGe{constructor(e,t,r){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((i,s)=>i[0]+e[s]+i[1]),this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((i,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.offset=r==="reflect"?0:1,this.shaderKey=`mirrorPad_${r}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map((c,u)=>`uniforms.pad${u}[0]`).join(","),r=this.xShape.map((c,u)=>`uniforms.pad${u}[0] + uniforms.xShape${e>1?`[${u}]`:""}`).join(","),i=e===1?"start":"start[i]",s=e===1?"end":"end[i]",o=e===1?"outC":"outC[i]",a=Ki(e),l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${t});
          let end = ${a}(${r});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${o} < ${i}) {
              ${o} = ${i} * 2 - ${o} - ${this.offset};
            } else if(${o} >= ${s}) {
              ${o} = (${s} - 1) * 2 - ${o} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nGe={kernelName:sw,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{paddings:i,mode:s}=e,o=t,a=i.map(u=>({type:"int32",data:[u[0],u[1]]})),l=new tGe(r.shape,i,s);return o.runWebGPUProgram(l,[r],r.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rGe=Xs({opType:vn.MOD}),iGe={kernelName:ly,backendName:"webgpu",kernelFunc:rGe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sGe{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${kt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oGe{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${kt("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Q(n){const{inputs:e,backend:t,attrs:r}=n,{logits:i}=e,{dim:s}=r,o=Xt({inputs:{x:i},backend:t,attrs:{shape:[Ee(i.shape)/i.shape[s],i.shape[s]]}}),a=new oGe(o.shape),l=t.runWebGPUProgram(a,[o],i.dtype),c=Xt({inputs:{x:l},backend:t,attrs:{shape:i.shape}});return t.disposeData(o.dataId),t.disposeData(l.dataId),c}const aGe={kernelName:Sw,backendName:"webgpu",kernelFunc:_Q};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lGe(n){const{inputs:e,backend:t,attrs:r}=n,{logits:i}=e,{numSamples:s,seed:o,normalized:a}=r,l=a?i:_Q({inputs:{logits:i},backend:t,attrs:{dim:i.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new sGe(c,s),f=[{type:"float32",data:[o]},{type:"int32",data:[u]}],d=t.runWebGPUProgram(h,[l],"int32",f);return a||t.disposeData(l.dataId),d}const cGe={kernelName:w2,backendName:"webgpu",kernelFunc:lGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uGe(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const s=t.tensorMap.get(r.dataId),[o,a]=b4e(s.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,o)}const i=new Vw(r.shape,vt.NEG);return t.runWebGPUProgram(i,[r],r.dtype)}const hGe={kernelName:ow,backendName:"webgpu",kernelFunc:uGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fGe(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:i,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,c=t.readSync(i.dataId),u=t.readSync(s.dataId),{selectedIndices:h}=tC(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const dGe={kernelName:x2,backendName:"webgpu",kernelFunc:fGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pGe(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:i,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=t.readSync(i.dataId),h=t.readSync(s.dataId),f=o,d=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=nC(u,h,f,d,p,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const mGe={kernelName:_2,backendName:"webgpu",kernelFunc:pGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gGe{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${kt("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yGe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:i}=e,{dtype:s,depth:o,onValue:a,offValue:l}=r,c=Ee(i.shape),u=new gGe(c,o),h=Xt({inputs:{x:i},backend:t,attrs:{shape:[c]}}),f=[{type:"float32",data:[a]},{type:"float32",data:[l]}],d=t.runWebGPUProgram(u,[h],s,f);t.disposeData(h.dataId);const p=[...i.shape,o],m=Xt({inputs:{x:d},backend:t,attrs:{shape:p}});return t.disposeData(d.dataId),m}const bGe={kernelName:cw,backendName:"webgpu",kernelFunc:yGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FI(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const i=mC({inputs:{input:r},backend:t}),s=FI({inputs:{x:i},backend:t}),o=FN({inputs:{input:r},backend:t}),a=FI({inputs:{x:o},backend:t}),l=Hy({inputs:{real:s,imag:a},backend:t});return t.disposeData(i.dataId),t.disposeData(s.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),l}else return wa({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const vGe={kernelName:Tw,backendName:"webgpu",kernelFunc:FI};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SQ(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const i=mC({inputs:{input:r},backend:t}),s=SQ({inputs:{x:i},backend:t}),o=FN({inputs:{input:r},backend:t}),a=FI({inputs:{x:o},backend:t}),l=Hy({inputs:{real:s,imag:a},backend:t});return t.disposeData(i.dataId),t.disposeData(s.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),l}else return wa({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const wGe={kernelName:lw,backendName:"webgpu",kernelFunc:SQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xGe(n){const{inputs:e,backend:t,attrs:r}=n,{axis:i}=r;if(e.length===1)return RD({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const s=e[0].shape,o=e[0].dtype;e.forEach(u=>{qs(s,u.shape,"All tensors passed to stack must have matching shapes"),U(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=RD({inputs:{input:u},backend:t,attrs:{dim:i}});return a.push(h),h}),c=fQ({inputs:l,backend:t,attrs:{axis:i}});return a.forEach(u=>t.disposeData(u.dataId)),c}const _Ge={kernelName:uw,backendName:"webgpu",kernelFunc:xGe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CQ(n,e=!1){const t=n.length,r=Ki(t),i=n.map((h,f)=>`uniforms.pad${f}[0]`).join(","),s=n.map((h,f)=>`uniforms.pad${f}[0] + uniforms.xShape${t>1?`[${f}]`:""}`).join(","),o=t>1?`${r}(${i})`:`${i}`,a=t>1?`${r}(${s})`:`${s}`,l=t>1?"any(paddedCoords < start)":"paddedCoords < start",c=t>1?"any(paddedCoords >= end)":"paddedCoords >= end",u=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
        let start = ${o};
        let end = ${a};
        if (${l} || ${c}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${u}));
        }
  `}class SGe{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((r,i)=>r[0]+e[i]+r[1]),this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((r,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${CQ(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CGe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{paddings:s,constantValue:o}=r;if(s.every(c=>Rn(c,[0,0])))return Xa({inputs:{x:i},backend:t});if(Ee(i.shape)===0){const c=s.map((u,h)=>u[0]+i.shape[h]+u[1]);return wa({backend:t,attrs:{shape:c,value:o,dtype:i.dtype}})}const a=[{type:"float32",data:[o]}];s.map(c=>a.push({type:"int32",data:[c[0],c[1]]}));const l=new SGe(i.shape,s);return t.runWebGPUProgram(l,[i],i.dtype,a)},kGe={kernelName:hw,backendName:"webgpu",kernelFunc:CGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TGe=Xs({opType:vn.POW}),EGe={kernelName:uy,backendName:"webgpu",kernelFunc:TGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IGe(n){const{inputs:e,backend:t}=n,{x:r,alpha:i}=e,s=new DI(vn.PRELU,r.shape,i.shape);return t.runWebGPUProgram(s,[r,i],"float32")}const AGe={kernelName:fw,backendName:"webgpu",kernelFunc:IGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MGe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:o}=r;return Gy(i,s,o,"prod",t)}const NGe={kernelName:dw,backendName:"webgpu",kernelFunc:MGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Ge=n=>{const{backend:e,attrs:t}=n,{start:r,stop:i,step:s,dtype:o}=t,a=x4e(r,i,s,o);return e.makeTensorInfo([a.length],o,a)},RGe={kernelName:S2,backendName:"webgpu",kernelFunc:$Ge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PGe=Xs({opType:vn.DIV}),DGe={kernelName:jg,backendName:"webgpu",kernelFunc:PGe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OGe=gr({opType:vt.RECIPROCAL}),FGe={kernelName:hy,backendName:"webgpu",kernelFunc:OGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LGe=gr({opType:vt.RELU}),zGe={kernelName:fy,backendName:"webgpu",kernelFunc:LGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BGe=gr({opType:vt.RELU6}),VGe={kernelName:dy,backendName:"webgpu",kernelFunc:BGe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UGe{constructor(e,t,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,r,e[3]],this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WGe(n){const{inputs:e,backend:t,attrs:r}=n,{images:i}=e,{alignCorners:s,size:o,halfPixelCenters:a}=r,[l,c]=o,u=s&&l>1?1:0,h=s&&c>1?1:0,d=[{type:"float32",data:[u,h]},{type:"float32",data:[a?.5:0]}],p=new UGe(i.shape,l,c);return t.runWebGPUProgram(p,[i],"float32",d)}const HGe={kernelName:gw,backendName:"webgpu",kernelFunc:WGe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GGe{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jGe(n){const{inputs:e,backend:t,attrs:r}=n,{images:i,dy:s}=e,{alignCorners:o}=r,[,a,l]=i.shape,[,c,u]=s.shape,h=[o&&c>1?a-1:a,o&&u>1?l-1:l],f=[o&&c>1?c-1:c,o&&u>1?u-1:u],d=h[0]/f[0],p=h[1]/f[1],m=1/d,g=1/p,y=Math.ceil(m)*2+2,b=Math.ceil(g)*2+2,_=new GGe(i.shape,o),w=[{type:"int32",data:h},{type:"int32",data:f},{type:"float32",data:[d]},{type:"float32",data:[p]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[b]}];return t.runWebGPUProgram(_,[s],s.dtype,w)}const qGe={kernelName:T2,backendName:"webgpu",kernelFunc:jGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XGe{constructor(e,t,r,i){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,r,e[3]],this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=i,this.shaderKey=`resizeNearest_${i}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KGe(n){const{inputs:e,backend:t,attrs:r}=n,{images:i}=e,{alignCorners:s,halfPixelCenters:o,size:a}=r,[l,c]=a,u=s&&l>1?1:0,h=s&&c>1?1:0,d=[{type:"float32",data:[u,h]},{type:"float32",data:[s?.5:0]}],p=new XGe(i.shape,l,c,o);return t.runWebGPUProgram(p,[i],i.dtype,d)}const YGe={kernelName:mw,backendName:"webgpu",kernelFunc:KGe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZGe{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JGe(n){const{inputs:e,backend:t,attrs:r}=n,{images:i,dy:s}=e,{alignCorners:o}=r,[,a,l]=i.shape,[,c,u]=s.shape,h=[o&&c>1?a-1:a,o&&u>1?l-1:l],f=[o&&c>1?c-1:c,o&&u>1?u-1:u],d=h[0]/f[0],p=h[1]/f[1],m=1/d,g=1/p,y=Math.ceil(m)*2+2,b=Math.ceil(g)*2+2,_=new ZGe(i.shape,o),w=[{type:"int32",data:h},{type:"int32",data:f},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[b]}];return t.runWebGPUProgram(_,[s],s.dtype,w)}const QGe={kernelName:k2,backendName:"webgpu",kernelFunc:JGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e6e{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t6e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{dims:s}=r,o=i.shape.length;if(o===0)return Xa({inputs:{x:i},backend:t});const a=i.shape,l=[1,1,1,1];a.forEach((g,y)=>{const b=y+4-o;l[b]=g});const c=An(s,i.shape),u=[0,0,0,0];c.forEach(g=>{const y=g+4-o;u[y]=1});const h=[{type:"int32",data:u}],f=Xt({inputs:{x:i},backend:t,attrs:{shape:l}}),d=new e6e(l),p=t.runWebGPUProgram(d,[f],f.dtype,h);t.disposeData(f.dataId);const m=Xt({inputs:{x:p},backend:t,attrs:{shape:a}});return t.disposeData(p.dataId),m}const n6e={kernelName:yw,backendName:"webgpu",kernelFunc:t6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r6e{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${kt("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i6e={kernelName:z2,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:i,fillValue:s,center:o}=e,a=t,l=new r6e(r.shape,s),[c,u]=hN(o,r.shape[1],r.shape[2]),h=[{type:"float32",data:[c]},{type:"float32",data:[u]},{type:"float32",data:[Math.sin(i)]},{type:"float32",data:[Math.cos(i)]}];return typeof s=="number"?h.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):h.push({type:"float32",data:s}),a.runWebGPUProgram(l,[r],r.dtype,h)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s6e=gr({opType:vt.ROUND}),o6e={kernelName:py,backendName:"webgpu",kernelFunc:s6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a6e=gr({opType:vt.RSQRT,cpuKernelImpl:_4e}),l6e={kernelName:my,backendName:"webgpu",kernelFunc:a6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X1{constructor(e,t,r,i,s,o,a,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=o,this.type=a,this.sumDupeIndices=l,this.dispatchLayout=Ot(e),this.dispatch=Tt(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${r}_${i}_${this.sliceDimGreaterThanOne}_${a}_${l}`;const c=Ki(s.length);this.uniforms=`sliceDim : i32, strides: ${c}, updatesSize: i32,`,this.updatesRank=i,this.indicesRank=r}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const t=`getIndices(${e})`,r=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let i="",s="";this.dispatchLayout.x.length===1?(i="flattenedIndex",s=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(i="vec2<i32>(flattenedIndex, coords[1])",s=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(c,u)=>`coords[${u}]`).join(", ")})`;return`
    ${s}
      ${kt("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${r};
          }
          let updateValue =
              ${Nm(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${i});

          ${this.sumDupeIndices?Mp("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c6e(n){const{inputs:e,backend:t,attrs:r}=n,{indices:i,updates:s}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Lu(s,i,o),f=[h/c,c];if(h===0)return t.makeTensorInfo(o,i.dtype);const d=Xt({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),p=Xt({inputs:{x:s},backend:t,attrs:{shape:[l,c]}}),m=p.dtype,g=wa({backend:t,attrs:{shape:f,value:0,dtype:m}}),y=Ee(p.shape),b=[{type:"int32",data:[a]},{type:"int32",data:u},{type:"int32",data:[y]}],_=new X1(p.shape,a,d.shape.length,p.shape.length,u,f,m),w=t.runWebGPUProgram(_,[p,d],m,b,g),S=Xt({inputs:{x:w},backend:t,attrs:{shape:o}});return t.disposeData(d.dataId),t.disposeData(p.dataId),t.disposeData(w.dataId),S}const u6e={kernelName:E2,backendName:"webgpu",kernelFunc:c6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h6e{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${kt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f6e(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:i,values:s}=e,{side:o}=r,a=new h6e([s.shape[0],s.shape[1]],o),l=[{type:"int32",data:[i.shape[1]]}];return t.runWebGPUProgram(a,[i,s],"int32",l)}const d6e={kernelName:A2,backendName:"webgpu",kernelFunc:f6e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p6e{constructor(e,t,r){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=r,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],o=[];for(let a=0;a<this.outputShape.length;a++)o.push(`${i[a]}`),a<this.cRank&&s.push(`${i[a]}`);e=s.join(),t=o.join()}return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m6e(n){const{inputs:e,backend:t}=n,{condition:r,t:i,e:s}=e,o=new p6e(r.shape.length,i.shape,i.shape.length);return t.runWebGPUProgram(o,[r,i,s],As(i.dtype,s.dtype))}const g6e={kernelName:bw,backendName:"webgpu",kernelFunc:m6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y6e=gr({opType:vt.SELU}),b6e={kernelName:gy,backendName:"webgpu",kernelFunc:y6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v6e=gr({opType:vt.SIGMOID}),w6e={kernelName:wy,backendName:"webgpu",kernelFunc:v6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x6e=gr({opType:vt.SIGN}),_6e={kernelName:vy,backendName:"webgpu",kernelFunc:x6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S6e=gr({opType:vt.SIN}),C6e={kernelName:yy,backendName:"webgpu",kernelFunc:S6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k6e=gr({opType:vt.SINH}),T6e={kernelName:by,backendName:"webgpu",kernelFunc:k6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E6e=gr({opType:vt.SOFTPLUS}),I6e={kernelName:xy,backendName:"webgpu",kernelFunc:E6e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A6e{constructor(e,t,r,i,s,o){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[s[l]];this.outputShape=a,this.newDim=s,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${Ki(i.length)}, paddedXShapeStrides : ${Ki(o)}, `,r.map((l,c)=>{this.uniforms+=` pad${c} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${s}`}getUserCode(){const e=Ki(this.outputShape.length),t=sQ(this.newDim);return`
      ${RE(this.paddedXShape,"PaddedX")}
      ${kt("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${CQ(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M6e=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockShape:s,paddings:o}=r;U(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=s.reduce((b,_)=>b*_),l=[[0,0]];l.push(...o);for(let b=1+s.length;b<i.shape.length;++b)l.push([0,0]);const c=l.map((b,_)=>b[0]+i.shape[_]+b[1]),u=Oy(c,s,a,!1),h=Fy(u.length,s.length,!1),f=Ly(c,s,a,!1),d=Zt(c),p=new A6e(i.shape,c,l,u,h,d.length),m=[{type:"int32",data:u},{type:"int32",data:d}];l.map(b=>m.push({type:"int32",data:[b[0],b[1]]}));const g=t.runWebGPUProgram(p,[i],i.dtype,m),y=Xt({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeData(g.dataId),y},N6e={kernelName:xw,backendName:"webgpu",kernelFunc:M6e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $6e{constructor(e,t,r){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=r,this.dispatchLayout=Ot([t]),this.dispatch=Tt(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Mp("&result[outIndex]","value",this.type)}
      }
    }
  `}}class R6e{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=Ot(t),this.dispatch=Tt(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Mp("&result[segmentId]","1","int32")}
      }
    }
  `}}class P6e{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=Ot(e),this.dispatch=Tt(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kQ(n,e,t,r=!1,i){const o=Ee(n.shape)/n.shape[0],a=n.dtype,l=Ee(e.shape),c=i.readSync(t.dataId),h=l>0?c[l-1]+1:0;let f;const d=n.shape.slice();d[0]=h;const p=l*o,m=wa({backend:i,attrs:{shape:d,value:0,dtype:a}});f=new $6e(d,p,a);let g=[{type:"int32",data:[o]},{type:"int32",data:[p]}];const y=i.runWebGPUProgram(f,[n,e,t],a,g,m);if(r)return y;const b=wa({backend:i,attrs:{shape:[h],value:0,dtype:"int32"}});f=new R6e(h,t.shape);const _=i.runWebGPUProgram(f,[t],"int32",null,b),w=wa({backend:i,attrs:{shape:d,value:0,dtype:a}});f=new P6e(d,a),g=[{type:"int32",data:[o]}];const S=i.runWebGPUProgram(f,[y,_],a,g,w);return i.disposeData(y.dataId),i.disposeData(_.dataId),S}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D6e(n){const{inputs:e,backend:t}=n,{data:r,indices:i,segmentIds:s}=e;return kQ(r,i,s,!1,t)}const O6e={kernelName:M2,backendName:"webgpu",kernelFunc:D6e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F6e(n){const{inputs:e,backend:t}=n,{data:r,indices:i,segmentIds:s}=e;return kQ(r,i,s,!0,t)}const L6e={kernelName:N2,backendName:"webgpu",kernelFunc:F6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z6e{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[i]*t[i];this.outputShape=r,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=B6e(this.rank,"uniforms.");return`
      ${kt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function B6e(n,e=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${e}aShape)`;const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<n;i++)r.push(`(${t[i]} % ${e}aShape[${i}])`);return r.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pB(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{reps:s}=r;if(t.shouldExecuteOnCPU([i])||i.dtype==="string"||i.shape.length>=5){const l=t.readSync(i.dataId),c=i.dtype==="string"?l.map(f=>Sc(f)):l,u=Sn(i.shape,i.dtype,c),h=A4e(u,s);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new z6e(i.shape,s);return t.runWebGPUProgram(o,[i],i.dtype)}const V6e={kernelName:Ey,backendName:"webgpu",kernelFunc:pB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U6e(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:i,sparseValues:s,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:f}=Lu(s,i,a),d=!1;if(s.dtype==="string"){const A=t.bufferSync(i),M=t.bufferSync(s),E=Sc(t.readSync(o.dataId)[0]),N=S4e(A,M,a,f,u,c,l,h,E,d);return t.makeTensorInfo(a,N.dtype,N.values)}const p=[f/u,u],m=Xt({inputs:{x:i},backend:t,attrs:{shape:[c,l]}}),g=s.shape.length?Xt({inputs:{x:s},backend:t,attrs:{shape:[c,u]}}):Xa({inputs:{x:s},backend:t}),y=g.dtype,b=t.makeTensorInfo([],y,js(1,y)),_=Xt({inputs:{x:o},backend:t,attrs:{shape:Array(p.length).fill(1)}}),w=pB({inputs:{x:_},backend:t,attrs:{reps:p}}),S=Ee([c,u]),C=[{type:"int32",data:[l]},{type:"int32",data:h},{type:"int32",data:[S]}];switch(c){case 0:break;case 1:{const A=new X1([c,u],l,m.shape.length,g.shape.length,h,p,y,d);t.runWebGPUProgram(A,[g,m],y,C,w)}break;default:{const A=new X1([c,u],l,m.shape.length,b.shape.length,h,p,y,d);t.runWebGPUProgram(A,[b,m],y,C,w)}{const A=new X1([c,u],l,m.shape.length,g.shape.length,h,p,y);t.runWebGPUProgram(A,[g,m],y,C,w)}}const k=Xt({inputs:{x:w},backend:t,attrs:{shape:a}});return t.disposeData(m.dataId),t.disposeData(g.dataId),t.disposeData(_.dataId),t.disposeData(b.dataId),t.disposeData(w.dataId),k}const W6e={kernelName:$2,backendName:"webgpu",kernelFunc:U6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H6e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{numOrSizeSplits:s,axis:o}=r,a=An(o,i.shape)[0],l=kN(i,s,a),c=i.shape.length,u=new Array(c).fill(0),h=i.shape.slice();return l.map(f=>{const d=[...h];d[a]=f;const p=Uw({inputs:{x:i},backend:t,attrs:{begin:u,size:d}});return u[a]+=f,p})}const G6e={kernelName:_w,backendName:"webgpu",kernelFunc:H6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j6e=gr({opType:vt.SQRT}),q6e={kernelName:_y,backendName:"webgpu",kernelFunc:j6e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X6e={kernelName:R2,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,r=e,i=new Vw(t.shape,vt.SQUARE);return r.runWebGPUProgram(i,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K6e=Xs({opType:vn.SQUARED_DIFFERENCE}),Y6e={kernelName:Sy,backendName:"webgpu",kernelFunc:K6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z6e({inputs:n,attrs:e,backend:t}){const{x:r}=n,i=new Vw(r.shape,vt.STEP,"stepAlpha : f32,"),s=[{type:"float32",data:[e.alpha]}];return t.runWebGPUProgram(i,[r],r.dtype,s)}const J6e={kernelName:Iy,backendName:"webgpu",kernelFunc:Z6e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q6e{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=Ki(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let i=0;t=this.outputShape.map((s,o)=>(i++,this.outputShape.length===1?`coords * uniforms.strides[${o}] + uniforms.begin[${o}]`:`coords[${i-1}] * uniforms.strides[${o}] + uniforms.begin[${o}]`)).join(",")}return`
       ${kt("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e5e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{begin:s,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:f}=r,{finalShapeSparse:d,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:_,strides:w}=lN(i.shape,s,o,a,l,c,u,h,f);let S;if(m)S=Xt({inputs:{x:i},backend:t,attrs:{shape:p}});else if(g||y){U(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const C=aN(b,_,w),k=Uw({inputs:{x:i},backend:t,attrs:{begin:b,size:C}});S=Xt({inputs:{x:k},backend:t,attrs:{shape:p}}),t.disposeData(k.dataId)}else if(t.shouldExecuteOnCPU([i])){const k=t.readSync(i.dataId),A=Sn(i.shape,i.dtype,k),M=T4e(d,A,w,b);S=t.makeTensorInfo(p,i.dtype,M.values)}else{const k=new Q6e(d),A=[{type:"int32",data:b},{type:"int32",data:w}],M=t.runWebGPUProgram(k,[i],i.dtype,A);S=Xt({inputs:{x:M},backend:t,attrs:{shape:p}}),t.disposeData(M.dataId)}return S}const t5e={kernelName:D2,backendName:"webgpu",kernelFunc:e5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n5e(n){const{inputs:e,backend:t,attrs:r}=n,{separator:i,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,f=t.readSync(u.dataId),d=t.readSync(h.dataId),[p,m]=E4e(f,d,i,s,o,a,l,c);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(h.shape,"int32",m)]}const r5e={kernelName:O2,backendName:"webgpu",kernelFunc:n5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i5e=Xs({opType:vn.SUB,cpuKernelImpl:I4e,supportsComplex:!0}),s5e={kernelName:Cy,backendName:"webgpu",kernelFunc:i5e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o5e=gr({opType:vt.TAN}),a5e={kernelName:ky,backendName:"webgpu",kernelFunc:o5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l5e=gr({opType:vt.TANH}),c5e={kernelName:Ty,backendName:"webgpu",kernelFunc:l5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u5e(n){const{inputs:e,backend:t,attrs:r}=n,{tensor:i,indices:s,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Lu(o,s,i.shape),f=[h/c,c];if(h===0)return t.makeTensorInfo(i.shape,s.dtype);const d=[],p=Xt({inputs:{x:s},backend:t,attrs:{shape:[l,a]}});d.push(p);const m=Xt({inputs:{x:o},backend:t,attrs:{shape:[l,c]}});d.push(m);const g=Xt({inputs:{x:i},backend:t,attrs:{shape:f}});d.push(g);const y=pB({inputs:{x:g},backend:t,attrs:{reps:Array(f.length).fill(1)}}),b=new X1([l,c],a,p.shape.length,m.shape.length,u,f,i.dtype,!1),_=Ee([l,c]),w=[{type:"int32",data:[a]},{type:"int32",data:u},{type:"int32",data:[_]}],S=t.runWebGPUProgram(b,[m,p],g.dtype,w,y);d.push(S);const C=Xt({inputs:{x:S},backend:t,attrs:{shape:i.shape}});return d.forEach(k=>t.disposeData(k.dataId)),C}const h5e={kernelName:I2,backendName:"webgpu",kernelFunc:u5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f5e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${kt("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class d5e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${kt("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0(n,e){e!==null&&n.disposeData(e.dataId)}function ZH(n){let e=1;for(;e<n;)e*=2;return e}function p5e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{k:s,sorted:o}=r,a=i.shape,l=a[a.length-1];if(t.shouldExecuteOnCPU([i])){const S=t.readSync(i.dataId),[C,k]=M4e(S,a,i.dtype,s,o);return[t.makeTensorInfo(C.shape,C.dtype,C.values),t.makeTensorInfo(k.shape,k.dtype,k.values)]}if(s===0)return a[a.length-1]=0,[t.makeTensorInfo(a,i.dtype,[]),t.makeTensorInfo(a,"int32",[])];if(l===1)return[i,wa({attrs:{shape:a,dtype:"int32",value:0},backend:t})];const u=Ee(a)/l,h=Xt({inputs:{x:i},attrs:{shape:[u,l]},backend:t}),f=ZH(s),d=ZH(l);let p=null;const m=()=>p===null?[h,h]:[h,p],g=(S,C,k)=>{const A=m(),M=new f5e(k),N=[{type:"int32",data:[l]},{type:"int32",data:[p===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[S]},{type:"int32",data:[C]}],O=p;p=t.runWebGPUProgram(M,A,"int32",N),A0(t,O)};for(let S=1;S<f;S*=2){const C=S*2;for(let k=S;k>=1;k/=2)g(C,k,[u,d])}for(let S=d;S>f;S/=2){const C=m(),k=new d5e([u,S/2]),M=[{type:"int32",data:[l]},{type:"int32",data:[p===null?1:0]},{type:"int32",data:[f]}],E=p;p=t.runWebGPUProgram(k,C,"int32",M),A0(t,E);const N=f/2,O=N*2;for(let R=N;R>=1;R/=2)g(O,R,p.shape)}let y=p;p=Uw({inputs:{x:p},backend:t,attrs:{begin:0,size:[u,s]}}),A0(t,y);let b=wQ({inputs:{x:h,indices:p},backend:t,attrs:{axis:1,batchDims:1}});A0(t,h);const _=a.slice(0,-1);_.push(s),y=p,p=Xt({inputs:{x:p},attrs:{shape:_},backend:t}),A0(t,y);const w=b;return b=Xt({inputs:{x:b},attrs:{shape:_},backend:t}),A0(t,w),[b,p]}const m5e={kernelName:F2,backendName:"webgpu",kernelFunc:p5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g5e{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${kt("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y5e(n){const{inputs:e,backend:t,attrs:r}=n,{image:i,transforms:s}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=r,[u,h,f,d]=i.shape,[p,m]=c??[h,f],g=[u,p,m,d],y=new g5e(g),b=o==="nearest"?1:2;let _;switch(a){case"constant":_=1;break;case"reflect":_=2;break;case"wrap":_=3;break;case"nearest":_=4;break;default:_=1;break}const w=[{type:"int32",data:[b]},{type:"int32",data:[_]},{type:"float32",data:[l]}];return t.runWebGPUProgram(y,[i,s],"float32",w)}const b5e={kernelName:L2,backendName:"webgpu",kernelFunc:y5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v5e(n){const{inputs:e,backend:t,attrs:r}=n,{value:i}=e;let{axis:s}=r;s<0&&(s+=i.shape.length);const o=i,a=o.shape.length,l=i.shape[s],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==s&&(c[u++]=o.shape[m]);const h=[],f=new Array(a).fill(0),d=o.shape.slice();d[s]=1;const p=new Array(l);for(let m=0;m<p.length;m++){f[s]=m;const g=Uw({inputs:{x:o},backend:t,attrs:{begin:f,size:d}}),y=Xt({inputs:{x:g},backend:t,attrs:{shape:c}});p[m]=y,h.push(g)}return h.forEach(m=>t.disposeData(m.dataId)),p}const w5e={kernelName:Cw,backendName:"webgpu",kernelFunc:v5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x5e{constructor(e,t,r){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=Ot(e),this.dispatch=Tt(this.dispatchLayout,e,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${r} type.`);this.type=r,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${kt("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Mp("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _5e(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,segmentIds:s}=e,{numSegments:o}=r,a=i.shape.length,l=[];let c=0;const u=Lr([c],a);let h=i;u!=null&&(h=Ch({inputs:{x:i},backend:t,attrs:{perm:u}}),l.push(h),c=ni(1,a)[0]);const f=jz(h.shape,c,o),d=Ee([h.shape[c]]),p=Xt({inputs:{x:h},backend:t,attrs:{shape:[-1,d]}});l.push(p);const m=i.dtype,g=[p.shape[0],o],y=wa({backend:t,attrs:{shape:g,value:0,dtype:m}}),b=new x5e(p.shape,g,m),_=[{type:"int32",data:[o]},{type:"int32",data:[Ee(p.shape)]}],w=t.runWebGPUProgram(b,[p,s],m,_,y),S=Xt({inputs:{x:w},backend:t,attrs:{shape:f}});l.push(w);let C=S;if(u!=null){l.push(S);const k=Ph(u);C=Ch({inputs:{x:C},backend:t,attrs:{perm:k}})}return l.forEach(k=>t.disposeData(k.dataId)),C}const S5e={kernelName:kw,backendName:"webgpu",kernelFunc:_5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C5e=[KBe,R4e,D4e,F4e,z4e,U4e,K4e,Z4e,Q4e,tVe,rVe,sVe,aVe,cVe,hVe,gVe,bVe,_Ve,CVe,TVe,NVe,DVe,LVe,UVe,HVe,XVe,ZBe,ZVe,tUe,cUe,mUe,vUe,_Ue,CUe,TUe,IUe,MUe,RUe,DUe,FUe,zUe,UUe,KUe,ZUe,GUe,eWe,rWe,aWe,cWe,fWe,gWe,bWe,wWe,_We,CWe,TWe,EWe,AWe,NWe,jBe,RWe,zWe,DWe,FWe,UWe,HWe,jWe,KWe,JWe,eHe,nHe,YBe,iHe,QVe,oHe,lHe,uHe,fHe,pHe,gHe,vHe,SHe,xHe,kHe,EHe,AHe,RHe,OHe,dVe,LHe,BHe,XHe,UHe,jHe,YHe,pVe,JHe,eGe,nGe,iGe,cGe,dWe,hGe,dGe,mGe,zVe,bGe,wGe,_Ge,kGe,EGe,AGe,NGe,RGe,BVe,DGe,FGe,zGe,VGe,qBe,HGe,qGe,YGe,QGe,n6e,i6e,o6e,l6e,u6e,d6e,g6e,b6e,w6e,_6e,C6e,T6e,AVe,J6e,t5e,r5e,aGe,I6e,N6e,O6e,L6e,W6e,G6e,q6e,X6e,Y6e,s5e,pWe,a5e,c5e,h5e,V6e,m5e,b5e,G4e,w5e,S5e,vGe];for(const n of C5e)B2(n);function PD(n){"@babel/helpers - typeof";return PD=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},PD(n)}function zu(n,e){if(e.length<n)throw new TypeError(n+" argument"+(n>1?"s":"")+" required, but only "+e.length+" present")}function Ko(n){zu(1,arguments);var e=Object.prototype.toString.call(n);return n instanceof Date||PD(n)==="object"&&e==="[object Date]"?new Date(n.getTime()):typeof n=="number"||e==="[object Number]"?new Date(n):((typeof n=="string"||e==="[object String]")&&typeof console<"u"&&(console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"),console.warn(new Error().stack)),new Date(NaN))}var k5e={};function T5e(){return k5e}function JH(n){var e=new Date(Date.UTC(n.getFullYear(),n.getMonth(),n.getDate(),n.getHours(),n.getMinutes(),n.getSeconds(),n.getMilliseconds()));return e.setUTCFullYear(n.getFullYear()),n.getTime()-e.getTime()}function PE(n,e){zu(2,arguments);var t=Ko(n),r=Ko(e),i=t.getTime()-r.getTime();return i<0?-1:i>0?1:i}function E5e(n,e){zu(2,arguments);var t=Ko(n),r=Ko(e),i=t.getFullYear()-r.getFullYear(),s=t.getMonth()-r.getMonth();return i*12+s}function I5e(n,e){return zu(2,arguments),Ko(n).getTime()-Ko(e).getTime()}var QH={ceil:Math.ceil,round:Math.round,floor:Math.floor,trunc:function(e){return e<0?Math.ceil(e):Math.floor(e)}},A5e="trunc";function M5e(n){return n?QH[n]:QH[A5e]}function N5e(n){zu(1,arguments);var e=Ko(n);return e.setHours(23,59,59,999),e}function $5e(n){zu(1,arguments);var e=Ko(n),t=e.getMonth();return e.setFullYear(e.getFullYear(),t+1,0),e.setHours(23,59,59,999),e}function R5e(n){zu(1,arguments);var e=Ko(n);return N5e(e).getTime()===$5e(e).getTime()}function P5e(n,e){zu(2,arguments);var t=Ko(n),r=Ko(e),i=PE(t,r),s=Math.abs(E5e(t,r)),o;if(s<1)o=0;else{t.getMonth()===1&&t.getDate()>27&&t.setDate(30),t.setMonth(t.getMonth()-i*s);var a=PE(t,r)===-i;R5e(Ko(n))&&s===1&&PE(n,r)===1&&(a=!1),o=i*(s-Number(a))}return o===0?0:o}function D5e(n,e,t){zu(2,arguments);var r=I5e(n,e)/1e3;return M5e(t==null?void 0:t.roundingMethod)(r)}var O5e={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXWeeks:{one:"about 1 week",other:"about {{count}} weeks"},xWeeks:{one:"1 week",other:"{{count}} weeks"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}},F5e=function(e,t,r){var i,s=O5e[e];return typeof s=="string"?i=s:t===1?i=s.one:i=s.other.replace("{{count}}",t.toString()),r!=null&&r.addSuffix?r.comparison&&r.comparison>0?"in "+i:i+" ago":i};const L5e=F5e;function f3(n){return function(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},t=e.width?String(e.width):n.defaultWidth,r=n.formats[t]||n.formats[n.defaultWidth];return r}}var z5e={full:"EEEE, MMMM do, y",long:"MMMM do, y",medium:"MMM d, y",short:"MM/dd/yyyy"},B5e={full:"h:mm:ss a zzzz",long:"h:mm:ss a z",medium:"h:mm:ss a",short:"h:mm a"},V5e={full:"{{date}} 'at' {{time}}",long:"{{date}} 'at' {{time}}",medium:"{{date}}, {{time}}",short:"{{date}}, {{time}}"},U5e={date:f3({formats:z5e,defaultWidth:"full"}),time:f3({formats:B5e,defaultWidth:"full"}),dateTime:f3({formats:V5e,defaultWidth:"full"})};const W5e=U5e;var H5e={lastWeek:"'last' eeee 'at' p",yesterday:"'yesterday at' p",today:"'today at' p",tomorrow:"'tomorrow at' p",nextWeek:"eeee 'at' p",other:"P"},G5e=function(e,t,r,i){return H5e[e]};const j5e=G5e;function zx(n){return function(e,t){var r=t!=null&&t.context?String(t.context):"standalone",i;if(r==="formatting"&&n.formattingValues){var s=n.defaultFormattingWidth||n.defaultWidth,o=t!=null&&t.width?String(t.width):s;i=n.formattingValues[o]||n.formattingValues[s]}else{var a=n.defaultWidth,l=t!=null&&t.width?String(t.width):n.defaultWidth;i=n.values[l]||n.values[a]}var c=n.argumentCallback?n.argumentCallback(e):e;return i[c]}}var q5e={narrow:["B","A"],abbreviated:["BC","AD"],wide:["Before Christ","Anno Domini"]},X5e={narrow:["1","2","3","4"],abbreviated:["Q1","Q2","Q3","Q4"],wide:["1st quarter","2nd quarter","3rd quarter","4th quarter"]},K5e={narrow:["J","F","M","A","M","J","J","A","S","O","N","D"],abbreviated:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],wide:["January","February","March","April","May","June","July","August","September","October","November","December"]},Y5e={narrow:["S","M","T","W","T","F","S"],short:["Su","Mo","Tu","We","Th","Fr","Sa"],abbreviated:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],wide:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]},Z5e={narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"}},J5e={narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"}},Q5e=function(e,t){var r=Number(e),i=r%100;if(i>20||i<10)switch(i%10){case 1:return r+"st";case 2:return r+"nd";case 3:return r+"rd"}return r+"th"},eje={ordinalNumber:Q5e,era:zx({values:q5e,defaultWidth:"wide"}),quarter:zx({values:X5e,defaultWidth:"wide",argumentCallback:function(e){return e-1}}),month:zx({values:K5e,defaultWidth:"wide"}),day:zx({values:Y5e,defaultWidth:"wide"}),dayPeriod:zx({values:Z5e,defaultWidth:"wide",formattingValues:J5e,defaultFormattingWidth:"wide"})};const tje=eje;function Bx(n){return function(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},r=t.width,i=r&&n.matchPatterns[r]||n.matchPatterns[n.defaultMatchWidth],s=e.match(i);if(!s)return null;var o=s[0],a=r&&n.parsePatterns[r]||n.parsePatterns[n.defaultParseWidth],l=Array.isArray(a)?rje(a,function(h){return h.test(o)}):nje(a,function(h){return h.test(o)}),c;c=n.valueCallback?n.valueCallback(l):l,c=t.valueCallback?t.valueCallback(c):c;var u=e.slice(o.length);return{value:c,rest:u}}}function nje(n,e){for(var t in n)if(n.hasOwnProperty(t)&&e(n[t]))return t}function rje(n,e){for(var t=0;t<n.length;t++)if(e(n[t]))return t}function ije(n){return function(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},r=e.match(n.matchPattern);if(!r)return null;var i=r[0],s=e.match(n.parsePattern);if(!s)return null;var o=n.valueCallback?n.valueCallback(s[0]):s[0];o=t.valueCallback?t.valueCallback(o):o;var a=e.slice(i.length);return{value:o,rest:a}}}var sje=/^(\d+)(th|st|nd|rd)?/i,oje=/\d+/i,aje={narrow:/^(b|a)/i,abbreviated:/^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,wide:/^(before christ|before common era|anno domini|common era)/i},lje={any:[/^b/i,/^(a|c)/i]},cje={narrow:/^[1234]/i,abbreviated:/^q[1234]/i,wide:/^[1234](th|st|nd|rd)? quarter/i},uje={any:[/1/i,/2/i,/3/i,/4/i]},hje={narrow:/^[jfmasond]/i,abbreviated:/^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,wide:/^(january|february|march|april|may|june|july|august|september|october|november|december)/i},fje={narrow:[/^j/i,/^f/i,/^m/i,/^a/i,/^m/i,/^j/i,/^j/i,/^a/i,/^s/i,/^o/i,/^n/i,/^d/i],any:[/^ja/i,/^f/i,/^mar/i,/^ap/i,/^may/i,/^jun/i,/^jul/i,/^au/i,/^s/i,/^o/i,/^n/i,/^d/i]},dje={narrow:/^[smtwf]/i,short:/^(su|mo|tu|we|th|fr|sa)/i,abbreviated:/^(sun|mon|tue|wed|thu|fri|sat)/i,wide:/^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i},pje={narrow:[/^s/i,/^m/i,/^t/i,/^w/i,/^t/i,/^f/i,/^s/i],any:[/^su/i,/^m/i,/^tu/i,/^w/i,/^th/i,/^f/i,/^sa/i]},mje={narrow:/^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,any:/^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i},gje={any:{am:/^a/i,pm:/^p/i,midnight:/^mi/i,noon:/^no/i,morning:/morning/i,afternoon:/afternoon/i,evening:/evening/i,night:/night/i}},yje={ordinalNumber:ije({matchPattern:sje,parsePattern:oje,valueCallback:function(e){return parseInt(e,10)}}),era:Bx({matchPatterns:aje,defaultMatchWidth:"wide",parsePatterns:lje,defaultParseWidth:"any"}),quarter:Bx({matchPatterns:cje,defaultMatchWidth:"wide",parsePatterns:uje,defaultParseWidth:"any",valueCallback:function(e){return e+1}}),month:Bx({matchPatterns:hje,defaultMatchWidth:"wide",parsePatterns:fje,defaultParseWidth:"any"}),day:Bx({matchPatterns:dje,defaultMatchWidth:"wide",parsePatterns:pje,defaultParseWidth:"any"}),dayPeriod:Bx({matchPatterns:mje,defaultMatchWidth:"any",parsePatterns:gje,defaultParseWidth:"any"})};const bje=yje;var vje={code:"en-US",formatDistance:L5e,formatLong:W5e,formatRelative:j5e,localize:tje,match:bje,options:{weekStartsOn:0,firstWeekContainsDate:1}};const wje=vje;function TQ(n,e){if(n==null)throw new TypeError("assign requires that input parameter not be null or undefined");for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n}function xje(n){return TQ({},n)}var eG=1440,_je=2520,d3=43200,Sje=86400;function Cje(n,e,t){var r,i;zu(2,arguments);var s=T5e(),o=(r=(i=t==null?void 0:t.locale)!==null&&i!==void 0?i:s.locale)!==null&&r!==void 0?r:wje;if(!o.formatDistance)throw new RangeError("locale must contain formatDistance property");var a=PE(n,e);if(isNaN(a))throw new RangeError("Invalid time value");var l=TQ(xje(t),{addSuffix:!!(t!=null&&t.addSuffix),comparison:a}),c,u;a>0?(c=Ko(e),u=Ko(n)):(c=Ko(n),u=Ko(e));var h=D5e(u,c),f=(JH(u)-JH(c))/1e3,d=Math.round((h-f)/60),p;if(d<2)return t!=null&&t.includeSeconds?h<5?o.formatDistance("lessThanXSeconds",5,l):h<10?o.formatDistance("lessThanXSeconds",10,l):h<20?o.formatDistance("lessThanXSeconds",20,l):h<40?o.formatDistance("halfAMinute",0,l):h<60?o.formatDistance("lessThanXMinutes",1,l):o.formatDistance("xMinutes",1,l):d===0?o.formatDistance("lessThanXMinutes",1,l):o.formatDistance("xMinutes",d,l);if(d<45)return o.formatDistance("xMinutes",d,l);if(d<90)return o.formatDistance("aboutXHours",1,l);if(d<eG){var m=Math.round(d/60);return o.formatDistance("aboutXHours",m,l)}else{if(d<_je)return o.formatDistance("xDays",1,l);if(d<d3){var g=Math.round(d/eG);return o.formatDistance("xDays",g,l)}else if(d<Sje)return p=Math.round(d/d3),o.formatDistance("aboutXMonths",p,l)}if(p=P5e(u,c),p<12){var y=Math.round(d/d3);return o.formatDistance("xMonths",y,l)}else{var b=p%12,_=Math.floor(p/12);return b<3?o.formatDistance("aboutXYears",_,l):b<9?o.formatDistance("overXYears",_,l):o.formatDistance("almostXYears",_+1,l)}}function kje(n,e){return zu(1,arguments),Cje(n,Date.now(),e)}/** @license MIT License (c) copyright 2010-2016 original author or authors */function EQ(n,e){for(var t=e.length,r=new Array(t+1),i=0;i<t;++i)r[i]=e[i];return r[t]=n,r}function Tje(n,e){var t=n.length,r=e.length,i=new Array(t+r),s=0;for(s=0;s<t;s++)i[s]=n[s];for(var o=0;o<r;o++)i[s++]=e[o];return i}function Eje(n,e){for(var t=e.length,r=new Array(t),i=0;i<t;++i)r[i]=n(e[i]);return r}function LN(n,e,t){for(var r=e,i=0,s=t.length;i<s;++i)r=n(r,t[i],i);return r}function Ije(n,e){if(n<0)throw new TypeError("i must be >= 0");var t=e.length;return t===0||n>=t?e:t===1?[]:Aje(n,e,t-1)}function Aje(n,e,t){var r=new Array(t),i;for(i=0;i<n;++i)r[i]=e[i];for(i=n;i<t;++i)r[i]=e[i+1];return r}function Mje(n,e){for(var t=e.length,r=new Array(t),i=0,s=void 0,o=0;o<t;++o)s=e[o],n(s)||(r[i]=s,++i);return r.length=i,r}function IQ(n,e){for(var t=0,r=e.length;t<r;++t)if(n===e[t])return t;return-1}/** @license MIT License (c) copyright 2010-2016 original author or authors */var Nje=function(n){return n},$je=function(n,e){return function(t){return n(e(t))}},Rje=function(n,e){return n(e)};function Tr(n){function e(t,r){switch(arguments.length){case 0:return e;case 1:return function(i){return n(t,i)};default:return n(t,r)}}return e}function Bu(n){function e(t,r,i){switch(arguments.length){case 0:return e;case 1:return Tr(function(s,o){return n(t,s,o)});case 2:return function(s){return n(t,r,s)};default:return n(t,r,i)}}return e}var Pje=function(){function n(e,t,r,i,s){this.time=e,this.localOffset=t,this.period=r,this.task=i,this.scheduler=s,this.active=!0}return n.prototype.run=function(){return this.task.run(this.time-this.localOffset)},n.prototype.error=function(e){return this.task.error(this.time-this.localOffset,e)},n.prototype.dispose=function(){return this.active=!1,this.scheduler.cancel(this),this.task.dispose()},n}(),AQ=function(){function n(e,t){this.origin=e,this.scheduler=t}return n.prototype.currentTime=function(){return this.scheduler.currentTime()-this.origin},n.prototype.scheduleTask=function(e,t,r,i){return this.scheduler.scheduleTask(e+this.origin,t,r,i)},n.prototype.relative=function(e){return new n(e+this.origin,this.scheduler)},n.prototype.cancel=function(e){return this.scheduler.cancel(e)},n.prototype.cancelAll=function(e){return this.scheduler.cancelAll(e)},n}();/** @license MIT License (c) copyright 2010-2017 original author or authors */var Dje=function(n){return Promise.resolve(n).then(MQ)};function MQ(n){try{return n.run()}catch(e){return n.error(e)}}/** @license MIT License (c) copyright 2010-2017 original author or authors */var Oje=function(){function n(e,t){var r=this;this._runReadyTasksBound=function(){return r._runReadyTasks()},this.timer=e,this.timeline=t,this._timer=null,this._nextArrival=1/0}return n.prototype.currentTime=function(){return this.timer.now()},n.prototype.scheduleTask=function(e,t,r,i){var s=this.currentTime()+Math.max(0,t),o=new Pje(s,e,r,i,this);return this.timeline.add(o),this._scheduleNextRun(),o},n.prototype.relative=function(e){return new AQ(e,this)},n.prototype.cancel=function(e){e.active=!1,this.timeline.remove(e)&&this._reschedule()},n.prototype.cancelAll=function(e){this.timeline.removeAll(e),this._reschedule()},n.prototype._reschedule=function(){this.timeline.isEmpty()?this._unschedule():this._scheduleNextRun()},n.prototype._unschedule=function(){this.timer.clearTimer(this._timer),this._timer=null},n.prototype._scheduleNextRun=function(){if(!this.timeline.isEmpty()){var e=this.timeline.nextArrival();this._timer===null?this._scheduleNextArrival(e):e<this._nextArrival&&(this._unschedule(),this._scheduleNextArrival(e))}},n.prototype._scheduleNextArrival=function(e){this._nextArrival=e;var t=Math.max(0,e-this.currentTime());this._timer=this.timer.setTimer(this._runReadyTasksBound,t)},n.prototype._runReadyTasks=function(){this._timer=null,this.timeline.runTasks(this.currentTime(),MQ),this._scheduleNextRun()},n}();/** @license MIT License (c) copyright 2010-2017 original author or authors */var Fje=function(){function n(){this.tasks=[]}return n.prototype.nextArrival=function(){return this.isEmpty()?1/0:this.tasks[0].time},n.prototype.isEmpty=function(){return this.tasks.length===0},n.prototype.add=function(e){NQ(e,this.tasks)},n.prototype.remove=function(e){var t=RQ($Q(e),this.tasks);if(t>=0&&t<this.tasks.length){var r=this.tasks[t].events,i=IQ(e,r);if(i>=0)return r.splice(i,1),r.length===0&&this.tasks.splice(t,1),!0}return!1},n.prototype.removeAll=function(e){for(var t=0;t<this.tasks.length;++t)Uje(e,this.tasks[t])},n.prototype.runTasks=function(e,t){for(var r=this.tasks,i=r.length,s=0;s<i&&r[s].time<=e;)++s;this.tasks=r.slice(s);for(var o=0;o<s;++o)this.tasks=Lje(t,r[o].events,this.tasks)},n}();function Lje(n,e,t){for(var r=0;r<e.length;++r){var i=e[r];i.active&&(n(i),i.period>=0&&i.active&&(i.time=i.time+i.period,NQ(i,t)))}return t}function NQ(n,e){var t=e.length,r=$Q(n);if(t===0){e.push(DD(r,[n]));return}var i=RQ(r,e);i>=t?e.push(DD(r,[n])):zje(n,e,r,i)}function zje(n,e,t,r){var i=e[r];t===i.time?Bje(n,i.events):e.splice(r,0,DD(t,[n]))}function Bje(n,e){e.length===0||n.time>=e[e.length-1].time?e.push(n):Vje(n,e)}function Vje(n,e){for(var t=0;t<e.length;t++)if(n.time<e[t].time){e.splice(t,0,n);break}}function $Q(n){return Math.floor(n.time)}function Uje(n,e){e.events=Mje(n,e.events)}function RQ(n,e){for(var t=0,r=e.length,i,s;t<r;){if(i=Math.floor((t+r)/2),s=e[i],n===s.time)return i;n<s.time?r=i:t=i+1}return r}var DD=function(n,e){return{time:n,events:e}};/** @license MIT License (c) copyright 2010-2017 original author or authors */var Wje=function(){function n(e){this._clock=e}return n.prototype.now=function(){return this._clock.now()},n.prototype.setTimer=function(e,t){return t<=0?Hje(e):setTimeout(e,t)},n.prototype.clearTimer=function(e){return e instanceof PQ?e.cancel():clearTimeout(e)},n}(),PQ=function(){function n(e){this.f=e,this.active=!0}return n.prototype.run=function(){if(this.active)return this.f()},n.prototype.error=function(e){throw e},n.prototype.cancel=function(){this.active=!1},n}();function Hje(n){var e=new PQ(n);return Dje(e),e}var Gje=function(){function n(e,t){this.origin=t,this.clock=e}return n.prototype.now=function(){return this.clock.now()-this.origin},n}(),jje=function(){function n(e,t){this.origin=t,this.hrtime=e}return n.prototype.now=function(){var e=this.hrtime(this.origin);return(e[0]*1e9+e[1])/1e6},n}(),DQ=function(n){return new Gje(n,n.now())},qje=function(){return DQ(performance)},Xje=function(){return DQ(Date)},Kje=function(){return new jje(process.hrtime,process.hrtime())},Yje=function(){return typeof performance<"u"&&typeof performance.now=="function"?qje():typeof process<"u"&&typeof process.hrtime=="function"?Kje():Xje()},DE=function(n){return n.currentTime()},zN=Tr(function(n,e){return e.scheduleTask(0,0,-1,n)}),LI=Bu(function(n,e,t){return t.scheduleTask(0,n,-1,e)}),Zje=Bu(function(n,e,t){return t.scheduleTask(0,0,n,e)}),Jje=function(n){return n.dispose()},mB=Tr(function(n,e){return new AQ(n,e)}),Qje=function(){return new Oje(e8e(),new Fje)},e8e=function(){return new Wje(Yje())},N_=function(){return OQ},OQ=new(function(){function n(){}return n.prototype.dispose=function(){},n}()),t8e=function(n){return n===OQ},gB=function(n){return new n8e(n)},n8e=function(){function n(e){this.disposed=!1,this.disposable=e}return n.prototype.dispose=function(){this.disposed||(this.disposed=!0,this.disposable&&(this.disposable.dispose(),this.disposable=void 0))},n}();/** @license MIT License (c) copyright 2010 original author or authors */var gC=function(n){var e=LN(r8e,[],n);return e.length===0?N_():new FQ(e)},Ww=Tr(function(n,e){return gC([n,e])}),r8e=function(n,e){return t8e(e)?n:e instanceof FQ?Tje(n,e.disposables):EQ(e,n)},FQ=function(){function n(e){this.disposables=e}return n.prototype.dispose=function(){o8e(i8e(this.disposables))},n}(),i8e=function(n){return LN(s8e,[],n)},s8e=function(n,e){try{e.dispose()}catch(t){n.push(t)}return n},o8e=function(n){if(n.length>0)throw new LQ(n.length+" errors",n)},LQ=function(){function n(e,t){this.name="DisposeAllError",this.message=e,this.errors=t,Error.call(this,e),Error.captureStackTrace&&Error.captureStackTrace(this,n),this.stack=""+this.stack+a8e(this.errors)}return n}();LQ.prototype=Object.create(Error.prototype);var a8e=function(n){return LN(l8e,"",n)},l8e=function(n,e,t){return n+(`
[`+(t+1)+"] "+e.stack)};/** @license MIT License (c) copyright 2010-2017 original author or authors */var hg=Bu(function(n,e,t){try{e.dispose()}catch(r){t.error(n,r)}});/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */var OD=function(n,e){return OD=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var i in r)r.hasOwnProperty(i)&&(t[i]=r[i])},OD(n,e)};function Yr(n,e){OD(n,e);function t(){this.constructor=n}n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}/** @license MIT License (c) copyright 2010-2016 original author or authors */function zQ(n){setTimeout(c8e,0,n)}function c8e(n){throw n}/** @license MIT License (c) copyright 2010-2016 original author or authors */var u8e=function(n,e,t){return new f8e(n,e,t)},yB=function(n,e){return new d8e(n,e)},BQ=function(n){return new p8e(n)},h8e=function(n,e){return new m8e(n,e)},BN=function(){function n(e){this.sink=e,this.active=!0}return n.prototype.dispose=function(){this.active=!1},n.prototype.run=function(e){this.active&&this.runIfActive(e)},n.prototype.error=function(e,t){if(!this.active)return zQ(t);this.sink.error(e,t)},n}(),f8e=function(n){Yr(e,n);function e(t,r,i){var s=n.call(this,i)||this;return s.runEvent=t,s.value=r,s}return e.prototype.runIfActive=function(t){this.runEvent(t,this.value,this.sink)},e}(BN),d8e=function(n){Yr(e,n);function e(t,r){var i=n.call(this,r)||this;return i.value=t,i}return e.prototype.runIfActive=function(t){this.sink.event(t,this.value)},e}(BN),p8e=function(n){Yr(e,n);function e(){return n!==null&&n.apply(this,arguments)||this}return e.prototype.runIfActive=function(t){this.sink.end(t)},e}(BN),m8e=function(n){Yr(e,n);function e(t,r){var i=n.call(this,r)||this;return i.value=t,i}return e.prototype.runIfActive=function(t){this.sink.error(t,this.value)},e}(BN);/** @license MIT License (c) copyright 2010-2017 original author or authors */var Ks=function(){return UQ},Ms=function(n){return n===UQ},VQ=function(n){return n.some(Ms)},g8e=function(){function n(){}return n.prototype.run=function(e,t){return zN(BQ(e),t)},n}(),UQ=new g8e;/** @license MIT License (c) copyright 2010-2017 original author or authors */var $_=function(){return b8e},y8e=function(){function n(){}return n.prototype.run=function(){return N_()},n}(),b8e=new y8e;/** @license MIT License (c) copyright 2010-2017 original author or authors */var WQ=function(n,e){return new v8e(n,e)},v8e=function(){function n(e,t){this.time=e,this.value=t}return n.prototype.run=function(e,t){return LI(this.time,u8e(w8e,this.value,e),t)},n}();function w8e(n,e,t){t.event(n,e),t.end(n)}/** @license MIT License (c) copyright 2010-2017 original author or authors */var FD=function(n){return WQ(0,n)};/** @license MIT License (c) copyright 2010-2016 original author or authors */var x8e=function(n){return new _8e(n)},_8e=function(){function n(e){this.period=e}return n.prototype.run=function(e,t){return Zje(this.period,yB(void 0,e),t)},n}(),VN=function(){function n(){this.disposable=void 0,this.disposed=!1}return n.prototype.setDisposable=function(e){if(this.disposable!==void 0)throw new Error("setDisposable called more than once");this.disposable=e,this.disposed&&e.dispose()},n.prototype.dispose=function(){this.disposed||(this.disposed=!0,this.disposable!==void 0&&this.disposable.dispose())},n}();/** @license MIT License (c) copyright 2010-2017 original author or authors */var S8e=Tr(function(n,e){return new Promise(function(t,r){return C8e(n,e,t,r)})});function C8e(n,e,t,r){var i=new VN,s=new k8e(t,r,i);i.setDisposable(n.run(s,e))}var k8e=function(){function n(e,t,r){this._end=e,this._error=t,this._disposable=r,this.active=!0}return n.prototype.event=function(){},n.prototype.end=function(){this.active&&this.dispose(this._error,this._end,void 0)},n.prototype.error=function(e,t){this.dispose(this._error,this._error,t)},n.prototype.dispose=function(e,t,r){this.active=!1,T8e(e,t,r,this._disposable)},n}();function T8e(n,e,t,r){try{r.dispose()}catch(i){n(i);return}e(t)}var HQ=function(n,e,t){return t.run(n,e)},p3=function(){function n(e,t){this.sink=t,this.offset=e}return n.prototype.event=function(e,t){this.sink.event(e+this.offset,t)},n.prototype.error=function(e,t){this.sink.error(e+this.offset,t)},n.prototype.end=function(e){this.sink.end(e+this.offset)},n}(),bB=function(n,e){return new E8e(n,e)},E8e=function(){function n(e,t){this.origin=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(I8e(this.origin,e),mB(this.origin,t))},n}(),I8e=function(n,e){return e instanceof p3?new p3(n+e.offset,e.sink):new p3(n,e)},Ii=function(){function n(e){this.sink=e}return n.prototype.end=function(e){return this.sink.end(e)},n.prototype.error=function(e,t){return this.sink.error(e,t)},n}();/** @license MIT License (c) copyright 2010 original author or authors */var A8e=function(n,e,t){return Ms(t)?Ks():new M8e(n,e,t)},M8e=function(){function n(e,t,r){this.step=e,this.seed=t,this.source=r}return n.prototype.run=function(e,t){return this.source.run(new N8e(this.step,this.seed,e),t)},n}(),N8e=function(n){Yr(e,n);function e(t,r,i){var s=n.call(this,i)||this;return s.step=t,s.seed=r,s}return e.prototype.event=function(t,r){var i=this.step(this.seed,r);this.seed=i.seed,this.sink.event(t,i.value)},e}(Ii);/** @license MIT License (c) copyright 2010-2016 original author or authors */var $8e=function(n,e,t){return new R8e(n,e,t)},R8e=function(){function n(e,t,r){this.source=r,this.f=e,this.value=t}return n.prototype.run=function(e,t){var r=zN(yB(this.value,e),t),i=this.source.run(new P8e(this.f,this.value,e),t);return Ww(r,i)},n}(),P8e=function(n){Yr(e,n);function e(t,r,i){var s=n.call(this,i)||this;return s.f=t,s.value=r,s}return e.prototype.event=function(t,r){var i=this.f;this.value=i(this.value,r),this.sink.event(t,this.value)},e}(Ii);/** @license MIT License (c) copyright 2010-2016 original author or authors */var GQ=function(n,e){return new D8e(n,e)},D8e=function(){function n(e,t){this.f=e,this.source=t}return n.prototype.run=function(e,t){return new O8e(this.f,this.source,e,t)},n}(),O8e=function(n){Yr(e,n);function e(t,r,i,s){var o=n.call(this,i)||this;return o.f=t,o.scheduler=s,o.active=!0,o.disposable=gB(r.run(o,s)),o}return e.prototype.event=function(t,r){this.active&&this.sink.event(t,r)},e.prototype.end=function(t){this.active&&(hg(t,this.disposable,this.sink),this.startNext(t,this.sink))},e.prototype.startNext=function(t,r){try{this.disposable=this.continue(this.f,t,r)}catch(i){r.error(t,i)}},e.prototype.continue=function(t,r,i){return HQ(i,this.scheduler,bB(r,t()))},e.prototype.dispose=function(){return this.active=!1,this.disposable.dispose()},e}(Ii);/** @license MIT License (c) copyright 2010-2017 original author or authors */var F8e=function(n,e){return GQ(function(){return e},FD(n))};/** @license MIT License (c) copyright 2010-2016 original author or authors */var jQ=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new L8e(this.p,e),t)},n.create=function(e,t){return Ms(t)?t:t instanceof n?new n(z8e(t.p,e),t.source):new n(e,t)},n}(),L8e=function(n){Yr(e,n);function e(t,r){var i=n.call(this,r)||this;return i.p=t,i}return e.prototype.event=function(t,r){var i=this.p;i(r)&&this.sink.event(t,r)},e}(Ii),z8e=function(n,e){return function(t){return n(t)&&e(t)}};/** @license MIT License (c) copyright 2010-2016 original author or authors */var B8e=function(){function n(e,t,r){this.p=e,this.f=t,this.source=r}return n.prototype.run=function(e,t){return this.source.run(new V8e(this.p,this.f,e),t)},n}(),V8e=function(n){Yr(e,n);function e(t,r,i){var s=n.call(this,i)||this;return s.p=t,s.f=r,s}return e.prototype.event=function(t,r){var i=this.f,s=this.p;s(r)&&this.sink.event(t,i(r))},e}(Ii);/** @license MIT License (c) copyright 2010-2016 original author or authors */var yC=function(){function n(e,t){this.f=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new U8e(this.f,e),t)},n.create=function(e,t){return Ms(t)?Ks():t instanceof n?new n($je(e,t.f),t.source):t instanceof jQ?new B8e(t.p,e,t.source):new n(e,t)},n}(),U8e=function(n){Yr(e,n);function e(t,r){var i=n.call(this,r)||this;return i.f=t,i}return e.prototype.event=function(t,r){var i=this.f;this.sink.event(t,i(r))},e}(Ii);/** @license MIT License (c) copyright 2010-2016 original author or authors */var UN=function(n,e){return yC.create(n,e)},W8e=function(n,e){return UN(function(){return n},e)},H8e=function(n,e){return new G8e(n,e)},G8e=function(){function n(e,t){this.source=t,this.f=e}return n.prototype.run=function(e,t){return this.source.run(new j8e(this.f,e),t)},n}(),j8e=function(n){Yr(e,n);function e(t,r){var i=n.call(this,r)||this;return i.f=t,i}return e.prototype.event=function(t,r){var i=this.f;i(r),this.sink.event(t,r)},e}(Ii);/** @license MIT License (c) copyright 2010-2016 original author or authors */var vB=function(n){Yr(e,n);function e(t,r){var i=n.call(this,r)||this;return i.index=t,i.active=!0,i.value=void 0,i}return e.prototype.event=function(t,r){this.active&&(this.value=r,this.sink.event(t,this))},e.prototype.end=function(t){this.active&&(this.active=!1,this.sink.event(t,this))},e}(Ii);/** @license MIT License (c) copyright 2010-2016 original author or authors */function qQ(n,e){switch(e.length){case 0:return n();case 1:return n(e[0]);case 2:return n(e[0],e[1]);case 3:return n(e[0],e[1],e[2]);case 4:return n(e[0],e[1],e[2],e[3]);case 5:return n(e[0],e[1],e[2],e[3],e[4]);default:return n.apply(void 0,e)}}/** @license MIT License (c) copyright 2010 original author or authors */var XQ=function(n,e,t){return q8e(n,[e,t])},q8e=function(n,e){return e.length===0||VQ(e)?Ks():e.length===1?UN(n,e[0]):new X8e(n,e)},X8e=function(){function n(e,t){this.f=e,this.sources=t}return n.prototype.run=function(e,t){for(var r=this.sources.length,i=new Array(r),s=new Array(r),o=new K8e(i,s.length,e,this.f),a=void 0,l=0;l<r;++l)a=s[l]=new vB(l,o),i[l]=this.sources[l].run(a,t);return gC(i)},n}(),K8e=function(n){Yr(e,n);function e(t,r,i,s){var o=n.call(this,i)||this;return o.disposables=t,o.f=s,o.awaiting=r,o.values=new Array(r),o.hasValue=new Array(r).fill(!1),o.activeCount=r,o}return e.prototype.event=function(t,r){if(!r.active){this.dispose(t,r.index);return}var i=r.index,s=this.updateReady(i);this.values[i]=r.value,s===0&&this.sink.event(t,qQ(this.f,this.values))},e.prototype.updateReady=function(t){return this.awaiting>0&&(this.hasValue[t]||(this.hasValue[t]=!0,this.awaiting-=1)),this.awaiting},e.prototype.dispose=function(t,r){hg(t,this.disposables[r],this.sink),--this.activeCount===0&&this.sink.end(t)},e}(Ii);/** @license MIT License (c) copyright 2010-2016 original author or authors */function Y8e(n,e){return XQ(Rje,n,e)}/** @license MIT License (c) copyright 2010 original author or authors */var KQ=function(n,e){return WN(Nje,n,e)},WN=function(n,e,t){return Ms(t)?Ks():new Z8e(n,e,t)},Z8e=function(){function n(e,t,r){this.f=e,this.concurrency=t,this.source=r}return n.prototype.run=function(e,t){return new Q8e(this.f,this.concurrency,this.source,e,t)},n}(),J8e=function(n){return n.length>0},Q8e=function(){function n(e,t,r,i,s){this.f=e,this.concurrency=t,this.sink=i,this.scheduler=s,this.pending=[],this.current=[],this.disposable=gB(r.run(this,s)),this.active=!0}return n.prototype.event=function(e,t){this.addInner(e,t)},n.prototype.addInner=function(e,t){this.current.length<this.concurrency?this.startInner(e,t):this.pending.push(t)},n.prototype.startInner=function(e,t){try{this.initInner(e,t)}catch(r){this.error(e,r)}},n.prototype.initInner=function(e,t){var r=new tqe(e,this,this.sink);r.disposable=eqe(this.f,e,t,r,this.scheduler),this.current.push(r)},n.prototype.end=function(e){this.active=!1,hg(e,this.disposable,this.sink),this.checkEnd(e)},n.prototype.error=function(e,t){this.active=!1,this.sink.error(e,t)},n.prototype.dispose=function(){this.active=!1,this.pending.length=0,this.disposable.dispose(),gC(this.current).dispose()},n.prototype.endInner=function(e,t){var r=this.current.indexOf(t);r>=0&&this.current.splice(r,1),hg(e,t,this);var i=this.pending;J8e(i)?this.startInner(e,i.shift()):this.checkEnd(e)},n.prototype.checkEnd=function(e){!this.active&&this.current.length===0&&this.sink.end(e)},n}(),eqe=function(n,e,t,r,i){return n(t).run(r,mB(e,i))},tqe=function(){function n(e,t,r){this.time=e,this.outer=t,this.sink=r,this.disposable=N_()}return n.prototype.event=function(e,t){this.sink.event(e+this.time,t)},n.prototype.end=function(e){this.outer.endInner(e+this.time,this)},n.prototype.error=function(e,t){this.outer.error(e+this.time,t)},n.prototype.dispose=function(){return this.disposable.dispose()},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */var nqe=function(n,e){return WN(n,1/0,e)},YQ=function(n){return KQ(1/0,n)};/** @license MIT License (c) copyright 2010-2016 original author or authors */var rqe=function(n,e){return WN(n,1,e)};/** @license MIT License (c) copyright 2010-2016 original author or authors */function iqe(n,e){return sqe([n,e])}var sqe=function(n){return oqe(aqe(n))},oqe=function(n){return n.length===0?Ks():n.length===1?n[0]:new ZQ(LN(cqe,[],n))},aqe=function(n){return n.filter(lqe)},lqe=function(n){return!Ms(n)},cqe=function(n,e){return n.concat(e instanceof ZQ?e.sources:e)},ZQ=function(){function n(e){this.sources=e}return n.prototype.run=function(e,t){for(var r=this.sources.length,i=new Array(r),s=new Array(r),o=new uqe(i,s,e),a=void 0,l=0;l<r;++l)a=s[l]=new vB(l,o),i[l]=this.sources[l].run(a,t);return gC(i)},n}(),uqe=function(n){Yr(e,n);function e(t,r,i){var s=n.call(this,i)||this;return s.disposables=t,s.activeCount=r.length,s}return e.prototype.event=function(t,r){if(!r.active){this.dispose(t,r.index);return}this.sink.event(t,r.value)},e.prototype.dispose=function(t,r){hg(t,this.disposables[r],this.sink),--this.activeCount===0&&this.sink.end(t)},e}(Ii);/** @license MIT License (c) copyright 2010 original author or authors */var hqe=function(n,e){return JQ(function(t){return t},n,e)},JQ=function(n,e,t){return Ms(t)||Ms(e)?Ks():new fqe(n,e,t)},fqe=function(){function n(e,t,r){this.f=e,this.values=t,this.sampler=r}return n.prototype.run=function(e,t){var r=new dqe(this.f,e),i=this.values.run(r.latest,t),s=this.sampler.run(r,t);return Ww(s,i)},n}(),dqe=function(n){Yr(e,n);function e(t,r){var i=n.call(this,r)||this;return i.f=t,i.latest=new pqe(i),i}return e.prototype.event=function(t,r){if(this.latest.hasValue){var i=this.f;this.sink.event(t,i(this.latest.value,r))}},e}(Ii),pqe=function(n){Yr(e,n);function e(t){var r=n.call(this,t)||this;return r.hasValue=!1,r}return e.prototype.event=function(t,r){this.value=r,this.hasValue=!0},e.prototype.end=function(){},e}(Ii);/** @license MIT License (c) copyright 2010 original author or authors */var QQ=function(n,e){var t=Math.max(0,n),r=Math.max(t,e);return{min:t,max:r}},mqe=function(n,e){return QQ(n.min+e.min,Math.min(n.max,n.min+e.max))},gqe=function(n){return n.min>=n.max},yqe=function(n){return n.min<=0&&n.max===1/0},eee=function(n,e){return wB(0,n,e)},bqe=function(n,e){return wB(n,1/0,e)},wB=function(n,e,t){return xB(QQ(n,e),t)},xB=function(n,e){return vqe(n,e)?Ks():e instanceof yC?xqe(n,e):e instanceof tee?_qe(n,e):wqe(n,e)},vqe=function(n,e){return Ms(e)||gqe(n)},wqe=function(n,e){return yqe(n)?e:new tee(n,e)},xqe=function(n,e){return yC.create(e.f,xB(n,e.source))},_qe=function(n,e){return xB(mqe(e.bounds,n),e.source)},tee=function(){function n(e,t){this.source=t,this.bounds=e}return n.prototype.run=function(e,t){var r=new VN,i=new Sqe(this.bounds.min,this.bounds.max-this.bounds.min,e,r);return r.setDisposable(this.source.run(i,t)),r},n}(),Sqe=function(n){Yr(e,n);function e(t,r,i,s){var o=n.call(this,i)||this;return o.skip=t,o.take=r,o.disposable=s,o}return e.prototype.event=function(t,r){if(this.skip>0){this.skip-=1;return}this.take!==0&&(this.take-=1,this.sink.event(t,r),this.take===0&&(this.disposable.dispose(),this.sink.end(t)))},e}(Ii),Cqe=function(n,e){return Ms(e)?Ks():new kqe(n,e)},kqe=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){var r=new VN,i=new Tqe(this.p,e,r);return r.setDisposable(this.source.run(i,t)),r},n}(),Tqe=function(n){Yr(e,n);function e(t,r,i){var s=n.call(this,r)||this;return s.p=t,s.active=!0,s.disposable=i,s}return e.prototype.event=function(t,r){if(this.active){var i=this.p;this.active=i(r),this.active?this.sink.event(t,r):(this.disposable.dispose(),this.sink.end(t))}},e}(Ii),Eqe=function(n,e){return Ms(e)?Ks():new Iqe(n,e)},Iqe=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new Aqe(this.p,e),t)},n}(),Aqe=function(n){Yr(e,n);function e(t,r){var i=n.call(this,r)||this;return i.p=t,i.skipping=!0,i}return e.prototype.event=function(t,r){if(this.skipping){var i=this.p;if(this.skipping=i(r),this.skipping)return}this.sink.event(t,r)},e}(Ii),Mqe=function(n,e){return Ms(e)?Ks():new Nqe(n,e)},Nqe=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new $qe(this.p,e),t)},n}(),$qe=function(n){Yr(e,n);function e(t,r){var i=n.call(this,r)||this;return i.p=t,i.skipping=!1,i}return e.prototype.event=function(t,r){if(!this.skipping){var i=this.p;this.skipping=i(r),this.sink.event(t,r),this.skipping&&this.sink.end(t)}},e}(Ii);/** @license MIT License (c) copyright 2017 original author or authors */var Rqe=function(n,e){return nee(Pqe,n,e)},nee=function(n,e,t){return Ms(t)||e.length===0?Ks():new Dqe(n,e,eee(e.length,t))},Pqe=function(n){return n},Dqe=function(){function n(e,t,r){this.f=e,this.items=t,this.source=r}return n.prototype.run=function(e,t){return this.source.run(new Oqe(this.f,this.items,e),t)},n}(),Oqe=function(n){Yr(e,n);function e(t,r,i){var s=n.call(this,i)||this;return s.f=t,s.items=r,s.index=0,s}return e.prototype.event=function(t,r){var i=this.f;this.sink.event(t,i(this.items[this.index],r)),this.index+=1},e}(Ii),Fqe=2,Lqe=1e4,zqe=function(){function n(){this.head=0,this.tail=0,this.capacityMask=3,this.list=new Array(4)}return n.prototype.push=function(e){var t=this.tail;return this.list[t]=e,this.tail=t+1&this.capacityMask,this.tail===this.head&&this.growArray(),this.head<this.tail?this.tail-this.head:this.capacityMask+1-(this.head-this.tail)},n.prototype.shift=function(){var e=this.head;if(e!==this.tail){var t=this.list[e];return this.list[e]=void 0,this.head=e+1&this.capacityMask,e<Fqe&&this.tail>Lqe&&this.tail<=this.list.length>>>2&&this.shrinkArray(),t}},n.prototype.isEmpty=function(){return this.head===this.tail},n.prototype.length=function(){return this.head===this.tail?0:this.head<this.tail?this.tail-this.head:this.capacityMask+1-(this.head-this.tail)},n.prototype.growArray=function(){this.head&&(this.list=this.copyArray(),this.head=0),this.tail=this.list.length,this.list.length*=2,this.capacityMask=this.capacityMask<<1|1},n.prototype.shrinkArray=function(){this.list.length>>>=1,this.capacityMask>>>=1},n.prototype.copyArray=function(){var e=[],t=this.list,r=t.length,i;for(i=this.head;i<r;i++)e.push(t[i]);for(i=0;i<this.tail;i++)e.push(t[i]);return e},n}();/** @license MIT License (c) copyright 2010 original author or authors */function Bqe(n,e,t){return Vqe(n,[e,t])}var Vqe=function(n,e){return e.length===0||VQ(e)?Ks():e.length===1?UN(n,e[0]):new Uqe(n,e)},Uqe=function(){function n(e,t){this.f=e,this.sources=t}return n.prototype.run=function(e,t){for(var r=this.sources.length,i=new Array(r),s=new Array(r),o=new Array(r),a=new Wqe(this.f,o,s,e),l=void 0,c=0;c<r;++c)o[c]=new zqe,l=s[c]=new vB(c,a),i[c]=this.sources[c].run(l,t);return gC(i)},n}(),Wqe=function(n){Yr(e,n);function e(t,r,i,s){var o=n.call(this,s)||this;return o.f=t,o.sinks=i,o.buffers=r,o}return e.prototype.event=function(t,r){if(!r.active){this.dispose(t,r.index);return}var i=this.buffers,s=i[r.index];if(s.push(r.value),s.length()===1){if(!qqe(i))return;Hqe(this.f,t,i,this.sink),jqe(this.buffers,this.sinks)&&this.sink.end(t)}},e.prototype.dispose=function(t,r){var i=this.buffers[r];i.isEmpty()&&this.sink.end(t)},e}(Ii),Hqe=function(n,e,t,r){return r.event(e,qQ(n,Eje(Gqe,t)))},Gqe=function(n){return n.shift()};function jqe(n,e){for(var t=0,r=n.length;t<r;++t)if(n[t].isEmpty()&&!e[t].active)return!0;return!1}function qqe(n){for(var e=0,t=n.length;e<t;++e)if(n[e].isEmpty())return!1;return!0}/** @license MIT License (c) copyright 2010-2016 original author or authors */var Xqe=function(n){return Ms(n)?Ks():new Kqe(n)},Kqe=function(){function n(e){this.source=e}return n.prototype.run=function(e,t){var r=new Yqe(e,t);return Ww(r,this.source.run(r,t))},n}(),Yqe=function(){function n(e,t){this.sink=e,this.scheduler=t,this.current=null,this.ended=!1}return n.prototype.event=function(e,t){this.disposeCurrent(e),this.current=new Zqe(t,e,1/0,this,this.sink,this.scheduler)},n.prototype.end=function(e){this.ended=!0,this.checkEnd(e)},n.prototype.error=function(e,t){this.ended=!0,this.sink.error(e,t)},n.prototype.dispose=function(){return this.disposeCurrent(DE(this.scheduler))},n.prototype.disposeCurrent=function(e){if(this.current!==null)return this.current.dispose(e)},n.prototype.disposeInner=function(e,t){t.dispose(e),t===this.current&&(this.current=null)},n.prototype.checkEnd=function(e){this.ended&&this.current===null&&this.sink.end(e)},n.prototype.endInner=function(e,t){this.disposeInner(e,t),this.checkEnd(e)},n.prototype.errorInner=function(e,t,r){this.disposeInner(e,r),this.sink.error(e,t)},n}(),Zqe=function(){function n(e,t,r,i,s,o){this.min=t,this.max=r,this.outer=i,this.sink=s,this.disposable=e.run(this,mB(t,o))}return n.prototype.event=function(e,t){var r=Math.max(0,e+this.min);r<this.max&&this.sink.event(r,t)},n.prototype.end=function(e){this.outer.endInner(e+this.min,this)},n.prototype.error=function(e,t){this.outer.errorInner(e+this.min,t,this)},n.prototype.dispose=function(e){hg(e,this.disposable,this.sink)},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */function Jqe(n,e){return jQ.create(n,e)}var Qqe=function(n){return ree(n9e,n)},ree=function(n,e){return Ms(e)?Ks():new e9e(n,e)},e9e=function(){function n(e,t){this.equals=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new t9e(this.equals,e),t)},n}(),t9e=function(n){Yr(e,n);function e(t,r){var i=n.call(this,r)||this;return i.equals=t,i.value=void 0,i.init=!0,i}return e.prototype.event=function(t,r){this.init?(this.init=!1,this.value=r,this.sink.event(t,r)):this.equals(this.value,r)||(this.value=r,this.sink.event(t,r))},e}(Ii);function n9e(n,e){return n===e}/** @license MIT License (c) copyright 2010-2016 original author or authors */var iee=function(n,e){return new i9e(n,e)},see=function(n,e){return new s9e(n,e)},r9e=function(n,e){return iee(YQ(n),see(n,e))},i9e=function(){function n(e,t){this.maxSignal=e,this.source=t}return n.prototype.run=function(e,t){var r=new VN,i=this.source.run(e,t),s=this.maxSignal.run(new l9e(e,r),t);return r.setDisposable(Ww(i,s)),r},n}(),s9e=function(){function n(e,t){this.minSignal=e,this.source=t}return n.prototype.run=function(e,t){var r=new a9e(this.minSignal,e,t),i=this.source.run(new o9e(r,e),t);return Ww(r,i)},n}(),o9e=function(n){Yr(e,n);function e(t,r){var i=n.call(this,r)||this;return i.min=t,i}return e.prototype.event=function(t,r){this.min.allow&&this.sink.event(t,r)},e}(Ii),a9e=function(n){Yr(e,n);function e(t,r,i){var s=n.call(this,r)||this;return s.allow=!1,s.disposable=t.run(s,i),s}return e.prototype.event=function(){this.allow=!0,this.dispose()},e.prototype.end=function(){},e.prototype.dispose=function(){this.disposable.dispose()},e}(Ii),l9e=function(n){Yr(e,n);function e(t,r){var i=n.call(this,t)||this;return i.disposable=r,i}return e.prototype.event=function(t){this.disposable.dispose(),this.sink.end(t)},e.prototype.end=function(){},e}(Ii);/** @license MIT License (c) copyright 2010-2016 original author or authors */var c9e=function(n,e){return n<=0?e:new u9e(n,e)},u9e=function(){function n(e,t){this.dt=e,this.source=t}return n.prototype.run=function(e,t){var r=new h9e(this.dt,e,t);return Ww(r,this.source.run(r,t))},n}(),h9e=function(n){Yr(e,n);function e(t,r,i){var s=n.call(this,r)||this;return s.dt=t,s.scheduler=i,s.tasks=[],s}return e.prototype.dispose=function(){this.tasks.forEach(Jje)},e.prototype.event=function(t,r){this.tasks.push(LI(this.dt,yB(r,this.sink),this.scheduler))},e.prototype.end=function(){this.tasks.push(LI(this.dt,BQ(this.sink),this.scheduler))},e}(Ii);/** @license MIT License (c) copyright 2010-2017 original author or authors */var oee=function(n,e){return Ms(e)?Ks():e instanceof yC?f9e(n,e):e instanceof LD?d9e(n,e):new LD(n,e)},f9e=function(n,e){return yC.create(e.f,oee(n,e.source))},d9e=function(n,e){return new LD(Math.max(n,e.period),e.source)},LD=function(){function n(e,t){this.period=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new p9e(this.period,e),t)},n}(),p9e=function(n){Yr(e,n);function e(t,r){var i=n.call(this,r)||this;return i.time=0,i.period=t,i}return e.prototype.event=function(t,r){t>=this.time&&(this.time=t+this.period,this.sink.event(t,r))},e}(Ii),m9e=function(n,e){return Ms(e)?Ks():new g9e(n,e)},g9e=function(){function n(e,t){this.dt=e,this.source=t}return n.prototype.run=function(e,t){return new y9e(this.dt,this.source,e,t)},n}(),y9e=function(){function n(e,t,r,i){this.dt=e,this.sink=r,this.scheduler=i,this.timer=null,this.disposable=t.run(this,i)}return n.prototype.event=function(e,t){this.clearTimer(),this.value=t,this.timer=LI(this.dt,new b9e(this,t),this.scheduler)},n.prototype.handleEventFromTask=function(e,t){this.clearTimer(),this.sink.event(e,t)},n.prototype.end=function(e){this.clearTimer()&&(this.sink.event(e,this.value),this.value=void 0),this.sink.end(e)},n.prototype.error=function(e,t){this.clearTimer(),this.sink.error(e,t)},n.prototype.dispose=function(){this.clearTimer(),this.disposable.dispose()},n.prototype.clearTimer=function(){return this.timer===null?!1:(this.timer.dispose(),this.timer=null,!0)},n}(),b9e=function(){function n(e,t){this.sink=e,this.value=t}return n.prototype.run=function(e){this.sink.handleEventFromTask(e,this.value)},n.prototype.error=function(e,t){this.sink.error(e,t)},n.prototype.dispose=function(){},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */var v9e=function(n){return Ms(n)?Ks():new w9e(n)},w9e=function(){function n(e){this.source=e}return n.prototype.run=function(e,t){return this.source.run(new x9e(e,t),t)},n}(),x9e=function(){function n(e,t){var r=this;this.eventBound=function(i){return r.sink.event(DE(r.scheduler),i)},this.endBound=function(){return r.sink.end(DE(r.scheduler))},this.errorBound=function(i){return r.sink.error(DE(r.scheduler),i)},this.sink=e,this.scheduler=t,this.queue=Promise.resolve()}return n.prototype.event=function(e,t){var r=this;this.queue=this.queue.then(function(){return r.handlePromise(t)}).catch(this.errorBound)},n.prototype.end=function(){this.queue=this.queue.then(this.endBound).catch(this.errorBound)},n.prototype.error=function(e,t){var r=this;this.queue=this.queue.then(function(){return r.errorBound(t)}).catch(zQ)},n.prototype.handlePromise=function(e){return e.then(this.eventBound)},n}(),_9e=function(){function n(e){this.sink=e,this.active=!0}return n.prototype.event=function(e,t){this.active&&this.sink.event(e,t)},n.prototype.end=function(e){this.active&&(this.disable(),this.sink.end(e))},n.prototype.error=function(e,t){this.disable(),this.sink.error(e,t)},n.prototype.disable=function(){return this.active=!1,this.sink},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */function aee(n,e,t){try{t.event(n,e)}catch(r){t.error(n,r)}}function lee(n,e){try{e.end(n)}catch(t){e.error(n,t)}}/** @license MIT License (c) copyright 2010-2016 original author or authors */var S9e=function(n,e){return Ms(e)?Ks():new T9e(n,e)},C9e=function(n){return new k9e(n)},k9e=function(){function n(e){this.value=e}return n.prototype.run=function(e,t){return zN(h8e(this.value,e),t)},n}(),T9e=function(){function n(e,t){this.f=e,this.source=t}return n.prototype.run=function(e,t){return new E9e(this.f,this.source,e,t)},n}(),E9e=function(){function n(e,t,r,i){this.f=e,this.sink=new _9e(r),this.scheduler=i,this.disposable=t.run(this,i)}return n.prototype.event=function(e,t){aee(e,t,this.sink)},n.prototype.end=function(e){lee(e,this.sink)},n.prototype.error=function(e,t){var r=this.sink.disable();hg(e,this.disposable,this.sink),this._startNext(e,t,r)},n.prototype._startNext=function(e,t,r){try{this.disposable=this._continue(this.f,e,t,r)}catch(i){r.error(e,i)}},n.prototype._continue=function(e,t,r,i){return HQ(i,this.scheduler,bB(t,e(r)))},n.prototype.dispose=function(){return this.disposable.dispose()},n}(),I9e=function(n){return n instanceof tG||Ms(n)?n:new tG(n)},tG=function(){function n(e){this.source=new A9e(e)}return n.prototype.run=function(e,t){return this.source.run(e,t)},n}(),A9e=function(){function n(e){this.source=e,this.sinks=[],this.disposable=N_()}return n.prototype.run=function(e,t){var r=this.add(e);return r===1&&(this.disposable=this.source.run(this,t)),gB(new M9e(this,e))},n.prototype.dispose=function(){var e=this.disposable;return this.disposable=N_(),e.dispose()},n.prototype.add=function(e){return this.sinks=EQ(e,this.sinks),this.sinks.length},n.prototype.remove=function(e){var t=IQ(e,this.sinks);return t>=0&&(this.sinks=Ije(t,this.sinks)),this.sinks.length},n.prototype.event=function(e,t){var r=this.sinks;if(r.length===1)return r[0].event(e,t);for(var i=0;i<r.length;++i)aee(e,t,r[i])},n.prototype.end=function(e){for(var t=this.sinks,r=0;r<t.length;++r)lee(e,t[r])},n.prototype.error=function(e,t){for(var r=this.sinks,i=0;i<r.length;++i)r[i].error(e,t)},n}(),M9e=function(){function n(e,t){this.source=e,this.sink=t}return n.prototype.dispose=function(){this.source.remove(this.sink)===0&&this.source.dispose()},n}(),N9e=Tr(bB),$9e=Bu(A8e),R9e=Bu($8e),P9e=Tr(F8e),nG=Tr(UN),D9e=Tr(W8e),rG=Tr(H8e),O9e=Tr(Y8e),F9e=Tr(nqe),L9e=Tr(GQ),z9e=Tr(rqe),B9e=Tr(KQ),V9e=Bu(WN),iG=Tr(iqe),U9e=Bu(XQ),sG=Tr(hqe),W9e=Bu(JQ),H9e=Bu(nee),G9e=Tr(Rqe),j9e=Bu(Bqe),q9e=Tr(Jqe),X9e=Tr(ree),K9e=Tr(eee),Y9e=Tr(bqe),Z9e=Bu(wB),J9e=Tr(Cqe),Q9e=Tr(Eqe),e7e=Tr(Mqe),oG=Tr(iee),t7e=Tr(see),n7e=Tr(r9e),r7e=Tr(c9e),i7e=Tr(oee),s7e=Tr(m9e),o7e=Tr(S9e),aG=function(){var n=[];return[function(e){return a7e(n,e)},new l7e(n)]},a7e=function(n,e){return n.forEach(function(t){var r=t.sink,i=t.scheduler;return u7e(i.currentTime(),e,r)})},l7e=function(){function n(e){this.sinks=e}return n.prototype.run=function(e,t){var r={sink:e,scheduler:t};return this.sinks.push(r),new c7e(r,this.sinks)},n}(),c7e=function(){function n(e,t){this.sink=e,this.sinks=t}return n.prototype.dispose=function(){var e=this.sinks.indexOf(this.sink);e>=0&&this.sinks.splice(e,1)},n}();function u7e(n,e,t){try{t.event(n,e)}catch(r){t.error(n,r)}}const h7e=n=>{const e=new Set;do for(const t of Reflect.ownKeys(n))e.add([n,t]);while((n=Reflect.getPrototypeOf(n))&&n!==Object.prototype);return e};function f7e(n,{include:e,exclude:t}={}){const r=i=>{const s=o=>typeof o=="string"?i===o:o.test(i);return e?e.some(s):t?!t.some(s):!0};for(const[i,s]of h7e(n.constructor.prototype)){if(s==="constructor"||!r(s))continue;const o=Reflect.getOwnPropertyDescriptor(i,s);o&&typeof o.value=="function"&&(n[s]=n[s].bind(n))}return n}var zD={exports:{}},d7e=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,p7e=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],cee=function(e){var t=e,r=e.indexOf("["),i=e.indexOf("]");r!=-1&&i!=-1&&(e=e.substring(0,r)+e.substring(r,i).replace(/:/g,";")+e.substring(i,e.length));for(var s=d7e.exec(e||""),o={},a=14;a--;)o[p7e[a]]=s[a]||"";return r!=-1&&i!=-1&&(o.source=t,o.host=o.host.substring(1,o.host.length-1).replace(/;/g,":"),o.authority=o.authority.replace("[","").replace("]","").replace(/;/g,":"),o.ipv6uri=!0),o.pathNames=m7e(o,o.path),o.queryKey=g7e(o,o.query),o};function m7e(n,e){var t=/\/{2,9}/g,r=e.replace(t,"/").split("/");return(e.substr(0,1)=="/"||e.length===0)&&r.splice(0,1),e.substr(e.length-1,1)=="/"&&r.splice(r.length-1,1),r}function g7e(n,e){var t={};return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g,function(r,i,s){i&&(t[i]=s)}),t}var BD={exports:{}},VD={exports:{}},R_=1e3,P_=R_*60,D_=P_*60,O_=D_*24,y7e=O_*365.25,b7e=function(n,e){e=e||{};var t=typeof n;if(t==="string"&&n.length>0)return v7e(n);if(t==="number"&&isNaN(n)===!1)return e.long?x7e(n):w7e(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))};function v7e(n){if(n=String(n),!(n.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(e){var t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*y7e;case"days":case"day":case"d":return t*O_;case"hours":case"hour":case"hrs":case"hr":case"h":return t*D_;case"minutes":case"minute":case"mins":case"min":case"m":return t*P_;case"seconds":case"second":case"secs":case"sec":case"s":return t*R_;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function w7e(n){return n>=O_?Math.round(n/O_)+"d":n>=D_?Math.round(n/D_)+"h":n>=P_?Math.round(n/P_)+"m":n>=R_?Math.round(n/R_)+"s":n+"ms"}function x7e(n){return Jk(n,O_,"day")||Jk(n,D_,"hour")||Jk(n,P_,"minute")||Jk(n,R_,"second")||n+" ms"}function Jk(n,e,t){if(!(n<e))return n<e*1.5?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}(function(n,e){e=n.exports=r.debug=r.default=r,e.coerce=l,e.disable=o,e.enable=s,e.enabled=a,e.humanize=b7e,e.instances=[],e.names=[],e.skips=[],e.formatters={};function t(c){var u=0,h;for(h in c)u=(u<<5)-u+c.charCodeAt(h),u|=0;return e.colors[Math.abs(u)%e.colors.length]}function r(c){var u;function h(){if(h.enabled){var f=h,d=+new Date,p=d-(u||d);f.diff=p,f.prev=u,f.curr=d,u=d;for(var m=new Array(arguments.length),g=0;g<m.length;g++)m[g]=arguments[g];m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");var y=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,function(_,w){if(_==="%%")return _;y++;var S=e.formatters[w];if(typeof S=="function"){var C=m[y];_=S.call(f,C),m.splice(y,1),y--}return _}),e.formatArgs.call(f,m);var b=h.log||e.log||console.log.bind(console);b.apply(f,m)}}return h.namespace=c,h.enabled=e.enabled(c),h.useColors=e.useColors(),h.color=t(c),h.destroy=i,typeof e.init=="function"&&e.init(h),e.instances.push(h),h}function i(){var c=e.instances.indexOf(this);return c!==-1?(e.instances.splice(c,1),!0):!1}function s(c){e.save(c),e.names=[],e.skips=[];var u,h=(typeof c=="string"?c:"").split(/[\s,]+/),f=h.length;for(u=0;u<f;u++)h[u]&&(c=h[u].replace(/\*/g,".*?"),c[0]==="-"?e.skips.push(new RegExp("^"+c.substr(1)+"$")):e.names.push(new RegExp("^"+c+"$")));for(u=0;u<e.instances.length;u++){var d=e.instances[u];d.enabled=e.enabled(d.namespace)}}function o(){e.enable("")}function a(c){if(c[c.length-1]==="*")return!0;var u,h;for(u=0,h=e.skips.length;u<h;u++)if(e.skips[u].test(c))return!1;for(u=0,h=e.names.length;u<h;u++)if(e.names[u].test(c))return!0;return!1}function l(c){return c instanceof Error?c.stack||c.message:c}})(VD,VD.exports);var _7e=VD.exports;(function(n,e){e=n.exports=_7e,e.log=i,e.formatArgs=r,e.save=s,e.load=o,e.useColors=t,e.storage=typeof chrome<"u"&&typeof chrome.storage<"u"?chrome.storage.local:a(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&window.process.type==="renderer"?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}e.formatters.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}};function r(l){var c=this.useColors;if(l[0]=(c?"%c":"")+this.namespace+(c?" %c":" ")+l[0]+(c?"%c ":" ")+"+"+e.humanize(this.diff),!!c){var u="color: "+this.color;l.splice(1,0,u,"color: inherit");var h=0,f=0;l[0].replace(/%[a-zA-Z%]/g,function(d){d!=="%%"&&(h++,d==="%c"&&(f=h))}),l.splice(f,0,u)}}function i(){return typeof console=="object"&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function s(l){try{l==null?e.storage.removeItem("debug"):e.storage.debug=l}catch{}}function o(){var l;try{l=e.storage.debug}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}e.enable(o());function a(){try{return window.localStorage}catch{}}})(BD,BD.exports);var HN=BD.exports,S7e=cee,lG=HN("socket.io-client:url"),C7e=k7e;function k7e(n,e){var t=n;e=e||typeof location<"u"&&location,n==null&&(n=e.protocol+"//"+e.host),typeof n=="string"&&(n.charAt(0)==="/"&&(n.charAt(1)==="/"?n=e.protocol+n:n=e.host+n),/^(https?|wss?):\/\//.test(n)||(lG("protocol-less url %s",n),typeof e<"u"?n=e.protocol+"//"+n:n="https://"+n),lG("parse %s",n),t=S7e(n)),t.port||(/^(http|ws)$/.test(t.protocol)?t.port="80":/^(http|ws)s$/.test(t.protocol)&&(t.port="443")),t.path=t.path||"/";var r=t.host.indexOf(":")!==-1,i=r?"["+t.host+"]":t.host;return t.id=t.protocol+"://"+i+":"+t.port,t.href=t.protocol+"://"+i+(e&&e.port===t.port?"":":"+t.port),t}var GN={},UD={exports:{}},WD={exports:{}},F_=1e3,L_=F_*60,z_=L_*60,B_=z_*24,T7e=B_*365.25,E7e=function(n,e){e=e||{};var t=typeof n;if(t==="string"&&n.length>0)return I7e(n);if(t==="number"&&isNaN(n)===!1)return e.long?M7e(n):A7e(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))};function I7e(n){if(n=String(n),!(n.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(e){var t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*T7e;case"days":case"day":case"d":return t*B_;case"hours":case"hour":case"hrs":case"hr":case"h":return t*z_;case"minutes":case"minute":case"mins":case"min":case"m":return t*L_;case"seconds":case"second":case"secs":case"sec":case"s":return t*F_;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function A7e(n){return n>=B_?Math.round(n/B_)+"d":n>=z_?Math.round(n/z_)+"h":n>=L_?Math.round(n/L_)+"m":n>=F_?Math.round(n/F_)+"s":n+"ms"}function M7e(n){return Qk(n,B_,"day")||Qk(n,z_,"hour")||Qk(n,L_,"minute")||Qk(n,F_,"second")||n+" ms"}function Qk(n,e,t){if(!(n<e))return n<e*1.5?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}(function(n,e){e=n.exports=r.debug=r.default=r,e.coerce=l,e.disable=o,e.enable=s,e.enabled=a,e.humanize=E7e,e.instances=[],e.names=[],e.skips=[],e.formatters={};function t(c){var u=0,h;for(h in c)u=(u<<5)-u+c.charCodeAt(h),u|=0;return e.colors[Math.abs(u)%e.colors.length]}function r(c){var u;function h(){if(h.enabled){var f=h,d=+new Date,p=d-(u||d);f.diff=p,f.prev=u,f.curr=d,u=d;for(var m=new Array(arguments.length),g=0;g<m.length;g++)m[g]=arguments[g];m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");var y=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,function(_,w){if(_==="%%")return _;y++;var S=e.formatters[w];if(typeof S=="function"){var C=m[y];_=S.call(f,C),m.splice(y,1),y--}return _}),e.formatArgs.call(f,m);var b=h.log||e.log||console.log.bind(console);b.apply(f,m)}}return h.namespace=c,h.enabled=e.enabled(c),h.useColors=e.useColors(),h.color=t(c),h.destroy=i,typeof e.init=="function"&&e.init(h),e.instances.push(h),h}function i(){var c=e.instances.indexOf(this);return c!==-1?(e.instances.splice(c,1),!0):!1}function s(c){e.save(c),e.names=[],e.skips=[];var u,h=(typeof c=="string"?c:"").split(/[\s,]+/),f=h.length;for(u=0;u<f;u++)h[u]&&(c=h[u].replace(/\*/g,".*?"),c[0]==="-"?e.skips.push(new RegExp("^"+c.substr(1)+"$")):e.names.push(new RegExp("^"+c+"$")));for(u=0;u<e.instances.length;u++){var d=e.instances[u];d.enabled=e.enabled(d.namespace)}}function o(){e.enable("")}function a(c){if(c[c.length-1]==="*")return!0;var u,h;for(u=0,h=e.skips.length;u<h;u++)if(e.skips[u].test(c))return!1;for(u=0,h=e.names.length;u<h;u++)if(e.names[u].test(c))return!0;return!1}function l(c){return c instanceof Error?c.stack||c.message:c}})(WD,WD.exports);var N7e=WD.exports;(function(n,e){e=n.exports=N7e,e.log=i,e.formatArgs=r,e.save=s,e.load=o,e.useColors=t,e.storage=typeof chrome<"u"&&typeof chrome.storage<"u"?chrome.storage.local:a(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&window.process.type==="renderer"?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}e.formatters.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}};function r(l){var c=this.useColors;if(l[0]=(c?"%c":"")+this.namespace+(c?" %c":" ")+l[0]+(c?"%c ":" ")+"+"+e.humanize(this.diff),!!c){var u="color: "+this.color;l.splice(1,0,u,"color: inherit");var h=0,f=0;l[0].replace(/%[a-zA-Z%]/g,function(d){d!=="%%"&&(h++,d==="%c"&&(f=h))}),l.splice(f,0,u)}}function i(){return typeof console=="object"&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function s(l){try{l==null?e.storage.removeItem("debug"):e.storage.debug=l}catch{}}function o(){var l;try{l=e.storage.debug}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}e.enable(o());function a(){try{return window.localStorage}catch{}}})(UD,UD.exports);var $7e=UD.exports,uee={exports:{}};(function(n){n.exports=e;function e(r){if(r)return t(r)}function t(r){for(var i in e.prototype)r[i]=e.prototype[i];return r}e.prototype.on=e.prototype.addEventListener=function(r,i){return this._callbacks=this._callbacks||{},(this._callbacks["$"+r]=this._callbacks["$"+r]||[]).push(i),this},e.prototype.once=function(r,i){function s(){this.off(r,s),i.apply(this,arguments)}return s.fn=i,this.on(r,s),this},e.prototype.off=e.prototype.removeListener=e.prototype.removeAllListeners=e.prototype.removeEventListener=function(r,i){if(this._callbacks=this._callbacks||{},arguments.length==0)return this._callbacks={},this;var s=this._callbacks["$"+r];if(!s)return this;if(arguments.length==1)return delete this._callbacks["$"+r],this;for(var o,a=0;a<s.length;a++)if(o=s[a],o===i||o.fn===i){s.splice(a,1);break}return s.length===0&&delete this._callbacks["$"+r],this},e.prototype.emit=function(r){this._callbacks=this._callbacks||{};for(var i=new Array(arguments.length-1),s=this._callbacks["$"+r],o=1;o<arguments.length;o++)i[o-1]=arguments[o];if(s){s=s.slice(0);for(var o=0,a=s.length;o<a;++o)s[o].apply(this,i)}return this},e.prototype.listeners=function(r){return this._callbacks=this._callbacks||{},this._callbacks["$"+r]||[]},e.prototype.hasListeners=function(r){return!!this.listeners(r).length}})(uee);var Hw=uee.exports,jN={},R7e={}.toString,hee=Array.isArray||function(n){return R7e.call(n)=="[object Array]"},fee=F7e,P7e=typeof Buffer=="function"&&typeof Buffer.isBuffer=="function",D7e=typeof ArrayBuffer=="function",O7e=function(n){return typeof ArrayBuffer.isView=="function"?ArrayBuffer.isView(n):n.buffer instanceof ArrayBuffer};function F7e(n){return P7e&&Buffer.isBuffer(n)||D7e&&(n instanceof ArrayBuffer||O7e(n))}var _B=hee,dee=fee,pee=Object.prototype.toString,L7e=typeof Blob=="function"||typeof Blob<"u"&&pee.call(Blob)==="[object BlobConstructor]",z7e=typeof File=="function"||typeof File<"u"&&pee.call(File)==="[object FileConstructor]";jN.deconstructPacket=function(n){var e=[],t=n.data,r=n;return r.data=HD(t,e),r.attachments=e.length,{packet:r,buffers:e}};function HD(n,e){if(!n)return n;if(dee(n)){var t={_placeholder:!0,num:e.length};return e.push(n),t}else if(_B(n)){for(var r=new Array(n.length),i=0;i<n.length;i++)r[i]=HD(n[i],e);return r}else if(typeof n=="object"&&!(n instanceof Date)){var r={};for(var s in n)r[s]=HD(n[s],e);return r}return n}jN.reconstructPacket=function(n,e){return n.data=GD(n.data,e),n.attachments=void 0,n};function GD(n,e){if(!n)return n;if(n&&n._placeholder===!0){var t=typeof n.num=="number"&&n.num>=0&&n.num<e.length;if(t)return e[n.num];throw new Error("illegal attachments")}else if(_B(n))for(var r=0;r<n.length;r++)n[r]=GD(n[r],e);else if(typeof n=="object")for(var i in n)n[i]=GD(n[i],e);return n}jN.removeBlobs=function(n,e){function t(s,o,a){if(!s)return s;if(L7e&&s instanceof Blob||z7e&&s instanceof File){r++;var l=new FileReader;l.onload=function(){a?a[o]=this.result:i=this.result,--r||e(i)},l.readAsArrayBuffer(s)}else if(_B(s))for(var c=0;c<s.length;c++)t(s[c],c,s);else if(typeof s=="object"&&!dee(s))for(var u in s)t(s[u],u,s)}var r=0,i=n;t(i),r||e(i)};(function(n){var e=$7e("socket.io-parser"),t=Hw,r=jN,i=hee,s=fee;n.protocol=4,n.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],n.CONNECT=0,n.DISCONNECT=1,n.EVENT=2,n.ACK=3,n.ERROR=4,n.BINARY_EVENT=5,n.BINARY_ACK=6,n.Encoder=o,n.Decoder=h;function o(){}var a=n.ERROR+'"encode error"';o.prototype.encode=function(g,y){if(e("encoding packet %j",g),n.BINARY_EVENT===g.type||n.BINARY_ACK===g.type)u(g,y);else{var b=l(g);y([b])}};function l(g){var y=""+g.type;if((n.BINARY_EVENT===g.type||n.BINARY_ACK===g.type)&&(y+=g.attachments+"-"),g.nsp&&g.nsp!=="/"&&(y+=g.nsp+","),g.id!=null&&(y+=g.id),g.data!=null){var b=c(g.data);if(b!==!1)y+=b;else return a}return e("encoded %j as %s",g,y),y}function c(g){try{return JSON.stringify(g)}catch{return!1}}function u(g,y){function b(_){var w=r.deconstructPacket(_),S=l(w.packet),C=w.buffers;C.unshift(S),y(C)}r.removeBlobs(g,b)}function h(){this.reconstructor=null}t(h.prototype),h.prototype.add=function(g){var y;if(typeof g=="string"){if(this.reconstructor)throw new Error("got plaintext data when reconstructing a packet");y=f(g),n.BINARY_EVENT===y.type||n.BINARY_ACK===y.type?(this.reconstructor=new p(y),this.reconstructor.reconPack.attachments===0&&this.emit("decoded",y)):this.emit("decoded",y)}else if(s(g)||g.base64)if(this.reconstructor)y=this.reconstructor.takeBinaryData(g),y&&(this.reconstructor=null,this.emit("decoded",y));else throw new Error("got binary data when not reconstructing a packet");else throw new Error("Unknown type: "+g)};function f(g){var y=0,b={type:Number(g.charAt(0))};if(n.types[b.type]==null)return m("unknown packet type "+b.type);if(n.BINARY_EVENT===b.type||n.BINARY_ACK===b.type){for(var _=y+1;g.charAt(++y)!=="-"&&y!=g.length;);var w=g.substring(_,y);if(w!=Number(w)||g.charAt(y)!=="-")throw new Error("Illegal attachments");b.attachments=Number(w)}if(g.charAt(y+1)==="/"){for(var _=y+1;++y;){var S=g.charAt(y);if(S===","||y===g.length)break}b.nsp=g.substring(_,y)}else b.nsp="/";var C=g.charAt(y+1);if(C!==""&&Number(C)==C){for(var _=y+1;++y;){var S=g.charAt(y);if(S==null||Number(S)!=S){--y;break}if(y===g.length)break}b.id=Number(g.substring(_,y+1))}if(g.charAt(++y)){var k=d(g.substr(y)),A=k!==!1&&(b.type===n.ERROR||i(k));if(A)b.data=k;else return m("invalid payload")}return e("decoded %s as %j",g,b),b}function d(g){try{return JSON.parse(g)}catch{return!1}}h.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()};function p(g){this.reconPack=g,this.buffers=[]}p.prototype.takeBinaryData=function(g){if(this.buffers.push(g),this.buffers.length===this.reconPack.attachments){var y=r.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),y}return null},p.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]};function m(g){return{type:n.ERROR,data:"parser error: "+g}}})(GN);var SB={exports:{}},qN={},jD={exports:{}};try{jD.exports=typeof XMLHttpRequest<"u"&&"withCredentials"in new XMLHttpRequest}catch{jD.exports=!1}var B7e=jD.exports,CB=function(){return typeof self<"u"?self:typeof window<"u"?window:Function("return this")()}(),V7e=B7e,U7e=CB,kB=function(n){var e=n.xdomain,t=n.xscheme,r=n.enablesXDR;try{if(typeof XMLHttpRequest<"u"&&(!e||V7e))return new XMLHttpRequest}catch{}try{if(typeof XDomainRequest<"u"&&!t&&r)return new XDomainRequest}catch{}if(!e)try{return new U7e[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP")}catch{}},TB={exports:{}},jy={},W7e=Object.keys||function(e){var t=[],r=Object.prototype.hasOwnProperty;for(var i in e)r.call(e,i)&&t.push(i);return t},H7e={}.toString,G7e=Array.isArray||function(n){return H7e.call(n)=="[object Array]"},j7e=G7e,mee=Object.prototype.toString,q7e=typeof Blob=="function"||typeof Blob<"u"&&mee.call(Blob)==="[object BlobConstructor]",X7e=typeof File=="function"||typeof File<"u"&&mee.call(File)==="[object FileConstructor]",gee=OE;function OE(n){if(!n||typeof n!="object")return!1;if(j7e(n)){for(var e=0,t=n.length;e<t;e++)if(OE(n[e]))return!0;return!1}if(typeof Buffer=="function"&&Buffer.isBuffer&&Buffer.isBuffer(n)||typeof ArrayBuffer=="function"&&n instanceof ArrayBuffer||q7e&&n instanceof Blob||X7e&&n instanceof File)return!0;if(n.toJSON&&typeof n.toJSON=="function"&&arguments.length===1)return OE(n.toJSON(),!0);for(var r in n)if(Object.prototype.hasOwnProperty.call(n,r)&&OE(n[r]))return!0;return!1}var K7e=function(n,e,t){var r=n.byteLength;if(e=e||0,t=t||r,n.slice)return n.slice(e,t);if(e<0&&(e+=r),t<0&&(t+=r),t>r&&(t=r),e>=r||e>=t||r===0)return new ArrayBuffer(0);for(var i=new Uint8Array(n),s=new Uint8Array(t-e),o=e,a=0;o<t;o++,a++)s[a]=i[o];return s.buffer},Y7e=Z7e;function Z7e(n,e,t){var r=!1;return t=t||J7e,i.count=n,n===0?e():i;function i(s,o){if(i.count<=0)throw new Error("after called too many times");--i.count,s?(r=!0,e(s),e=t):i.count===0&&!r&&e(null,o)}}function J7e(){}/*! https://mths.be/utf8js v2.1.2 by @mathias */var Cd=String.fromCharCode;function yee(n){for(var e=[],t=0,r=n.length,i,s;t<r;)i=n.charCodeAt(t++),i>=55296&&i<=56319&&t<r?(s=n.charCodeAt(t++),(s&64512)==56320?e.push(((i&1023)<<10)+(s&1023)+65536):(e.push(i),t--)):e.push(i);return e}function Q7e(n){for(var e=n.length,t=-1,r,i="";++t<e;)r=n[t],r>65535&&(r-=65536,i+=Cd(r>>>10&1023|55296),r=56320|r&1023),i+=Cd(r);return i}function bee(n,e){if(n>=55296&&n<=57343){if(e)throw Error("Lone surrogate U+"+n.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function m3(n,e){return Cd(n>>e&63|128)}function eXe(n,e){if(!(n&4294967168))return Cd(n);var t="";return n&4294965248?n&4294901760?n&4292870144||(t=Cd(n>>18&7|240),t+=m3(n,12),t+=m3(n,6)):(bee(n,e)||(n=65533),t=Cd(n>>12&15|224),t+=m3(n,6)):t=Cd(n>>6&31|192),t+=Cd(n&63|128),t}function tXe(n,e){e=e||{};for(var t=e.strict!==!1,r=yee(n),i=r.length,s=-1,o,a="";++s<i;)o=r[s],a+=eXe(o,t);return a}function M0(){if(Id>=BI)throw Error("Invalid byte index");var n=zI[Id]&255;if(Id++,(n&192)==128)return n&63;throw Error("Invalid continuation byte")}function nXe(n){var e,t,r,i,s;if(Id>BI)throw Error("Invalid byte index");if(Id==BI)return!1;if(e=zI[Id]&255,Id++,!(e&128))return e;if((e&224)==192){if(t=M0(),s=(e&31)<<6|t,s>=128)return s;throw Error("Invalid continuation byte")}if((e&240)==224){if(t=M0(),r=M0(),s=(e&15)<<12|t<<6|r,s>=2048)return bee(s,n)?s:65533;throw Error("Invalid continuation byte")}if((e&248)==240&&(t=M0(),r=M0(),i=M0(),s=(e&7)<<18|t<<12|r<<6|i,s>=65536&&s<=1114111))return s;throw Error("Invalid UTF-8 detected")}var zI,BI,Id;function rXe(n,e){e=e||{};var t=e.strict!==!1;zI=yee(n),BI=zI.length,Id=0;for(var r=[],i;(i=nXe(t))!==!1;)r.push(i);return Q7e(r)}var iXe={version:"2.1.2",encode:tXe,decode:rXe},eT={},cG;function sXe(){return cG||(cG=1,function(n){eT.encode=function(e){var t=new Uint8Array(e),r,i=t.length,s="";for(r=0;r<i;r+=3)s+=n[t[r]>>2],s+=n[(t[r]&3)<<4|t[r+1]>>4],s+=n[(t[r+1]&15)<<2|t[r+2]>>6],s+=n[t[r+2]&63];return i%3===2?s=s.substring(0,s.length-1)+"=":i%3===1&&(s=s.substring(0,s.length-2)+"=="),s},eT.decode=function(e){var t=e.length*.75,r=e.length,i,s=0,o,a,l,c;e[e.length-1]==="="&&(t--,e[e.length-2]==="="&&t--);var u=new ArrayBuffer(t),h=new Uint8Array(u);for(i=0;i<r;i+=4)o=n.indexOf(e[i]),a=n.indexOf(e[i+1]),l=n.indexOf(e[i+2]),c=n.indexOf(e[i+3]),h[s++]=o<<2|a>>4,h[s++]=(a&15)<<4|l>>2,h[s++]=(l&3)<<6|c&63;return u}}("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")),eT}var g3,uG;function oXe(){if(uG)return g3;uG=1;var n=typeof n<"u"?n:typeof WebKitBlobBuilder<"u"?WebKitBlobBuilder:typeof MSBlobBuilder<"u"?MSBlobBuilder:typeof MozBlobBuilder<"u"?MozBlobBuilder:!1,e=function(){try{var a=new Blob(["hi"]);return a.size===2}catch{return!1}}(),t=e&&function(){try{var a=new Blob([new Uint8Array([1,2])]);return a.size===2}catch{return!1}}(),r=n&&n.prototype.append&&n.prototype.getBlob;function i(a){return a.map(function(l){if(l.buffer instanceof ArrayBuffer){var c=l.buffer;if(l.byteLength!==c.byteLength){var u=new Uint8Array(l.byteLength);u.set(new Uint8Array(c,l.byteOffset,l.byteLength)),c=u.buffer}return c}return l})}function s(a,l){l=l||{};var c=new n;return i(a).forEach(function(u){c.append(u)}),l.type?c.getBlob(l.type):c.getBlob()}function o(a,l){return new Blob(i(a),l||{})}return typeof Blob<"u"&&(s.prototype=Blob.prototype,o.prototype=Blob.prototype),g3=function(){return e?t?Blob:o:r?s:void 0}(),g3}(function(n){var e=W7e,t=gee,r=K7e,i=Y7e,s=iXe,o;typeof ArrayBuffer<"u"&&(o=sXe());var a=typeof navigator<"u"&&/Android/i.test(navigator.userAgent),l=typeof navigator<"u"&&/PhantomJS/i.test(navigator.userAgent),c=a||l;n.protocol=3;var u=n.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},h=e(u),f={type:"error",data:"parser error"},d=oXe();n.encodePacket=function(w,S,C,k){typeof S=="function"&&(k=S,S=!1),typeof C=="function"&&(k=C,C=null);var A=w.data===void 0?void 0:w.data.buffer||w.data;if(typeof ArrayBuffer<"u"&&A instanceof ArrayBuffer)return m(w,S,k);if(typeof d<"u"&&A instanceof d)return y(w,S,k);if(A&&A.base64)return p(w,k);var M=u[w.type];return w.data!==void 0&&(M+=C?s.encode(String(w.data),{strict:!1}):String(w.data)),k(""+M)};function p(w,S){var C="b"+n.packets[w.type]+w.data.data;return S(C)}function m(w,S,C){if(!S)return n.encodeBase64Packet(w,C);var k=w.data,A=new Uint8Array(k),M=new Uint8Array(1+k.byteLength);M[0]=u[w.type];for(var E=0;E<A.length;E++)M[E+1]=A[E];return C(M.buffer)}function g(w,S,C){if(!S)return n.encodeBase64Packet(w,C);var k=new FileReader;return k.onload=function(){n.encodePacket({type:w.type,data:k.result},S,!0,C)},k.readAsArrayBuffer(w.data)}function y(w,S,C){if(!S)return n.encodeBase64Packet(w,C);if(c)return g(w,S,C);var k=new Uint8Array(1);k[0]=u[w.type];var A=new d([k.buffer,w.data]);return C(A)}n.encodeBase64Packet=function(w,S){var C="b"+n.packets[w.type];if(typeof d<"u"&&w.data instanceof d){var k=new FileReader;return k.onload=function(){var O=k.result.split(",")[1];S(C+O)},k.readAsDataURL(w.data)}var A;try{A=String.fromCharCode.apply(null,new Uint8Array(w.data))}catch{for(var M=new Uint8Array(w.data),E=new Array(M.length),N=0;N<M.length;N++)E[N]=M[N];A=String.fromCharCode.apply(null,E)}return C+=btoa(A),S(C)},n.decodePacket=function(w,S,C){if(w===void 0)return f;if(typeof w=="string"){if(w.charAt(0)==="b")return n.decodeBase64Packet(w.substr(1),S);if(C&&(w=b(w),w===!1))return f;var A=w.charAt(0);return Number(A)!=A||!h[A]?f:w.length>1?{type:h[A],data:w.substring(1)}:{type:h[A]}}var k=new Uint8Array(w),A=k[0],M=r(w,1);return d&&S==="blob"&&(M=new d([M])),{type:h[A],data:M}};function b(w){try{w=s.decode(w,{strict:!1})}catch{return!1}return w}n.decodeBase64Packet=function(w,S){var C=h[w.charAt(0)];if(!o)return{type:C,data:{base64:!0,data:w.substr(1)}};var k=o.decode(w.substr(1));return S==="blob"&&d&&(k=new d([k])),{type:C,data:k}},n.encodePayload=function(w,S,C){typeof S=="function"&&(C=S,S=null);var k=t(w);if(S&&k)return d&&!c?n.encodePayloadAsBlob(w,C):n.encodePayloadAsArrayBuffer(w,C);if(!w.length)return C("0:");function A(E){return E.length+":"+E}function M(E,N){n.encodePacket(E,k?S:!1,!1,function(O){N(null,A(O))})}_(w,M,function(E,N){return C(N.join(""))})};function _(w,S,C){for(var k=new Array(w.length),A=i(w.length,C),M=function(N,O,R){S(O,function(D,z){k[N]=z,R(D,k)})},E=0;E<w.length;E++)M(E,w[E],A)}n.decodePayload=function(w,S,C){if(typeof w!="string")return n.decodePayloadAsBinary(w,S,C);typeof S=="function"&&(C=S,S=null);var k;if(w==="")return C(f,0,1);for(var A="",M,E,N=0,O=w.length;N<O;N++){var R=w.charAt(N);if(R!==":"){A+=R;continue}if(A===""||A!=(M=Number(A))||(E=w.substr(N+1,M),A!=E.length))return C(f,0,1);if(E.length){if(k=n.decodePacket(E,S,!1),f.type===k.type&&f.data===k.data)return C(f,0,1);var D=C(k,N+M,O);if(D===!1)return}N+=M,A=""}if(A!=="")return C(f,0,1)},n.encodePayloadAsArrayBuffer=function(w,S){if(!w.length)return S(new ArrayBuffer(0));function C(k,A){n.encodePacket(k,!0,!0,function(M){return A(null,M)})}_(w,C,function(k,A){var M=A.reduce(function(O,R){var D;return typeof R=="string"?D=R.length:D=R.byteLength,O+D.toString().length+D+2},0),E=new Uint8Array(M),N=0;return A.forEach(function(O){var R=typeof O=="string",D=O;if(R){for(var X=new Uint8Array(O.length),z=0;z<O.length;z++)X[z]=O.charCodeAt(z);D=X.buffer}R?E[N++]=0:E[N++]=1;for(var B=D.byteLength.toString(),z=0;z<B.length;z++)E[N++]=parseInt(B[z]);E[N++]=255;for(var X=new Uint8Array(D),z=0;z<X.length;z++)E[N++]=X[z]}),S(E.buffer)})},n.encodePayloadAsBlob=function(w,S){function C(k,A){n.encodePacket(k,!0,!0,function(M){var E=new Uint8Array(1);if(E[0]=1,typeof M=="string"){for(var N=new Uint8Array(M.length),O=0;O<M.length;O++)N[O]=M.charCodeAt(O);M=N.buffer,E[0]=0}for(var R=M instanceof ArrayBuffer?M.byteLength:M.size,D=R.toString(),z=new Uint8Array(D.length+1),O=0;O<D.length;O++)z[O]=parseInt(D[O]);if(z[D.length]=255,d){var B=new d([E.buffer,z.buffer,M]);A(null,B)}})}_(w,C,function(k,A){return S(new d(A))})},n.decodePayloadAsBinary=function(w,S,C){typeof S=="function"&&(C=S,S=null);for(var k=w,A=[];k.byteLength>0;){for(var M=new Uint8Array(k),E=M[0]===0,N="",O=1;M[O]!==255;O++){if(N.length>310)return C(f,0,1);N+=M[O]}k=r(k,2+N.length),N=parseInt(N);var R=r(k,0,N);if(E)try{R=String.fromCharCode.apply(null,new Uint8Array(R))}catch{var D=new Uint8Array(R);R="";for(var O=0;O<D.length;O++)R+=String.fromCharCode(D[O])}A.push(R),k=r(k,N)}var z=A.length;A.forEach(function(B,X){C(n.decodePacket(B,S,!0),X,z)})}})(jy);var y3,hG;function EB(){if(hG)return y3;hG=1;var n=jy,e=Hw;y3=t;function t(r){this.path=r.path,this.hostname=r.hostname,this.port=r.port,this.secure=r.secure,this.query=r.query,this.timestampParam=r.timestampParam,this.timestampRequests=r.timestampRequests,this.readyState="",this.agent=r.agent||!1,this.socket=r.socket,this.enablesXDR=r.enablesXDR,this.withCredentials=r.withCredentials,this.pfx=r.pfx,this.key=r.key,this.passphrase=r.passphrase,this.cert=r.cert,this.ca=r.ca,this.ciphers=r.ciphers,this.rejectUnauthorized=r.rejectUnauthorized,this.forceNode=r.forceNode,this.isReactNative=r.isReactNative,this.extraHeaders=r.extraHeaders,this.localAddress=r.localAddress}return e(t.prototype),t.prototype.onError=function(r,i){var s=new Error(r);return s.type="TransportError",s.description=i,this.emit("error",s),this},t.prototype.open=function(){return(this.readyState==="closed"||this.readyState==="")&&(this.readyState="opening",this.doOpen()),this},t.prototype.close=function(){return(this.readyState==="opening"||this.readyState==="open")&&(this.doClose(),this.onClose()),this},t.prototype.send=function(r){if(this.readyState==="open")this.write(r);else throw new Error("Transport not open")},t.prototype.onOpen=function(){this.readyState="open",this.writable=!0,this.emit("open")},t.prototype.onData=function(r){var i=n.decodePacket(r,this.socket.binaryType);this.onPacket(i)},t.prototype.onPacket=function(r){this.emit("packet",r)},t.prototype.onClose=function(){this.readyState="closed",this.emit("close")},y3}var Gw={};Gw.encode=function(n){var e="";for(var t in n)n.hasOwnProperty(t)&&(e.length&&(e+="&"),e+=encodeURIComponent(t)+"="+encodeURIComponent(n[t]));return e};Gw.decode=function(n){for(var e={},t=n.split("&"),r=0,i=t.length;r<i;r++){var s=t[r].split("=");e[decodeURIComponent(s[0])]=decodeURIComponent(s[1])}return e};var XN=function(n,e){var t=function(){};t.prototype=e.prototype,n.prototype=new t,n.prototype.constructor=n},vee="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),VI=64,wee={},fG=0,Ad=0,dG;function qD(n){var e="";do e=vee[n%VI]+e,n=Math.floor(n/VI);while(n>0);return e}function aXe(n){var e=0;for(Ad=0;Ad<n.length;Ad++)e=e*VI+wee[n.charAt(Ad)];return e}function IB(){var n=qD(+new Date);return n!==dG?(fG=0,dG=n):n+"."+qD(fG++)}for(;Ad<VI;Ad++)wee[vee[Ad]]=Ad;IB.encode=qD;IB.decode=aXe;var xee=IB,XD={exports:{}},KD={exports:{}},V_=1e3,U_=V_*60,W_=U_*60,H_=W_*24,lXe=H_*365.25,cXe=function(n,e){e=e||{};var t=typeof n;if(t==="string"&&n.length>0)return uXe(n);if(t==="number"&&isNaN(n)===!1)return e.long?fXe(n):hXe(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))};function uXe(n){if(n=String(n),!(n.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(e){var t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*lXe;case"days":case"day":case"d":return t*H_;case"hours":case"hour":case"hrs":case"hr":case"h":return t*W_;case"minutes":case"minute":case"mins":case"min":case"m":return t*U_;case"seconds":case"second":case"secs":case"sec":case"s":return t*V_;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function hXe(n){return n>=H_?Math.round(n/H_)+"d":n>=W_?Math.round(n/W_)+"h":n>=U_?Math.round(n/U_)+"m":n>=V_?Math.round(n/V_)+"s":n+"ms"}function fXe(n){return tT(n,H_,"day")||tT(n,W_,"hour")||tT(n,U_,"minute")||tT(n,V_,"second")||n+" ms"}function tT(n,e,t){if(!(n<e))return n<e*1.5?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}(function(n,e){e=n.exports=r.debug=r.default=r,e.coerce=l,e.disable=o,e.enable=s,e.enabled=a,e.humanize=cXe,e.instances=[],e.names=[],e.skips=[],e.formatters={};function t(c){var u=0,h;for(h in c)u=(u<<5)-u+c.charCodeAt(h),u|=0;return e.colors[Math.abs(u)%e.colors.length]}function r(c){var u;function h(){if(h.enabled){var f=h,d=+new Date,p=d-(u||d);f.diff=p,f.prev=u,f.curr=d,u=d;for(var m=new Array(arguments.length),g=0;g<m.length;g++)m[g]=arguments[g];m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");var y=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,function(_,w){if(_==="%%")return _;y++;var S=e.formatters[w];if(typeof S=="function"){var C=m[y];_=S.call(f,C),m.splice(y,1),y--}return _}),e.formatArgs.call(f,m);var b=h.log||e.log||console.log.bind(console);b.apply(f,m)}}return h.namespace=c,h.enabled=e.enabled(c),h.useColors=e.useColors(),h.color=t(c),h.destroy=i,typeof e.init=="function"&&e.init(h),e.instances.push(h),h}function i(){var c=e.instances.indexOf(this);return c!==-1?(e.instances.splice(c,1),!0):!1}function s(c){e.save(c),e.names=[],e.skips=[];var u,h=(typeof c=="string"?c:"").split(/[\s,]+/),f=h.length;for(u=0;u<f;u++)h[u]&&(c=h[u].replace(/\*/g,".*?"),c[0]==="-"?e.skips.push(new RegExp("^"+c.substr(1)+"$")):e.names.push(new RegExp("^"+c+"$")));for(u=0;u<e.instances.length;u++){var d=e.instances[u];d.enabled=e.enabled(d.namespace)}}function o(){e.enable("")}function a(c){if(c[c.length-1]==="*")return!0;var u,h;for(u=0,h=e.skips.length;u<h;u++)if(e.skips[u].test(c))return!1;for(u=0,h=e.names.length;u<h;u++)if(e.names[u].test(c))return!0;return!1}function l(c){return c instanceof Error?c.stack||c.message:c}})(KD,KD.exports);var dXe=KD.exports;(function(n,e){e=n.exports=dXe,e.log=i,e.formatArgs=r,e.save=s,e.load=o,e.useColors=t,e.storage=typeof chrome<"u"&&typeof chrome.storage<"u"?chrome.storage.local:a(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&window.process.type==="renderer"?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}e.formatters.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}};function r(l){var c=this.useColors;if(l[0]=(c?"%c":"")+this.namespace+(c?" %c":" ")+l[0]+(c?"%c ":" ")+"+"+e.humanize(this.diff),!!c){var u="color: "+this.color;l.splice(1,0,u,"color: inherit");var h=0,f=0;l[0].replace(/%[a-zA-Z%]/g,function(d){d!=="%%"&&(h++,d==="%c"&&(f=h))}),l.splice(f,0,u)}}function i(){return typeof console=="object"&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function s(l){try{l==null?e.storage.removeItem("debug"):e.storage.debug=l}catch{}}function o(){var l;try{l=e.storage.debug}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}e.enable(o());function a(){try{return window.localStorage}catch{}}})(XD,XD.exports);var KN=XD.exports,_ee=EB(),pXe=Gw,See=jy,mXe=XN,gXe=xee,hu=KN("engine.io-client:polling"),Cee=Fh,yXe=function(){var n=kB,e=new n({xdomain:!1});return e.responseType!=null}();function Fh(n){var e=n&&n.forceBase64;(!yXe||e)&&(this.supportsBinary=!1),_ee.call(this,n)}mXe(Fh,_ee);Fh.prototype.name="polling";Fh.prototype.doOpen=function(){this.poll()};Fh.prototype.pause=function(n){var e=this;this.readyState="pausing";function t(){hu("paused"),e.readyState="paused",n()}if(this.polling||!this.writable){var r=0;this.polling&&(hu("we are currently polling - waiting to pause"),r++,this.once("pollComplete",function(){hu("pre-pause polling complete"),--r||t()})),this.writable||(hu("we are currently writing - waiting to pause"),r++,this.once("drain",function(){hu("pre-pause writing complete"),--r||t()}))}else t()};Fh.prototype.poll=function(){hu("polling"),this.polling=!0,this.doPoll(),this.emit("poll")};Fh.prototype.onData=function(n){var e=this;hu("polling got data %s",n);var t=function(r,i,s){if(e.readyState==="opening"&&r.type==="open"&&e.onOpen(),r.type==="close")return e.onClose(),!1;e.onPacket(r)};See.decodePayload(n,this.socket.binaryType,t),this.readyState!=="closed"&&(this.polling=!1,this.emit("pollComplete"),this.readyState==="open"?this.poll():hu('ignoring poll - transport state "%s"',this.readyState))};Fh.prototype.doClose=function(){var n=this;function e(){hu("writing close packet"),n.write([{type:"close"}])}this.readyState==="open"?(hu("transport open - closing"),e()):(hu("transport not open - deferring close"),this.once("open",e))};Fh.prototype.write=function(n){var e=this;this.writable=!1;var t=function(){e.writable=!0,e.emit("drain")};See.encodePayload(n,this.supportsBinary,function(r){e.doWrite(r,t)})};Fh.prototype.uri=function(){var n=this.query||{},e=this.secure?"https":"http",t="";this.timestampRequests!==!1&&(n[this.timestampParam]=gXe()),!this.supportsBinary&&!n.sid&&(n.b64=1),n=pXe.encode(n),this.port&&(e==="https"&&Number(this.port)!==443||e==="http"&&Number(this.port)!==80)&&(t=":"+this.port),n.length&&(n="?"+n);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+t+this.path+n};var bXe=kB,kee=Cee,vXe=Hw,wXe=XN,YD=KN("engine.io-client:polling-xhr"),xXe=CB;TB.exports=jw;TB.exports.Request=Gs;function pG(){}function jw(n){if(kee.call(this,n),this.requestTimeout=n.requestTimeout,this.extraHeaders=n.extraHeaders,typeof location<"u"){var e=location.protocol==="https:",t=location.port;t||(t=e?443:80),this.xd=typeof location<"u"&&n.hostname!==location.hostname||t!==n.port,this.xs=n.secure!==e}}wXe(jw,kee);jw.prototype.supportsBinary=!0;jw.prototype.request=function(n){return n=n||{},n.uri=this.uri(),n.xd=this.xd,n.xs=this.xs,n.agent=this.agent||!1,n.supportsBinary=this.supportsBinary,n.enablesXDR=this.enablesXDR,n.withCredentials=this.withCredentials,n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized,n.requestTimeout=this.requestTimeout,n.extraHeaders=this.extraHeaders,new Gs(n)};jw.prototype.doWrite=function(n,e){var t=typeof n!="string"&&n!==void 0,r=this.request({method:"POST",data:n,isBinary:t}),i=this;r.on("success",e),r.on("error",function(s){i.onError("xhr post error",s)}),this.sendXhr=r};jw.prototype.doPoll=function(){YD("xhr poll");var n=this.request(),e=this;n.on("data",function(t){e.onData(t)}),n.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=n};function Gs(n){this.method=n.method||"GET",this.uri=n.uri,this.xd=!!n.xd,this.xs=!!n.xs,this.async=n.async!==!1,this.data=n.data!==void 0?n.data:null,this.agent=n.agent,this.isBinary=n.isBinary,this.supportsBinary=n.supportsBinary,this.enablesXDR=n.enablesXDR,this.withCredentials=n.withCredentials,this.requestTimeout=n.requestTimeout,this.pfx=n.pfx,this.key=n.key,this.passphrase=n.passphrase,this.cert=n.cert,this.ca=n.ca,this.ciphers=n.ciphers,this.rejectUnauthorized=n.rejectUnauthorized,this.extraHeaders=n.extraHeaders,this.create()}vXe(Gs.prototype);Gs.prototype.create=function(){var n={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized;var e=this.xhr=new bXe(n),t=this;try{YD("xhr open %s: %s",this.method,this.uri),e.open(this.method,this.uri,this.async);try{if(this.extraHeaders){e.setDisableHeaderCheck&&e.setDisableHeaderCheck(!0);for(var r in this.extraHeaders)this.extraHeaders.hasOwnProperty(r)&&e.setRequestHeader(r,this.extraHeaders[r])}}catch{}if(this.method==="POST")try{this.isBinary?e.setRequestHeader("Content-type","application/octet-stream"):e.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch{}try{e.setRequestHeader("Accept","*/*")}catch{}"withCredentials"in e&&(e.withCredentials=this.withCredentials),this.requestTimeout&&(e.timeout=this.requestTimeout),this.hasXDR()?(e.onload=function(){t.onLoad()},e.onerror=function(){t.onError(e.responseText)}):e.onreadystatechange=function(){if(e.readyState===2)try{var i=e.getResponseHeader("Content-Type");(t.supportsBinary&&i==="application/octet-stream"||i==="application/octet-stream; charset=UTF-8")&&(e.responseType="arraybuffer")}catch{}e.readyState===4&&(e.status===200||e.status===1223?t.onLoad():setTimeout(function(){t.onError(typeof e.status=="number"?e.status:0)},0))},YD("xhr data %s",this.data),e.send(this.data)}catch(i){setTimeout(function(){t.onError(i)},0);return}typeof document<"u"&&(this.index=Gs.requestsCount++,Gs.requests[this.index]=this)};Gs.prototype.onSuccess=function(){this.emit("success"),this.cleanup()};Gs.prototype.onData=function(n){this.emit("data",n),this.onSuccess()};Gs.prototype.onError=function(n){this.emit("error",n),this.cleanup(!0)};Gs.prototype.cleanup=function(n){if(!(typeof this.xhr>"u"||this.xhr===null)){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=pG:this.xhr.onreadystatechange=pG,n)try{this.xhr.abort()}catch{}typeof document<"u"&&delete Gs.requests[this.index],this.xhr=null}};Gs.prototype.onLoad=function(){var n;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch{}e==="application/octet-stream"||e==="application/octet-stream; charset=UTF-8"?n=this.xhr.response||this.xhr.responseText:n=this.xhr.responseText}catch(t){this.onError(t)}n!=null&&this.onData(n)};Gs.prototype.hasXDR=function(){return typeof XDomainRequest<"u"&&!this.xs&&this.enablesXDR};Gs.prototype.abort=function(){this.cleanup()};Gs.requestsCount=0;Gs.requests={};if(typeof document<"u"){if(typeof attachEvent=="function")attachEvent("onunload",mG);else if(typeof addEventListener=="function"){var _Xe="onpagehide"in xXe?"pagehide":"unload";addEventListener(_Xe,mG,!1)}}function mG(){for(var n in Gs.requests)Gs.requests.hasOwnProperty(n)&&Gs.requests[n].abort()}var SXe=TB.exports,AB=Cee,CXe=XN,gG=CB,kXe=qw,TXe=/\n/g,EXe=/\\n/g,nT;function IXe(){}function qw(n){AB.call(this,n),this.query=this.query||{},nT||(nT=gG.___eio=gG.___eio||[]),this.index=nT.length;var e=this;nT.push(function(t){e.onData(t)}),this.query.j=this.index,typeof addEventListener=="function"&&addEventListener("beforeunload",function(){e.script&&(e.script.onerror=IXe)},!1)}CXe(qw,AB);qw.prototype.supportsBinary=!1;qw.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),AB.prototype.doClose.call(this)};qw.prototype.doPoll=function(){var n=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(i){n.onError("jsonp poll error",i)};var t=document.getElementsByTagName("script")[0];t?t.parentNode.insertBefore(e,t):(document.head||document.body).appendChild(e),this.script=e;var r=typeof navigator<"u"&&/gecko/i.test(navigator.userAgent);r&&setTimeout(function(){var i=document.createElement("iframe");document.body.appendChild(i),document.body.removeChild(i)},100)};qw.prototype.doWrite=function(n,e){var t=this;if(!this.form){var r=document.createElement("form"),i=document.createElement("textarea"),s=this.iframeId="eio_iframe_"+this.index,o;r.className="socketio",r.style.position="absolute",r.style.top="-1000px",r.style.left="-1000px",r.target=s,r.method="POST",r.setAttribute("accept-charset","utf-8"),i.name="d",r.appendChild(i),document.body.appendChild(r),this.form=r,this.area=i}this.form.action=this.uri();function a(){l(),e()}function l(){if(t.iframe)try{t.form.removeChild(t.iframe)}catch(u){t.onError("jsonp polling iframe removal error",u)}try{var c='<iframe src="javascript:0" name="'+t.iframeId+'">';o=document.createElement(c)}catch{o=document.createElement("iframe"),o.name=t.iframeId,o.src="javascript:0"}o.id=t.iframeId,t.form.appendChild(o),t.iframe=o}l(),n=n.replace(EXe,`\\
`),this.area.value=n.replace(TXe,"\\n");try{this.form.submit()}catch{}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){t.iframe.readyState==="complete"&&a()}:this.iframe.onload=a};var MB=EB(),AXe=jy,MXe=Gw,NXe=XN,$Xe=xee,RXe=KN("engine.io-client:websocket"),UI,NB;typeof WebSocket<"u"?UI=WebSocket:typeof self<"u"&&(UI=self.WebSocket||self.MozWebSocket);if(typeof window>"u")try{NB=_K}catch{}var Mb=UI||NB,PXe=Ec;function Ec(n){var e=n&&n.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=n.perMessageDeflate,this.usingBrowserWebSocket=UI&&!n.forceNode,this.protocols=n.protocols,this.usingBrowserWebSocket||(Mb=NB),MB.call(this,n)}NXe(Ec,MB);Ec.prototype.name="websocket";Ec.prototype.supportsBinary=!0;Ec.prototype.doOpen=function(){if(this.check()){var n=this.uri(),e=this.protocols,t={};this.isReactNative||(t.agent=this.agent,t.perMessageDeflate=this.perMessageDeflate,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized),this.extraHeaders&&(t.headers=this.extraHeaders),this.localAddress&&(t.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket&&!this.isReactNative?e?new Mb(n,e):new Mb(n):new Mb(n,e,t)}catch(r){return this.emit("error",r)}this.ws.binaryType===void 0&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}};Ec.prototype.addEventListeners=function(){var n=this;this.ws.onopen=function(){n.onOpen()},this.ws.onclose=function(){n.onClose()},this.ws.onmessage=function(e){n.onData(e.data)},this.ws.onerror=function(e){n.onError("websocket error",e)}};Ec.prototype.write=function(n){var e=this;this.writable=!1;for(var t=n.length,r=0,i=t;r<i;r++)(function(o){AXe.encodePacket(o,e.supportsBinary,function(a){if(!e.usingBrowserWebSocket){var l={};if(o.options&&(l.compress=o.options.compress),e.perMessageDeflate){var c=typeof a=="string"?Buffer.byteLength(a):a.length;c<e.perMessageDeflate.threshold&&(l.compress=!1)}}try{e.usingBrowserWebSocket?e.ws.send(a):e.ws.send(a,l)}catch{RXe("websocket closed before onclose event")}--t||s()})})(n[r]);function s(){e.emit("flush"),setTimeout(function(){e.writable=!0,e.emit("drain")},0)}};Ec.prototype.onClose=function(){MB.prototype.onClose.call(this)};Ec.prototype.doClose=function(){typeof this.ws<"u"&&this.ws.close()};Ec.prototype.uri=function(){var n=this.query||{},e=this.secure?"wss":"ws",t="";this.port&&(e==="wss"&&Number(this.port)!==443||e==="ws"&&Number(this.port)!==80)&&(t=":"+this.port),this.timestampRequests&&(n[this.timestampParam]=$Xe()),this.supportsBinary||(n.b64=1),n=MXe.encode(n),n.length&&(n="?"+n);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+t+this.path+n};Ec.prototype.check=function(){return!!Mb&&!("__initialize"in Mb&&this.name===Ec.prototype.name)};var DXe=kB,OXe=SXe,FXe=kXe,LXe=PXe;qN.polling=zXe;qN.websocket=LXe;function zXe(n){var e,t=!1,r=!1,i=n.jsonp!==!1;if(typeof location<"u"){var s=location.protocol==="https:",o=location.port;o||(o=s?443:80),t=n.hostname!==location.hostname||o!==n.port,r=n.secure!==s}if(n.xdomain=t,n.xscheme=r,e=new DXe(n),"open"in e&&!n.forceJSONP)return new OXe(n);if(!i)throw new Error("JSONP disabled");return new FXe(n)}var BXe=[].indexOf,Tee=function(n,e){if(BXe)return n.indexOf(e);for(var t=0;t<n.length;++t)if(n[t]===e)return t;return-1},VXe=qN,UXe=Hw,ws=KN("engine.io-client:socket"),WXe=Tee,Eee=jy,yG=cee,HXe=Gw,GXe=pr;function pr(n,e){if(!(this instanceof pr))return new pr(n,e);e=e||{},n&&typeof n=="object"&&(e=n,n=null),n?(n=yG(n),e.hostname=n.host,e.secure=n.protocol==="https"||n.protocol==="wss",e.port=n.port,n.query&&(e.query=n.query)):e.host&&(e.hostname=yG(e.host).host),this.secure=e.secure!=null?e.secure:typeof location<"u"&&location.protocol==="https:",e.hostname&&!e.port&&(e.port=this.secure?"443":"80"),this.agent=e.agent||!1,this.hostname=e.hostname||(typeof location<"u"?location.hostname:"localhost"),this.port=e.port||(typeof location<"u"&&location.port?location.port:this.secure?443:80),this.query=e.query||{},typeof this.query=="string"&&(this.query=HXe.decode(this.query)),this.upgrade=e.upgrade!==!1,this.path=(e.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!e.forceJSONP,this.jsonp=e.jsonp!==!1,this.forceBase64=!!e.forceBase64,this.enablesXDR=!!e.enablesXDR,this.withCredentials=e.withCredentials!==!1,this.timestampParam=e.timestampParam||"t",this.timestampRequests=e.timestampRequests,this.transports=e.transports||["polling","websocket"],this.transportOptions=e.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=e.policyPort||843,this.rememberUpgrade=e.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=e.onlyBinaryUpgrades,this.perMessageDeflate=e.perMessageDeflate!==!1?e.perMessageDeflate||{}:!1,this.perMessageDeflate===!0&&(this.perMessageDeflate={}),this.perMessageDeflate&&this.perMessageDeflate.threshold==null&&(this.perMessageDeflate.threshold=1024),this.pfx=e.pfx||void 0,this.key=e.key||void 0,this.passphrase=e.passphrase||void 0,this.cert=e.cert||void 0,this.ca=e.ca||void 0,this.ciphers=e.ciphers||void 0,this.rejectUnauthorized=e.rejectUnauthorized===void 0?!0:e.rejectUnauthorized,this.forceNode=!!e.forceNode,this.isReactNative=typeof navigator<"u"&&typeof navigator.product=="string"&&navigator.product.toLowerCase()==="reactnative",(typeof self>"u"||this.isReactNative)&&(e.extraHeaders&&Object.keys(e.extraHeaders).length>0&&(this.extraHeaders=e.extraHeaders),e.localAddress&&(this.localAddress=e.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,this.open()}pr.priorWebsocketSuccess=!1;UXe(pr.prototype);pr.protocol=Eee.protocol;pr.Socket=pr;pr.Transport=EB();pr.transports=qN;pr.parser=jy;pr.prototype.createTransport=function(n){ws('creating transport "%s"',n);var e=jXe(this.query);e.EIO=Eee.protocol,e.transport=n;var t=this.transportOptions[n]||{};this.id&&(e.sid=this.id);var r=new VXe[n]({query:e,socket:this,agent:t.agent||this.agent,hostname:t.hostname||this.hostname,port:t.port||this.port,secure:t.secure||this.secure,path:t.path||this.path,forceJSONP:t.forceJSONP||this.forceJSONP,jsonp:t.jsonp||this.jsonp,forceBase64:t.forceBase64||this.forceBase64,enablesXDR:t.enablesXDR||this.enablesXDR,withCredentials:t.withCredentials||this.withCredentials,timestampRequests:t.timestampRequests||this.timestampRequests,timestampParam:t.timestampParam||this.timestampParam,policyPort:t.policyPort||this.policyPort,pfx:t.pfx||this.pfx,key:t.key||this.key,passphrase:t.passphrase||this.passphrase,cert:t.cert||this.cert,ca:t.ca||this.ca,ciphers:t.ciphers||this.ciphers,rejectUnauthorized:t.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:t.perMessageDeflate||this.perMessageDeflate,extraHeaders:t.extraHeaders||this.extraHeaders,forceNode:t.forceNode||this.forceNode,localAddress:t.localAddress||this.localAddress,requestTimeout:t.requestTimeout||this.requestTimeout,protocols:t.protocols||void 0,isReactNative:this.isReactNative});return r};function jXe(n){var e={};for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t]);return e}pr.prototype.open=function(){var n;if(this.rememberUpgrade&&pr.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)n="websocket";else if(this.transports.length===0){var e=this;setTimeout(function(){e.emit("error","No transports available")},0);return}else n=this.transports[0];this.readyState="opening";try{n=this.createTransport(n)}catch{this.transports.shift(),this.open();return}n.open(),this.setTransport(n)};pr.prototype.setTransport=function(n){ws("setting transport %s",n.name);var e=this;this.transport&&(ws("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners()),this.transport=n,n.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})};pr.prototype.probe=function(n){ws('probing transport "%s"',n);var e=this.createTransport(n,{probe:1}),t=!1,r=this;pr.priorWebsocketSuccess=!1;function i(){if(r.onlyBinaryUpgrades){var h=!this.supportsBinary&&r.transport.supportsBinary;t=t||h}t||(ws('probe transport "%s" opened',n),e.send([{type:"ping",data:"probe"}]),e.once("packet",function(f){if(!t)if(f.type==="pong"&&f.data==="probe"){if(ws('probe transport "%s" pong',n),r.upgrading=!0,r.emit("upgrading",e),!e)return;pr.priorWebsocketSuccess=e.name==="websocket",ws('pausing current transport "%s"',r.transport.name),r.transport.pause(function(){t||r.readyState!=="closed"&&(ws("changing transport and sending upgrade packet"),u(),r.setTransport(e),e.send([{type:"upgrade"}]),r.emit("upgrade",e),e=null,r.upgrading=!1,r.flush())})}else{ws('probe transport "%s" failed',n);var d=new Error("probe error");d.transport=e.name,r.emit("upgradeError",d)}}))}function s(){t||(t=!0,u(),e.close(),e=null)}function o(h){var f=new Error("probe error: "+h);f.transport=e.name,s(),ws('probe transport "%s" failed because of error: %s',n,h),r.emit("upgradeError",f)}function a(){o("transport closed")}function l(){o("socket closed")}function c(h){e&&h.name!==e.name&&(ws('"%s" works - aborting "%s"',h.name,e.name),s())}function u(){e.removeListener("open",i),e.removeListener("error",o),e.removeListener("close",a),r.removeListener("close",l),r.removeListener("upgrading",c)}e.once("open",i),e.once("error",o),e.once("close",a),this.once("close",l),this.once("upgrading",c),e.open()};pr.prototype.onOpen=function(){if(ws("socket open"),this.readyState="open",pr.priorWebsocketSuccess=this.transport.name==="websocket",this.emit("open"),this.flush(),this.readyState==="open"&&this.upgrade&&this.transport.pause){ws("starting upgrade probes");for(var n=0,e=this.upgrades.length;n<e;n++)this.probe(this.upgrades[n])}};pr.prototype.onPacket=function(n){if(this.readyState==="opening"||this.readyState==="open"||this.readyState==="closing")switch(ws('socket receive: type "%s", data "%s"',n.type,n.data),this.emit("packet",n),this.emit("heartbeat"),n.type){case"open":this.onHandshake(JSON.parse(n.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=n.data,this.onError(e);break;case"message":this.emit("data",n.data),this.emit("message",n.data);break}else ws('packet received with socket readyState "%s"',this.readyState)};pr.prototype.onHandshake=function(n){this.emit("handshake",n),this.id=n.sid,this.transport.query.sid=n.sid,this.upgrades=this.filterUpgrades(n.upgrades),this.pingInterval=n.pingInterval,this.pingTimeout=n.pingTimeout,this.onOpen(),this.readyState!=="closed"&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))};pr.prototype.onHeartbeat=function(n){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){e.readyState!=="closed"&&e.onClose("ping timeout")},n||e.pingInterval+e.pingTimeout)};pr.prototype.setPing=function(){var n=this;clearTimeout(n.pingIntervalTimer),n.pingIntervalTimer=setTimeout(function(){ws("writing ping packet - expecting pong within %sms",n.pingTimeout),n.ping(),n.onHeartbeat(n.pingTimeout)},n.pingInterval)};pr.prototype.ping=function(){var n=this;this.sendPacket("ping",function(){n.emit("ping")})};pr.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,this.writeBuffer.length===0?this.emit("drain"):this.flush()};pr.prototype.flush=function(){this.readyState!=="closed"&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(ws("flushing %d packets in socket",this.writeBuffer.length),this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))};pr.prototype.write=pr.prototype.send=function(n,e,t){return this.sendPacket("message",n,e,t),this};pr.prototype.sendPacket=function(n,e,t,r){if(typeof e=="function"&&(r=e,e=void 0),typeof t=="function"&&(r=t,t=null),!(this.readyState==="closing"||this.readyState==="closed")){t=t||{},t.compress=t.compress!==!1;var i={type:n,data:e,options:t};this.emit("packetCreate",i),this.writeBuffer.push(i),r&&this.once("flush",r),this.flush()}};pr.prototype.close=function(){if(this.readyState==="opening"||this.readyState==="open"){this.readyState="closing";var n=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?r():e()}):this.upgrading?r():e()}function e(){n.onClose("forced close"),ws("socket closing - telling transport to close"),n.transport.close()}function t(){n.removeListener("upgrade",t),n.removeListener("upgradeError",t),e()}function r(){n.once("upgrade",t),n.once("upgradeError",t)}return this};pr.prototype.onError=function(n){ws("socket error %j",n),pr.priorWebsocketSuccess=!1,this.emit("error",n),this.onClose("transport error",n)};pr.prototype.onClose=function(n,e){if(this.readyState==="opening"||this.readyState==="open"||this.readyState==="closing"){ws('socket close with reason: "%s"',n);var t=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",n,e),t.writeBuffer=[],t.prevBufferLen=0}};pr.prototype.filterUpgrades=function(n){for(var e=[],t=0,r=n.length;t<r;t++)~WXe(this.transports,n[t])&&e.push(n[t]);return e};SB.exports=GXe;SB.exports.parser=jy;var qXe=SB.exports,Iee={exports:{}},XXe=KXe;function KXe(n,e){var t=[];e=e||0;for(var r=e||0;r<n.length;r++)t[r-e]=n[r];return t}var Aee=YXe;function YXe(n,e,t){return n.on(e,t),{destroy:function(){n.removeListener(e,t)}}}var bG=[].slice,Mee=function(n,e){if(typeof e=="string"&&(e=n[e]),typeof e!="function")throw new Error("bind() requires a function");var t=bG.call(arguments,2);return function(){return e.apply(n,t.concat(bG.call(arguments)))}};(function(n,e){var t=GN,r=Hw,i=XXe,s=Aee,o=Mee,a=HN("socket.io-client:socket"),l=Gw,c=gee;n.exports=f;var u={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},h=r.prototype.emit;function f(d,p,m){this.io=d,this.nsp=p,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,this.flags={},m&&m.query&&(this.query=m.query),this.io.autoConnect&&this.open()}r(f.prototype),f.prototype.subEvents=function(){if(!this.subs){var d=this.io;this.subs=[s(d,"open",o(this,"onopen")),s(d,"packet",o(this,"onpacket")),s(d,"close",o(this,"onclose"))]}},f.prototype.open=f.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.reconnecting||this.io.open(),this.io.readyState==="open"&&this.onopen(),this.emit("connecting"),this)},f.prototype.send=function(){var d=i(arguments);return d.unshift("message"),this.emit.apply(this,d),this},f.prototype.emit=function(d){if(u.hasOwnProperty(d))return h.apply(this,arguments),this;var p=i(arguments),m={type:(this.flags.binary!==void 0?this.flags.binary:c(p))?t.BINARY_EVENT:t.EVENT,data:p};return m.options={},m.options.compress=!this.flags||this.flags.compress!==!1,typeof p[p.length-1]=="function"&&(a("emitting packet with ack id %d",this.ids),this.acks[this.ids]=p.pop(),m.id=this.ids++),this.connected?this.packet(m):this.sendBuffer.push(m),this.flags={},this},f.prototype.packet=function(d){d.nsp=this.nsp,this.io.packet(d)},f.prototype.onopen=function(){if(a("transport is open - connecting"),this.nsp!=="/")if(this.query){var d=typeof this.query=="object"?l.encode(this.query):this.query;a("sending connect packet with query %s",d),this.packet({type:t.CONNECT,query:d})}else this.packet({type:t.CONNECT})},f.prototype.onclose=function(d){a("close (%s)",d),this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",d)},f.prototype.onpacket=function(d){var p=d.nsp===this.nsp,m=d.type===t.ERROR&&d.nsp==="/";if(!(!p&&!m))switch(d.type){case t.CONNECT:this.onconnect();break;case t.EVENT:this.onevent(d);break;case t.BINARY_EVENT:this.onevent(d);break;case t.ACK:this.onack(d);break;case t.BINARY_ACK:this.onack(d);break;case t.DISCONNECT:this.ondisconnect();break;case t.ERROR:this.emit("error",d.data);break}},f.prototype.onevent=function(d){var p=d.data||[];a("emitting event %j",p),d.id!=null&&(a("attaching ack callback to event"),p.push(this.ack(d.id))),this.connected?h.apply(this,p):this.receiveBuffer.push(p)},f.prototype.ack=function(d){var p=this,m=!1;return function(){if(!m){m=!0;var g=i(arguments);a("sending ack %j",g),p.packet({type:c(g)?t.BINARY_ACK:t.ACK,id:d,data:g})}}},f.prototype.onack=function(d){var p=this.acks[d.id];typeof p=="function"?(a("calling ack %s with %j",d.id,d.data),p.apply(this,d.data),delete this.acks[d.id]):a("bad ack %s",d.id)},f.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emitBuffered(),this.emit("connect")},f.prototype.emitBuffered=function(){var d;for(d=0;d<this.receiveBuffer.length;d++)h.apply(this,this.receiveBuffer[d]);for(this.receiveBuffer=[],d=0;d<this.sendBuffer.length;d++)this.packet(this.sendBuffer[d]);this.sendBuffer=[]},f.prototype.ondisconnect=function(){a("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")},f.prototype.destroy=function(){if(this.subs){for(var d=0;d<this.subs.length;d++)this.subs[d].destroy();this.subs=null}this.io.destroy(this)},f.prototype.close=f.prototype.disconnect=function(){return this.connected&&(a("performing disconnect (%s)",this.nsp),this.packet({type:t.DISCONNECT})),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},f.prototype.compress=function(d){return this.flags.compress=d,this},f.prototype.binary=function(d){return this.flags.binary=d,this}})(Iee);var Nee=Iee.exports,ZXe=Xw;function Xw(n){n=n||{},this.ms=n.min||100,this.max=n.max||1e4,this.factor=n.factor||2,this.jitter=n.jitter>0&&n.jitter<=1?n.jitter:0,this.attempts=0}Xw.prototype.duration=function(){var n=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),t=Math.floor(e*this.jitter*n);n=Math.floor(e*10)&1?n+t:n-t}return Math.min(n,this.max)|0};Xw.prototype.reset=function(){this.attempts=0};Xw.prototype.setMin=function(n){this.ms=n};Xw.prototype.setMax=function(n){this.max=n};Xw.prototype.setJitter=function(n){this.jitter=n};var JXe=qXe,QXe=Nee,eKe=Hw,tKe=GN,_d=Aee,N0=Mee,jo=HN("socket.io-client:manager"),$ee=Tee,nKe=ZXe,Ree=Object.prototype.hasOwnProperty,vG=kr;function kr(n,e){if(!(this instanceof kr))return new kr(n,e);n&&typeof n=="object"&&(e=n,n=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new nKe({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(e.timeout==null?2e4:e.timeout),this.readyState="closed",this.uri=n,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var t=e.parser||tKe;this.encoder=new t.Encoder,this.decoder=new t.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&&this.open()}kr.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var n in this.nsps)Ree.call(this.nsps,n)&&this.nsps[n].emit.apply(this.nsps[n],arguments)};kr.prototype.updateSocketIds=function(){for(var n in this.nsps)Ree.call(this.nsps,n)&&(this.nsps[n].id=this.generateId(n))};kr.prototype.generateId=function(n){return(n==="/"?"":n+"#")+this.engine.id};eKe(kr.prototype);kr.prototype.reconnection=function(n){return arguments.length?(this._reconnection=!!n,this):this._reconnection};kr.prototype.reconnectionAttempts=function(n){return arguments.length?(this._reconnectionAttempts=n,this):this._reconnectionAttempts};kr.prototype.reconnectionDelay=function(n){return arguments.length?(this._reconnectionDelay=n,this.backoff&&this.backoff.setMin(n),this):this._reconnectionDelay};kr.prototype.randomizationFactor=function(n){return arguments.length?(this._randomizationFactor=n,this.backoff&&this.backoff.setJitter(n),this):this._randomizationFactor};kr.prototype.reconnectionDelayMax=function(n){return arguments.length?(this._reconnectionDelayMax=n,this.backoff&&this.backoff.setMax(n),this):this._reconnectionDelayMax};kr.prototype.timeout=function(n){return arguments.length?(this._timeout=n,this):this._timeout};kr.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&this.backoff.attempts===0&&this.reconnect()};kr.prototype.open=kr.prototype.connect=function(n,e){if(jo("readyState %s",this.readyState),~this.readyState.indexOf("open"))return this;jo("opening %s",this.uri),this.engine=JXe(this.uri,this.opts);var t=this.engine,r=this;this.readyState="opening",this.skipReconnect=!1;var i=_d(t,"open",function(){r.onopen(),n&&n()}),s=_d(t,"error",function(l){if(jo("connect_error"),r.cleanup(),r.readyState="closed",r.emitAll("connect_error",l),n){var c=new Error("Connection error");c.data=l,n(c)}else r.maybeReconnectOnOpen()});if(this._timeout!==!1){var o=this._timeout;jo("connect attempt will timeout after %d",o),o===0&&i.destroy();var a=setTimeout(function(){jo("connect attempt timed out after %d",o),i.destroy(),t.close(),t.emit("error","timeout"),r.emitAll("connect_timeout",o)},o);this.subs.push({destroy:function(){clearTimeout(a)}})}return this.subs.push(i),this.subs.push(s),this};kr.prototype.onopen=function(){jo("open"),this.cleanup(),this.readyState="open",this.emit("open");var n=this.engine;this.subs.push(_d(n,"data",N0(this,"ondata"))),this.subs.push(_d(n,"ping",N0(this,"onping"))),this.subs.push(_d(n,"pong",N0(this,"onpong"))),this.subs.push(_d(n,"error",N0(this,"onerror"))),this.subs.push(_d(n,"close",N0(this,"onclose"))),this.subs.push(_d(this.decoder,"decoded",N0(this,"ondecoded")))};kr.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")};kr.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)};kr.prototype.ondata=function(n){this.decoder.add(n)};kr.prototype.ondecoded=function(n){this.emit("packet",n)};kr.prototype.onerror=function(n){jo("error",n),this.emitAll("error",n)};kr.prototype.socket=function(n,e){var t=this.nsps[n];if(!t){t=new QXe(this,n,e),this.nsps[n]=t;var r=this;t.on("connecting",i),t.on("connect",function(){t.id=r.generateId(n)}),this.autoConnect&&i()}function i(){~$ee(r.connecting,t)||r.connecting.push(t)}return t};kr.prototype.destroy=function(n){var e=$ee(this.connecting,n);~e&&this.connecting.splice(e,1),!this.connecting.length&&this.close()};kr.prototype.packet=function(n){jo("writing packet %j",n);var e=this;n.query&&n.type===0&&(n.nsp+="?"+n.query),e.encoding?e.packetBuffer.push(n):(e.encoding=!0,this.encoder.encode(n,function(t){for(var r=0;r<t.length;r++)e.engine.write(t[r],n.options);e.encoding=!1,e.processPacketQueue()}))};kr.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var n=this.packetBuffer.shift();this.packet(n)}};kr.prototype.cleanup=function(){jo("cleanup");for(var n=this.subs.length,e=0;e<n;e++){var t=this.subs.shift();t.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()};kr.prototype.close=kr.prototype.disconnect=function(){jo("disconnect"),this.skipReconnect=!0,this.reconnecting=!1,this.readyState==="opening"&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()};kr.prototype.onclose=function(n){jo("onclose"),this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",n),this._reconnection&&!this.skipReconnect&&this.reconnect()};kr.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var n=this;if(this.backoff.attempts>=this._reconnectionAttempts)jo("reconnect failed"),this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();jo("will wait %dms before reconnect attempt",e),this.reconnecting=!0;var t=setTimeout(function(){n.skipReconnect||(jo("attempting reconnect"),n.emitAll("reconnect_attempt",n.backoff.attempts),n.emitAll("reconnecting",n.backoff.attempts),!n.skipReconnect&&n.open(function(r){r?(jo("reconnect attempt error"),n.reconnecting=!1,n.reconnect(),n.emitAll("reconnect_error",r.data)):(jo("reconnect success"),n.onreconnect())}))},e);this.subs.push({destroy:function(){clearTimeout(t)}})}};kr.prototype.onreconnect=function(){var n=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",n)};(function(n,e){var t=C7e,r=GN,i=vG,s=HN("socket.io-client");n.exports=e=a;var o=e.managers={};function a(l,c){typeof l=="object"&&(c=l,l=void 0),c=c||{};var u=t(l),h=u.source,f=u.id,d=u.path,p=o[f]&&d in o[f].nsps,m=c.forceNew||c["force new connection"]||c.multiplex===!1||p,g;return m?(s("ignoring socket cache for %s",h),g=i(h,c)):(o[f]||(s("new io instance for %s",h),o[f]=i(h,c)),g=o[f]),u.query&&!c.query&&(c.query=u.query),g.socket(u.path,c)}e.protocol=r.protocol,e.connect=a,e.Manager=vG,e.Socket=Nee})(zD,zD.exports);var rKe=zD.exports;const iKe=Ay(rKe);var ZD={exports:{}},YN={},JD={exports:{}},b3,wG;function sKe(){if(wG)return b3;wG=1;var n=1e3,e=n*60,t=e*60,r=t*24,i=r*7,s=r*365.25;b3=function(u,h){h=h||{};var f=typeof u;if(f==="string"&&u.length>0)return o(u);if(f==="number"&&isFinite(u))return h.long?l(u):a(u);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(u))};function o(u){if(u=String(u),!(u.length>100)){var h=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(u);if(h){var f=parseFloat(h[1]),d=(h[2]||"ms").toLowerCase();switch(d){case"years":case"year":case"yrs":case"yr":case"y":return f*s;case"weeks":case"week":case"w":return f*i;case"days":case"day":case"d":return f*r;case"hours":case"hour":case"hrs":case"hr":case"h":return f*t;case"minutes":case"minute":case"mins":case"min":case"m":return f*e;case"seconds":case"second":case"secs":case"sec":case"s":return f*n;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return f;default:return}}}}function a(u){var h=Math.abs(u);return h>=r?Math.round(u/r)+"d":h>=t?Math.round(u/t)+"h":h>=e?Math.round(u/e)+"m":h>=n?Math.round(u/n)+"s":u+"ms"}function l(u){var h=Math.abs(u);return h>=r?c(u,h,r,"day"):h>=t?c(u,h,t,"hour"):h>=e?c(u,h,e,"minute"):h>=n?c(u,h,n,"second"):u+" ms"}function c(u,h,f,d){var p=h>=f*1.5;return Math.round(u/f)+" "+d+(p?"s":"")}return b3}function oKe(n){t.debug=t,t.default=t,t.coerce=l,t.disable=s,t.enable=i,t.enabled=o,t.humanize=sKe(),t.destroy=c,Object.keys(n).forEach(u=>{t[u]=n[u]}),t.names=[],t.skips=[],t.formatters={};function e(u){let h=0;for(let f=0;f<u.length;f++)h=(h<<5)-h+u.charCodeAt(f),h|=0;return t.colors[Math.abs(h)%t.colors.length]}t.selectColor=e;function t(u){let h,f=null,d,p;function m(...g){if(!m.enabled)return;const y=m,b=Number(new Date),_=b-(h||b);y.diff=_,y.prev=h,y.curr=b,h=b,g[0]=t.coerce(g[0]),typeof g[0]!="string"&&g.unshift("%O");let w=0;g[0]=g[0].replace(/%([a-zA-Z%])/g,(C,k)=>{if(C==="%%")return"%";w++;const A=t.formatters[k];if(typeof A=="function"){const M=g[w];C=A.call(y,M),g.splice(w,1),w--}return C}),t.formatArgs.call(y,g),(y.log||t.log).apply(y,g)}return m.namespace=u,m.useColors=t.useColors(),m.color=t.selectColor(u),m.extend=r,m.destroy=t.destroy,Object.defineProperty(m,"enabled",{enumerable:!0,configurable:!1,get:()=>f!==null?f:(d!==t.namespaces&&(d=t.namespaces,p=t.enabled(u)),p),set:g=>{f=g}}),typeof t.init=="function"&&t.init(m),m}function r(u,h){const f=t(this.namespace+(typeof h>"u"?":":h)+u);return f.log=this.log,f}function i(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let h;const f=(typeof u=="string"?u:"").split(/[\s,]+/),d=f.length;for(h=0;h<d;h++)f[h]&&(u=f[h].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.slice(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function s(){const u=[...t.names.map(a),...t.skips.map(a).map(h=>"-"+h)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let h,f;for(h=0,f=t.skips.length;h<f;h++)if(t.skips[h].test(u))return!1;for(h=0,f=t.names.length;h<f;h++)if(t.names[h].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function l(u){return u instanceof Error?u.stack||u.message:u}function c(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.enable(t.load()),t}var aKe=oKe;(function(n,e){e.formatArgs=r,e.save=i,e.load=s,e.useColors=t,e.storage=o(),e.destroy=(()=>{let l=!1;return()=>{l||(l=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function r(l){if(l[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+l[0]+(this.useColors?"%c ":" ")+"+"+n.exports.humanize(this.diff),!this.useColors)return;const c="color: "+this.color;l.splice(1,0,c,"color: inherit");let u=0,h=0;l[0].replace(/%[a-zA-Z%]/g,f=>{f!=="%%"&&(u++,f==="%c"&&(h=u))}),l.splice(h,0,c)}e.log=console.debug||console.log||(()=>{});function i(l){try{l?e.storage.setItem("debug",l):e.storage.removeItem("debug")}catch{}}function s(){let l;try{l=e.storage.getItem("debug")}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}function o(){try{return localStorage}catch{}}n.exports=aKe(e);const{formatters:a}=n.exports;a.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}}})(JD,JD.exports);var $B=JD.exports;const xG=$B("@feathersjs/errors");function er(n,e,t,r,i){n=n||"Error";let s,o,a;n instanceof Error?(o=n.message||"Error",n.errors&&(s=n.errors)):typeof n=="object"?(o=n.message||"Error",i=n):o=n,i&&(a=JSON.parse(JSON.stringify(i)),a.errors?(s=a.errors,delete a.errors):i.errors&&(s=JSON.parse(JSON.stringify(i.errors)))),this.type="FeathersError",this.name=e,this.message=o,this.code=t,this.className=r,this.data=a,this.errors=s||{},xG(`${this.name}(${this.code}): ${this.message}`),xG(this.errors),Error.captureStackTrace?Error.captureStackTrace(this,er):this.stack=new Error().stack}function ho(n,e){n.prototype=Object.create(e.prototype),n.prototype.constructor=n}ho(er,Error);Object.defineProperty(er.prototype,"toJSON",{value:function(){return{name:this.name,message:this.message,code:this.code,className:this.className,data:this.data,errors:this.errors}}});function QD(n,e){er.call(this,n,"BadRequest",400,"bad-request",e)}ho(QD,er);function eO(n,e){er.call(this,n,"NotAuthenticated",401,"not-authenticated",e)}ho(eO,er);function tO(n,e){er.call(this,n,"PaymentError",402,"payment-error",e)}ho(tO,er);function nO(n,e){er.call(this,n,"Forbidden",403,"forbidden",e)}ho(nO,er);function rO(n,e){er.call(this,n,"NotFound",404,"not-found",e)}ho(rO,er);function iO(n,e){er.call(this,n,"MethodNotAllowed",405,"method-not-allowed",e)}ho(iO,er);function sO(n,e){er.call(this,n,"NotAcceptable",406,"not-acceptable",e)}ho(sO,er);function oO(n,e){er.call(this,n,"Timeout",408,"timeout",e)}ho(oO,er);function aO(n,e){er.call(this,n,"Conflict",409,"conflict",e)}ho(aO,er);function lO(n,e){er(this,n,"Gone",410,"gone")}ho(lO,er);function cO(n,e){er.call(this,n,"LengthRequired",411,"length-required",e)}ho(cO,er);function uO(n,e){er.call(this,n,"Unprocessable",422,"unprocessable",e)}ho(uO,er);function hO(n,e){er.call(this,n,"TooManyRequests",429,"too-many-requests",e)}ho(hO,er);function fO(n,e){er.call(this,n,"GeneralError",500,"general-error",e)}ho(fO,er);function dO(n,e){er.call(this,n,"NotImplemented",501,"not-implemented",e)}ho(dO,er);function pO(n,e){er.call(this,n,"BadGateway",502,"bad-gateway",e)}ho(pO,er);function mO(n,e){er.call(this,n,"Unavailable",503,"unavailable",e)}ho(mO,er);const Pee={FeathersError:er,BadRequest:QD,NotAuthenticated:eO,PaymentError:tO,Forbidden:nO,NotFound:rO,MethodNotAllowed:iO,NotAcceptable:sO,Timeout:oO,Conflict:aO,Gone:lO,LengthRequired:cO,Unprocessable:uO,TooManyRequests:hO,GeneralError:fO,NotImplemented:dO,BadGateway:pO,Unavailable:mO,400:QD,401:eO,402:tO,403:nO,404:rO,405:iO,406:sO,408:oO,409:aO,410:lO,411:cO,422:uO,429:hO,500:fO,501:dO,502:pO,503:mO};function lKe(n){if(!n)return n;const e=Pee[n.name],t=e?new e(n.message,n.data):new Error(n.message||n);return typeof n=="object"&&Object.assign(t,n),t}var bC=Object.assign({convert:lKe},Pee),fg={};Object.defineProperty(fg,"__esModule",{value:!0});fg.StorageWrapper=fg.MemoryStorage=void 0;class cKe{constructor(){this.store={}}getItem(e){return Promise.resolve(this.store[e])}setItem(e,t){return Promise.resolve(this.store[e]=t)}removeItem(e){const t=this.store[e];return delete this.store[e],Promise.resolve(t)}}fg.MemoryStorage=cKe;class uKe{constructor(e){this.storage=e}getItem(e){return Promise.resolve(this.storage.getItem(e))}setItem(e,t){return Promise.resolve(this.storage.setItem(e,t))}removeItem(e){return Promise.resolve(this.storage.removeItem(e))}}fg.StorageWrapper=uKe;Object.defineProperty(YN,"__esModule",{value:!0});YN.AuthenticationClient=void 0;const _G=bC,hKe=fg,SG=(n,e)=>{const t=new RegExp(`(?:&?)${e}=([^&]*)`),r=n.hash?n.hash.match(t):null;if(r!==null){const[,i]=r;return[i,t]}return[null,t]};class fKe{constructor(e,t){const r=e.io||e.primus,i=new hKe.StorageWrapper(e.get("storage")||t.storage);this.app=e,this.options=t,this.authenticated=!1,this.app.set("storage",i),r&&this.handleSocket(r)}get service(){return this.app.service(this.options.path)}get storage(){return this.app.get("storage")}handleSocket(e){const t=this.app.io?"connect":"open",r=this.app.io?"disconnect":"disconnection";e.on(r,()=>{const i=new Promise(s=>e.once(t,o=>s(o))).then(()=>this.authenticated?this.reAuthenticate(!0):null);this.app.set("authentication",i)})}getFromLocation(e){const[t,r]=SG(e,this.options.locationKey);if(t!==null)return e.hash=e.hash.replace(r,""),Promise.resolve(t);const[i,s]=SG(e,this.options.locationErrorKey);return i!==null?(e.hash=e.hash.replace(s,""),Promise.reject(new _G.NotAuthenticated(decodeURIComponent(i)))):Promise.resolve(null)}setAccessToken(e){return this.storage.setItem(this.options.storageKey,e)}getAccessToken(){return this.storage.getItem(this.options.storageKey).then(e=>!e&&typeof window<"u"&&window.location?this.getFromLocation(window.location):e||null)}removeAccessToken(){return this.storage.removeItem(this.options.storageKey)}reset(){return this.app.set("authentication",null),this.authenticated=!1,Promise.resolve(null)}handleError(e,t){if(e.code===401||e.code===403){const r=this.removeAccessToken().then(()=>this.reset());return t==="logout"?r:r.then(()=>Promise.reject(e))}return Promise.reject(e)}reAuthenticate(e=!1,t){const r=this.app.get("authentication");return!r||e===!0?this.getAccessToken().then(i=>{if(!i)throw new _G.NotAuthenticated("No accessToken found in storage");return this.authenticate({strategy:t||this.options.jwtStrategy,accessToken:i})}):r}authenticate(e,t){if(!e)return this.reAuthenticate();const r=this.service.create(e,t).then(i=>{const{accessToken:s}=i;return this.authenticated=!0,this.app.emit("login",i),this.app.emit("authenticated",i),this.setAccessToken(s).then(()=>i)}).catch(i=>this.handleError(i,"authenticate"));return this.app.set("authentication",r),r}logout(){return Promise.resolve(this.app.get("authentication")).then(()=>this.service.remove(null).then(e=>this.removeAccessToken().then(()=>this.reset()).then(()=>(this.app.emit("logout",e),e)))).catch(e=>this.handleError(e,"logout"))}}YN.AuthenticationClient=fKe;var Dee={},ZN={},Np={},ys={},RB={};(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.createSymbol=n.makeUrl=n.isPromise=n._=n.stripSlashes=void 0;function e(s){return s.replace(/^(\/+)|(\/+)$/g,"")}n.stripSlashes=e,n._={each(s,o){s&&typeof s.forEach=="function"?s.forEach(o):n._.isObject(s)&&Object.keys(s).forEach(a=>o(s[a],a))},some(s,o){return Object.keys(s).map(a=>[s[a],a]).some(([a,l])=>o(a,l))},every(s,o){return Object.keys(s).map(a=>[s[a],a]).every(([a,l])=>o(a,l))},keys(s){return Object.keys(s)},values(s){return n._.keys(s).map(o=>s[o])},isMatch(s,o){return n._.keys(o).every(a=>s[a]===o[a])},isEmpty(s){return n._.keys(s).length===0},isObject(s){return typeof s=="object"&&!Array.isArray(s)&&s!==null},isObjectOrArray(s){return typeof s=="object"&&s!==null},extend(s,...o){return Object.assign(s,...o)},omit(s,...o){const a=n._.extend({},s);return o.forEach(l=>delete a[l]),a},pick(s,...o){return o.reduce((a,l)=>(s[l]!==void 0&&(a[l]=s[l]),a),{})},merge(s,o){return n._.isObject(s)&&n._.isObject(o)&&Object.keys(o).forEach(a=>{n._.isObject(o[a])?(s[a]||Object.assign(s,{[a]:{}}),n._.merge(s[a],o[a])):Object.assign(s,{[a]:o[a]})}),s}};function t(s){return n._.isObject(s)&&typeof s.then=="function"}n.isPromise=t;function r(s,o={}){const a=typeof o.get=="function"?o.get.bind(o):()=>{},l=a("env")||"production",c=a("host")||{}.HOST_NAME||"localhost",u=l==="development"||l==="test"||l===void 0?"http":"https",h=a("port")||{}.PORT||3030,f=l==="development"||l==="test"||l===void 0?`:${h}`:"";return s=s||"",`${u}://${c}${f}/${n.stripSlashes(s)}`}n.makeUrl=r;function i(s){return typeof Symbol<"u"?Symbol(s):s}n.createSymbol=i})(RB);Object.defineProperty(ys,"__esModule",{value:!0});ys.enableHooks=ys.processHooks=ys.getHooks=ys.isHookObject=ys.convertHookData=ys.makeArguments=ys.defaultMakeArguments=ys.createHookObject=ys.ACTIVATE_HOOKS=void 0;const Oee=RB,{each:gO,pick:dKe}=Oee._;ys.ACTIVATE_HOOKS=(0,Oee.createSymbol)("__feathersActivateHooks");function pKe(n,e={}){const t={};return Object.defineProperty(t,"toJSON",{value(){return dKe(this,"type","method","path","params","id","data","result","error")}}),Object.assign(t,e,{method:n,get path(){const{app:r,service:i}=e;return!i||!r||!r.services?null:Object.keys(r.services).find(s=>r.services[s]===i)}})}ys.createHookObject=pKe;function Fee(n){const e=[];return typeof n.id<"u"&&e.push(n.id),n.data&&e.push(n.data),e.push(n.params||{}),e}ys.defaultMakeArguments=Fee;function mKe(n){switch(n.method){case"find":return[n.params];case"get":case"remove":return[n.id,n.params];case"update":case"patch":return[n.id,n.data,n.params];case"create":return[n.data,n.params]}return Fee(n)}ys.makeArguments=mKe;function Lee(n){let e={};return Array.isArray(n)?e={all:n}:typeof n!="object"?e={all:[n]}:gO(n,function(t,r){e[r]=Array.isArray(t)?t:[t]}),e}ys.convertHookData=Lee;function zee(n){return typeof n=="object"&&typeof n.method=="string"&&typeof n.type=="string"}ys.isHookObject=zee;function gKe(n,e,t,r,i=!1){const s=n.__hooks[t][r]||[],o=e.__hooks[t][r]||[];return i?o.concat(s):s.concat(o)}ys.getHooks=gKe;function yKe(n,e){let t=e;const r=s=>{if(s){if(!zee(s))throw new Error(`${t.type} hook for '${t.method}' method returned invalid hook object`);t=s}return t};return n.reduce((s,o)=>{const a=o.bind(this);return s.then(l=>a(l)).then(r)},Promise.resolve(t)).then(()=>t).catch(s=>{throw s.hook=t,s})}ys.processHooks=yKe;function bKe(n,e,t){if(typeof n.hooks=="function")return n;const r={};return t.forEach(i=>{r[i]={}}),Object.defineProperty(n,"__hooks",{configurable:!0,value:r,writable:!0}),Object.assign(n,{hooks(i){return gO(i,(s,o)=>{if(!this.__hooks[o])throw new Error(`'${o}' is not a valid hook type`);const a=Lee(s);gO(a,(l,c)=>{if(c!=="all"&&e.indexOf(c)===-1)throw new Error(`'${c}' is not a valid hook method`)}),e.forEach(l=>{const c=this.__hooks[o][l]||(this.__hooks[o][l]=[]);a.all&&c.push.apply(c,a.all),a[l]&&c.push.apply(c,a[l])})}),this}})}ys.enableHooks=bKe;(function(n){var e=gt&&gt.__createBinding||(Object.create?function(o,a,l,c){c===void 0&&(c=l);var u=Object.getOwnPropertyDescriptor(a,l);(!u||("get"in u?!a.__esModule:u.writable||u.configurable))&&(u={enumerable:!0,get:function(){return a[l]}}),Object.defineProperty(o,c,u)}:function(o,a,l,c){c===void 0&&(c=l),o[c]=a[l]}),t=gt&&gt.__setModuleDefault||(Object.create?function(o,a){Object.defineProperty(o,"default",{enumerable:!0,value:a})}:function(o,a){o.default=a}),r=gt&&gt.__importStar||function(o){if(o&&o.__esModule)return o;var a={};if(o!=null)for(var l in o)l!=="default"&&Object.prototype.hasOwnProperty.call(o,l)&&e(a,o,l);return t(a,o),a},i=gt&&gt.__exportStar||function(o,a){for(var l in o)l!=="default"&&!Object.prototype.hasOwnProperty.call(a,l)&&e(a,o,l)};Object.defineProperty(n,"__esModule",{value:!0}),n.hooks=void 0;const s=r(ys);i(RB,n),n.hooks=s})(Np);Object.defineProperty(ZN,"__esModule",{value:!0});ZN.authentication=void 0;const vKe=Np,wKe=()=>n=>{const{app:e,params:t,path:r,method:i,app:{authentication:s}}=n;return(0,vKe.stripSlashes)(s.options.path)===r&&i==="create"?n:Promise.resolve(e.get("authentication")).then(o=>(o&&(n.params=Object.assign({},o,t)),n))};ZN.authentication=wKe;var JN={};Object.defineProperty(JN,"__esModule",{value:!0});JN.populateHeader=void 0;const xKe=()=>n=>{const{app:e,params:{accessToken:t}}=n,r=e.authentication;if(e.rest&&t){const{scheme:i,header:s}=r.options,o=`${i} ${t}`;n.params.headers=Object.assign({},{[s]:o},n.params.headers)}return n};JN.populateHeader=xKe;(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.populateHeader=n.authentication=void 0;var e=ZN;Object.defineProperty(n,"authentication",{enumerable:!0,get:function(){return e.authentication}});var t=JN;Object.defineProperty(n,"populateHeader",{enumerable:!0,get:function(){return t.populateHeader}})})(Dee);(function(n,e){var t=gt&&gt.__createBinding||(Object.create?function(u,h,f,d){d===void 0&&(d=f);var p=Object.getOwnPropertyDescriptor(h,f);(!p||("get"in p?!h.__esModule:p.writable||p.configurable))&&(p={enumerable:!0,get:function(){return h[f]}}),Object.defineProperty(u,d,p)}:function(u,h,f,d){d===void 0&&(d=f),u[d]=h[f]}),r=gt&&gt.__setModuleDefault||(Object.create?function(u,h){Object.defineProperty(u,"default",{enumerable:!0,value:h})}:function(u,h){u.default=h}),i=gt&&gt.__importStar||function(u){if(u&&u.__esModule)return u;var h={};if(u!=null)for(var f in u)f!=="default"&&Object.prototype.hasOwnProperty.call(u,f)&&t(h,u,f);return r(h,u),h};Object.defineProperty(e,"__esModule",{value:!0}),e.defaults=e.defaultStorage=e.hooks=e.MemoryStorage=e.AuthenticationClient=e.getDefaultStorage=void 0;const s=YN;Object.defineProperty(e,"AuthenticationClient",{enumerable:!0,get:function(){return s.AuthenticationClient}});const o=i(Dee);e.hooks=o;const a=fg;Object.defineProperty(e,"MemoryStorage",{enumerable:!0,get:function(){return a.MemoryStorage}});const l=()=>{try{return new a.StorageWrapper(window.localStorage)}catch{}return new a.MemoryStorage};e.getDefaultStorage=l,e.defaultStorage=(0,e.getDefaultStorage)(),e.defaults={header:"Authorization",scheme:"Bearer",storageKey:"feathers-jwt",locationKey:"access_token",locationErrorKey:"error",jwtStrategy:"jwt",path:"/authentication",Authentication:s.AuthenticationClient,storage:e.defaultStorage};const c=(u={})=>{const h=Object.assign({},e.defaults,u),{Authentication:f}=h;return d=>{const p=new f(d,h);d.authentication=p,d.authenticate=p.authenticate.bind(p),d.reAuthenticate=p.reAuthenticate.bind(p),d.logout=p.logout.bind(p),d.hooks({before:{all:[o.authentication(),o.populateHeader()]}})}};e.default=c,n.exports=Object.assign(c,n.exports)})(ZD,ZD.exports);var _Ke=ZD.exports;const SKe=Ay(_Ke);var PB={exports:{}},Bee={exports:{}};(function(n,e){(function(t,r){n.exports=r()})(gt,function(){var t=typeof Object.getOwnPropertySymbols=="function";function r(i,s,o,a){var l=typeof s=="function",c=function(){var u=this._super;this._super=l?s:i[o];var h=a.apply(this,arguments);return this._super=u,h};return l&&(Object.keys(s).forEach(function(u){c[u]=s[u]}),t&&Object.getOwnPropertySymbols(s).forEach(function(u){c[u]=s[u]})),c}return{create:function(){var i=Object.create(this),s=typeof i.__init=="string"?i.__init:"init";return typeof i[s]=="function"&&i[s].apply(i,arguments),i},mixin:function(i,s){var o=s||this,a=/\b_super\b/,l=Object.getPrototypeOf(o)||o.prototype,c={},u=i,h=function(d){var p=Object.getOwnPropertyDescriptor(u,d);!c[d]&&p&&(c[d]=p)};do Object.getOwnPropertyNames(u).forEach(h),t&&Object.getOwnPropertySymbols(u).forEach(h);while((u=Object.getPrototypeOf(u))&&Object.getPrototypeOf(u));var f=function(d){var p=c[d];typeof p.value=="function"&&a.test(p.value)&&(p.value=r(l,o[d],d,p.value)),Object.defineProperty(o,d,p)};return Object.keys(c).forEach(f),t&&Object.getOwnPropertySymbols(c).forEach(f),o},extend:function(i,s){return this.mixin(i,Object.create(s||this))},proxy:function(i){var s=this[i],o=Array.prototype.slice.call(arguments,1);return o.unshift(this),s.bind.apply(s,o)}}})})(Bee);var DB=Bee.exports,yO={exports:{}},OB={exports:{}},Nb=typeof Reflect=="object"?Reflect:null,CG=Nb&&typeof Nb.apply=="function"?Nb.apply:function(e,t,r){return Function.prototype.apply.call(e,t,r)},FE;Nb&&typeof Nb.ownKeys=="function"?FE=Nb.ownKeys:Object.getOwnPropertySymbols?FE=function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:FE=function(e){return Object.getOwnPropertyNames(e)};function CKe(n){console&&console.warn&&console.warn(n)}var Vee=Number.isNaN||function(e){return e!==e};function Xr(){Xr.init.call(this)}OB.exports=Xr;OB.exports.once=IKe;Xr.EventEmitter=Xr;Xr.prototype._events=void 0;Xr.prototype._eventsCount=0;Xr.prototype._maxListeners=void 0;var kG=10;function QN(n){if(typeof n!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof n)}Object.defineProperty(Xr,"defaultMaxListeners",{enumerable:!0,get:function(){return kG},set:function(n){if(typeof n!="number"||n<0||Vee(n))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+n+".");kG=n}});Xr.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0};Xr.prototype.setMaxListeners=function(e){if(typeof e!="number"||e<0||Vee(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this};function Uee(n){return n._maxListeners===void 0?Xr.defaultMaxListeners:n._maxListeners}Xr.prototype.getMaxListeners=function(){return Uee(this)};Xr.prototype.emit=function(e){for(var t=[],r=1;r<arguments.length;r++)t.push(arguments[r]);var i=e==="error",s=this._events;if(s!==void 0)i=i&&s.error===void 0;else if(!i)return!1;if(i){var o;if(t.length>0&&(o=t[0]),o instanceof Error)throw o;var a=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw a.context=o,a}var l=s[e];if(l===void 0)return!1;if(typeof l=="function")CG(l,this,t);else for(var c=l.length,u=qee(l,c),r=0;r<c;++r)CG(u[r],this,t);return!0};function Wee(n,e,t,r){var i,s,o;if(QN(t),s=n._events,s===void 0?(s=n._events=Object.create(null),n._eventsCount=0):(s.newListener!==void 0&&(n.emit("newListener",e,t.listener?t.listener:t),s=n._events),o=s[e]),o===void 0)o=s[e]=t,++n._eventsCount;else if(typeof o=="function"?o=s[e]=r?[t,o]:[o,t]:r?o.unshift(t):o.push(t),i=Uee(n),i>0&&o.length>i&&!o.warned){o.warned=!0;var a=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");a.name="MaxListenersExceededWarning",a.emitter=n,a.type=e,a.count=o.length,CKe(a)}return n}Xr.prototype.addListener=function(e,t){return Wee(this,e,t,!1)};Xr.prototype.on=Xr.prototype.addListener;Xr.prototype.prependListener=function(e,t){return Wee(this,e,t,!0)};function kKe(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function Hee(n,e,t){var r={fired:!1,wrapFn:void 0,target:n,type:e,listener:t},i=kKe.bind(r);return i.listener=t,r.wrapFn=i,i}Xr.prototype.once=function(e,t){return QN(t),this.on(e,Hee(this,e,t)),this};Xr.prototype.prependOnceListener=function(e,t){return QN(t),this.prependListener(e,Hee(this,e,t)),this};Xr.prototype.removeListener=function(e,t){var r,i,s,o,a;if(QN(t),i=this._events,i===void 0)return this;if(r=i[e],r===void 0)return this;if(r===t||r.listener===t)--this._eventsCount===0?this._events=Object.create(null):(delete i[e],i.removeListener&&this.emit("removeListener",e,r.listener||t));else if(typeof r!="function"){for(s=-1,o=r.length-1;o>=0;o--)if(r[o]===t||r[o].listener===t){a=r[o].listener,s=o;break}if(s<0)return this;s===0?r.shift():TKe(r,s),r.length===1&&(i[e]=r[0]),i.removeListener!==void 0&&this.emit("removeListener",e,a||t)}return this};Xr.prototype.off=Xr.prototype.removeListener;Xr.prototype.removeAllListeners=function(e){var t,r,i;if(r=this._events,r===void 0)return this;if(r.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):r[e]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete r[e]),this;if(arguments.length===0){var s=Object.keys(r),o;for(i=0;i<s.length;++i)o=s[i],o!=="removeListener"&&this.removeAllListeners(o);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(t=r[e],typeof t=="function")this.removeListener(e,t);else if(t!==void 0)for(i=t.length-1;i>=0;i--)this.removeListener(e,t[i]);return this};function Gee(n,e,t){var r=n._events;if(r===void 0)return[];var i=r[e];return i===void 0?[]:typeof i=="function"?t?[i.listener||i]:[i]:t?EKe(i):qee(i,i.length)}Xr.prototype.listeners=function(e){return Gee(this,e,!0)};Xr.prototype.rawListeners=function(e){return Gee(this,e,!1)};Xr.listenerCount=function(n,e){return typeof n.listenerCount=="function"?n.listenerCount(e):jee.call(n,e)};Xr.prototype.listenerCount=jee;function jee(n){var e=this._events;if(e!==void 0){var t=e[n];if(typeof t=="function")return 1;if(t!==void 0)return t.length}return 0}Xr.prototype.eventNames=function(){return this._eventsCount>0?FE(this._events):[]};function qee(n,e){for(var t=new Array(e),r=0;r<e;++r)t[r]=n[r];return t}function TKe(n,e){for(;e+1<n.length;e++)n[e]=n[e+1];n.pop()}function EKe(n){for(var e=new Array(n.length),t=0;t<e.length;++t)e[t]=n[t].listener||n[t];return e}function IKe(n,e){return new Promise(function(t,r){function i(o){n.removeListener(e,s),r(o)}function s(){typeof n.removeListener=="function"&&n.removeListener("error",i),t([].slice.call(arguments))}Xee(n,e,s,{once:!0}),e!=="error"&&AKe(n,i,{once:!0})})}function AKe(n,e,t){typeof n.on=="function"&&Xee(n,"error",e,t)}function Xee(n,e,t,r){if(typeof n.on=="function")r.once?n.once(e,t):n.on(e,t);else if(typeof n.addEventListener=="function")n.addEventListener(e,function i(s){r.once&&n.removeEventListener(e,i),t(s)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof n)}var MKe=OB.exports;(function(n,e){const{EventEmitter:t}=MKe,r=DB,i=e.eventHook=function(){return function(a){const{app:l,service:c}=a,u=a.event===null?a.event:l.eventMappings[a.method],h=c._hookEvents&&c._hookEvents.indexOf(u)!==-1;u&&h&&a.type!=="error"&&(Array.isArray(a.result)?a.result:[a.result]).forEach(d=>c.emit(u,d,a))}},s=e.eventMixin=function(a){if(a._serviceEvents)return;const l=this,c=typeof a.on=="function"&&typeof a.emit=="function";typeof a.mixin=="function"&&!c&&a.mixin(t.prototype),Object.defineProperties(a,{_serviceEvents:{value:Array.isArray(a.events)?a.events.slice():[]},_hookEvents:{value:[]}}),Object.keys(l.eventMappings).forEach(u=>{const h=l.eventMappings[u],f=a._serviceEvents.indexOf(h)!==-1;typeof a[u]=="function"&&!f&&(a._serviceEvents.push(h),a._hookEvents.push(h))})};n.exports=function(){return function(o){Object.assign(o,{eventMappings:{create:"created",update:"updated",remove:"removed",patch:"patched"}}),o.hooks({finally:i()}),r.mixin(t.prototype,o),o.mixins.push(s)}}})(yO,yO.exports);var NKe=yO.exports,bO={exports:{}};const{_:$Ke}=Np,RKe=n=>{const{service:e,method:t}=n,r=e.methods[t];return n.arguments.forEach((i,s)=>{n[r[s]]=i}),n.params||(n.params={}),n},PKe=n=>{const{service:e,method:t,path:r}=n,i=e.methods[t];if(i.includes("id")&&n.id===void 0)throw new Error(`An id must be provided to the '${r}.${t}' method`);if(i.includes("data")&&!$Ke.isObjectOrArray(n.data))throw new Error(`A data object must be provided to the '${r}.${t}' method`);return n};var DKe=[RKe,PKe];(function(n,e){const{hooks:t,isPromise:r}=Np,i=DKe,{createHookObject:s,getHooks:o,processHooks:a,enableHooks:l,ACTIVATE_HOOKS:c}=t,u=function({app:d,service:p,method:m,original:g}){return(y={})=>{const b=d.hookTypes.reduce((_,w)=>{const S=y[w]||[];return _[w]=Array.isArray(S)?S:[S],_},{});return function(..._){const w=_[_.length-1]===!0?_.pop():!1,S=s(m,{type:"before",arguments:_,service:p,app:d});return Promise.resolve(S).then(C=>a.call(p,i.concat(b.before),C)).then(C=>typeof C.result<"u"?C:new Promise(A=>{const M=g||p[m],E=p.methods[m].map(O=>C[O]),N=M.apply(p,E);if(!r(N))throw new Error(`Service method '${C.method}' for '${C.path}' service must return a promise`);A(N)}).then(A=>(C.result=A,C)).catch(A=>{throw A.hook=C,A})).then(C=>{const k=Object.assign({},C,{type:"after"});return a.call(p,b.after,k)}).catch(C=>{const k=Object.assign({},C.hook,{type:"error",original:C.hook,error:C,result:void 0});return a.call(p,b.error,k).catch(A=>Object.assign({},A.hook,{error:A,result:void 0}))}).then(C=>a.call(p,b.finally,C).catch(k=>Object.assign({},k.hook,{error:k,result:void 0}))).then(C=>typeof C.error<"u"&&typeof C.result>"u"?Promise.reject(w?C:C.error):w?C:C.result)}}},h=e.hookMixin=function(d){if(typeof d.hooks=="function")return;d.methods=Object.getOwnPropertyNames(d).filter(y=>typeof d[y]=="function"&&d[y][c]).reduce((y,b)=>(y[b]=d[b][c],y),d.methods||{}),Object.assign(d.methods,{find:["params"],get:["id","params"],create:["data","params"],update:["id","data","params"],patch:["id","data","params"],remove:["id","params"]});const p=this,m=Object.keys(d.methods),g=m.reduce((y,b)=>(typeof d[b]!="function"||(y[b]=function(){const _=this,w=Array.from(arguments),S=_._super.bind(_);return u({app:p,service:_,method:b,original:S})({before:o(p,_,"before",b),after:o(p,_,"after",b,!0),error:o(p,_,"error",b,!0),finally:o(p,_,"finally",b,!0)})(...w)}),y),{});l(d,m,p.hookTypes),d.mixin(g)};n.exports=function(){return function(f){Object.assign(f,{hookTypes:["before","after","error","finally"]}),l(f,f.methods,f.hookTypes),f.mixins.push(h)}},n.exports.withHooks=u,n.exports.ACTIVATE_HOOKS=c,n.exports.activateHooks=function(d){return p=>(Object.defineProperty(p,c,{value:d}),p)}})(bO,bO.exports);var Kee=bO.exports,Yee="4.5.17";const v3=$B("feathers:application"),{stripSlashes:TG}=Np,OKe=DB,FKe=NKe,LKe=Kee,zKe=Yee,EG=OKe.extend({create:null}),BKe={init(){Object.assign(this,{version:zKe,methods:["find","get","create","update","patch","remove"],mixins:[],services:{},providers:[],_setup:!1,settings:{}}),this.configure(LKe()),this.configure(FKe())},get(n){return this.settings[n]},set(n,e){return this.settings[n]=e,this},disable(n){return this.settings[n]=!1,this},disabled(n){return!this.settings[n]},enable(n){return this.settings[n]=!0,this},enabled(n){return!!this.settings[n]},configure(n){return n.call(this,this),this},service(n,e){if(typeof e<"u")throw new Error("Registering a new service with `app.service(path, service)` is no longer supported. Use `app.use(path, service)` instead.");const t=TG(n)||"/",r=this.services.hasOwnProperty(t)?this.services[t]:void 0;return typeof r>"u"&&typeof this.defaultService=="function"?this.use(t,this.defaultService(t)).service(t):r},use(n,e,t={}){if(typeof n!="string")throw new Error(`'${n}' is not a valid service path.`);const r=TG(n)||"/",i=typeof e.service=="function"&&e.services,s=this.methods.concat("setup").some(a=>typeof e[a]=="function");if(i){const a=e;return Object.keys(a.services).forEach(l=>this.use(`${r}/${l}`,a.service(l))),this}if(!s)throw new Error(`Invalid service object passed for path \`${r}\``);const o=EG.isPrototypeOf(e)?e:EG.extend(e);return v3(`Registering new service at \`${r}\``),this.mixins.forEach(a=>a.call(this,o,r,t)),typeof o._setup=="function"&&o._setup(this,r),this.providers.forEach(a=>a.call(this,o,r,t)),this._isSetup&&typeof o.setup=="function"&&(v3(`Setting up service for \`${r}\``),o.setup(this,r)),this.services[r]=o,this},setup(){return Object.keys(this.services).forEach(n=>{const e=this.services[n];v3(`Setting up service for \`${n}\``),typeof e.setup=="function"&&e.setup(this,n)}),this._isSetup=!0,this}};var VKe=BKe;const UKe=DB,WKe=VKe,HKe=Yee,{ACTIVATE_HOOKS:GKe,activateHooks:jKe}=Kee,qKe=Object.create(null);function vC(){const n=Object.create(qKe);return UKe.mixin(WKe,n),n.init(),n}vC.version=HKe;vC.ACTIVATE_HOOKS=GKe;vC.activateHooks=jKe;PB.exports=vC;PB.exports.default=vC;var XKe=PB.exports;const KKe=Ay(XKe);var FB={exports:{}},e$={},YKe=gt&&gt.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e$,"__esModule",{value:!0});e$.Service=void 0;const ZKe=YKe($B),IG=bC,Zee=(0,ZKe.default)("@feathersjs/transport-commons/client"),JKe=["addListener","emit","listenerCount","listeners","on","once","prependListener","prependOnceListener","removeAllListeners","removeListener"],QKe=["eventNames","getMaxListeners","setMaxListeners"],eYe=n=>{QKe.forEach(e=>{n[e]=function(...t){if(typeof this.connection[e]!="function")throw new Error(`Can not call '${e}' on the client service connection`);return this.connection[e](...t)}}),JKe.forEach(e=>{n[e]=function(t,...r){if(typeof this.connection[e]!="function")throw new Error(`Can not call '${e}' on the client service connection`);const i=`${this.path} ${t}`;Zee(`Calling emitter method ${e} with namespaced event '${i}'`);const s=this.connection[e](i,...r);return s===this.connection?this:s}})};let tYe=class{constructor(e){this.events=e.events,this.path=e.name,this.connection=e.connection,this.method=e.method,this.timeout=e.timeout||5e3,eYe(this)}send(e,...t){return new Promise((r,i)=>{const s=setTimeout(()=>i(new IG.Timeout(`Timeout of ${this.timeout}ms exceeded calling ${e} on ${this.path}`,{timeout:this.timeout,method:e,path:this.path})),this.timeout);t.unshift(e,this.path),t.push(function(o,a){return o=(0,IG.convert)(o),clearTimeout(s),o?i(o):r(a)}),Zee(`Sending socket.${this.method}`,t),this.connection[this.method](...t)})}find(e={}){return this.send("find",e.query||{})}get(e,t={}){return this.send("get",e,t.query||{})}create(e,t={}){return this.send("create",e,t.query||{})}update(e,t,r={}){return this.send("update",e,t,r.query||{})}patch(e,t,r={}){return this.send("patch",e,t,r.query||{})}remove(e,t={}){return this.send("remove",e,t.query||{})}off(e,...t){if(typeof this.connection.off=="function"){const r=this.connection.off(`${this.path} ${e}`,...t);return r===this.connection?this:r}else if(t.length===0)return this.removeAllListeners(e);return this.removeListener(e,...t)}};e$.Service=tYe;var nYe=e$.Service;const AG=nYe;function Jee(n,e){if(!n)throw new Error("Socket.io connection needs to be provided");if(n&&n.io&&n.io.engine&&n.io.engine.transport&&n.io.engine.transport.query&&n.io.engine.transport.query.EIO>3)throw console.error("You are trying to use the Socket.io client version 3 or later with Feathers v4 which only supports Socket.io version 2. Please use socket.io-client version 2 instead."),new Error("socket.io-client must be version 2.x");const t=function(i){const s=Object.keys(this.eventMappings||{}).map(a=>this.eventMappings[a]),o=Object.assign({},e,{events:s,name:i,connection:n,method:"emit"});return new AG(o)},r=function(i){if(typeof i.defaultService=="function")throw new Error("Only one default client provider can be configured");i.io=n,i.defaultService=t};return r.Service=AG,r.service=t,r}FB.exports=Jee;FB.exports.default=Jee;var rYe=FB.exports;const iYe=Ay(rYe);var LB={exports:{}},Qee={},t$={},vO={exports:{}};(function(n,e){Object.defineProperty(e,"__esModule",{value:!0}),e.OPERATORS=e.FILTERS=void 0;const t=Np,r=bC;function i(u){if(typeof u<"u")return Math.abs(parseInt(u,10))}function s(u,h){if(h&&h.default){const f=typeof u=="number"&&!isNaN(u)?u:h.default,d=typeof h.max=="number"?h.max:Number.MAX_VALUE;return Math.min(f,d)}return u}function o(u){return typeof u!="object"||Array.isArray(u)?u:Object.keys(u).reduce((h,f)=>(h[f]=typeof u[f]=="object"?u[f]:parseInt(u[f],10),h),{})}function a(u,h,f){if(Array.isArray(u))return u.map(d=>a(d,h,f));if(t._.isObject(u)&&u.constructor==={}.constructor){const d={};return t._.each(u,(p,m)=>{if(m[0]==="$"){if(f[m]!==void 0)return;if(!h.includes(m))throw new r.BadRequest(`Invalid query parameter ${m}`,u)}d[m]=a(p,h,f)}),Object.getOwnPropertySymbols(u).forEach(p=>{d[p]=u[p]}),d}return u}function l(u,h,f,d){return Array.isArray(f)?t._.each(f,p=>{h[p]!==void 0&&(u[p]=h[p])}):t._.each(f,(p,m)=>{const g=p(h[m],d);g!==void 0&&(u[m]=g)}),u}e.FILTERS={$sort:u=>o(u),$limit:(u,h)=>s(i(u),h.paginate),$skip:u=>i(u),$select:u=>u},e.OPERATORS=["$in","$nin","$lt","$lte","$gt","$gte","$ne","$or"];function c(u,h={}){const{filters:f={},operators:d=[]}=h,p={};return p.filters=l({},u,e.FILTERS,h),p.filters=l(p.filters,u,f,h),p.query=a(u,e.OPERATORS.concat(d),p.filters),p}e.default=c,n.exports=Object.assign(c,n.exports)})(vO,vO.exports);var ete=vO.exports,sYe=gt&&gt.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(t$,"__esModule",{value:!0});t$.AdapterService=void 0;const S1=bC,oYe=sYe(ete),$0=(n,e,...t)=>typeof n[e]!="function"?Promise.reject(new S1.NotImplemented(`Method ${e} not available`)):n[e](...t),aYe={find:!0,get:!1,update:!1};let lYe=class{constructor(e){this.options=Object.assign({id:"id",events:[],paginate:{},multi:!1,filters:[],whitelist:[]},e)}get id(){return this.options.id}get events(){return this.options.events}filterQuery(e={},t={}){const r=typeof e.paginate<"u"?e.paginate:this.options.paginate,{query:i={}}=e,s=Object.assign({operators:this.options.whitelist||[],filters:this.options.filters,paginate:r},t),o=(0,oYe.default)(i,s);return Object.assign(o,{paginate:r})}allowsMulti(e){const t=aYe[e];if(typeof t<"u")return t;const r=this.options.multi;return r===!0||r===!1?r:r.includes(e)}find(e){return $0(this,"_find",e)}get(e,t){return $0(this,"_get",e,t)}create(e,t){return Array.isArray(e)&&!this.allowsMulti("create")?Promise.reject(new S1.MethodNotAllowed("Can not create multiple entries")):$0(this,"_create",e,t)}update(e,t,r){return e===null||Array.isArray(t)?Promise.reject(new S1.BadRequest("You can not replace multiple instances. Did you mean 'patch'?")):$0(this,"_update",e,t,r)}patch(e,t,r){return e===null&&!this.allowsMulti("patch")?Promise.reject(new S1.MethodNotAllowed("Can not patch multiple entries")):$0(this,"_patch",e,t,r)}remove(e,t){return e===null&&!this.allowsMulti("remove")?Promise.reject(new S1.MethodNotAllowed("Can not remove multiple entries")):$0(this,"_remove",e,t)}};t$.AdapterService=lYe;var tte={};(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.sorter=n.compare=n.compareArrays=n.compareNSB=void 0;function e(s,o){return s<o?-1:s>o?1:0}n.compareNSB=e;function t(s,o){let a,l;for(a=0;a<Math.min(s.length,o.length);a+=1)if(l=n.compare(s[a],o[a]),l!==0)return l;return n.compareNSB(s.length,o.length)}n.compareArrays=t;function r(s,o,a=n.compareNSB){const{compareNSB:l,compare:c,compareArrays:u}=n;if(s===void 0)return o===void 0?0:-1;if(o===void 0)return s===void 0?0:1;if(s===null)return o===null?0:-1;if(o===null)return s===null?0:1;if(typeof s=="number")return typeof o=="number"?l(s,o):-1;if(typeof o=="number")return typeof s=="number"?l(s,o):1;if(typeof s=="string")return typeof o=="string"?a(s,o):-1;if(typeof o=="string")return typeof s=="string"?a(s,o):1;if(typeof s=="boolean")return typeof o=="boolean"?l(s,o):-1;if(typeof o=="boolean")return typeof s=="boolean"?l(s,o):1;if(s instanceof Date)return o instanceof Date?l(s.getTime(),o.getTime()):-1;if(o instanceof Date)return s instanceof Date?l(s.getTime(),o.getTime()):1;if(Array.isArray(s))return Array.isArray(o)?u(s,o):-1;if(Array.isArray(o))return Array.isArray(s)?u(s,o):1;const h=Object.keys(s).sort(),f=Object.keys(o).sort();let d=0;for(let p=0;p<Math.min(h.length,f.length);p+=1)if(d=c(s[h[p]],o[f[p]]),d!==0)return d;return l(h.length,f.length)}n.compare=r;function i(s){const o=Object.keys(s).map(a=>{const l=s[a];return{key:a,direction:l}});return function(a,l){let c;for(const u of o)if(c=u.direction*n.compare(a[u.key],l[u.key]),c!==0)return c;return 0}}n.sorter=i})(tte);(function(n){var e=gt&&gt.__createBinding||(Object.create?function(l,c,u,h){h===void 0&&(h=u);var f=Object.getOwnPropertyDescriptor(c,u);(!f||("get"in f?!c.__esModule:f.writable||f.configurable))&&(f={enumerable:!0,get:function(){return c[u]}}),Object.defineProperty(l,h,f)}:function(l,c,u,h){h===void 0&&(h=u),l[h]=c[u]}),t=gt&&gt.__exportStar||function(l,c){for(var u in l)u!=="default"&&!Object.prototype.hasOwnProperty.call(c,u)&&e(c,l,u)},r=gt&&gt.__importDefault||function(l){return l&&l.__esModule?l:{default:l}};Object.defineProperty(n,"__esModule",{value:!0}),n.select=n.OPERATORS=n.FILTERS=n.filterQuery=n.AdapterService=void 0;const i=Np;var s=t$;Object.defineProperty(n,"AdapterService",{enumerable:!0,get:function(){return s.AdapterService}});var o=ete;Object.defineProperty(n,"filterQuery",{enumerable:!0,get:function(){return r(o).default}}),Object.defineProperty(n,"FILTERS",{enumerable:!0,get:function(){return o.FILTERS}}),Object.defineProperty(n,"OPERATORS",{enumerable:!0,get:function(){return o.OPERATORS}}),t(tte,n);function a(l,...c){const u=l&&l.query&&l.query.$select;Array.isArray(u)&&c.length&&u.push(...c);const h=f=>Array.isArray(u)?i._.pick(f,...u):f;return f=>Array.isArray(f)?f.map(h):h(f)}n.select=a})(Qee);function zB(n){var e="[object "+n+"]";return function(t){return Object.prototype.toString.call(t)===e}}var sp=zB("Array"),nte=zB("Object"),cYe=zB("Function");function wc(n,e){return cYe(n.get)?n.get(e):n[e]}const uYe=n=>(e,t,r,i,s)=>s?!!s.find(([o,a,l])=>n(e,a,l)):n(e,t,r,i),ac=uYe(n=>function(e,t,r,i,s){if(!sp(t)||!t.length)return n(e,t);for(var o=0,a=t.length;o<a;o++)if(n(e,wc(t,o)))return!0;return!1});function rte(n){return function(e,t,r,i){if(!sp(t)||!t.length)return n(e,t,r,i);for(var s=0,o=t.length;s<o;s++)if(!n(e,wc(t,s),t,i))return!1;return!0}}function pu(n,e,t,r,i){return n.validate(n.options,e,t,r,i)}var WI={$eq:ac(function(n,e){return n(e)}),$ne:rte(function(n,e){return n(e)}),$gt:ac(function(n,e){return n(e)}),$gte:ac(function(n,e){return n(e)}),$lt:ac(function(n,e){return n(e)}),$lte:ac(function(n,e){return n(e)}),$mod:ac(function(n,e){return n(e)}),$in(n,e){return n(e)},$nin:function(n,e){return n(e)},$not:function(n,e,t,r){return n(e,t,r)},$type:function(n,e){return n(e)},$all:function(n,e,t,r,i){return WI.$and(n,e,t,r,i)},$size:function(n,e){return e?n===e.length:!1},$or:function(n,e,t,r){for(var i=0,s=n.length;i<s;i++)if(pu(wc(n,i),e,t,r))return!0;return!1},$nor:function(n,e,t,r){return!WI.$or(n,e,t,r)},$and:function(n,e,t,r,i){if(i){for(var s=0,o=n.length;s<o;s++)if(!pu(wc(n,s),e,t,r,i))return!1}else for(var s=0,o=n.length;s<o;s++)if(!pu(wc(n,s),e,t,r,i))return!1;return!0},$regex:ac(function(n,e){return typeof e=="string"&&n.test(e)}),$where:function(n,e,t,r){return n.call(e,e,t,r)},$elemMatch:function(n,e,t,r){return sp(e)?!!~hYe(e,n):pu(n,e,t,r)},$exists:function(n,e,t,r){return r.hasOwnProperty(t)===n}},K1={$eq:function(n,e,{comparable:t,compare:r}){return n instanceof RegExp?ac(function(i){return typeof i=="string"&&n.test(i)}):n instanceof Function?ac(n):sp(n)&&!n.length?ac(function(i){return sp(i)&&!i.length}):ac(n===null?function(i){return i==null}:function(i){return r(t(i),t(n))===0})},$gt:function(n,e,{comparable:t,compare:r}){return function(i){return r(t(i),t(n))>0}},$gte:function(n,e,{comparable:t,compare:r}){return function(i){return r(t(i),t(n))>=0}},$lt:function(n,e,{comparable:t,compare:r}){return function(i){return r(t(i),t(n))<0}},$lte:function(n,e,{comparable:t,compare:r}){return function(i){return r(t(i),t(n))<=0}},$in:function(n,e,t){const{comparable:r}=t;return function(i){if(i instanceof Array){for(var s=i.length;s--;)if(~n.indexOf(r(wc(i,s))))return!0}else{var o=r(i);if(o===i&&typeof i=="object"){for(var s=n.length;s--;)if(String(n[s])===String(i)&&String(i)!=="[object Object]")return!0}if(typeof o>"u"){for(var s=n.length;s--;)if(n[s]==null)return!0}for(var s=n.length;s--;){var a=ste(wc(n,s),t),l=pu(a,o,s,n);if(l&&String(l)!=="[object Object]"&&String(o)!=="[object Object]")return!0}return!!~n.indexOf(o)}return!1}},$nin:function(n,e,t){const r=K1.$in(n,e,t);return function(i,s,o,a){return!r(i,s,o,a)}},$mod:function(n){return function(e){return e%n[0]==n[1]}},$ne:function(n,e,t){const r=K1.$eq(n,e,t);return rte(function(i,s,o,a){return!r(i,s,o,a)})},$and:function(n,e,t){return n.map(fb(t))},$all:function(n,e,t){return K1.$and(n,e,t)},$or:function(n,e,t){return n.map(fb(t))},$nor:function(n,e,t){return n.map(fb(t))},$not:function(n,e,t){const r=fb(t)(n);return function(i,s,o){return!pu(r,i,s,o)}},$type:function(n){return function(e,t,r){return e!=null?e instanceof n||e.constructor==n:!1}},$regex:function(n,e){return new RegExp(n,e.$options)},$where:function(n){return typeof n=="string"?new Function("obj","return "+n):n},$elemMatch:function(n,e,t){return fb(t)(n)},$exists:function(n){return!!n}};function hYe(n,e){for(var t=0;t<n.length;t++)if(wc(n,t),pu(e,wc(n,t)))return t;return-1}function LE(n,e){return{options:n,validate:e}}function fYe({keyPath:n,child:e,query:t},r){const i=[];if(wO(r,n,0,r,i),i.length===1){const[s,o,a]=i[0];return pu(e,s,o,a)}return t&&typeof t.$ne<"u",i.map(([s])=>s),pu(e,void 0,void 0,void 0,i)}function wO(n,e,t,r,i){if(t===e.length||n==null){i.push([n,e[t-1],r]);return}var s=wc(e,t);if(sp(n)&&isNaN(Number(s)))for(var o=0,a=n.length;o<a;o++)wO(wc(n,o),e,t,n,i);else wO(wc(n,s),e,t+1,n,i)}function dYe(n,e,t){return LE({keyPath:n,child:e,query:t},fYe)}function pYe(n){return n&&(n.constructor===Object||n.constructor===Array||n.constructor.toString()==="function Object() { [native code] }"||n.constructor.toString()==="function Array() { [native code] }")}function fb(n){const{comparable:e,expressions:t}=n;var r=function(a){return(!a||!pYe(a))&&(a={$eq:a}),a},i=function(a){a=e(a);var l=[];for(var c in a){var u=a[c];if(c!=="$options"){var h=WI[c]||n&&t&&t[c];if(h)K1[c]&&(u=K1[c](u,a,n)),l.push(LE(e(u),h));else{if(c.charCodeAt(0)===36)throw new Error("Unknown operation "+c);var f=c.split(".");l.push(dYe(f,s(u),u))}}}return l.length===1?l[0]:LE(l,WI.$and)},s=function(a){return a=r(a),mYe(a)?LE(a,HI):i(a)},o=function(a){return i(r(a))};return o}function HI(n,e){if(Object.prototype.toString.call(n)!==Object.prototype.toString.call(e))return!1;if(nte(n)){if(Object.keys(n).length!==Object.keys(e).length)return!1;for(var t in n)if(!HI(n[t],e[t]))return!1;return!0}else if(sp(n)){if(n.length!==e.length)return!1;for(var r=0,i=n.length;r<i;r++)if(!HI(n[r],e[r]))return!1;return!0}else return n===e}function ite(n,e){if(!nte(n))return e;for(var t in n)e.push(t),ite(n[t],e);return e}function mYe(n){return ite(n,[]).join(",").search(/[$.]/)===-1}function ste(n,e){var t=fb(e)(n);return e&&e.select&&(t={options:t,validate:function(r,i,s,o){return pu(r,i&&e.select(i),s,o)}}),t}function gYe(n,e){e=Object.assign({compare:ote,comparable:BB},e);var t=ste(n,e);return function(r,i,s){return pu(t,r,i,s)}}function ote(n,e){if(HI(n,e))return 0;if(typeof n==typeof e){if(n>e)return 1;if(n<e)return-1}}function BB(n){return n instanceof Date?n.getTime():sp(n)?n.map(BB):n&&typeof n.toJSON=="function"?n.toJSON():n}const yYe=Object.freeze(Object.defineProperty({__proto__:null,comparable:BB,compare:ote,default:gYe},Symbol.toStringTag,{value:"Module"})),bYe=My(yYe),vYe=bC,{_:R0}=Np,{sorter:wYe,select:xYe,AdapterService:_Ye}=Qee,SYe=bYe.default,rT=(n,...e)=>xYe(...e)(JSON.parse(JSON.stringify(n)));let ate=class extends _Ye{constructor(e={}){super(R0.extend({id:"id",matcher:SYe,sorter:wYe},e)),this._uId=e.startId||0,this.store=e.store||{}}async getEntries(e={}){const{query:t}=this.filterQuery(e);return this._find(Object.assign({},e,{paginate:!1,query:t}))}async _find(e={}){const{query:t,filters:r,paginate:i}=this.filterQuery(e);let s=R0.values(this.store).filter(this.options.matcher(t));const o=s.length;r.$sort!==void 0&&s.sort(this.options.sorter(r.$sort)),r.$skip!==void 0&&(s=s.slice(r.$skip)),r.$limit!==void 0&&(s=s.slice(0,r.$limit));const a={total:o,limit:r.$limit,skip:r.$skip||0,data:s.map(l=>rT(l,e))};return i&&i.default?a:a.data}async _get(e,t={}){if(e in this.store){const{query:r}=this.filterQuery(t),i=this.store[e];if(this.options.matcher(r)(i))return rT(i,t,this.id)}throw new vYe.NotFound(`No record found for id '${e}'`)}async _create(e,t={}){if(Array.isArray(e))return Promise.all(e.map(o=>this._create(o,t)));const r=e[this.id]||this._uId++,i=R0.extend({},e,{[this.id]:r}),s=this.store[r]=i;return rT(s,t,this.id)}async _update(e,t,r={}){const s=(await this._get(e))[this.id];return e=s==e?s:e,this.store[e]=R0.extend({},t,{[this.id]:e}),this._get(e,r)}async _patch(e,t,r={}){const i=s=>{const o=s[this.id];return this.store[o]=R0.extend(this.store[o],R0.omit(t,this.id)),rT(this.store[o],r,this.id)};return e===null?(await this.getEntries(r)).map(i):i(await this._get(e,r))}async _remove(e,t={}){if(e===null){const i=await this.getEntries(t);return Promise.all(i.map(s=>this._remove(s[this.id],t)))}const r=await this._get(e,t);return delete this.store[e],r}};LB.exports=n=>new ate(n);LB.exports.Service=ate;var lte=LB.exports;const CYe=Ay(lte);var VB={exports:{}};const{Service:kYe}=lte,MG=[];class cte extends kYe{constructor(e={}){if(super(e),this._storageKey=e.name||"feathers",this._storage=e.storage||typeof window<"u"&&window.localStorage,this._throttle=e.throttle||200,this._reuseKeys=e.reuseKeys||!1,this.store=null,!this._storage)throw new Error("The `storage` option needs to be provided");if(MG.indexOf(this._storageKey)===-1)MG.push(this._storageKey);else if(!this._reuseKeys)throw new Error(`The storage name '${this._storageKey}' is already in use by another instance.`);this.ready()}ready(){return this.store?Promise.resolve(this.store):Promise.resolve(this._storage.getItem(this._storageKey)).then(e=>JSON.parse(e||"{}")).then(e=>{const t=Object.keys(e),r=e[t[t.length-1]];return this._uId=t.length&&typeof r[this.id]<"u"?r[this.id]+1:this._uId,this.store=e})}flush(e){return this._timeout||(this._timeout=setTimeout(()=>{this._storage.setItem(this._storageKey,JSON.stringify(this.store)),delete this._timeout},this._throttle)),e}execute(e,...t){return this.ready().then(()=>super[e](...t))}find(...e){return this.execute("find",...e)}get(...e){return this.execute("get",...e)}create(...e){return this.execute("create",...e).then(t=>this.flush(t))}patch(...e){return this.execute("patch",...e).then(t=>this.flush(t))}update(...e){return this.execute("update",...e).then(t=>this.flush(t))}remove(...e){return this.execute("remove",...e).then(t=>this.flush(t))}}VB.exports=function(e){return new cte(e)};VB.exports.Service=cte;var TYe=VB.exports;const EYe=Ay(TYe);var GI={exports:{}};/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */GI.exports;(function(n,e){(function(){var t,r="4.17.21",i=200,s="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",o="Expected a function",a="Invalid `variable` option passed into `_.template`",l="__lodash_hash_undefined__",c=500,u="__lodash_placeholder__",h=1,f=2,d=4,p=1,m=2,g=1,y=2,b=4,_=8,w=16,S=32,C=64,k=128,A=256,M=512,E=30,N="...",O=800,R=16,D=1,z=2,B=3,X=1/0,H=9007199254740991,te=17976931348623157e292,ge=0/0,ae=4294967295,Ne=ae-1,Te=ae>>>1,De=[["ary",k],["bind",g],["bindKey",y],["curry",_],["curryRight",w],["flip",M],["partial",S],["partialRight",C],["rearg",A]],be="[object Arguments]",Ke="[object Array]",Oe="[object AsyncFunction]",ot="[object Boolean]",He="[object Date]",mt="[object DOMException]",ht="[object Error]",Ue="[object Function]",Be="[object GeneratorFunction]",Ve="[object Map]",ft="[object Number]",Ye="[object Null]",ee="[object Object]",J="[object Promise]",it="[object Proxy]",Ge="[object RegExp]",ye="[object Set]",Je="[object String]",bt="[object Symbol]",It="[object Undefined]",pt="[object WeakMap]",ce="[object WeakSet]",rt="[object ArrayBuffer]",Et="[object DataView]",yt="[object Float32Array]",Ht="[object Float64Array]",Mn="[object Int8Array]",Cr="[object Int16Array]",Bi="[object Int32Array]",Ai="[object Uint8Array]",Mi="[object Uint8ClampedArray]",zh="[object Uint16Array]",Ul="[object Uint32Array]",Wl=/\b__p \+= '';/g,mo=/\b(__p \+=) '' \+/g,Hl=/(__e\(.*?\)|\b__t\)) \+\n'';/g,Bc=/&(?:amp|lt|gt|quot|#39);/g,Vc=/[&<>"']/g,Ps=RegExp(Bc.source),Bh=RegExp(Vc.source),rl=/<%-([\s\S]+?)%>/g,Vh=/<%([\s\S]+?)%>/g,re=/<%=([\s\S]+?)%>/g,We=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Fe=/^\w*$/,Qe=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,wt=/[\\^$.*+?()[\]{}|]/g,Bn=RegExp(wt.source),sn=/^\s+/,Tn=/\s/,En=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,Nn=/\{\n\/\* \[wrapped with (.+)\] \*/,tr=/,? & /,_n=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,hr=/[()=,{}\[\]\/\s]/,Ds=/\\(\\)?/g,xr=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Zs=/\w*$/,Ar=/^[-+]0x[0-9a-f]+$/i,Mo=/^0b[01]+$/i,ri=/^\[object .+?Constructor\]$/,go=/^0o[0-7]+$/i,No=/^(?:0|[1-9]\d*)$/,Ni=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,yo=/($^)/,Uh=/['\n\r\u2028\u2029\\]/g,il="\\ud800-\\udfff",Js="\\u0300-\\u036f",Uc="\\ufe20-\\ufe2f",Aa="\\u20d0-\\u20ff",$i=Js+Uc+Aa,Wc="\\u2700-\\u27bf",Qs="a-z\\xdf-\\xf6\\xf8-\\xff",Vi="\\xac\\xb1\\xd7\\xf7",Wh="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",s0="\\u2000-\\u206f",Hh=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",eo="A-Z\\xc0-\\xd6\\xd8-\\xde",Gh="\\ufe0e\\ufe0f",Kf=Vi+Wh+s0+Hh,ju="['’]",Yf="["+il+"]",jh="["+Kf+"]",Gl="["+$i+"]",Zr="\\d+",o0="["+Wc+"]",Zf="["+Qs+"]",Hc="[^"+il+Kf+Zr+Wc+Qs+eo+"]",qh="\\ud83c[\\udffb-\\udfff]",a0="(?:"+Gl+"|"+qh+")",l0="[^"+il+"]",G="(?:\\ud83c[\\udde6-\\uddff]){2}",Y="[\\ud800-\\udbff][\\udc00-\\udfff]",de="["+eo+"]",Re="\\u200d",lt="(?:"+Zf+"|"+Hc+")",Vt="(?:"+de+"|"+Hc+")",$n="(?:"+ju+"(?:d|ll|m|re|s|t|ve))?",Ri="(?:"+ju+"(?:D|LL|M|RE|S|T|VE))?",Ui=a0+"?",ds="["+Gh+"]?",Ma="(?:"+Re+"(?:"+[l0,G,Y].join("|")+")"+ds+Ui+")*",px="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",Vp="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",YC=ds+Ui+Ma,j$="(?:"+[o0,G,Y].join("|")+")"+YC,q$="(?:"+[l0+Gl+"?",Gl,G,Y,Yf].join("|")+")",X$=RegExp(ju,"g"),mx=RegExp(Gl,"g"),c0=RegExp(qh+"(?="+qh+")|"+q$+YC,"g"),ZC=RegExp([de+"?"+Zf+"+"+$n+"(?="+[jh,de,"$"].join("|")+")",Vt+"+"+Ri+"(?="+[jh,de+lt,"$"].join("|")+")",de+"?"+lt+"+"+$n,de+"+"+Ri,Vp,px,Zr,j$].join("|"),"g"),Up=RegExp("["+Re+il+$i+Gh+"]"),sl=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,K$=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],Y$=-1,Br={};Br[yt]=Br[Ht]=Br[Mn]=Br[Cr]=Br[Bi]=Br[Ai]=Br[Mi]=Br[zh]=Br[Ul]=!0,Br[be]=Br[Ke]=Br[rt]=Br[ot]=Br[Et]=Br[He]=Br[ht]=Br[Ue]=Br[Ve]=Br[ft]=Br[ee]=Br[Ge]=Br[ye]=Br[Je]=Br[pt]=!1;var Rr={};Rr[be]=Rr[Ke]=Rr[rt]=Rr[Et]=Rr[ot]=Rr[He]=Rr[yt]=Rr[Ht]=Rr[Mn]=Rr[Cr]=Rr[Bi]=Rr[Ve]=Rr[ft]=Rr[ee]=Rr[Ge]=Rr[ye]=Rr[Je]=Rr[bt]=Rr[Ai]=Rr[Mi]=Rr[zh]=Rr[Ul]=!0,Rr[ht]=Rr[Ue]=Rr[pt]=!1;var gx={À:"A",Á:"A",Â:"A",Ã:"A",Ä:"A",Å:"A",à:"a",á:"a",â:"a",ã:"a",ä:"a",å:"a",Ç:"C",ç:"c",Ð:"D",ð:"d",È:"E",É:"E",Ê:"E",Ë:"E",è:"e",é:"e",ê:"e",ë:"e",Ì:"I",Í:"I",Î:"I",Ï:"I",ì:"i",í:"i",î:"i",ï:"i",Ñ:"N",ñ:"n",Ò:"O",Ó:"O",Ô:"O",Õ:"O",Ö:"O",Ø:"O",ò:"o",ó:"o",ô:"o",õ:"o",ö:"o",ø:"o",Ù:"U",Ú:"U",Û:"U",Ü:"U",ù:"u",ú:"u",û:"u",ü:"u",Ý:"Y",ý:"y",ÿ:"y",Æ:"Ae",æ:"ae",Þ:"Th",þ:"th",ß:"ss",Ā:"A",Ă:"A",Ą:"A",ā:"a",ă:"a",ą:"a",Ć:"C",Ĉ:"C",Ċ:"C",Č:"C",ć:"c",ĉ:"c",ċ:"c",č:"c",Ď:"D",Đ:"D",ď:"d",đ:"d",Ē:"E",Ĕ:"E",Ė:"E",Ę:"E",Ě:"E",ē:"e",ĕ:"e",ė:"e",ę:"e",ě:"e",Ĝ:"G",Ğ:"G",Ġ:"G",Ģ:"G",ĝ:"g",ğ:"g",ġ:"g",ģ:"g",Ĥ:"H",Ħ:"H",ĥ:"h",ħ:"h",Ĩ:"I",Ī:"I",Ĭ:"I",Į:"I",İ:"I",ĩ:"i",ī:"i",ĭ:"i",į:"i",ı:"i",Ĵ:"J",ĵ:"j",Ķ:"K",ķ:"k",ĸ:"k",Ĺ:"L",Ļ:"L",Ľ:"L",Ŀ:"L",Ł:"L",ĺ:"l",ļ:"l",ľ:"l",ŀ:"l",ł:"l",Ń:"N",Ņ:"N",Ň:"N",Ŋ:"N",ń:"n",ņ:"n",ň:"n",ŋ:"n",Ō:"O",Ŏ:"O",Ő:"O",ō:"o",ŏ:"o",ő:"o",Ŕ:"R",Ŗ:"R",Ř:"R",ŕ:"r",ŗ:"r",ř:"r",Ś:"S",Ŝ:"S",Ş:"S",Š:"S",ś:"s",ŝ:"s",ş:"s",š:"s",Ţ:"T",Ť:"T",Ŧ:"T",ţ:"t",ť:"t",ŧ:"t",Ũ:"U",Ū:"U",Ŭ:"U",Ů:"U",Ű:"U",Ų:"U",ũ:"u",ū:"u",ŭ:"u",ů:"u",ű:"u",ų:"u",Ŵ:"W",ŵ:"w",Ŷ:"Y",ŷ:"y",Ÿ:"Y",Ź:"Z",Ż:"Z",Ž:"Z",ź:"z",ż:"z",ž:"z",Ĳ:"IJ",ĳ:"ij",Œ:"Oe",œ:"oe",ŉ:"'n",ſ:"s"},yx={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},Jf={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},JC={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},bx=parseFloat,Z$=parseInt,QC=typeof gt=="object"&&gt&&gt.Object===Object&&gt,Wp=typeof self=="object"&&self&&self.Object===Object&&self,ps=QC||Wp||Function("return this")(),u0=e&&!e.nodeType&&e,Xh=u0&&!0&&n&&!n.nodeType&&n,ek=Xh&&Xh.exports===u0,Qf=ek&&QC.process,oa=function(){try{var Ae=Xh&&Xh.require&&Xh.require("util").types;return Ae||Qf&&Qf.binding&&Qf.binding("util")}catch{}}(),tk=oa&&oa.isArrayBuffer,vx=oa&&oa.isDate,nk=oa&&oa.isMap,rk=oa&&oa.isRegExp,h0=oa&&oa.isSet,f0=oa&&oa.isTypedArray;function $o(Ae,je,Le){switch(Le.length){case 0:return Ae.call(je);case 1:return Ae.call(je,Le[0]);case 2:return Ae.call(je,Le[0],Le[1]);case 3:return Ae.call(je,Le[0],Le[1],Le[2])}return Ae.apply(je,Le)}function J$(Ae,je,Le,jt){for(var Dn=-1,Er=Ae==null?0:Ae.length;++Dn<Er;){var Fs=Ae[Dn];je(jt,Fs,Le(Fs),Ae)}return jt}function Na(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length;++Le<jt&&je(Ae[Le],Le,Ae)!==!1;);return Ae}function Q$(Ae,je){for(var Le=Ae==null?0:Ae.length;Le--&&je(Ae[Le],Le,Ae)!==!1;);return Ae}function ik(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length;++Le<jt;)if(!je(Ae[Le],Le,Ae))return!1;return!0}function Gc(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length,Dn=0,Er=[];++Le<jt;){var Fs=Ae[Le];je(Fs,Le,Ae)&&(Er[Dn++]=Fs)}return Er}function d0(Ae,je){var Le=Ae==null?0:Ae.length;return!!Le&&T(Ae,je,0)>-1}function wx(Ae,je,Le){for(var jt=-1,Dn=Ae==null?0:Ae.length;++jt<Dn;)if(Le(je,Ae[jt]))return!0;return!1}function Vr(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length,Dn=Array(jt);++Le<jt;)Dn[Le]=je(Ae[Le],Le,Ae);return Dn}function qu(Ae,je){for(var Le=-1,jt=je.length,Dn=Ae.length;++Le<jt;)Ae[Dn+Le]=je[Le];return Ae}function xx(Ae,je,Le,jt){var Dn=-1,Er=Ae==null?0:Ae.length;for(jt&&Er&&(Le=Ae[++Dn]);++Dn<Er;)Le=je(Le,Ae[Dn],Dn,Ae);return Le}function eR(Ae,je,Le,jt){var Dn=Ae==null?0:Ae.length;for(jt&&Dn&&(Le=Ae[--Dn]);Dn--;)Le=je(Le,Ae[Dn],Dn,Ae);return Le}function ed(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length;++Le<jt;)if(je(Ae[Le],Le,Ae))return!0;return!1}var tR=ne("length");function nR(Ae){return Ae.split("")}function rR(Ae){return Ae.match(_n)||[]}function _x(Ae,je,Le){var jt;return Le(Ae,function(Dn,Er,Fs){if(je(Dn,Er,Fs))return jt=Er,!1}),jt}function Hp(Ae,je,Le,jt){for(var Dn=Ae.length,Er=Le+(jt?1:-1);jt?Er--:++Er<Dn;)if(je(Ae[Er],Er,Ae))return Er;return-1}function T(Ae,je,Le){return je===je?Jce(Ae,je,Le):Hp(Ae,L,Le)}function $(Ae,je,Le,jt){for(var Dn=Le-1,Er=Ae.length;++Dn<Er;)if(jt(Ae[Dn],je))return Dn;return-1}function L(Ae){return Ae!==Ae}function W(Ae,je){var Le=Ae==null?0:Ae.length;return Le?Pe(Ae,je)/Le:ge}function ne(Ae){return function(je){return je==null?t:je[Ae]}}function oe(Ae){return function(je){return Ae==null?t:Ae[je]}}function se(Ae,je,Le,jt,Dn){return Dn(Ae,function(Er,Fs,Jr){Le=jt?(jt=!1,Er):je(Le,Er,Fs,Jr)}),Le}function Ce(Ae,je){var Le=Ae.length;for(Ae.sort(je);Le--;)Ae[Le]=Ae[Le].value;return Ae}function Pe(Ae,je){for(var Le,jt=-1,Dn=Ae.length;++jt<Dn;){var Er=je(Ae[jt]);Er!==t&&(Le=Le===t?Er:Le+Er)}return Le}function dt(Ae,je){for(var Le=-1,jt=Array(Ae);++Le<Ae;)jt[Le]=je(Le);return jt}function At(Ae,je){return Vr(je,function(Le){return[Le,Ae[Le]]})}function fn(Ae){return Ae&&Ae.slice(0,XV(Ae)+1).replace(sn,"")}function Ut(Ae){return function(je){return Ae(je)}}function Rt(Ae,je){return Vr(je,function(Le){return Ae[Le]})}function an(Ae,je){return Ae.has(je)}function Vn(Ae,je){for(var Le=-1,jt=Ae.length;++Le<jt&&T(je,Ae[Le],0)>-1;);return Le}function Ur(Ae,je){for(var Le=Ae.length;Le--&&T(je,Ae[Le],0)>-1;);return Le}function Wr(Ae,je){for(var Le=Ae.length,jt=0;Le--;)Ae[Le]===je&&++jt;return jt}var Os=oe(gx),$a=oe(yx);function Ro(Ae){return"\\"+JC[Ae]}function yr(Ae,je){return Ae==null?t:Ae[je]}function xi(Ae){return Up.test(Ae)}function Xu(Ae){return sl.test(Ae)}function iR(Ae){for(var je,Le=[];!(je=Ae.next()).done;)Le.push(je.value);return Le}function Sx(Ae){var je=-1,Le=Array(Ae.size);return Ae.forEach(function(jt,Dn){Le[++je]=[Dn,jt]}),Le}function sk(Ae,je){return function(Le){return Ae(je(Le))}}function Ku(Ae,je){for(var Le=-1,jt=Ae.length,Dn=0,Er=[];++Le<jt;){var Fs=Ae[Le];(Fs===je||Fs===u)&&(Ae[Le]=u,Er[Dn++]=Le)}return Er}function p0(Ae){var je=-1,Le=Array(Ae.size);return Ae.forEach(function(jt){Le[++je]=jt}),Le}function m0(Ae){var je=-1,Le=Array(Ae.size);return Ae.forEach(function(jt){Le[++je]=[jt,jt]}),Le}function Jce(Ae,je,Le){for(var jt=Le-1,Dn=Ae.length;++jt<Dn;)if(Ae[jt]===je)return jt;return-1}function Qce(Ae,je,Le){for(var jt=Le+1;jt--;)if(Ae[jt]===je)return jt;return jt}function g0(Ae){return xi(Ae)?tue(Ae):tR(Ae)}function jc(Ae){return xi(Ae)?nue(Ae):nR(Ae)}function XV(Ae){for(var je=Ae.length;je--&&Tn.test(Ae.charAt(je)););return je}var eue=oe(Jf);function tue(Ae){for(var je=c0.lastIndex=0;c0.test(Ae);)++je;return je}function nue(Ae){return Ae.match(c0)||[]}function rue(Ae){return Ae.match(ZC)||[]}var iue=function Ae(je){je=je==null?ps:y0.defaults(ps.Object(),je,y0.pick(ps,K$));var Le=je.Array,jt=je.Date,Dn=je.Error,Er=je.Function,Fs=je.Math,Jr=je.Object,sR=je.RegExp,sue=je.String,jl=je.TypeError,ok=Le.prototype,oue=Er.prototype,b0=Jr.prototype,ak=je["__core-js_shared__"],lk=oue.toString,Pr=b0.hasOwnProperty,aue=0,KV=function(){var v=/[^.]+$/.exec(ak&&ak.keys&&ak.keys.IE_PROTO||"");return v?"Symbol(src)_1."+v:""}(),ck=b0.toString,lue=lk.call(Jr),cue=ps._,uue=sR("^"+lk.call(Pr).replace(wt,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),uk=ek?je.Buffer:t,td=je.Symbol,hk=je.Uint8Array,YV=uk?uk.allocUnsafe:t,fk=sk(Jr.getPrototypeOf,Jr),ZV=Jr.create,JV=b0.propertyIsEnumerable,dk=ok.splice,QV=td?td.isConcatSpreadable:t,Cx=td?td.iterator:t,Gp=td?td.toStringTag:t,pk=function(){try{var v=Yp(Jr,"defineProperty");return v({},"",{}),v}catch{}}(),hue=je.clearTimeout!==ps.clearTimeout&&je.clearTimeout,fue=jt&&jt.now!==ps.Date.now&&jt.now,due=je.setTimeout!==ps.setTimeout&&je.setTimeout,mk=Fs.ceil,gk=Fs.floor,oR=Jr.getOwnPropertySymbols,pue=uk?uk.isBuffer:t,eU=je.isFinite,mue=ok.join,gue=sk(Jr.keys,Jr),Ls=Fs.max,Po=Fs.min,yue=jt.now,bue=je.parseInt,tU=Fs.random,vue=ok.reverse,aR=Yp(je,"DataView"),kx=Yp(je,"Map"),lR=Yp(je,"Promise"),v0=Yp(je,"Set"),Tx=Yp(je,"WeakMap"),Ex=Yp(Jr,"create"),yk=Tx&&new Tx,w0={},wue=Zp(aR),xue=Zp(kx),_ue=Zp(lR),Sue=Zp(v0),Cue=Zp(Tx),bk=td?td.prototype:t,Ix=bk?bk.valueOf:t,nU=bk?bk.toString:t;function q(v){if(Wi(v)&&!Fn(v)&&!(v instanceof ar)){if(v instanceof ql)return v;if(Pr.call(v,"__wrapped__"))return rW(v)}return new ql(v)}var x0=function(){function v(){}return function(x){if(!Pi(x))return{};if(ZV)return ZV(x);v.prototype=x;var I=new v;return v.prototype=t,I}}();function vk(){}function ql(v,x){this.__wrapped__=v,this.__actions__=[],this.__chain__=!!x,this.__index__=0,this.__values__=t}q.templateSettings={escape:rl,evaluate:Vh,interpolate:re,variable:"",imports:{_:q}},q.prototype=vk.prototype,q.prototype.constructor=q,ql.prototype=x0(vk.prototype),ql.prototype.constructor=ql;function ar(v){this.__wrapped__=v,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=ae,this.__views__=[]}function kue(){var v=new ar(this.__wrapped__);return v.__actions__=Ra(this.__actions__),v.__dir__=this.__dir__,v.__filtered__=this.__filtered__,v.__iteratees__=Ra(this.__iteratees__),v.__takeCount__=this.__takeCount__,v.__views__=Ra(this.__views__),v}function Tue(){if(this.__filtered__){var v=new ar(this);v.__dir__=-1,v.__filtered__=!0}else v=this.clone(),v.__dir__*=-1;return v}function Eue(){var v=this.__wrapped__.value(),x=this.__dir__,I=Fn(v),P=x<0,V=I?v.length:0,K=zhe(0,V,this.__views__),le=K.start,xe=K.end,Me=xe-le,et=P?xe:le-1,nt=this.__iteratees__,ut=nt.length,Ft=0,tn=Po(Me,this.__takeCount__);if(!I||!P&&V==Me&&tn==Me)return TU(v,this.__actions__);var yn=[];e:for(;Me--&&Ft<tn;){et+=x;for(var qn=-1,bn=v[et];++qn<ut;){var nr=nt[qn],fr=nr.iteratee,ll=nr.type,ca=fr(bn);if(ll==z)bn=ca;else if(!ca){if(ll==D)continue e;break e}}yn[Ft++]=bn}return yn}ar.prototype=x0(vk.prototype),ar.prototype.constructor=ar;function jp(v){var x=-1,I=v==null?0:v.length;for(this.clear();++x<I;){var P=v[x];this.set(P[0],P[1])}}function Iue(){this.__data__=Ex?Ex(null):{},this.size=0}function Aue(v){var x=this.has(v)&&delete this.__data__[v];return this.size-=x?1:0,x}function Mue(v){var x=this.__data__;if(Ex){var I=x[v];return I===l?t:I}return Pr.call(x,v)?x[v]:t}function Nue(v){var x=this.__data__;return Ex?x[v]!==t:Pr.call(x,v)}function $ue(v,x){var I=this.__data__;return this.size+=this.has(v)?0:1,I[v]=Ex&&x===t?l:x,this}jp.prototype.clear=Iue,jp.prototype.delete=Aue,jp.prototype.get=Mue,jp.prototype.has=Nue,jp.prototype.set=$ue;function Kh(v){var x=-1,I=v==null?0:v.length;for(this.clear();++x<I;){var P=v[x];this.set(P[0],P[1])}}function Rue(){this.__data__=[],this.size=0}function Pue(v){var x=this.__data__,I=wk(x,v);if(I<0)return!1;var P=x.length-1;return I==P?x.pop():dk.call(x,I,1),--this.size,!0}function Due(v){var x=this.__data__,I=wk(x,v);return I<0?t:x[I][1]}function Oue(v){return wk(this.__data__,v)>-1}function Fue(v,x){var I=this.__data__,P=wk(I,v);return P<0?(++this.size,I.push([v,x])):I[P][1]=x,this}Kh.prototype.clear=Rue,Kh.prototype.delete=Pue,Kh.prototype.get=Due,Kh.prototype.has=Oue,Kh.prototype.set=Fue;function Yh(v){var x=-1,I=v==null?0:v.length;for(this.clear();++x<I;){var P=v[x];this.set(P[0],P[1])}}function Lue(){this.size=0,this.__data__={hash:new jp,map:new(kx||Kh),string:new jp}}function zue(v){var x=$k(this,v).delete(v);return this.size-=x?1:0,x}function Bue(v){return $k(this,v).get(v)}function Vue(v){return $k(this,v).has(v)}function Uue(v,x){var I=$k(this,v),P=I.size;return I.set(v,x),this.size+=I.size==P?0:1,this}Yh.prototype.clear=Lue,Yh.prototype.delete=zue,Yh.prototype.get=Bue,Yh.prototype.has=Vue,Yh.prototype.set=Uue;function qp(v){var x=-1,I=v==null?0:v.length;for(this.__data__=new Yh;++x<I;)this.add(v[x])}function Wue(v){return this.__data__.set(v,l),this}function Hue(v){return this.__data__.has(v)}qp.prototype.add=qp.prototype.push=Wue,qp.prototype.has=Hue;function qc(v){var x=this.__data__=new Kh(v);this.size=x.size}function Gue(){this.__data__=new Kh,this.size=0}function jue(v){var x=this.__data__,I=x.delete(v);return this.size=x.size,I}function que(v){return this.__data__.get(v)}function Xue(v){return this.__data__.has(v)}function Kue(v,x){var I=this.__data__;if(I instanceof Kh){var P=I.__data__;if(!kx||P.length<i-1)return P.push([v,x]),this.size=++I.size,this;I=this.__data__=new Yh(P)}return I.set(v,x),this.size=I.size,this}qc.prototype.clear=Gue,qc.prototype.delete=jue,qc.prototype.get=que,qc.prototype.has=Xue,qc.prototype.set=Kue;function rU(v,x){var I=Fn(v),P=!I&&Jp(v),V=!I&&!P&&od(v),K=!I&&!P&&!V&&k0(v),le=I||P||V||K,xe=le?dt(v.length,sue):[],Me=xe.length;for(var et in v)(x||Pr.call(v,et))&&!(le&&(et=="length"||V&&(et=="offset"||et=="parent")||K&&(et=="buffer"||et=="byteLength"||et=="byteOffset")||ef(et,Me)))&&xe.push(et);return xe}function iU(v){var x=v.length;return x?v[vR(0,x-1)]:t}function Yue(v,x){return Rk(Ra(v),Xp(x,0,v.length))}function Zue(v){return Rk(Ra(v))}function cR(v,x,I){(I!==t&&!Xc(v[x],I)||I===t&&!(x in v))&&Zh(v,x,I)}function Ax(v,x,I){var P=v[x];(!(Pr.call(v,x)&&Xc(P,I))||I===t&&!(x in v))&&Zh(v,x,I)}function wk(v,x){for(var I=v.length;I--;)if(Xc(v[I][0],x))return I;return-1}function Jue(v,x,I,P){return nd(v,function(V,K,le){x(P,V,I(V),le)}),P}function sU(v,x){return v&&Zu(x,to(x),v)}function Que(v,x){return v&&Zu(x,Da(x),v)}function Zh(v,x,I){x=="__proto__"&&pk?pk(v,x,{configurable:!0,enumerable:!0,value:I,writable:!0}):v[x]=I}function uR(v,x){for(var I=-1,P=x.length,V=Le(P),K=v==null;++I<P;)V[I]=K?t:HR(v,x[I]);return V}function Xp(v,x,I){return v===v&&(I!==t&&(v=v<=I?v:I),x!==t&&(v=v>=x?v:x)),v}function Xl(v,x,I,P,V,K){var le,xe=x&h,Me=x&f,et=x&d;if(I&&(le=V?I(v,P,V,K):I(v)),le!==t)return le;if(!Pi(v))return v;var nt=Fn(v);if(nt){if(le=Vhe(v),!xe)return Ra(v,le)}else{var ut=Do(v),Ft=ut==Ue||ut==Be;if(od(v))return AU(v,xe);if(ut==ee||ut==be||Ft&&!V){if(le=Me||Ft?{}:XU(v),!xe)return Me?Mhe(v,Que(le,v)):Ahe(v,sU(le,v))}else{if(!Rr[ut])return V?v:{};le=Uhe(v,ut,xe)}}K||(K=new qc);var tn=K.get(v);if(tn)return tn;K.set(v,le),SW(v)?v.forEach(function(bn){le.add(Xl(bn,x,I,bn,v,K))}):xW(v)&&v.forEach(function(bn,nr){le.set(nr,Xl(bn,x,I,nr,v,K))});var yn=et?Me?MR:AR:Me?Da:to,qn=nt?t:yn(v);return Na(qn||v,function(bn,nr){qn&&(nr=bn,bn=v[nr]),Ax(le,nr,Xl(bn,x,I,nr,v,K))}),le}function ehe(v){var x=to(v);return function(I){return oU(I,v,x)}}function oU(v,x,I){var P=I.length;if(v==null)return!P;for(v=Jr(v);P--;){var V=I[P],K=x[V],le=v[V];if(le===t&&!(V in v)||!K(le))return!1}return!0}function aU(v,x,I){if(typeof v!="function")throw new jl(o);return Ox(function(){v.apply(t,I)},x)}function Mx(v,x,I,P){var V=-1,K=d0,le=!0,xe=v.length,Me=[],et=x.length;if(!xe)return Me;I&&(x=Vr(x,Ut(I))),P?(K=wx,le=!1):x.length>=i&&(K=an,le=!1,x=new qp(x));e:for(;++V<xe;){var nt=v[V],ut=I==null?nt:I(nt);if(nt=P||nt!==0?nt:0,le&&ut===ut){for(var Ft=et;Ft--;)if(x[Ft]===ut)continue e;Me.push(nt)}else K(x,ut,P)||Me.push(nt)}return Me}var nd=PU(Yu),lU=PU(fR,!0);function the(v,x){var I=!0;return nd(v,function(P,V,K){return I=!!x(P,V,K),I}),I}function xk(v,x,I){for(var P=-1,V=v.length;++P<V;){var K=v[P],le=x(K);if(le!=null&&(xe===t?le===le&&!al(le):I(le,xe)))var xe=le,Me=K}return Me}function nhe(v,x,I,P){var V=v.length;for(I=Hn(I),I<0&&(I=-I>V?0:V+I),P=P===t||P>V?V:Hn(P),P<0&&(P+=V),P=I>P?0:kW(P);I<P;)v[I++]=x;return v}function cU(v,x){var I=[];return nd(v,function(P,V,K){x(P,V,K)&&I.push(P)}),I}function bo(v,x,I,P,V){var K=-1,le=v.length;for(I||(I=Hhe),V||(V=[]);++K<le;){var xe=v[K];x>0&&I(xe)?x>1?bo(xe,x-1,I,P,V):qu(V,xe):P||(V[V.length]=xe)}return V}var hR=DU(),uU=DU(!0);function Yu(v,x){return v&&hR(v,x,to)}function fR(v,x){return v&&uU(v,x,to)}function _k(v,x){return Gc(x,function(I){return tf(v[I])})}function Kp(v,x){x=id(x,v);for(var I=0,P=x.length;v!=null&&I<P;)v=v[Ju(x[I++])];return I&&I==P?v:t}function hU(v,x,I){var P=x(v);return Fn(v)?P:qu(P,I(v))}function aa(v){return v==null?v===t?It:Ye:Gp&&Gp in Jr(v)?Lhe(v):Zhe(v)}function dR(v,x){return v>x}function rhe(v,x){return v!=null&&Pr.call(v,x)}function ihe(v,x){return v!=null&&x in Jr(v)}function she(v,x,I){return v>=Po(x,I)&&v<Ls(x,I)}function pR(v,x,I){for(var P=I?wx:d0,V=v[0].length,K=v.length,le=K,xe=Le(K),Me=1/0,et=[];le--;){var nt=v[le];le&&x&&(nt=Vr(nt,Ut(x))),Me=Po(nt.length,Me),xe[le]=!I&&(x||V>=120&&nt.length>=120)?new qp(le&&nt):t}nt=v[0];var ut=-1,Ft=xe[0];e:for(;++ut<V&&et.length<Me;){var tn=nt[ut],yn=x?x(tn):tn;if(tn=I||tn!==0?tn:0,!(Ft?an(Ft,yn):P(et,yn,I))){for(le=K;--le;){var qn=xe[le];if(!(qn?an(qn,yn):P(v[le],yn,I)))continue e}Ft&&Ft.push(yn),et.push(tn)}}return et}function ohe(v,x,I,P){return Yu(v,function(V,K,le){x(P,I(V),K,le)}),P}function Nx(v,x,I){x=id(x,v),v=JU(v,x);var P=v==null?v:v[Ju(Yl(x))];return P==null?t:$o(P,v,I)}function fU(v){return Wi(v)&&aa(v)==be}function ahe(v){return Wi(v)&&aa(v)==rt}function lhe(v){return Wi(v)&&aa(v)==He}function $x(v,x,I,P,V){return v===x?!0:v==null||x==null||!Wi(v)&&!Wi(x)?v!==v&&x!==x:che(v,x,I,P,$x,V)}function che(v,x,I,P,V,K){var le=Fn(v),xe=Fn(x),Me=le?Ke:Do(v),et=xe?Ke:Do(x);Me=Me==be?ee:Me,et=et==be?ee:et;var nt=Me==ee,ut=et==ee,Ft=Me==et;if(Ft&&od(v)){if(!od(x))return!1;le=!0,nt=!1}if(Ft&&!nt)return K||(K=new qc),le||k0(v)?GU(v,x,I,P,V,K):Ohe(v,x,Me,I,P,V,K);if(!(I&p)){var tn=nt&&Pr.call(v,"__wrapped__"),yn=ut&&Pr.call(x,"__wrapped__");if(tn||yn){var qn=tn?v.value():v,bn=yn?x.value():x;return K||(K=new qc),V(qn,bn,I,P,K)}}return Ft?(K||(K=new qc),Fhe(v,x,I,P,V,K)):!1}function uhe(v){return Wi(v)&&Do(v)==Ve}function mR(v,x,I,P){var V=I.length,K=V,le=!P;if(v==null)return!K;for(v=Jr(v);V--;){var xe=I[V];if(le&&xe[2]?xe[1]!==v[xe[0]]:!(xe[0]in v))return!1}for(;++V<K;){xe=I[V];var Me=xe[0],et=v[Me],nt=xe[1];if(le&&xe[2]){if(et===t&&!(Me in v))return!1}else{var ut=new qc;if(P)var Ft=P(et,nt,Me,v,x,ut);if(!(Ft===t?$x(nt,et,p|m,P,ut):Ft))return!1}}return!0}function dU(v){if(!Pi(v)||jhe(v))return!1;var x=tf(v)?uue:ri;return x.test(Zp(v))}function hhe(v){return Wi(v)&&aa(v)==Ge}function fhe(v){return Wi(v)&&Do(v)==ye}function dhe(v){return Wi(v)&&zk(v.length)&&!!Br[aa(v)]}function pU(v){return typeof v=="function"?v:v==null?Oa:typeof v=="object"?Fn(v)?yU(v[0],v[1]):gU(v):OW(v)}function gR(v){if(!Dx(v))return gue(v);var x=[];for(var I in Jr(v))Pr.call(v,I)&&I!="constructor"&&x.push(I);return x}function phe(v){if(!Pi(v))return Yhe(v);var x=Dx(v),I=[];for(var P in v)P=="constructor"&&(x||!Pr.call(v,P))||I.push(P);return I}function yR(v,x){return v<x}function mU(v,x){var I=-1,P=Pa(v)?Le(v.length):[];return nd(v,function(V,K,le){P[++I]=x(V,K,le)}),P}function gU(v){var x=$R(v);return x.length==1&&x[0][2]?YU(x[0][0],x[0][1]):function(I){return I===v||mR(I,v,x)}}function yU(v,x){return PR(v)&&KU(x)?YU(Ju(v),x):function(I){var P=HR(I,v);return P===t&&P===x?GR(I,v):$x(x,P,p|m)}}function Sk(v,x,I,P,V){v!==x&&hR(x,function(K,le){if(V||(V=new qc),Pi(K))mhe(v,x,le,I,Sk,P,V);else{var xe=P?P(OR(v,le),K,le+"",v,x,V):t;xe===t&&(xe=K),cR(v,le,xe)}},Da)}function mhe(v,x,I,P,V,K,le){var xe=OR(v,I),Me=OR(x,I),et=le.get(Me);if(et){cR(v,I,et);return}var nt=K?K(xe,Me,I+"",v,x,le):t,ut=nt===t;if(ut){var Ft=Fn(Me),tn=!Ft&&od(Me),yn=!Ft&&!tn&&k0(Me);nt=Me,Ft||tn||yn?Fn(xe)?nt=xe:ts(xe)?nt=Ra(xe):tn?(ut=!1,nt=AU(Me,!0)):yn?(ut=!1,nt=MU(Me,!0)):nt=[]:Fx(Me)||Jp(Me)?(nt=xe,Jp(xe)?nt=TW(xe):(!Pi(xe)||tf(xe))&&(nt=XU(Me))):ut=!1}ut&&(le.set(Me,nt),V(nt,Me,P,K,le),le.delete(Me)),cR(v,I,nt)}function bU(v,x){var I=v.length;if(I)return x+=x<0?I:0,ef(x,I)?v[x]:t}function vU(v,x,I){x.length?x=Vr(x,function(K){return Fn(K)?function(le){return Kp(le,K.length===1?K[0]:K)}:K}):x=[Oa];var P=-1;x=Vr(x,Ut(dn()));var V=mU(v,function(K,le,xe){var Me=Vr(x,function(et){return et(K)});return{criteria:Me,index:++P,value:K}});return Ce(V,function(K,le){return Ihe(K,le,I)})}function ghe(v,x){return wU(v,x,function(I,P){return GR(v,P)})}function wU(v,x,I){for(var P=-1,V=x.length,K={};++P<V;){var le=x[P],xe=Kp(v,le);I(xe,le)&&Rx(K,id(le,v),xe)}return K}function yhe(v){return function(x){return Kp(x,v)}}function bR(v,x,I,P){var V=P?$:T,K=-1,le=x.length,xe=v;for(v===x&&(x=Ra(x)),I&&(xe=Vr(v,Ut(I)));++K<le;)for(var Me=0,et=x[K],nt=I?I(et):et;(Me=V(xe,nt,Me,P))>-1;)xe!==v&&dk.call(xe,Me,1),dk.call(v,Me,1);return v}function xU(v,x){for(var I=v?x.length:0,P=I-1;I--;){var V=x[I];if(I==P||V!==K){var K=V;ef(V)?dk.call(v,V,1):_R(v,V)}}return v}function vR(v,x){return v+gk(tU()*(x-v+1))}function bhe(v,x,I,P){for(var V=-1,K=Ls(mk((x-v)/(I||1)),0),le=Le(K);K--;)le[P?K:++V]=v,v+=I;return le}function wR(v,x){var I="";if(!v||x<1||x>H)return I;do x%2&&(I+=v),x=gk(x/2),x&&(v+=v);while(x);return I}function Kn(v,x){return FR(ZU(v,x,Oa),v+"")}function vhe(v){return iU(T0(v))}function whe(v,x){var I=T0(v);return Rk(I,Xp(x,0,I.length))}function Rx(v,x,I,P){if(!Pi(v))return v;x=id(x,v);for(var V=-1,K=x.length,le=K-1,xe=v;xe!=null&&++V<K;){var Me=Ju(x[V]),et=I;if(Me==="__proto__"||Me==="constructor"||Me==="prototype")return v;if(V!=le){var nt=xe[Me];et=P?P(nt,Me,xe):t,et===t&&(et=Pi(nt)?nt:ef(x[V+1])?[]:{})}Ax(xe,Me,et),xe=xe[Me]}return v}var _U=yk?function(v,x){return yk.set(v,x),v}:Oa,xhe=pk?function(v,x){return pk(v,"toString",{configurable:!0,enumerable:!1,value:qR(x),writable:!0})}:Oa;function _he(v){return Rk(T0(v))}function Kl(v,x,I){var P=-1,V=v.length;x<0&&(x=-x>V?0:V+x),I=I>V?V:I,I<0&&(I+=V),V=x>I?0:I-x>>>0,x>>>=0;for(var K=Le(V);++P<V;)K[P]=v[P+x];return K}function She(v,x){var I;return nd(v,function(P,V,K){return I=x(P,V,K),!I}),!!I}function Ck(v,x,I){var P=0,V=v==null?P:v.length;if(typeof x=="number"&&x===x&&V<=Te){for(;P<V;){var K=P+V>>>1,le=v[K];le!==null&&!al(le)&&(I?le<=x:le<x)?P=K+1:V=K}return V}return xR(v,x,Oa,I)}function xR(v,x,I,P){var V=0,K=v==null?0:v.length;if(K===0)return 0;x=I(x);for(var le=x!==x,xe=x===null,Me=al(x),et=x===t;V<K;){var nt=gk((V+K)/2),ut=I(v[nt]),Ft=ut!==t,tn=ut===null,yn=ut===ut,qn=al(ut);if(le)var bn=P||yn;else et?bn=yn&&(P||Ft):xe?bn=yn&&Ft&&(P||!tn):Me?bn=yn&&Ft&&!tn&&(P||!qn):tn||qn?bn=!1:bn=P?ut<=x:ut<x;bn?V=nt+1:K=nt}return Po(K,Ne)}function SU(v,x){for(var I=-1,P=v.length,V=0,K=[];++I<P;){var le=v[I],xe=x?x(le):le;if(!I||!Xc(xe,Me)){var Me=xe;K[V++]=le===0?0:le}}return K}function CU(v){return typeof v=="number"?v:al(v)?ge:+v}function ol(v){if(typeof v=="string")return v;if(Fn(v))return Vr(v,ol)+"";if(al(v))return nU?nU.call(v):"";var x=v+"";return x=="0"&&1/v==-X?"-0":x}function rd(v,x,I){var P=-1,V=d0,K=v.length,le=!0,xe=[],Me=xe;if(I)le=!1,V=wx;else if(K>=i){var et=x?null:Phe(v);if(et)return p0(et);le=!1,V=an,Me=new qp}else Me=x?[]:xe;e:for(;++P<K;){var nt=v[P],ut=x?x(nt):nt;if(nt=I||nt!==0?nt:0,le&&ut===ut){for(var Ft=Me.length;Ft--;)if(Me[Ft]===ut)continue e;x&&Me.push(ut),xe.push(nt)}else V(Me,ut,I)||(Me!==xe&&Me.push(ut),xe.push(nt))}return xe}function _R(v,x){return x=id(x,v),v=JU(v,x),v==null||delete v[Ju(Yl(x))]}function kU(v,x,I,P){return Rx(v,x,I(Kp(v,x)),P)}function kk(v,x,I,P){for(var V=v.length,K=P?V:-1;(P?K--:++K<V)&&x(v[K],K,v););return I?Kl(v,P?0:K,P?K+1:V):Kl(v,P?K+1:0,P?V:K)}function TU(v,x){var I=v;return I instanceof ar&&(I=I.value()),xx(x,function(P,V){return V.func.apply(V.thisArg,qu([P],V.args))},I)}function SR(v,x,I){var P=v.length;if(P<2)return P?rd(v[0]):[];for(var V=-1,K=Le(P);++V<P;)for(var le=v[V],xe=-1;++xe<P;)xe!=V&&(K[V]=Mx(K[V]||le,v[xe],x,I));return rd(bo(K,1),x,I)}function EU(v,x,I){for(var P=-1,V=v.length,K=x.length,le={};++P<V;){var xe=P<K?x[P]:t;I(le,v[P],xe)}return le}function CR(v){return ts(v)?v:[]}function kR(v){return typeof v=="function"?v:Oa}function id(v,x){return Fn(v)?v:PR(v,x)?[v]:nW(Mr(v))}var Che=Kn;function sd(v,x,I){var P=v.length;return I=I===t?P:I,!x&&I>=P?v:Kl(v,x,I)}var IU=hue||function(v){return ps.clearTimeout(v)};function AU(v,x){if(x)return v.slice();var I=v.length,P=YV?YV(I):new v.constructor(I);return v.copy(P),P}function TR(v){var x=new v.constructor(v.byteLength);return new hk(x).set(new hk(v)),x}function khe(v,x){var I=x?TR(v.buffer):v.buffer;return new v.constructor(I,v.byteOffset,v.byteLength)}function The(v){var x=new v.constructor(v.source,Zs.exec(v));return x.lastIndex=v.lastIndex,x}function Ehe(v){return Ix?Jr(Ix.call(v)):{}}function MU(v,x){var I=x?TR(v.buffer):v.buffer;return new v.constructor(I,v.byteOffset,v.length)}function NU(v,x){if(v!==x){var I=v!==t,P=v===null,V=v===v,K=al(v),le=x!==t,xe=x===null,Me=x===x,et=al(x);if(!xe&&!et&&!K&&v>x||K&&le&&Me&&!xe&&!et||P&&le&&Me||!I&&Me||!V)return 1;if(!P&&!K&&!et&&v<x||et&&I&&V&&!P&&!K||xe&&I&&V||!le&&V||!Me)return-1}return 0}function Ihe(v,x,I){for(var P=-1,V=v.criteria,K=x.criteria,le=V.length,xe=I.length;++P<le;){var Me=NU(V[P],K[P]);if(Me){if(P>=xe)return Me;var et=I[P];return Me*(et=="desc"?-1:1)}}return v.index-x.index}function $U(v,x,I,P){for(var V=-1,K=v.length,le=I.length,xe=-1,Me=x.length,et=Ls(K-le,0),nt=Le(Me+et),ut=!P;++xe<Me;)nt[xe]=x[xe];for(;++V<le;)(ut||V<K)&&(nt[I[V]]=v[V]);for(;et--;)nt[xe++]=v[V++];return nt}function RU(v,x,I,P){for(var V=-1,K=v.length,le=-1,xe=I.length,Me=-1,et=x.length,nt=Ls(K-xe,0),ut=Le(nt+et),Ft=!P;++V<nt;)ut[V]=v[V];for(var tn=V;++Me<et;)ut[tn+Me]=x[Me];for(;++le<xe;)(Ft||V<K)&&(ut[tn+I[le]]=v[V++]);return ut}function Ra(v,x){var I=-1,P=v.length;for(x||(x=Le(P));++I<P;)x[I]=v[I];return x}function Zu(v,x,I,P){var V=!I;I||(I={});for(var K=-1,le=x.length;++K<le;){var xe=x[K],Me=P?P(I[xe],v[xe],xe,I,v):t;Me===t&&(Me=v[xe]),V?Zh(I,xe,Me):Ax(I,xe,Me)}return I}function Ahe(v,x){return Zu(v,RR(v),x)}function Mhe(v,x){return Zu(v,jU(v),x)}function Tk(v,x){return function(I,P){var V=Fn(I)?J$:Jue,K=x?x():{};return V(I,v,dn(P,2),K)}}function _0(v){return Kn(function(x,I){var P=-1,V=I.length,K=V>1?I[V-1]:t,le=V>2?I[2]:t;for(K=v.length>3&&typeof K=="function"?(V--,K):t,le&&la(I[0],I[1],le)&&(K=V<3?t:K,V=1),x=Jr(x);++P<V;){var xe=I[P];xe&&v(x,xe,P,K)}return x})}function PU(v,x){return function(I,P){if(I==null)return I;if(!Pa(I))return v(I,P);for(var V=I.length,K=x?V:-1,le=Jr(I);(x?K--:++K<V)&&P(le[K],K,le)!==!1;);return I}}function DU(v){return function(x,I,P){for(var V=-1,K=Jr(x),le=P(x),xe=le.length;xe--;){var Me=le[v?xe:++V];if(I(K[Me],Me,K)===!1)break}return x}}function Nhe(v,x,I){var P=x&g,V=Px(v);function K(){var le=this&&this!==ps&&this instanceof K?V:v;return le.apply(P?I:this,arguments)}return K}function OU(v){return function(x){x=Mr(x);var I=xi(x)?jc(x):t,P=I?I[0]:x.charAt(0),V=I?sd(I,1).join(""):x.slice(1);return P[v]()+V}}function S0(v){return function(x){return xx(PW(RW(x).replace(X$,"")),v,"")}}function Px(v){return function(){var x=arguments;switch(x.length){case 0:return new v;case 1:return new v(x[0]);case 2:return new v(x[0],x[1]);case 3:return new v(x[0],x[1],x[2]);case 4:return new v(x[0],x[1],x[2],x[3]);case 5:return new v(x[0],x[1],x[2],x[3],x[4]);case 6:return new v(x[0],x[1],x[2],x[3],x[4],x[5]);case 7:return new v(x[0],x[1],x[2],x[3],x[4],x[5],x[6])}var I=x0(v.prototype),P=v.apply(I,x);return Pi(P)?P:I}}function $he(v,x,I){var P=Px(v);function V(){for(var K=arguments.length,le=Le(K),xe=K,Me=C0(V);xe--;)le[xe]=arguments[xe];var et=K<3&&le[0]!==Me&&le[K-1]!==Me?[]:Ku(le,Me);if(K-=et.length,K<I)return VU(v,x,Ek,V.placeholder,t,le,et,t,t,I-K);var nt=this&&this!==ps&&this instanceof V?P:v;return $o(nt,this,le)}return V}function FU(v){return function(x,I,P){var V=Jr(x);if(!Pa(x)){var K=dn(I,3);x=to(x),I=function(xe){return K(V[xe],xe,V)}}var le=v(x,I,P);return le>-1?V[K?x[le]:le]:t}}function LU(v){return Qh(function(x){var I=x.length,P=I,V=ql.prototype.thru;for(v&&x.reverse();P--;){var K=x[P];if(typeof K!="function")throw new jl(o);if(V&&!le&&Nk(K)=="wrapper")var le=new ql([],!0)}for(P=le?P:I;++P<I;){K=x[P];var xe=Nk(K),Me=xe=="wrapper"?NR(K):t;Me&&DR(Me[0])&&Me[1]==(k|_|S|A)&&!Me[4].length&&Me[9]==1?le=le[Nk(Me[0])].apply(le,Me[3]):le=K.length==1&&DR(K)?le[xe]():le.thru(K)}return function(){var et=arguments,nt=et[0];if(le&&et.length==1&&Fn(nt))return le.plant(nt).value();for(var ut=0,Ft=I?x[ut].apply(this,et):nt;++ut<I;)Ft=x[ut].call(this,Ft);return Ft}})}function Ek(v,x,I,P,V,K,le,xe,Me,et){var nt=x&k,ut=x&g,Ft=x&y,tn=x&(_|w),yn=x&M,qn=Ft?t:Px(v);function bn(){for(var nr=arguments.length,fr=Le(nr),ll=nr;ll--;)fr[ll]=arguments[ll];if(tn)var ca=C0(bn),cl=Wr(fr,ca);if(P&&(fr=$U(fr,P,V,tn)),K&&(fr=RU(fr,K,le,tn)),nr-=cl,tn&&nr<et){var ns=Ku(fr,ca);return VU(v,x,Ek,bn.placeholder,I,fr,ns,xe,Me,et-nr)}var Kc=ut?I:this,rf=Ft?Kc[v]:v;return nr=fr.length,xe?fr=Jhe(fr,xe):yn&&nr>1&&fr.reverse(),nt&&Me<nr&&(fr.length=Me),this&&this!==ps&&this instanceof bn&&(rf=qn||Px(rf)),rf.apply(Kc,fr)}return bn}function zU(v,x){return function(I,P){return ohe(I,v,x(P),{})}}function Ik(v,x){return function(I,P){var V;if(I===t&&P===t)return x;if(I!==t&&(V=I),P!==t){if(V===t)return P;typeof I=="string"||typeof P=="string"?(I=ol(I),P=ol(P)):(I=CU(I),P=CU(P)),V=v(I,P)}return V}}function ER(v){return Qh(function(x){return x=Vr(x,Ut(dn())),Kn(function(I){var P=this;return v(x,function(V){return $o(V,P,I)})})})}function Ak(v,x){x=x===t?" ":ol(x);var I=x.length;if(I<2)return I?wR(x,v):x;var P=wR(x,mk(v/g0(x)));return xi(x)?sd(jc(P),0,v).join(""):P.slice(0,v)}function Rhe(v,x,I,P){var V=x&g,K=Px(v);function le(){for(var xe=-1,Me=arguments.length,et=-1,nt=P.length,ut=Le(nt+Me),Ft=this&&this!==ps&&this instanceof le?K:v;++et<nt;)ut[et]=P[et];for(;Me--;)ut[et++]=arguments[++xe];return $o(Ft,V?I:this,ut)}return le}function BU(v){return function(x,I,P){return P&&typeof P!="number"&&la(x,I,P)&&(I=P=t),x=nf(x),I===t?(I=x,x=0):I=nf(I),P=P===t?x<I?1:-1:nf(P),bhe(x,I,P,v)}}function Mk(v){return function(x,I){return typeof x=="string"&&typeof I=="string"||(x=Zl(x),I=Zl(I)),v(x,I)}}function VU(v,x,I,P,V,K,le,xe,Me,et){var nt=x&_,ut=nt?le:t,Ft=nt?t:le,tn=nt?K:t,yn=nt?t:K;x|=nt?S:C,x&=~(nt?C:S),x&b||(x&=~(g|y));var qn=[v,x,V,tn,ut,yn,Ft,xe,Me,et],bn=I.apply(t,qn);return DR(v)&&QU(bn,qn),bn.placeholder=P,eW(bn,v,x)}function IR(v){var x=Fs[v];return function(I,P){if(I=Zl(I),P=P==null?0:Po(Hn(P),292),P&&eU(I)){var V=(Mr(I)+"e").split("e"),K=x(V[0]+"e"+(+V[1]+P));return V=(Mr(K)+"e").split("e"),+(V[0]+"e"+(+V[1]-P))}return x(I)}}var Phe=v0&&1/p0(new v0([,-0]))[1]==X?function(v){return new v0(v)}:YR;function UU(v){return function(x){var I=Do(x);return I==Ve?Sx(x):I==ye?m0(x):At(x,v(x))}}function Jh(v,x,I,P,V,K,le,xe){var Me=x&y;if(!Me&&typeof v!="function")throw new jl(o);var et=P?P.length:0;if(et||(x&=~(S|C),P=V=t),le=le===t?le:Ls(Hn(le),0),xe=xe===t?xe:Hn(xe),et-=V?V.length:0,x&C){var nt=P,ut=V;P=V=t}var Ft=Me?t:NR(v),tn=[v,x,I,P,V,nt,ut,K,le,xe];if(Ft&&Khe(tn,Ft),v=tn[0],x=tn[1],I=tn[2],P=tn[3],V=tn[4],xe=tn[9]=tn[9]===t?Me?0:v.length:Ls(tn[9]-et,0),!xe&&x&(_|w)&&(x&=~(_|w)),!x||x==g)var yn=Nhe(v,x,I);else x==_||x==w?yn=$he(v,x,xe):(x==S||x==(g|S))&&!V.length?yn=Rhe(v,x,I,P):yn=Ek.apply(t,tn);var qn=Ft?_U:QU;return eW(qn(yn,tn),v,x)}function WU(v,x,I,P){return v===t||Xc(v,b0[I])&&!Pr.call(P,I)?x:v}function HU(v,x,I,P,V,K){return Pi(v)&&Pi(x)&&(K.set(x,v),Sk(v,x,t,HU,K),K.delete(x)),v}function Dhe(v){return Fx(v)?t:v}function GU(v,x,I,P,V,K){var le=I&p,xe=v.length,Me=x.length;if(xe!=Me&&!(le&&Me>xe))return!1;var et=K.get(v),nt=K.get(x);if(et&&nt)return et==x&&nt==v;var ut=-1,Ft=!0,tn=I&m?new qp:t;for(K.set(v,x),K.set(x,v);++ut<xe;){var yn=v[ut],qn=x[ut];if(P)var bn=le?P(qn,yn,ut,x,v,K):P(yn,qn,ut,v,x,K);if(bn!==t){if(bn)continue;Ft=!1;break}if(tn){if(!ed(x,function(nr,fr){if(!an(tn,fr)&&(yn===nr||V(yn,nr,I,P,K)))return tn.push(fr)})){Ft=!1;break}}else if(!(yn===qn||V(yn,qn,I,P,K))){Ft=!1;break}}return K.delete(v),K.delete(x),Ft}function Ohe(v,x,I,P,V,K,le){switch(I){case Et:if(v.byteLength!=x.byteLength||v.byteOffset!=x.byteOffset)return!1;v=v.buffer,x=x.buffer;case rt:return!(v.byteLength!=x.byteLength||!K(new hk(v),new hk(x)));case ot:case He:case ft:return Xc(+v,+x);case ht:return v.name==x.name&&v.message==x.message;case Ge:case Je:return v==x+"";case Ve:var xe=Sx;case ye:var Me=P&p;if(xe||(xe=p0),v.size!=x.size&&!Me)return!1;var et=le.get(v);if(et)return et==x;P|=m,le.set(v,x);var nt=GU(xe(v),xe(x),P,V,K,le);return le.delete(v),nt;case bt:if(Ix)return Ix.call(v)==Ix.call(x)}return!1}function Fhe(v,x,I,P,V,K){var le=I&p,xe=AR(v),Me=xe.length,et=AR(x),nt=et.length;if(Me!=nt&&!le)return!1;for(var ut=Me;ut--;){var Ft=xe[ut];if(!(le?Ft in x:Pr.call(x,Ft)))return!1}var tn=K.get(v),yn=K.get(x);if(tn&&yn)return tn==x&&yn==v;var qn=!0;K.set(v,x),K.set(x,v);for(var bn=le;++ut<Me;){Ft=xe[ut];var nr=v[Ft],fr=x[Ft];if(P)var ll=le?P(fr,nr,Ft,x,v,K):P(nr,fr,Ft,v,x,K);if(!(ll===t?nr===fr||V(nr,fr,I,P,K):ll)){qn=!1;break}bn||(bn=Ft=="constructor")}if(qn&&!bn){var ca=v.constructor,cl=x.constructor;ca!=cl&&"constructor"in v&&"constructor"in x&&!(typeof ca=="function"&&ca instanceof ca&&typeof cl=="function"&&cl instanceof cl)&&(qn=!1)}return K.delete(v),K.delete(x),qn}function Qh(v){return FR(ZU(v,t,oW),v+"")}function AR(v){return hU(v,to,RR)}function MR(v){return hU(v,Da,jU)}var NR=yk?function(v){return yk.get(v)}:YR;function Nk(v){for(var x=v.name+"",I=w0[x],P=Pr.call(w0,x)?I.length:0;P--;){var V=I[P],K=V.func;if(K==null||K==v)return V.name}return x}function C0(v){var x=Pr.call(q,"placeholder")?q:v;return x.placeholder}function dn(){var v=q.iteratee||XR;return v=v===XR?pU:v,arguments.length?v(arguments[0],arguments[1]):v}function $k(v,x){var I=v.__data__;return Ghe(x)?I[typeof x=="string"?"string":"hash"]:I.map}function $R(v){for(var x=to(v),I=x.length;I--;){var P=x[I],V=v[P];x[I]=[P,V,KU(V)]}return x}function Yp(v,x){var I=yr(v,x);return dU(I)?I:t}function Lhe(v){var x=Pr.call(v,Gp),I=v[Gp];try{v[Gp]=t;var P=!0}catch{}var V=ck.call(v);return P&&(x?v[Gp]=I:delete v[Gp]),V}var RR=oR?function(v){return v==null?[]:(v=Jr(v),Gc(oR(v),function(x){return JV.call(v,x)}))}:ZR,jU=oR?function(v){for(var x=[];v;)qu(x,RR(v)),v=fk(v);return x}:ZR,Do=aa;(aR&&Do(new aR(new ArrayBuffer(1)))!=Et||kx&&Do(new kx)!=Ve||lR&&Do(lR.resolve())!=J||v0&&Do(new v0)!=ye||Tx&&Do(new Tx)!=pt)&&(Do=function(v){var x=aa(v),I=x==ee?v.constructor:t,P=I?Zp(I):"";if(P)switch(P){case wue:return Et;case xue:return Ve;case _ue:return J;case Sue:return ye;case Cue:return pt}return x});function zhe(v,x,I){for(var P=-1,V=I.length;++P<V;){var K=I[P],le=K.size;switch(K.type){case"drop":v+=le;break;case"dropRight":x-=le;break;case"take":x=Po(x,v+le);break;case"takeRight":v=Ls(v,x-le);break}}return{start:v,end:x}}function Bhe(v){var x=v.match(Nn);return x?x[1].split(tr):[]}function qU(v,x,I){x=id(x,v);for(var P=-1,V=x.length,K=!1;++P<V;){var le=Ju(x[P]);if(!(K=v!=null&&I(v,le)))break;v=v[le]}return K||++P!=V?K:(V=v==null?0:v.length,!!V&&zk(V)&&ef(le,V)&&(Fn(v)||Jp(v)))}function Vhe(v){var x=v.length,I=new v.constructor(x);return x&&typeof v[0]=="string"&&Pr.call(v,"index")&&(I.index=v.index,I.input=v.input),I}function XU(v){return typeof v.constructor=="function"&&!Dx(v)?x0(fk(v)):{}}function Uhe(v,x,I){var P=v.constructor;switch(x){case rt:return TR(v);case ot:case He:return new P(+v);case Et:return khe(v,I);case yt:case Ht:case Mn:case Cr:case Bi:case Ai:case Mi:case zh:case Ul:return MU(v,I);case Ve:return new P;case ft:case Je:return new P(v);case Ge:return The(v);case ye:return new P;case bt:return Ehe(v)}}function Whe(v,x){var I=x.length;if(!I)return v;var P=I-1;return x[P]=(I>1?"& ":"")+x[P],x=x.join(I>2?", ":" "),v.replace(En,`{
/* [wrapped with `+x+`] */
`)}function Hhe(v){return Fn(v)||Jp(v)||!!(QV&&v&&v[QV])}function ef(v,x){var I=typeof v;return x=x??H,!!x&&(I=="number"||I!="symbol"&&No.test(v))&&v>-1&&v%1==0&&v<x}function la(v,x,I){if(!Pi(I))return!1;var P=typeof x;return(P=="number"?Pa(I)&&ef(x,I.length):P=="string"&&x in I)?Xc(I[x],v):!1}function PR(v,x){if(Fn(v))return!1;var I=typeof v;return I=="number"||I=="symbol"||I=="boolean"||v==null||al(v)?!0:Fe.test(v)||!We.test(v)||x!=null&&v in Jr(x)}function Ghe(v){var x=typeof v;return x=="string"||x=="number"||x=="symbol"||x=="boolean"?v!=="__proto__":v===null}function DR(v){var x=Nk(v),I=q[x];if(typeof I!="function"||!(x in ar.prototype))return!1;if(v===I)return!0;var P=NR(I);return!!P&&v===P[0]}function jhe(v){return!!KV&&KV in v}var qhe=ak?tf:JR;function Dx(v){var x=v&&v.constructor,I=typeof x=="function"&&x.prototype||b0;return v===I}function KU(v){return v===v&&!Pi(v)}function YU(v,x){return function(I){return I==null?!1:I[v]===x&&(x!==t||v in Jr(I))}}function Xhe(v){var x=Fk(v,function(P){return I.size===c&&I.clear(),P}),I=x.cache;return x}function Khe(v,x){var I=v[1],P=x[1],V=I|P,K=V<(g|y|k),le=P==k&&I==_||P==k&&I==A&&v[7].length<=x[8]||P==(k|A)&&x[7].length<=x[8]&&I==_;if(!(K||le))return v;P&g&&(v[2]=x[2],V|=I&g?0:b);var xe=x[3];if(xe){var Me=v[3];v[3]=Me?$U(Me,xe,x[4]):xe,v[4]=Me?Ku(v[3],u):x[4]}return xe=x[5],xe&&(Me=v[5],v[5]=Me?RU(Me,xe,x[6]):xe,v[6]=Me?Ku(v[5],u):x[6]),xe=x[7],xe&&(v[7]=xe),P&k&&(v[8]=v[8]==null?x[8]:Po(v[8],x[8])),v[9]==null&&(v[9]=x[9]),v[0]=x[0],v[1]=V,v}function Yhe(v){var x=[];if(v!=null)for(var I in Jr(v))x.push(I);return x}function Zhe(v){return ck.call(v)}function ZU(v,x,I){return x=Ls(x===t?v.length-1:x,0),function(){for(var P=arguments,V=-1,K=Ls(P.length-x,0),le=Le(K);++V<K;)le[V]=P[x+V];V=-1;for(var xe=Le(x+1);++V<x;)xe[V]=P[V];return xe[x]=I(le),$o(v,this,xe)}}function JU(v,x){return x.length<2?v:Kp(v,Kl(x,0,-1))}function Jhe(v,x){for(var I=v.length,P=Po(x.length,I),V=Ra(v);P--;){var K=x[P];v[P]=ef(K,I)?V[K]:t}return v}function OR(v,x){if(!(x==="constructor"&&typeof v[x]=="function")&&x!="__proto__")return v[x]}var QU=tW(_U),Ox=due||function(v,x){return ps.setTimeout(v,x)},FR=tW(xhe);function eW(v,x,I){var P=x+"";return FR(v,Whe(P,Qhe(Bhe(P),I)))}function tW(v){var x=0,I=0;return function(){var P=yue(),V=R-(P-I);if(I=P,V>0){if(++x>=O)return arguments[0]}else x=0;return v.apply(t,arguments)}}function Rk(v,x){var I=-1,P=v.length,V=P-1;for(x=x===t?P:x;++I<x;){var K=vR(I,V),le=v[K];v[K]=v[I],v[I]=le}return v.length=x,v}var nW=Xhe(function(v){var x=[];return v.charCodeAt(0)===46&&x.push(""),v.replace(Qe,function(I,P,V,K){x.push(V?K.replace(Ds,"$1"):P||I)}),x});function Ju(v){if(typeof v=="string"||al(v))return v;var x=v+"";return x=="0"&&1/v==-X?"-0":x}function Zp(v){if(v!=null){try{return lk.call(v)}catch{}try{return v+""}catch{}}return""}function Qhe(v,x){return Na(De,function(I){var P="_."+I[0];x&I[1]&&!d0(v,P)&&v.push(P)}),v.sort()}function rW(v){if(v instanceof ar)return v.clone();var x=new ql(v.__wrapped__,v.__chain__);return x.__actions__=Ra(v.__actions__),x.__index__=v.__index__,x.__values__=v.__values__,x}function efe(v,x,I){(I?la(v,x,I):x===t)?x=1:x=Ls(Hn(x),0);var P=v==null?0:v.length;if(!P||x<1)return[];for(var V=0,K=0,le=Le(mk(P/x));V<P;)le[K++]=Kl(v,V,V+=x);return le}function tfe(v){for(var x=-1,I=v==null?0:v.length,P=0,V=[];++x<I;){var K=v[x];K&&(V[P++]=K)}return V}function nfe(){var v=arguments.length;if(!v)return[];for(var x=Le(v-1),I=arguments[0],P=v;P--;)x[P-1]=arguments[P];return qu(Fn(I)?Ra(I):[I],bo(x,1))}var rfe=Kn(function(v,x){return ts(v)?Mx(v,bo(x,1,ts,!0)):[]}),ife=Kn(function(v,x){var I=Yl(x);return ts(I)&&(I=t),ts(v)?Mx(v,bo(x,1,ts,!0),dn(I,2)):[]}),sfe=Kn(function(v,x){var I=Yl(x);return ts(I)&&(I=t),ts(v)?Mx(v,bo(x,1,ts,!0),t,I):[]});function ofe(v,x,I){var P=v==null?0:v.length;return P?(x=I||x===t?1:Hn(x),Kl(v,x<0?0:x,P)):[]}function afe(v,x,I){var P=v==null?0:v.length;return P?(x=I||x===t?1:Hn(x),x=P-x,Kl(v,0,x<0?0:x)):[]}function lfe(v,x){return v&&v.length?kk(v,dn(x,3),!0,!0):[]}function cfe(v,x){return v&&v.length?kk(v,dn(x,3),!0):[]}function ufe(v,x,I,P){var V=v==null?0:v.length;return V?(I&&typeof I!="number"&&la(v,x,I)&&(I=0,P=V),nhe(v,x,I,P)):[]}function iW(v,x,I){var P=v==null?0:v.length;if(!P)return-1;var V=I==null?0:Hn(I);return V<0&&(V=Ls(P+V,0)),Hp(v,dn(x,3),V)}function sW(v,x,I){var P=v==null?0:v.length;if(!P)return-1;var V=P-1;return I!==t&&(V=Hn(I),V=I<0?Ls(P+V,0):Po(V,P-1)),Hp(v,dn(x,3),V,!0)}function oW(v){var x=v==null?0:v.length;return x?bo(v,1):[]}function hfe(v){var x=v==null?0:v.length;return x?bo(v,X):[]}function ffe(v,x){var I=v==null?0:v.length;return I?(x=x===t?1:Hn(x),bo(v,x)):[]}function dfe(v){for(var x=-1,I=v==null?0:v.length,P={};++x<I;){var V=v[x];P[V[0]]=V[1]}return P}function aW(v){return v&&v.length?v[0]:t}function pfe(v,x,I){var P=v==null?0:v.length;if(!P)return-1;var V=I==null?0:Hn(I);return V<0&&(V=Ls(P+V,0)),T(v,x,V)}function mfe(v){var x=v==null?0:v.length;return x?Kl(v,0,-1):[]}var gfe=Kn(function(v){var x=Vr(v,CR);return x.length&&x[0]===v[0]?pR(x):[]}),yfe=Kn(function(v){var x=Yl(v),I=Vr(v,CR);return x===Yl(I)?x=t:I.pop(),I.length&&I[0]===v[0]?pR(I,dn(x,2)):[]}),bfe=Kn(function(v){var x=Yl(v),I=Vr(v,CR);return x=typeof x=="function"?x:t,x&&I.pop(),I.length&&I[0]===v[0]?pR(I,t,x):[]});function vfe(v,x){return v==null?"":mue.call(v,x)}function Yl(v){var x=v==null?0:v.length;return x?v[x-1]:t}function wfe(v,x,I){var P=v==null?0:v.length;if(!P)return-1;var V=P;return I!==t&&(V=Hn(I),V=V<0?Ls(P+V,0):Po(V,P-1)),x===x?Qce(v,x,V):Hp(v,L,V,!0)}function xfe(v,x){return v&&v.length?bU(v,Hn(x)):t}var _fe=Kn(lW);function lW(v,x){return v&&v.length&&x&&x.length?bR(v,x):v}function Sfe(v,x,I){return v&&v.length&&x&&x.length?bR(v,x,dn(I,2)):v}function Cfe(v,x,I){return v&&v.length&&x&&x.length?bR(v,x,t,I):v}var kfe=Qh(function(v,x){var I=v==null?0:v.length,P=uR(v,x);return xU(v,Vr(x,function(V){return ef(V,I)?+V:V}).sort(NU)),P});function Tfe(v,x){var I=[];if(!(v&&v.length))return I;var P=-1,V=[],K=v.length;for(x=dn(x,3);++P<K;){var le=v[P];x(le,P,v)&&(I.push(le),V.push(P))}return xU(v,V),I}function LR(v){return v==null?v:vue.call(v)}function Efe(v,x,I){var P=v==null?0:v.length;return P?(I&&typeof I!="number"&&la(v,x,I)?(x=0,I=P):(x=x==null?0:Hn(x),I=I===t?P:Hn(I)),Kl(v,x,I)):[]}function Ife(v,x){return Ck(v,x)}function Afe(v,x,I){return xR(v,x,dn(I,2))}function Mfe(v,x){var I=v==null?0:v.length;if(I){var P=Ck(v,x);if(P<I&&Xc(v[P],x))return P}return-1}function Nfe(v,x){return Ck(v,x,!0)}function $fe(v,x,I){return xR(v,x,dn(I,2),!0)}function Rfe(v,x){var I=v==null?0:v.length;if(I){var P=Ck(v,x,!0)-1;if(Xc(v[P],x))return P}return-1}function Pfe(v){return v&&v.length?SU(v):[]}function Dfe(v,x){return v&&v.length?SU(v,dn(x,2)):[]}function Ofe(v){var x=v==null?0:v.length;return x?Kl(v,1,x):[]}function Ffe(v,x,I){return v&&v.length?(x=I||x===t?1:Hn(x),Kl(v,0,x<0?0:x)):[]}function Lfe(v,x,I){var P=v==null?0:v.length;return P?(x=I||x===t?1:Hn(x),x=P-x,Kl(v,x<0?0:x,P)):[]}function zfe(v,x){return v&&v.length?kk(v,dn(x,3),!1,!0):[]}function Bfe(v,x){return v&&v.length?kk(v,dn(x,3)):[]}var Vfe=Kn(function(v){return rd(bo(v,1,ts,!0))}),Ufe=Kn(function(v){var x=Yl(v);return ts(x)&&(x=t),rd(bo(v,1,ts,!0),dn(x,2))}),Wfe=Kn(function(v){var x=Yl(v);return x=typeof x=="function"?x:t,rd(bo(v,1,ts,!0),t,x)});function Hfe(v){return v&&v.length?rd(v):[]}function Gfe(v,x){return v&&v.length?rd(v,dn(x,2)):[]}function jfe(v,x){return x=typeof x=="function"?x:t,v&&v.length?rd(v,t,x):[]}function zR(v){if(!(v&&v.length))return[];var x=0;return v=Gc(v,function(I){if(ts(I))return x=Ls(I.length,x),!0}),dt(x,function(I){return Vr(v,ne(I))})}function cW(v,x){if(!(v&&v.length))return[];var I=zR(v);return x==null?I:Vr(I,function(P){return $o(x,t,P)})}var qfe=Kn(function(v,x){return ts(v)?Mx(v,x):[]}),Xfe=Kn(function(v){return SR(Gc(v,ts))}),Kfe=Kn(function(v){var x=Yl(v);return ts(x)&&(x=t),SR(Gc(v,ts),dn(x,2))}),Yfe=Kn(function(v){var x=Yl(v);return x=typeof x=="function"?x:t,SR(Gc(v,ts),t,x)}),Zfe=Kn(zR);function Jfe(v,x){return EU(v||[],x||[],Ax)}function Qfe(v,x){return EU(v||[],x||[],Rx)}var ede=Kn(function(v){var x=v.length,I=x>1?v[x-1]:t;return I=typeof I=="function"?(v.pop(),I):t,cW(v,I)});function uW(v){var x=q(v);return x.__chain__=!0,x}function tde(v,x){return x(v),v}function Pk(v,x){return x(v)}var nde=Qh(function(v){var x=v.length,I=x?v[0]:0,P=this.__wrapped__,V=function(K){return uR(K,v)};return x>1||this.__actions__.length||!(P instanceof ar)||!ef(I)?this.thru(V):(P=P.slice(I,+I+(x?1:0)),P.__actions__.push({func:Pk,args:[V],thisArg:t}),new ql(P,this.__chain__).thru(function(K){return x&&!K.length&&K.push(t),K}))});function rde(){return uW(this)}function ide(){return new ql(this.value(),this.__chain__)}function sde(){this.__values__===t&&(this.__values__=CW(this.value()));var v=this.__index__>=this.__values__.length,x=v?t:this.__values__[this.__index__++];return{done:v,value:x}}function ode(){return this}function ade(v){for(var x,I=this;I instanceof vk;){var P=rW(I);P.__index__=0,P.__values__=t,x?V.__wrapped__=P:x=P;var V=P;I=I.__wrapped__}return V.__wrapped__=v,x}function lde(){var v=this.__wrapped__;if(v instanceof ar){var x=v;return this.__actions__.length&&(x=new ar(this)),x=x.reverse(),x.__actions__.push({func:Pk,args:[LR],thisArg:t}),new ql(x,this.__chain__)}return this.thru(LR)}function cde(){return TU(this.__wrapped__,this.__actions__)}var ude=Tk(function(v,x,I){Pr.call(v,I)?++v[I]:Zh(v,I,1)});function hde(v,x,I){var P=Fn(v)?ik:the;return I&&la(v,x,I)&&(x=t),P(v,dn(x,3))}function fde(v,x){var I=Fn(v)?Gc:cU;return I(v,dn(x,3))}var dde=FU(iW),pde=FU(sW);function mde(v,x){return bo(Dk(v,x),1)}function gde(v,x){return bo(Dk(v,x),X)}function yde(v,x,I){return I=I===t?1:Hn(I),bo(Dk(v,x),I)}function hW(v,x){var I=Fn(v)?Na:nd;return I(v,dn(x,3))}function fW(v,x){var I=Fn(v)?Q$:lU;return I(v,dn(x,3))}var bde=Tk(function(v,x,I){Pr.call(v,I)?v[I].push(x):Zh(v,I,[x])});function vde(v,x,I,P){v=Pa(v)?v:T0(v),I=I&&!P?Hn(I):0;var V=v.length;return I<0&&(I=Ls(V+I,0)),Bk(v)?I<=V&&v.indexOf(x,I)>-1:!!V&&T(v,x,I)>-1}var wde=Kn(function(v,x,I){var P=-1,V=typeof x=="function",K=Pa(v)?Le(v.length):[];return nd(v,function(le){K[++P]=V?$o(x,le,I):Nx(le,x,I)}),K}),xde=Tk(function(v,x,I){Zh(v,I,x)});function Dk(v,x){var I=Fn(v)?Vr:mU;return I(v,dn(x,3))}function _de(v,x,I,P){return v==null?[]:(Fn(x)||(x=x==null?[]:[x]),I=P?t:I,Fn(I)||(I=I==null?[]:[I]),vU(v,x,I))}var Sde=Tk(function(v,x,I){v[I?0:1].push(x)},function(){return[[],[]]});function Cde(v,x,I){var P=Fn(v)?xx:se,V=arguments.length<3;return P(v,dn(x,4),I,V,nd)}function kde(v,x,I){var P=Fn(v)?eR:se,V=arguments.length<3;return P(v,dn(x,4),I,V,lU)}function Tde(v,x){var I=Fn(v)?Gc:cU;return I(v,Lk(dn(x,3)))}function Ede(v){var x=Fn(v)?iU:vhe;return x(v)}function Ide(v,x,I){(I?la(v,x,I):x===t)?x=1:x=Hn(x);var P=Fn(v)?Yue:whe;return P(v,x)}function Ade(v){var x=Fn(v)?Zue:_he;return x(v)}function Mde(v){if(v==null)return 0;if(Pa(v))return Bk(v)?g0(v):v.length;var x=Do(v);return x==Ve||x==ye?v.size:gR(v).length}function Nde(v,x,I){var P=Fn(v)?ed:She;return I&&la(v,x,I)&&(x=t),P(v,dn(x,3))}var $de=Kn(function(v,x){if(v==null)return[];var I=x.length;return I>1&&la(v,x[0],x[1])?x=[]:I>2&&la(x[0],x[1],x[2])&&(x=[x[0]]),vU(v,bo(x,1),[])}),Ok=fue||function(){return ps.Date.now()};function Rde(v,x){if(typeof x!="function")throw new jl(o);return v=Hn(v),function(){if(--v<1)return x.apply(this,arguments)}}function dW(v,x,I){return x=I?t:x,x=v&&x==null?v.length:x,Jh(v,k,t,t,t,t,x)}function pW(v,x){var I;if(typeof x!="function")throw new jl(o);return v=Hn(v),function(){return--v>0&&(I=x.apply(this,arguments)),v<=1&&(x=t),I}}var BR=Kn(function(v,x,I){var P=g;if(I.length){var V=Ku(I,C0(BR));P|=S}return Jh(v,P,x,I,V)}),mW=Kn(function(v,x,I){var P=g|y;if(I.length){var V=Ku(I,C0(mW));P|=S}return Jh(x,P,v,I,V)});function gW(v,x,I){x=I?t:x;var P=Jh(v,_,t,t,t,t,t,x);return P.placeholder=gW.placeholder,P}function yW(v,x,I){x=I?t:x;var P=Jh(v,w,t,t,t,t,t,x);return P.placeholder=yW.placeholder,P}function bW(v,x,I){var P,V,K,le,xe,Me,et=0,nt=!1,ut=!1,Ft=!0;if(typeof v!="function")throw new jl(o);x=Zl(x)||0,Pi(I)&&(nt=!!I.leading,ut="maxWait"in I,K=ut?Ls(Zl(I.maxWait)||0,x):K,Ft="trailing"in I?!!I.trailing:Ft);function tn(ns){var Kc=P,rf=V;return P=V=t,et=ns,le=v.apply(rf,Kc),le}function yn(ns){return et=ns,xe=Ox(nr,x),nt?tn(ns):le}function qn(ns){var Kc=ns-Me,rf=ns-et,FW=x-Kc;return ut?Po(FW,K-rf):FW}function bn(ns){var Kc=ns-Me,rf=ns-et;return Me===t||Kc>=x||Kc<0||ut&&rf>=K}function nr(){var ns=Ok();if(bn(ns))return fr(ns);xe=Ox(nr,qn(ns))}function fr(ns){return xe=t,Ft&&P?tn(ns):(P=V=t,le)}function ll(){xe!==t&&IU(xe),et=0,P=Me=V=xe=t}function ca(){return xe===t?le:fr(Ok())}function cl(){var ns=Ok(),Kc=bn(ns);if(P=arguments,V=this,Me=ns,Kc){if(xe===t)return yn(Me);if(ut)return IU(xe),xe=Ox(nr,x),tn(Me)}return xe===t&&(xe=Ox(nr,x)),le}return cl.cancel=ll,cl.flush=ca,cl}var Pde=Kn(function(v,x){return aU(v,1,x)}),Dde=Kn(function(v,x,I){return aU(v,Zl(x)||0,I)});function Ode(v){return Jh(v,M)}function Fk(v,x){if(typeof v!="function"||x!=null&&typeof x!="function")throw new jl(o);var I=function(){var P=arguments,V=x?x.apply(this,P):P[0],K=I.cache;if(K.has(V))return K.get(V);var le=v.apply(this,P);return I.cache=K.set(V,le)||K,le};return I.cache=new(Fk.Cache||Yh),I}Fk.Cache=Yh;function Lk(v){if(typeof v!="function")throw new jl(o);return function(){var x=arguments;switch(x.length){case 0:return!v.call(this);case 1:return!v.call(this,x[0]);case 2:return!v.call(this,x[0],x[1]);case 3:return!v.call(this,x[0],x[1],x[2])}return!v.apply(this,x)}}function Fde(v){return pW(2,v)}var Lde=Che(function(v,x){x=x.length==1&&Fn(x[0])?Vr(x[0],Ut(dn())):Vr(bo(x,1),Ut(dn()));var I=x.length;return Kn(function(P){for(var V=-1,K=Po(P.length,I);++V<K;)P[V]=x[V].call(this,P[V]);return $o(v,this,P)})}),VR=Kn(function(v,x){var I=Ku(x,C0(VR));return Jh(v,S,t,x,I)}),vW=Kn(function(v,x){var I=Ku(x,C0(vW));return Jh(v,C,t,x,I)}),zde=Qh(function(v,x){return Jh(v,A,t,t,t,x)});function Bde(v,x){if(typeof v!="function")throw new jl(o);return x=x===t?x:Hn(x),Kn(v,x)}function Vde(v,x){if(typeof v!="function")throw new jl(o);return x=x==null?0:Ls(Hn(x),0),Kn(function(I){var P=I[x],V=sd(I,0,x);return P&&qu(V,P),$o(v,this,V)})}function Ude(v,x,I){var P=!0,V=!0;if(typeof v!="function")throw new jl(o);return Pi(I)&&(P="leading"in I?!!I.leading:P,V="trailing"in I?!!I.trailing:V),bW(v,x,{leading:P,maxWait:x,trailing:V})}function Wde(v){return dW(v,1)}function Hde(v,x){return VR(kR(x),v)}function Gde(){if(!arguments.length)return[];var v=arguments[0];return Fn(v)?v:[v]}function jde(v){return Xl(v,d)}function qde(v,x){return x=typeof x=="function"?x:t,Xl(v,d,x)}function Xde(v){return Xl(v,h|d)}function Kde(v,x){return x=typeof x=="function"?x:t,Xl(v,h|d,x)}function Yde(v,x){return x==null||oU(v,x,to(x))}function Xc(v,x){return v===x||v!==v&&x!==x}var Zde=Mk(dR),Jde=Mk(function(v,x){return v>=x}),Jp=fU(function(){return arguments}())?fU:function(v){return Wi(v)&&Pr.call(v,"callee")&&!JV.call(v,"callee")},Fn=Le.isArray,Qde=tk?Ut(tk):ahe;function Pa(v){return v!=null&&zk(v.length)&&!tf(v)}function ts(v){return Wi(v)&&Pa(v)}function epe(v){return v===!0||v===!1||Wi(v)&&aa(v)==ot}var od=pue||JR,tpe=vx?Ut(vx):lhe;function npe(v){return Wi(v)&&v.nodeType===1&&!Fx(v)}function rpe(v){if(v==null)return!0;if(Pa(v)&&(Fn(v)||typeof v=="string"||typeof v.splice=="function"||od(v)||k0(v)||Jp(v)))return!v.length;var x=Do(v);if(x==Ve||x==ye)return!v.size;if(Dx(v))return!gR(v).length;for(var I in v)if(Pr.call(v,I))return!1;return!0}function ipe(v,x){return $x(v,x)}function spe(v,x,I){I=typeof I=="function"?I:t;var P=I?I(v,x):t;return P===t?$x(v,x,t,I):!!P}function UR(v){if(!Wi(v))return!1;var x=aa(v);return x==ht||x==mt||typeof v.message=="string"&&typeof v.name=="string"&&!Fx(v)}function ope(v){return typeof v=="number"&&eU(v)}function tf(v){if(!Pi(v))return!1;var x=aa(v);return x==Ue||x==Be||x==Oe||x==it}function wW(v){return typeof v=="number"&&v==Hn(v)}function zk(v){return typeof v=="number"&&v>-1&&v%1==0&&v<=H}function Pi(v){var x=typeof v;return v!=null&&(x=="object"||x=="function")}function Wi(v){return v!=null&&typeof v=="object"}var xW=nk?Ut(nk):uhe;function ape(v,x){return v===x||mR(v,x,$R(x))}function lpe(v,x,I){return I=typeof I=="function"?I:t,mR(v,x,$R(x),I)}function cpe(v){return _W(v)&&v!=+v}function upe(v){if(qhe(v))throw new Dn(s);return dU(v)}function hpe(v){return v===null}function fpe(v){return v==null}function _W(v){return typeof v=="number"||Wi(v)&&aa(v)==ft}function Fx(v){if(!Wi(v)||aa(v)!=ee)return!1;var x=fk(v);if(x===null)return!0;var I=Pr.call(x,"constructor")&&x.constructor;return typeof I=="function"&&I instanceof I&&lk.call(I)==lue}var WR=rk?Ut(rk):hhe;function dpe(v){return wW(v)&&v>=-H&&v<=H}var SW=h0?Ut(h0):fhe;function Bk(v){return typeof v=="string"||!Fn(v)&&Wi(v)&&aa(v)==Je}function al(v){return typeof v=="symbol"||Wi(v)&&aa(v)==bt}var k0=f0?Ut(f0):dhe;function ppe(v){return v===t}function mpe(v){return Wi(v)&&Do(v)==pt}function gpe(v){return Wi(v)&&aa(v)==ce}var ype=Mk(yR),bpe=Mk(function(v,x){return v<=x});function CW(v){if(!v)return[];if(Pa(v))return Bk(v)?jc(v):Ra(v);if(Cx&&v[Cx])return iR(v[Cx]());var x=Do(v),I=x==Ve?Sx:x==ye?p0:T0;return I(v)}function nf(v){if(!v)return v===0?v:0;if(v=Zl(v),v===X||v===-X){var x=v<0?-1:1;return x*te}return v===v?v:0}function Hn(v){var x=nf(v),I=x%1;return x===x?I?x-I:x:0}function kW(v){return v?Xp(Hn(v),0,ae):0}function Zl(v){if(typeof v=="number")return v;if(al(v))return ge;if(Pi(v)){var x=typeof v.valueOf=="function"?v.valueOf():v;v=Pi(x)?x+"":x}if(typeof v!="string")return v===0?v:+v;v=fn(v);var I=Mo.test(v);return I||go.test(v)?Z$(v.slice(2),I?2:8):Ar.test(v)?ge:+v}function TW(v){return Zu(v,Da(v))}function vpe(v){return v?Xp(Hn(v),-H,H):v===0?v:0}function Mr(v){return v==null?"":ol(v)}var wpe=_0(function(v,x){if(Dx(x)||Pa(x)){Zu(x,to(x),v);return}for(var I in x)Pr.call(x,I)&&Ax(v,I,x[I])}),EW=_0(function(v,x){Zu(x,Da(x),v)}),Vk=_0(function(v,x,I,P){Zu(x,Da(x),v,P)}),xpe=_0(function(v,x,I,P){Zu(x,to(x),v,P)}),_pe=Qh(uR);function Spe(v,x){var I=x0(v);return x==null?I:sU(I,x)}var Cpe=Kn(function(v,x){v=Jr(v);var I=-1,P=x.length,V=P>2?x[2]:t;for(V&&la(x[0],x[1],V)&&(P=1);++I<P;)for(var K=x[I],le=Da(K),xe=-1,Me=le.length;++xe<Me;){var et=le[xe],nt=v[et];(nt===t||Xc(nt,b0[et])&&!Pr.call(v,et))&&(v[et]=K[et])}return v}),kpe=Kn(function(v){return v.push(t,HU),$o(IW,t,v)});function Tpe(v,x){return _x(v,dn(x,3),Yu)}function Epe(v,x){return _x(v,dn(x,3),fR)}function Ipe(v,x){return v==null?v:hR(v,dn(x,3),Da)}function Ape(v,x){return v==null?v:uU(v,dn(x,3),Da)}function Mpe(v,x){return v&&Yu(v,dn(x,3))}function Npe(v,x){return v&&fR(v,dn(x,3))}function $pe(v){return v==null?[]:_k(v,to(v))}function Rpe(v){return v==null?[]:_k(v,Da(v))}function HR(v,x,I){var P=v==null?t:Kp(v,x);return P===t?I:P}function Ppe(v,x){return v!=null&&qU(v,x,rhe)}function GR(v,x){return v!=null&&qU(v,x,ihe)}var Dpe=zU(function(v,x,I){x!=null&&typeof x.toString!="function"&&(x=ck.call(x)),v[x]=I},qR(Oa)),Ope=zU(function(v,x,I){x!=null&&typeof x.toString!="function"&&(x=ck.call(x)),Pr.call(v,x)?v[x].push(I):v[x]=[I]},dn),Fpe=Kn(Nx);function to(v){return Pa(v)?rU(v):gR(v)}function Da(v){return Pa(v)?rU(v,!0):phe(v)}function Lpe(v,x){var I={};return x=dn(x,3),Yu(v,function(P,V,K){Zh(I,x(P,V,K),P)}),I}function zpe(v,x){var I={};return x=dn(x,3),Yu(v,function(P,V,K){Zh(I,V,x(P,V,K))}),I}var Bpe=_0(function(v,x,I){Sk(v,x,I)}),IW=_0(function(v,x,I,P){Sk(v,x,I,P)}),Vpe=Qh(function(v,x){var I={};if(v==null)return I;var P=!1;x=Vr(x,function(K){return K=id(K,v),P||(P=K.length>1),K}),Zu(v,MR(v),I),P&&(I=Xl(I,h|f|d,Dhe));for(var V=x.length;V--;)_R(I,x[V]);return I});function Upe(v,x){return AW(v,Lk(dn(x)))}var Wpe=Qh(function(v,x){return v==null?{}:ghe(v,x)});function AW(v,x){if(v==null)return{};var I=Vr(MR(v),function(P){return[P]});return x=dn(x),wU(v,I,function(P,V){return x(P,V[0])})}function Hpe(v,x,I){x=id(x,v);var P=-1,V=x.length;for(V||(V=1,v=t);++P<V;){var K=v==null?t:v[Ju(x[P])];K===t&&(P=V,K=I),v=tf(K)?K.call(v):K}return v}function Gpe(v,x,I){return v==null?v:Rx(v,x,I)}function jpe(v,x,I,P){return P=typeof P=="function"?P:t,v==null?v:Rx(v,x,I,P)}var MW=UU(to),NW=UU(Da);function qpe(v,x,I){var P=Fn(v),V=P||od(v)||k0(v);if(x=dn(x,4),I==null){var K=v&&v.constructor;V?I=P?new K:[]:Pi(v)?I=tf(K)?x0(fk(v)):{}:I={}}return(V?Na:Yu)(v,function(le,xe,Me){return x(I,le,xe,Me)}),I}function Xpe(v,x){return v==null?!0:_R(v,x)}function Kpe(v,x,I){return v==null?v:kU(v,x,kR(I))}function Ype(v,x,I,P){return P=typeof P=="function"?P:t,v==null?v:kU(v,x,kR(I),P)}function T0(v){return v==null?[]:Rt(v,to(v))}function Zpe(v){return v==null?[]:Rt(v,Da(v))}function Jpe(v,x,I){return I===t&&(I=x,x=t),I!==t&&(I=Zl(I),I=I===I?I:0),x!==t&&(x=Zl(x),x=x===x?x:0),Xp(Zl(v),x,I)}function Qpe(v,x,I){return x=nf(x),I===t?(I=x,x=0):I=nf(I),v=Zl(v),she(v,x,I)}function eme(v,x,I){if(I&&typeof I!="boolean"&&la(v,x,I)&&(x=I=t),I===t&&(typeof x=="boolean"?(I=x,x=t):typeof v=="boolean"&&(I=v,v=t)),v===t&&x===t?(v=0,x=1):(v=nf(v),x===t?(x=v,v=0):x=nf(x)),v>x){var P=v;v=x,x=P}if(I||v%1||x%1){var V=tU();return Po(v+V*(x-v+bx("1e-"+((V+"").length-1))),x)}return vR(v,x)}var tme=S0(function(v,x,I){return x=x.toLowerCase(),v+(I?$W(x):x)});function $W(v){return jR(Mr(v).toLowerCase())}function RW(v){return v=Mr(v),v&&v.replace(Ni,Os).replace(mx,"")}function nme(v,x,I){v=Mr(v),x=ol(x);var P=v.length;I=I===t?P:Xp(Hn(I),0,P);var V=I;return I-=x.length,I>=0&&v.slice(I,V)==x}function rme(v){return v=Mr(v),v&&Bh.test(v)?v.replace(Vc,$a):v}function ime(v){return v=Mr(v),v&&Bn.test(v)?v.replace(wt,"\\$&"):v}var sme=S0(function(v,x,I){return v+(I?"-":"")+x.toLowerCase()}),ome=S0(function(v,x,I){return v+(I?" ":"")+x.toLowerCase()}),ame=OU("toLowerCase");function lme(v,x,I){v=Mr(v),x=Hn(x);var P=x?g0(v):0;if(!x||P>=x)return v;var V=(x-P)/2;return Ak(gk(V),I)+v+Ak(mk(V),I)}function cme(v,x,I){v=Mr(v),x=Hn(x);var P=x?g0(v):0;return x&&P<x?v+Ak(x-P,I):v}function ume(v,x,I){v=Mr(v),x=Hn(x);var P=x?g0(v):0;return x&&P<x?Ak(x-P,I)+v:v}function hme(v,x,I){return I||x==null?x=0:x&&(x=+x),bue(Mr(v).replace(sn,""),x||0)}function fme(v,x,I){return(I?la(v,x,I):x===t)?x=1:x=Hn(x),wR(Mr(v),x)}function dme(){var v=arguments,x=Mr(v[0]);return v.length<3?x:x.replace(v[1],v[2])}var pme=S0(function(v,x,I){return v+(I?"_":"")+x.toLowerCase()});function mme(v,x,I){return I&&typeof I!="number"&&la(v,x,I)&&(x=I=t),I=I===t?ae:I>>>0,I?(v=Mr(v),v&&(typeof x=="string"||x!=null&&!WR(x))&&(x=ol(x),!x&&xi(v))?sd(jc(v),0,I):v.split(x,I)):[]}var gme=S0(function(v,x,I){return v+(I?" ":"")+jR(x)});function yme(v,x,I){return v=Mr(v),I=I==null?0:Xp(Hn(I),0,v.length),x=ol(x),v.slice(I,I+x.length)==x}function bme(v,x,I){var P=q.templateSettings;I&&la(v,x,I)&&(x=t),v=Mr(v),x=Vk({},x,P,WU);var V=Vk({},x.imports,P.imports,WU),K=to(V),le=Rt(V,K),xe,Me,et=0,nt=x.interpolate||yo,ut="__p += '",Ft=sR((x.escape||yo).source+"|"+nt.source+"|"+(nt===re?xr:yo).source+"|"+(x.evaluate||yo).source+"|$","g"),tn="//# sourceURL="+(Pr.call(x,"sourceURL")?(x.sourceURL+"").replace(/\s/g," "):"lodash.templateSources["+ ++Y$+"]")+`
`;v.replace(Ft,function(bn,nr,fr,ll,ca,cl){return fr||(fr=ll),ut+=v.slice(et,cl).replace(Uh,Ro),nr&&(xe=!0,ut+=`' +
__e(`+nr+`) +
'`),ca&&(Me=!0,ut+=`';
`+ca+`;
__p += '`),fr&&(ut+=`' +
((__t = (`+fr+`)) == null ? '' : __t) +
'`),et=cl+bn.length,bn}),ut+=`';
`;var yn=Pr.call(x,"variable")&&x.variable;if(!yn)ut=`with (obj) {
`+ut+`
}
`;else if(hr.test(yn))throw new Dn(a);ut=(Me?ut.replace(Wl,""):ut).replace(mo,"$1").replace(Hl,"$1;"),ut="function("+(yn||"obj")+`) {
`+(yn?"":`obj || (obj = {});
`)+"var __t, __p = ''"+(xe?", __e = _.escape":"")+(Me?`, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`:`;
`)+ut+`return __p
}`;var qn=DW(function(){return Er(K,tn+"return "+ut).apply(t,le)});if(qn.source=ut,UR(qn))throw qn;return qn}function vme(v){return Mr(v).toLowerCase()}function wme(v){return Mr(v).toUpperCase()}function xme(v,x,I){if(v=Mr(v),v&&(I||x===t))return fn(v);if(!v||!(x=ol(x)))return v;var P=jc(v),V=jc(x),K=Vn(P,V),le=Ur(P,V)+1;return sd(P,K,le).join("")}function _me(v,x,I){if(v=Mr(v),v&&(I||x===t))return v.slice(0,XV(v)+1);if(!v||!(x=ol(x)))return v;var P=jc(v),V=Ur(P,jc(x))+1;return sd(P,0,V).join("")}function Sme(v,x,I){if(v=Mr(v),v&&(I||x===t))return v.replace(sn,"");if(!v||!(x=ol(x)))return v;var P=jc(v),V=Vn(P,jc(x));return sd(P,V).join("")}function Cme(v,x){var I=E,P=N;if(Pi(x)){var V="separator"in x?x.separator:V;I="length"in x?Hn(x.length):I,P="omission"in x?ol(x.omission):P}v=Mr(v);var K=v.length;if(xi(v)){var le=jc(v);K=le.length}if(I>=K)return v;var xe=I-g0(P);if(xe<1)return P;var Me=le?sd(le,0,xe).join(""):v.slice(0,xe);if(V===t)return Me+P;if(le&&(xe+=Me.length-xe),WR(V)){if(v.slice(xe).search(V)){var et,nt=Me;for(V.global||(V=sR(V.source,Mr(Zs.exec(V))+"g")),V.lastIndex=0;et=V.exec(nt);)var ut=et.index;Me=Me.slice(0,ut===t?xe:ut)}}else if(v.indexOf(ol(V),xe)!=xe){var Ft=Me.lastIndexOf(V);Ft>-1&&(Me=Me.slice(0,Ft))}return Me+P}function kme(v){return v=Mr(v),v&&Ps.test(v)?v.replace(Bc,eue):v}var Tme=S0(function(v,x,I){return v+(I?" ":"")+x.toUpperCase()}),jR=OU("toUpperCase");function PW(v,x,I){return v=Mr(v),x=I?t:x,x===t?Xu(v)?rue(v):rR(v):v.match(x)||[]}var DW=Kn(function(v,x){try{return $o(v,t,x)}catch(I){return UR(I)?I:new Dn(I)}}),Eme=Qh(function(v,x){return Na(x,function(I){I=Ju(I),Zh(v,I,BR(v[I],v))}),v});function Ime(v){var x=v==null?0:v.length,I=dn();return v=x?Vr(v,function(P){if(typeof P[1]!="function")throw new jl(o);return[I(P[0]),P[1]]}):[],Kn(function(P){for(var V=-1;++V<x;){var K=v[V];if($o(K[0],this,P))return $o(K[1],this,P)}})}function Ame(v){return ehe(Xl(v,h))}function qR(v){return function(){return v}}function Mme(v,x){return v==null||v!==v?x:v}var Nme=LU(),$me=LU(!0);function Oa(v){return v}function XR(v){return pU(typeof v=="function"?v:Xl(v,h))}function Rme(v){return gU(Xl(v,h))}function Pme(v,x){return yU(v,Xl(x,h))}var Dme=Kn(function(v,x){return function(I){return Nx(I,v,x)}}),Ome=Kn(function(v,x){return function(I){return Nx(v,I,x)}});function KR(v,x,I){var P=to(x),V=_k(x,P);I==null&&!(Pi(x)&&(V.length||!P.length))&&(I=x,x=v,v=this,V=_k(x,to(x)));var K=!(Pi(I)&&"chain"in I)||!!I.chain,le=tf(v);return Na(V,function(xe){var Me=x[xe];v[xe]=Me,le&&(v.prototype[xe]=function(){var et=this.__chain__;if(K||et){var nt=v(this.__wrapped__),ut=nt.__actions__=Ra(this.__actions__);return ut.push({func:Me,args:arguments,thisArg:v}),nt.__chain__=et,nt}return Me.apply(v,qu([this.value()],arguments))})}),v}function Fme(){return ps._===this&&(ps._=cue),this}function YR(){}function Lme(v){return v=Hn(v),Kn(function(x){return bU(x,v)})}var zme=ER(Vr),Bme=ER(ik),Vme=ER(ed);function OW(v){return PR(v)?ne(Ju(v)):yhe(v)}function Ume(v){return function(x){return v==null?t:Kp(v,x)}}var Wme=BU(),Hme=BU(!0);function ZR(){return[]}function JR(){return!1}function Gme(){return{}}function jme(){return""}function qme(){return!0}function Xme(v,x){if(v=Hn(v),v<1||v>H)return[];var I=ae,P=Po(v,ae);x=dn(x),v-=ae;for(var V=dt(P,x);++I<v;)x(I);return V}function Kme(v){return Fn(v)?Vr(v,Ju):al(v)?[v]:Ra(nW(Mr(v)))}function Yme(v){var x=++aue;return Mr(v)+x}var Zme=Ik(function(v,x){return v+x},0),Jme=IR("ceil"),Qme=Ik(function(v,x){return v/x},1),ege=IR("floor");function tge(v){return v&&v.length?xk(v,Oa,dR):t}function nge(v,x){return v&&v.length?xk(v,dn(x,2),dR):t}function rge(v){return W(v,Oa)}function ige(v,x){return W(v,dn(x,2))}function sge(v){return v&&v.length?xk(v,Oa,yR):t}function oge(v,x){return v&&v.length?xk(v,dn(x,2),yR):t}var age=Ik(function(v,x){return v*x},1),lge=IR("round"),cge=Ik(function(v,x){return v-x},0);function uge(v){return v&&v.length?Pe(v,Oa):0}function hge(v,x){return v&&v.length?Pe(v,dn(x,2)):0}return q.after=Rde,q.ary=dW,q.assign=wpe,q.assignIn=EW,q.assignInWith=Vk,q.assignWith=xpe,q.at=_pe,q.before=pW,q.bind=BR,q.bindAll=Eme,q.bindKey=mW,q.castArray=Gde,q.chain=uW,q.chunk=efe,q.compact=tfe,q.concat=nfe,q.cond=Ime,q.conforms=Ame,q.constant=qR,q.countBy=ude,q.create=Spe,q.curry=gW,q.curryRight=yW,q.debounce=bW,q.defaults=Cpe,q.defaultsDeep=kpe,q.defer=Pde,q.delay=Dde,q.difference=rfe,q.differenceBy=ife,q.differenceWith=sfe,q.drop=ofe,q.dropRight=afe,q.dropRightWhile=lfe,q.dropWhile=cfe,q.fill=ufe,q.filter=fde,q.flatMap=mde,q.flatMapDeep=gde,q.flatMapDepth=yde,q.flatten=oW,q.flattenDeep=hfe,q.flattenDepth=ffe,q.flip=Ode,q.flow=Nme,q.flowRight=$me,q.fromPairs=dfe,q.functions=$pe,q.functionsIn=Rpe,q.groupBy=bde,q.initial=mfe,q.intersection=gfe,q.intersectionBy=yfe,q.intersectionWith=bfe,q.invert=Dpe,q.invertBy=Ope,q.invokeMap=wde,q.iteratee=XR,q.keyBy=xde,q.keys=to,q.keysIn=Da,q.map=Dk,q.mapKeys=Lpe,q.mapValues=zpe,q.matches=Rme,q.matchesProperty=Pme,q.memoize=Fk,q.merge=Bpe,q.mergeWith=IW,q.method=Dme,q.methodOf=Ome,q.mixin=KR,q.negate=Lk,q.nthArg=Lme,q.omit=Vpe,q.omitBy=Upe,q.once=Fde,q.orderBy=_de,q.over=zme,q.overArgs=Lde,q.overEvery=Bme,q.overSome=Vme,q.partial=VR,q.partialRight=vW,q.partition=Sde,q.pick=Wpe,q.pickBy=AW,q.property=OW,q.propertyOf=Ume,q.pull=_fe,q.pullAll=lW,q.pullAllBy=Sfe,q.pullAllWith=Cfe,q.pullAt=kfe,q.range=Wme,q.rangeRight=Hme,q.rearg=zde,q.reject=Tde,q.remove=Tfe,q.rest=Bde,q.reverse=LR,q.sampleSize=Ide,q.set=Gpe,q.setWith=jpe,q.shuffle=Ade,q.slice=Efe,q.sortBy=$de,q.sortedUniq=Pfe,q.sortedUniqBy=Dfe,q.split=mme,q.spread=Vde,q.tail=Ofe,q.take=Ffe,q.takeRight=Lfe,q.takeRightWhile=zfe,q.takeWhile=Bfe,q.tap=tde,q.throttle=Ude,q.thru=Pk,q.toArray=CW,q.toPairs=MW,q.toPairsIn=NW,q.toPath=Kme,q.toPlainObject=TW,q.transform=qpe,q.unary=Wde,q.union=Vfe,q.unionBy=Ufe,q.unionWith=Wfe,q.uniq=Hfe,q.uniqBy=Gfe,q.uniqWith=jfe,q.unset=Xpe,q.unzip=zR,q.unzipWith=cW,q.update=Kpe,q.updateWith=Ype,q.values=T0,q.valuesIn=Zpe,q.without=qfe,q.words=PW,q.wrap=Hde,q.xor=Xfe,q.xorBy=Kfe,q.xorWith=Yfe,q.zip=Zfe,q.zipObject=Jfe,q.zipObjectDeep=Qfe,q.zipWith=ede,q.entries=MW,q.entriesIn=NW,q.extend=EW,q.extendWith=Vk,KR(q,q),q.add=Zme,q.attempt=DW,q.camelCase=tme,q.capitalize=$W,q.ceil=Jme,q.clamp=Jpe,q.clone=jde,q.cloneDeep=Xde,q.cloneDeepWith=Kde,q.cloneWith=qde,q.conformsTo=Yde,q.deburr=RW,q.defaultTo=Mme,q.divide=Qme,q.endsWith=nme,q.eq=Xc,q.escape=rme,q.escapeRegExp=ime,q.every=hde,q.find=dde,q.findIndex=iW,q.findKey=Tpe,q.findLast=pde,q.findLastIndex=sW,q.findLastKey=Epe,q.floor=ege,q.forEach=hW,q.forEachRight=fW,q.forIn=Ipe,q.forInRight=Ape,q.forOwn=Mpe,q.forOwnRight=Npe,q.get=HR,q.gt=Zde,q.gte=Jde,q.has=Ppe,q.hasIn=GR,q.head=aW,q.identity=Oa,q.includes=vde,q.indexOf=pfe,q.inRange=Qpe,q.invoke=Fpe,q.isArguments=Jp,q.isArray=Fn,q.isArrayBuffer=Qde,q.isArrayLike=Pa,q.isArrayLikeObject=ts,q.isBoolean=epe,q.isBuffer=od,q.isDate=tpe,q.isElement=npe,q.isEmpty=rpe,q.isEqual=ipe,q.isEqualWith=spe,q.isError=UR,q.isFinite=ope,q.isFunction=tf,q.isInteger=wW,q.isLength=zk,q.isMap=xW,q.isMatch=ape,q.isMatchWith=lpe,q.isNaN=cpe,q.isNative=upe,q.isNil=fpe,q.isNull=hpe,q.isNumber=_W,q.isObject=Pi,q.isObjectLike=Wi,q.isPlainObject=Fx,q.isRegExp=WR,q.isSafeInteger=dpe,q.isSet=SW,q.isString=Bk,q.isSymbol=al,q.isTypedArray=k0,q.isUndefined=ppe,q.isWeakMap=mpe,q.isWeakSet=gpe,q.join=vfe,q.kebabCase=sme,q.last=Yl,q.lastIndexOf=wfe,q.lowerCase=ome,q.lowerFirst=ame,q.lt=ype,q.lte=bpe,q.max=tge,q.maxBy=nge,q.mean=rge,q.meanBy=ige,q.min=sge,q.minBy=oge,q.stubArray=ZR,q.stubFalse=JR,q.stubObject=Gme,q.stubString=jme,q.stubTrue=qme,q.multiply=age,q.nth=xfe,q.noConflict=Fme,q.noop=YR,q.now=Ok,q.pad=lme,q.padEnd=cme,q.padStart=ume,q.parseInt=hme,q.random=eme,q.reduce=Cde,q.reduceRight=kde,q.repeat=fme,q.replace=dme,q.result=Hpe,q.round=lge,q.runInContext=Ae,q.sample=Ede,q.size=Mde,q.snakeCase=pme,q.some=Nde,q.sortedIndex=Ife,q.sortedIndexBy=Afe,q.sortedIndexOf=Mfe,q.sortedLastIndex=Nfe,q.sortedLastIndexBy=$fe,q.sortedLastIndexOf=Rfe,q.startCase=gme,q.startsWith=yme,q.subtract=cge,q.sum=uge,q.sumBy=hge,q.template=bme,q.times=Xme,q.toFinite=nf,q.toInteger=Hn,q.toLength=kW,q.toLower=vme,q.toNumber=Zl,q.toSafeInteger=vpe,q.toString=Mr,q.toUpper=wme,q.trim=xme,q.trimEnd=_me,q.trimStart=Sme,q.truncate=Cme,q.unescape=kme,q.uniqueId=Yme,q.upperCase=Tme,q.upperFirst=jR,q.each=hW,q.eachRight=fW,q.first=aW,KR(q,function(){var v={};return Yu(q,function(x,I){Pr.call(q.prototype,I)||(v[I]=x)}),v}(),{chain:!1}),q.VERSION=r,Na(["bind","bindKey","curry","curryRight","partial","partialRight"],function(v){q[v].placeholder=q}),Na(["drop","take"],function(v,x){ar.prototype[v]=function(I){I=I===t?1:Ls(Hn(I),0);var P=this.__filtered__&&!x?new ar(this):this.clone();return P.__filtered__?P.__takeCount__=Po(I,P.__takeCount__):P.__views__.push({size:Po(I,ae),type:v+(P.__dir__<0?"Right":"")}),P},ar.prototype[v+"Right"]=function(I){return this.reverse()[v](I).reverse()}}),Na(["filter","map","takeWhile"],function(v,x){var I=x+1,P=I==D||I==B;ar.prototype[v]=function(V){var K=this.clone();return K.__iteratees__.push({iteratee:dn(V,3),type:I}),K.__filtered__=K.__filtered__||P,K}}),Na(["head","last"],function(v,x){var I="take"+(x?"Right":"");ar.prototype[v]=function(){return this[I](1).value()[0]}}),Na(["initial","tail"],function(v,x){var I="drop"+(x?"":"Right");ar.prototype[v]=function(){return this.__filtered__?new ar(this):this[I](1)}}),ar.prototype.compact=function(){return this.filter(Oa)},ar.prototype.find=function(v){return this.filter(v).head()},ar.prototype.findLast=function(v){return this.reverse().find(v)},ar.prototype.invokeMap=Kn(function(v,x){return typeof v=="function"?new ar(this):this.map(function(I){return Nx(I,v,x)})}),ar.prototype.reject=function(v){return this.filter(Lk(dn(v)))},ar.prototype.slice=function(v,x){v=Hn(v);var I=this;return I.__filtered__&&(v>0||x<0)?new ar(I):(v<0?I=I.takeRight(-v):v&&(I=I.drop(v)),x!==t&&(x=Hn(x),I=x<0?I.dropRight(-x):I.take(x-v)),I)},ar.prototype.takeRightWhile=function(v){return this.reverse().takeWhile(v).reverse()},ar.prototype.toArray=function(){return this.take(ae)},Yu(ar.prototype,function(v,x){var I=/^(?:filter|find|map|reject)|While$/.test(x),P=/^(?:head|last)$/.test(x),V=q[P?"take"+(x=="last"?"Right":""):x],K=P||/^find/.test(x);V&&(q.prototype[x]=function(){var le=this.__wrapped__,xe=P?[1]:arguments,Me=le instanceof ar,et=xe[0],nt=Me||Fn(le),ut=function(nr){var fr=V.apply(q,qu([nr],xe));return P&&Ft?fr[0]:fr};nt&&I&&typeof et=="function"&&et.length!=1&&(Me=nt=!1);var Ft=this.__chain__,tn=!!this.__actions__.length,yn=K&&!Ft,qn=Me&&!tn;if(!K&&nt){le=qn?le:new ar(this);var bn=v.apply(le,xe);return bn.__actions__.push({func:Pk,args:[ut],thisArg:t}),new ql(bn,Ft)}return yn&&qn?v.apply(this,xe):(bn=this.thru(ut),yn?P?bn.value()[0]:bn.value():bn)})}),Na(["pop","push","shift","sort","splice","unshift"],function(v){var x=ok[v],I=/^(?:push|sort|unshift)$/.test(v)?"tap":"thru",P=/^(?:pop|shift)$/.test(v);q.prototype[v]=function(){var V=arguments;if(P&&!this.__chain__){var K=this.value();return x.apply(Fn(K)?K:[],V)}return this[I](function(le){return x.apply(Fn(le)?le:[],V)})}}),Yu(ar.prototype,function(v,x){var I=q[x];if(I){var P=I.name+"";Pr.call(w0,P)||(w0[P]=[]),w0[P].push({name:x,func:I})}}),w0[Ek(t,y).name]=[{name:"wrapper",func:t}],ar.prototype.clone=kue,ar.prototype.reverse=Tue,ar.prototype.value=Eue,q.prototype.at=nde,q.prototype.chain=rde,q.prototype.commit=ide,q.prototype.next=sde,q.prototype.plant=ade,q.prototype.reverse=lde,q.prototype.toJSON=q.prototype.valueOf=q.prototype.value=cde,q.prototype.first=q.prototype.head,Cx&&(q.prototype[Cx]=ode),q},y0=iue();Xh?((Xh.exports=y0)._=y0,u0._=y0):ps._=y0}).call(gt)})(GI,GI.exports);var IYe=GI.exports;/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var xO=function(n,e){return xO=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(t[i]=r[i])},xO(n,e)};function Eo(n,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");xO(n,e);function t(){this.constructor=n}n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var UB=function(n){var e="[object "+n+"]";return function(t){return AYe(t)===e}},AYe=function(n){return Object.prototype.toString.call(n)},rv=function(n){return n instanceof Date?n.getTime():Kw(n)?n.map(rv):n&&typeof n.toJSON=="function"?n.toJSON():n},Kw=UB("Array"),MYe=UB("Object"),NYe=UB("Function"),$Ye=function(n){return n&&(n.constructor===Object||n.constructor===Array||n.constructor.toString()==="function Object() { [native code] }"||n.constructor.toString()==="function Array() { [native code] }")&&!n.toJSON},_O=function(n,e){if(n==null&&n==e||n===e)return!0;if(Object.prototype.toString.call(n)!==Object.prototype.toString.call(e))return!1;if(Kw(n)){if(n.length!==e.length)return!1;for(var t=0,r=n.length;t<r;t++)if(!_O(n[t],e[t]))return!1;return!0}else if(MYe(n)){if(Object.keys(n).length!==Object.keys(e).length)return!1;for(var i in n)if(!_O(n[i],e[i]))return!1;return!0}return!1},SO=function(n,e,t,r,i,s){var o=e[r];if(Kw(n)&&isNaN(Number(o))){for(var a=0,l=n.length;a<l;a++)if(!SO(n[a],e,t,r,a,n))return!1}return r===e.length||n==null?t(n,i,s,r===0):SO(n[o],e,t,r+1,o,n)},Vu=function(){function n(e,t,r,i){this.params=e,this.owneryQuery=t,this.options=r,this.name=i,this.init()}return n.prototype.init=function(){},n.prototype.reset=function(){this.done=!1,this.keep=!1},n}(),WB=function(n){Eo(e,n);function e(t,r,i,s){var o=n.call(this,t,r,i)||this;return o.children=s,o}return e.prototype.reset=function(){this.keep=!1,this.done=!1;for(var t=0,r=this.children.length;t<r;t++)this.children[t].reset()},e.prototype.childrenNext=function(t,r,i,s){for(var o=!0,a=!0,l=0,c=this.children.length;l<c;l++){var u=this.children[l];if(u.done||u.next(t,r,i,s),u.keep||(a=!1),u.done){if(!u.keep)break}else o=!1}this.done=o,this.keep=a},e}(Vu),ute=function(n){Eo(e,n);function e(t,r,i,s,o){var a=n.call(this,t,r,i,s)||this;return a.name=o,a}return e}(WB),RYe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.next=function(t,r,i,s){this.childrenNext(t,r,i,s)},e}(WB),CO=function(n){Eo(e,n);function e(t,r,i,s,o){var a=n.call(this,r,i,s,o)||this;return a.keyPath=t,a.propop=!0,a._nextNestedValue=function(l,c,u,h){return a.childrenNext(l,c,u,h),!a.done},a}return e.prototype.next=function(t,r,i){SO(t,this.keyPath,this._nextNestedValue,0,r,i)},e}(WB),HB=function(n,e){if(n instanceof Function)return n;if(n instanceof RegExp)return function(r){var i=typeof r=="string"&&n.test(r);return n.lastIndex=0,i};var t=rv(n);return function(r){return e(t,rv(r))}},$p=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){this._test=HB(this.params,this.options.compare)},e.prototype.next=function(t,r,i){(!Array.isArray(i)||i.hasOwnProperty(r))&&this._test(t,r,i)&&(this.done=!0,this.keep=!0)},e}(Vu),PYe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.next=function(){this.done=!0,this.keep=!1},e}(Vu),DYe=function(n){return function(e,t,r,i){return e==null?new PYe(e,t,r,i):n(e,t,r,i)}},n$=function(n){return DYe(function(e,t,r,i){var s=typeof rv(e),o=n(e);return new $p(function(a){return typeof rv(a)===s&&o(a)},t,r,i)})},OYe=function(n,e,t,r){var i=r.operations[n];return i||hte(n),i(e,t,r,n)},hte=function(n){throw new Error("Unsupported operation: "+n)},fte=function(n,e){for(var t in n)if(e.operations.hasOwnProperty(t)||t.charAt(0)==="$")return!0;return!1},FYe=function(n,e,t,r,i){if(fte(e,i)){var s=dte(e,t,i),o=s[0],a=s[1];if(a.length)throw new Error("Property queries must contain only operations, or exact objects.");return new CO(n,e,r,i,o)}return new CO(n,e,r,i,[new $p(e,r,i)])},Yw=function(n,e,t){e===void 0&&(e=null);var r=t===void 0?{}:t,i=r.compare,s=r.operations,o={compare:i||_O,operations:Object.assign({},s||{})},a=dte(n,null,o),l=a[0],c=a[1],u=[];return l.length&&u.push(new CO([],n,e,o,l)),u.push.apply(u,c),u.length===1?u[0]:new RYe(n,e,o,u)},dte=function(n,e,t){var r=[],i=[];if(!$Ye(n))return r.push(new $p(n,n,t)),[r,i];for(var s in n)if(t.operations.hasOwnProperty(s)){var o=OYe(s,n[s],n,t);if(o&&!o.propop&&e&&!t.operations[e])throw new Error("Malformed query. "+s+" cannot be matched against property.");o!=null&&r.push(o)}else s.charAt(0)==="$"?hte(s):i.push(FYe(s.split("."),n[s],s,n,t));return[r,i]},LYe=function(n){return function(e,t,r){return n.reset(),n.next(e,t,r),n.keep}},zYe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){this._test=HB(this.params,this.options.compare)},e.prototype.reset=function(){n.prototype.reset.call(this),this.keep=!0},e.prototype.next=function(t){this._test(t)&&(this.done=!0,this.keep=!1)},e}(Vu),BYe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){if(!this.params||typeof this.params!="object")throw new Error("Malformed query. $elemMatch must by an object.");this._queryOperation=Yw(this.params,this.owneryQuery,this.options)},e.prototype.reset=function(){n.prototype.reset.call(this),this._queryOperation.reset()},e.prototype.next=function(t){if(Kw(t)){for(var r=0,i=t.length;r<i;r++){this._queryOperation.reset();var s=t[r];this._queryOperation.next(s,r,t,!1),this.keep=this.keep||this._queryOperation.keep}this.done=!0}else this.done=!1,this.keep=!1},e}(Vu),VYe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){this._queryOperation=Yw(this.params,this.owneryQuery,this.options)},e.prototype.reset=function(){n.prototype.reset.call(this),this._queryOperation.reset()},e.prototype.next=function(t,r,i,s){this._queryOperation.next(t,r,i,s),this.done=this._queryOperation.done,this.keep=!this._queryOperation.keep},e}(Vu),pte=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){},e.prototype.next=function(t){Kw(t)&&t.length===this.params&&(this.done=!0,this.keep=!0)},e}(Vu),mte=function(n){if(n.length===0)throw new Error("$and/$or/$nor must be a nonempty array")},gte=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!1,t}return e.prototype.init=function(){var t=this;mte(this.params),this._ops=this.params.map(function(r){return Yw(r,null,t.options)})},e.prototype.reset=function(){this.done=!1,this.keep=!1;for(var t=0,r=this._ops.length;t<r;t++)this._ops[t].reset()},e.prototype.next=function(t,r,i){for(var s=!1,o=!1,a=0,l=this._ops.length;a<l;a++){var c=this._ops[a];if(c.next(t,r,i),c.keep){s=!0,o=c.keep;break}}this.keep=o,this.done=s},e}(Vu),UYe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!1,t}return e.prototype.next=function(t,r,i){n.prototype.next.call(this,t,r,i),this.keep=!this.keep},e}(gte),yte=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){var t=this;this._testers=this.params.map(function(r){if(fte(r,t.options))throw new Error("cannot nest $ under "+t.name.toLowerCase());return HB(r,t.options.compare)})},e.prototype.next=function(t,r,i){for(var s=!1,o=!1,a=0,l=this._testers.length;a<l;a++){var c=this._testers[a];if(c(t)){s=!0,o=!0;break}}this.keep=o,this.done=s},e}(Vu),WYe=function(n){Eo(e,n);function e(t,r,i,s){var o=n.call(this,t,r,i,s)||this;return o.propop=!0,o._in=new yte(t,r,i,s),o}return e.prototype.next=function(t,r,i,s){this._in.next(t,r,i),Kw(i)&&!s?this._in.keep?(this.keep=!1,this.done=!0):r==i.length-1&&(this.keep=!0,this.done=!0):(this.keep=!this._in.keep,this.done=!0)},e.prototype.reset=function(){n.prototype.reset.call(this),this._in.reset()},e}(Vu),HYe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.next=function(t,r,i){i.hasOwnProperty(r)===this.params&&(this.done=!0,this.keep=!0)},e}(Vu),GYe=function(n){Eo(e,n);function e(t,r,i,s){var o=n.call(this,t,r,i,t.map(function(a){return Yw(a,r,i)}),s)||this;return o.propop=!1,mte(t),o}return e.prototype.next=function(t,r,i,s){this.childrenNext(t,r,i,s)},e}(ute),jYe=function(n){Eo(e,n);function e(t,r,i,s){var o=n.call(this,t,r,i,t.map(function(a){return Yw(a,r,i)}),s)||this;return o.propop=!0,o}return e.prototype.next=function(t,r,i,s){this.childrenNext(t,r,i,s)},e}(ute),qYe=function(n,e,t){return new $p(n,e,t)},XYe=function(n,e,t,r){return new zYe(n,e,t,r)},KYe=function(n,e,t,r){return new gte(n,e,t,r)},YYe=function(n,e,t,r){return new UYe(n,e,t,r)},ZYe=function(n,e,t,r){return new BYe(n,e,t,r)},JYe=function(n,e,t,r){return new WYe(n,e,t,r)},QYe=function(n,e,t,r){return new yte(n,e,t,r)},eZe=n$(function(n){return function(e){return e<n}}),tZe=n$(function(n){return function(e){return e<=n}}),nZe=n$(function(n){return function(e){return e>n}}),rZe=n$(function(n){return function(e){return e>=n}}),iZe=function(n,e,t){var r=n[0],i=n[1];return new $p(function(s){return rv(s)%r===i},e,t)},sZe=function(n,e,t,r){return new HYe(n,e,t,r)},oZe=function(n,e,t){return new $p(new RegExp(n,e.$options),e,t)},aZe=function(n,e,t,r){return new VYe(n,e,t,r)},NG={number:function(n){return typeof n=="number"},string:function(n){return typeof n=="string"},bool:function(n){return typeof n=="boolean"},array:function(n){return Array.isArray(n)},null:function(n){return n===null},timestamp:function(n){return n instanceof Date}},lZe=function(n,e,t){return new $p(function(r){if(typeof n=="string"){if(!NG[n])throw new Error("Type alias does not exist");return NG[n](r)}return r!=null?r instanceof n||r.constructor===n:!1},e,t)},cZe=function(n,e,t,r){return new GYe(n,e,t,r)},uZe=function(n,e,t,r){return new jYe(n,e,t,r)},hZe=function(n,e,t){return new pte(n,e,t,"$size")},fZe=function(){return null},dZe=function(n,e,t){var r;if(NYe(n))r=n;else if(!{}.CSP_ENABLED)r=new Function("obj","return "+n);else throw new Error('In CSP mode, sift does not support strings in "$where" condition');return new $p(function(i){return r.bind(i)(i)},e,t)},pZe=Object.freeze({__proto__:null,$Size:pte,$eq:qYe,$ne:XYe,$or:KYe,$nor:YYe,$elemMatch:ZYe,$nin:JYe,$in:QYe,$lt:eZe,$lte:tZe,$gt:nZe,$gte:rZe,$mod:iZe,$exists:sZe,$regex:oZe,$not:aZe,$type:lZe,$and:cZe,$all:uZe,$size:hZe,$options:fZe,$where:dZe}),mZe=function(n,e,t){var r=t===void 0?{}:t,i=r.compare,s=r.operations;return Yw(n,e,{compare:i,operations:Object.assign({},pZe,s||{})})},gZe=function(n,e){e===void 0&&(e={});var t=mZe(n,null,e);return LYe(t)};const $G=gZe;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yZe=Ie();yZe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var ic;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(ic||(ic={}));var RG;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(RG||(RG={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GB={};function bZe(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};GB[n]=t}function bte(n){return GB[n]}function vZe(n){delete GB[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F(n,e,t,r,i){const s=e.inputParams[n];if(s&&s.inputIndexStart!==void 0){const a=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd,c=a<0?e.inputNames.length+a:a;if(s.type==="tensor")return ao(e.inputNames[c],t,r,i);if(s.type==="tensors"){const f=e.inputs.slice(a,l);return e.inputNames.slice(a,l).filter((p,m)=>{var g;return((g=f[m])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(p=>ao(p,t,r,i))}const u=ao(e.inputNames[c],t,r,i),h=u.dataSync();return s.type==="number"?h[0]:El(u.shape,h)}const o=e.attrParams[n];return o&&o.value}function ao(n,e,t,r){const[i,s]=Ba(n,t);if(r!=null){const a=r.getHashTableHandleByName(i);if(a!=null)return a}const o=t.currentContextIds.find(a=>!!e[jI(i,a)]);return o!==void 0?e[jI(i,o)][s]:void 0}function PG(n,e,t){return e[jI(n,t.currentContextId)]}function yf(n,e){const[t,r,i]=Ba(n,e);return[jI(t,e&&e.currentContextId),r,i]}function jI(n,e){return e?`${n}-${e}`:n}function Ba(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const s=e.parseNodeNameCache.get(n);if(s!=null)return s}const r=n.split(":");let i;if(r.length===1)i=[n,0,void 0];else{const s=r[0],o=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);i=[s,a,o]}return t&&e.parseNodeNameCache.set(n,i),i}function zE(n,e,t){let r=F("pad",n,e,t);if(r==="explicit"){r=F("explicitPaddings",n,e,t);const i=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)i[s][0]=r[s*2],i[s][1]=r[s*2+1];return i}return r}function bf(n){return n.kept?n:mh(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wZe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],xZe=Object.freeze(Object.defineProperty({__proto__:null,json:wZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Ze=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],SZe=Object.freeze(Object.defineProperty({__proto__:null,json:_Ze},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CZe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],kZe=Object.freeze(Object.defineProperty({__proto__:null,json:CZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TZe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],EZe=Object.freeze(Object.defineProperty({__proto__:null,json:TZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IZe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],AZe=Object.freeze(Object.defineProperty({__proto__:null,json:IZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MZe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],NZe=Object.freeze(Object.defineProperty({__proto__:null,json:MZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Ze=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],RZe=Object.freeze(Object.defineProperty({__proto__:null,json:$Ze},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PZe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],DZe=Object.freeze(Object.defineProperty({__proto__:null,json:PZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OZe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],FZe=Object.freeze(Object.defineProperty({__proto__:null,json:OZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LZe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],zZe=Object.freeze(Object.defineProperty({__proto__:null,json:LZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BZe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],VZe=Object.freeze(Object.defineProperty({__proto__:null,json:BZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UZe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],WZe=Object.freeze(Object.defineProperty({__proto__:null,json:UZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HZe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],GZe=Object.freeze(Object.defineProperty({__proto__:null,json:HZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jZe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],qZe=Object.freeze(Object.defineProperty({__proto__:null,json:jZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XZe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],KZe=Object.freeze(Object.defineProperty({__proto__:null,json:XZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YZe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],ZZe=Object.freeze(Object.defineProperty({__proto__:null,json:YZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JZe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],QZe=Object.freeze(Object.defineProperty({__proto__:null,json:JZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eJe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],tJe=Object.freeze(Object.defineProperty({__proto__:null,json:eJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nJe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],rJe=Object.freeze(Object.defineProperty({__proto__:null,json:nJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DG{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[xZe,SZe,kZe,EZe,AZe,NZe,RZe,DZe,FZe,zZe,VZe,WZe,GZe,qZe,KZe,ZZe,QZe,tJe,rJe],t=[].concat(...e.map(r=>r.json));this.opMappers=t.reduce((r,i)=>(r[i.tfOpName]=i,r),{})}transformGraph(e,t={}){const r=e.node,i=[],s=[],o=[],a=r.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?i.push(m[g.name]):g.op==="Const"?s.push(m[g.name]):(g.input==null||g.input.length===0)&&o.push(m[g.name]),m),{});let l=[];const c=[];let u={},h={};t!=null&&(u=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const f=Object.keys(a);f.forEach(m=>{const g=a[m];g.inputNames.forEach((y,b)=>{const[_,,w]=yf(y),S=a[_];if(S.outputs!=null){const C=S.outputs.indexOf(w);if(C!==-1){const k=`${_}:${C}`;g.inputNames[b]=k}}g.inputs.push(S),S.children.push(g)})}),Object.keys(h).length===0?f.forEach(m=>{const g=a[m];g.children.length===0&&c.push(g)}):Object.keys(h).forEach(m=>{const[g]=yf(m),y=a[g];y!=null&&(y.signatureKey=h[m],c.push(y))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{const[g]=yf(m),y=a[g];y&&(y.signatureKey=u[m],l.push(y))}):l=i;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const p={nodes:a,inputs:l,outputs:c,weights:s,placeholders:i,signature:t,functions:d};return o.length>0&&(p.initNodes=o),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){const t=bte(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((i,s)=>(i[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},i),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((i,s)=>{const o=s.type;let a;switch(s.type){case"string":a=kO(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=kO(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=$O(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=$O(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=EO(e.attr,s.tfName,s.defaultValue||0),a===void 0&&s.tfDeprecatedName&&(a=EO(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=NO(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=NO(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=TO(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=TO(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=PO(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=PO(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=MO(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=MO(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=RO(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=RO(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=IO(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=IO(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=AO(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=AO(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=OG(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=OG(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return i[s.name]={value:a,type:o},i},{})),r}mapFunction(e){const t=e.nodeDef,r=[],i=[];let s={};t!=null&&(s=t.reduce((h,f)=>(h[f.name]=this.mapNode(f),f.op==="Const"&&i.push(h[f.name]),h),{}));const o=[],a=[];e.signature.inputArg.forEach(h=>{const[f]=yf(h.name),d={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:jB(h.type),type:"dtype"}},children:[]};d.signatureKey=h.name,o.push(d),s[f]=d}),Object.keys(s).forEach(h=>{const f=s[h];f.inputNames.forEach((d,p)=>{const[m,,g]=yf(d),y=s[m];if(y.outputs!=null){const b=y.outputs.indexOf(g);if(b!==-1){const _=`${m}:${b}`;f.inputNames[p]=_}}f.inputs.push(y),y.children.push(f)})});const c=e.ret;e.signature.outputArg.forEach(h=>{const[f,d]=yf(c[h.name]),p=s[f];p!=null&&(p.defaultOutput=d,a.push(p))});const u=this.mapArgsToSignature(e);return{nodes:s,inputs:o,outputs:a,weights:i,placeholders:r,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}function iJe(n){const e=Ie().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function vte(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):iJe(n);return e?t:t.toLowerCase()}function kO(n,e,t,r=!1){const i=n[e];return i!=null?vte(i.s,r):t}function TO(n,e,t){const r=n[e];return r?r.b:t}function EO(n,e,t){const r=n[e]||{},i=r.i!=null?r.i:r.f!=null?r.f:t;return typeof i=="number"?i:parseInt(i,10)}function jB(n){switch(typeof n=="string"&&(n=ic[n]),n){case ic.DT_FLOAT:case ic.DT_HALF:return"float32";case ic.DT_INT32:case ic.DT_INT64:case ic.DT_INT8:case ic.DT_UINT8:return"int32";case ic.DT_BOOL:return"bool";case ic.DT_DOUBLE:return"float32";case ic.DT_STRING:return"string";default:return null}}function OG(n,e,t){const r=n[e];return r&&r.func?r.func.name:t}function IO(n,e,t){const r=n[e];return r&&r.type?jB(r.type):t}function AO(n,e,t){const r=n[e];return r&&r.list&&r.list.type?r.list.type.map(i=>jB(i)):t}function wte(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function MO(n,e,t){const r=n[e];return r&&r.shape?wte(r.shape):t}function NO(n,e,t){const r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):t}function $O(n,e,t,r=!1){const i=n[e];return i&&i.list&&i.list.s?i.list.s.map(s=>vte(s,r)):t}function RO(n,e,t){const r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(i=>wte(i)):t}function PO(n,e,t){const r=n[e];return r&&r.list&&r.list.b?r.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sJe{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(i=>this.getInput(i)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((i,s)=>(i[s]=this.getAttr(s),i),{}))}getInput(e){return ao(e,this.tensorMap,this.context)}getAttr(e,t){const r=this.node.rawAttrs[e];if(r.tensor!=null)return ao(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return EO(this.node.rawAttrs,e,t);if(r.s!=null)return kO(this.node.rawAttrs,e,t);if(r.b!=null)return TO(this.node.rawAttrs,e,t);if(r.shape!=null)return MO(this.node.rawAttrs,e,t);if(r.type!=null)return IO(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return NO(this.node.rawAttrs,e,t);if(r.list.s!=null)return $O(this.node.rawAttrs,e,t);if(r.list.shape!=null)return RO(this.node.rawAttrs,e,t);if(r.list.b!=null)return PO(this.node.rawAttrs,e,t);if(r.list.type!=null)return AO(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fo=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:TL,abs:vs,acos:kX,acosh:TX,add:Xe,addN:EX,all:OL,any:_I,argMax:ig,argMin:IX,asin:AX,asinh:MX,atan:NX,atan2:$X,atanh:RX,avgPool:$M,avgPool3d:LL,basicLSTMCell:PX,batchNorm:G2,batchNorm2d:zL,batchNorm3d:BL,batchNorm4d:VL,batchToSpaceND:RM,bincount:UL,bitwiseAnd:DX,booleanMaskAsync:HK,broadcastArgs:OX,broadcastTo:Ab,buffer:Sn,cast:St,ceil:FX,clipByValue:_a,clone:mh,complex:Rf,concat:li,concat1d:WL,concat2d:HL,concat3d:GL,concat4d:jL,conv1d:qL,conv2d:tp,conv2dTranspose:KL,conv3d:YL,conv3dTranspose:ZL,cos:PM,cosh:JL,cosineWindow:JM,cumprod:SI,cumsum:QL,denseBincount:CI,depthToSpace:zX,depthwiseConv2d:j2,diag:BX,dilation2d:VX,div:Lt,divNoNan:UX,dot:WX,dropout:Iz,einsum:Am,elu:q2,enclosingPowerOfTwo:Az,ensureShape:HX,equal:xu,erf:GX,euclideanNorm:XX,exp:Jo,expandDims:ss,expm1:KX,eye:DM,fft:qM,fill:$y,floor:X2,floorDiv:DL,fused:QK,gather:K2,gatherND:XK,greater:tl,greaterEqual:Tp,ifft:C_,imag:Y2,image:Ss,inTopKAsync:KK,irfft:xz,isFinite:YX,isInf:ZX,isNaN:JX,leakyRelu:OM,less:S_,lessEqual:Ry,linalg:$z,linspace:QX,localResponseNormalization:eK,log:$l,log1p:FM,logSigmoid:nK,logSoftmax:tz,logSumExp:zM,logicalAnd:_h,logicalNot:BM,logicalOr:nz,logicalXor:rK,losses:iY,lowerBound:iK,matMul:Gn,max:vc,maxPool:UM,maxPool3d:rz,maxPoolWithArgmax:sK,maximum:Uf,mean:Di,meshgrid:oK,min:__,minimum:rp,mirrorPad:iz,mod:aK,moments:Z2,movingAverage:GK,mul:fe,multiRNNCell:lK,multinomial:cK,neg:ci,norm:Ew,notEqual:qb,oneHot:Xb,ones:ga,onesLike:Rl,op:he,outerProduct:uK,pad:_u,pad1d:hK,pad2d:fK,pad3d:dK,pad4d:pK,pool:mK,pow:np,prelu:HM,print:PL,prod:gK,raggedGather:yK,raggedRange:bK,raggedTensorToTensor:vK,rand:wK,randomGamma:kK,randomNormal:GM,randomStandardNormal:TK,randomUniform:Ep,randomUniformInt:EK,range:og,real:Kb,reciprocal:IK,relu:Dh,relu6:pz,reshape:ve,reverse:kc,reverse1d:AK,reverse2d:MK,reverse3d:NK,reverse4d:$K,rfft:XM,round:mz,rsqrt:gz,scalar:Qt,scatterND:jK,searchSorted:VM,selu:yz,separableConv2d:bz,setdiff1dAsync:RK,sigmoid:Il,sign:PK,signal:rY,sin:vz,sinh:wz,slice:pn,slice1d:J2,slice2d:jM,slice3d:Q2,slice4d:Yb,softmax:eC,softplus:Iw,spaceToBatchND:WM,sparse:sY,sparseToDense:qK,spectral:nY,split:Ga,sqrt:_o,square:Or,squaredDifference:_z,squeeze:br,stack:Sa,step:Mw,stridedSlice:DK,string:oY,sub:Dt,sum:Kt,tan:OK,tanh:jb,tensor:Ts,tensor1d:Xi,tensor2d:ja,tensor3d:Sz,tensor4d:FK,tensor5d:LK,tensor6d:zK,tensorScatterUpdate:BK,tile:dc,topk:VK,transpose:ir,truncatedNormal:YM,unique:UK,unsortedSegmentSum:kz,unstack:Tc,upperBound:WK,variable:Tz,where:xo,whereAsync:Ez,zeros:pi,zerosLike:ur},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oJe=(n,e,t,r=fo)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(F("a",n,e,t),F("b",n,e,t))];case"AddN":return[r.addN(F("tensors",n,e,t))];case"FloorMod":case"Mod":return[r.mod(F("a",n,e,t),F("b",n,e,t))];case"Mul":return[r.mul(F("a",n,e,t),F("b",n,e,t))];case"RealDiv":case"Div":return[r.div(F("a",n,e,t),F("b",n,e,t))];case"DivNoNan":return[r.divNoNan(F("a",n,e,t),F("b",n,e,t))];case"FloorDiv":return[r.floorDiv(F("a",n,e,t),F("b",n,e,t))];case"Sub":return[r.sub(F("a",n,e,t),F("b",n,e,t))];case"Minimum":return[r.minimum(F("a",n,e,t),F("b",n,e,t))];case"Maximum":return[r.maximum(F("a",n,e,t),F("b",n,e,t))];case"Pow":return[r.pow(F("a",n,e,t),F("b",n,e,t))];case"SquaredDifference":return[r.squaredDifference(F("a",n,e,t),F("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aJe=(n,e,t,r=fo)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(F("x",n,e,t))];case"Acos":return[r.acos(F("x",n,e,t))];case"Acosh":return[r.acosh(F("x",n,e,t))];case"Asin":return[r.asin(F("x",n,e,t))];case"Asinh":return[r.asinh(F("x",n,e,t))];case"Atan":return[r.atan(F("x",n,e,t))];case"Atan2":return[r.atan2(F("x",n,e,t),F("y",n,e,t))];case"Atanh":return[r.atanh(F("x",n,e,t))];case"Ceil":return[r.ceil(F("x",n,e,t))];case"Complex":return[r.complex(F("real",n,e,t),F("imag",n,e,t))];case"Cos":return[r.cos(F("x",n,e,t))];case"Cosh":return[r.cosh(F("x",n,e,t))];case"Elu":return[r.elu(F("x",n,e,t))];case"Erf":return[r.erf(F("x",n,e,t))];case"Exp":return[r.exp(F("x",n,e,t))];case"Expm1":return[r.expm1(F("x",n,e,t))];case"Floor":return[r.floor(F("x",n,e,t))];case"Log":return[r.log(F("x",n,e,t))];case"Log1p":return[r.log1p(F("x",n,e,t))];case"Imag":return[r.imag(F("x",n,e,t))];case"Neg":return[r.neg(F("x",n,e,t))];case"Reciprocal":return[r.reciprocal(F("x",n,e,t))];case"Real":return[r.real(F("x",n,e,t))];case"Relu":return[r.relu(F("x",n,e,t))];case"Round":return[r.round(F("x",n,e,t))];case"Selu":return[r.selu(F("x",n,e,t))];case"Sigmoid":return[r.sigmoid(F("x",n,e,t))];case"Sin":return[r.sin(F("x",n,e,t))];case"Sign":return[r.sign(F("x",n,e,t))];case"Sinh":return[r.sinh(F("x",n,e,t))];case"Softplus":return[r.softplus(F("x",n,e,t))];case"Sqrt":return[r.sqrt(F("x",n,e,t))];case"Square":return[r.square(F("x",n,e,t))];case"Tanh":return[r.tanh(F("x",n,e,t))];case"Tan":return[r.tan(F("x",n,e,t))];case"ClipByValue":return[r.clipByValue(F("x",n,e,t),F("clipValueMin",n,e,t),F("clipValueMax",n,e,t))];case"Relu6":return[r.relu6(F("x",n,e,t))];case"Rsqrt":return[r.rsqrt(ao(n.inputNames[0],e,t))];case"LeakyRelu":return[r.leakyRelu(F("x",n,e,t),F("alpha",n,e,t))];case"Prelu":return[r.prelu(F("x",n,e,t),F("alpha",n,e,t))];case"IsNan":return[r.isNaN(ao(n.inputNames[0],e,t))];case"IsInf":return[r.isInf(ao(n.inputNames[0],e,t))];case"IsFinite":return[r.isFinite(ao(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oc(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){U(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){const i=n[r],s=e[r];U(i<0||s<0||i===s,()=>t+` Shapes ${n} and ${e} must match`)}}}function FG(n){return!(typeof n=="number"||n.some(e=>e<0))}function Vx(n,e,t){let r=DO(n,t);const i=!FG(r);if(i&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(i&&e.forEach(s=>{r=DO(s.shape,r)}),!FG(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function DO(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let r=0;r<n.length;++r){const i=n[r],s=e[r];if(i>=0&&s>=0&&i!==s)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=i>=0?i:s}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lJe{constructor(e,t,r,i,s,o,a){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=i,this.identicalElementShapes=s,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Qt(0),qi(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),oc(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,qi(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,i)=>this.write(r,t[i]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let i=0;i<this.size();i++)e.push(i)}if(e.length===0)return Ts([],[0].concat(this.elementShape));const r=this.readMany(e);return oc(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Sa(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Ts([],[0].concat(this.elementShape));const t=[];for(let i=0;i<this.size();i++)t.push(i);const r=this.readMany(t);return oc(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),li(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,Tc(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0;const i=e.map(l=>(r+=l,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=r===0?0:t.size/r,o=[];Se(()=>{t=ve(t,[1,r,s]);for(let l=0;l<e.length;++l){const u=[0,l===0?0:i[l-1],0],h=[1,e[l],s];o[l]=ve(pn(t,u,h),this.elementShape)}return o});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dg{get id(){return this.idTensor.id}constructor(e,t,r,i=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e!=null&&e.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);oc(t,s.shape,"TensorList shape mismatch: "),qi(s)}),this.idTensor=Qt(0),this.maxNumElements=i,qi(this.idTensor)}copy(){return new dg([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);oc(e,this.elementShape,"TensorList shape mismatch: ");const i=Vx(this.elementShape,this.tensors,e);return Se(()=>{const s=this.tensors.map(o=>ve(o,i));return Sa(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Vx(this.elementShape,this.tensors,e),i=this.tensors.pop();return i.kept=!1,oc(i.shape,e,"TensorList shape mismatch: "),ve(i,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(oc(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");qi(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new dg([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)t.tensors[r]=this.tensors[r];return t}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);oc(this.tensors[e].shape,t,"TensorList shape mismatch: ");const i=Vx(this.elementShape,this.tensors,t);return ve(this.tensors[e],i)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);oc(this.elementShape,t.shape,"TensorList shape mismatch: "),qi(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);oc(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=Vx(this.elementShape,this.tensors,r);return e.length===0?Ts([],[0].concat(i)):Se(()=>{const s=e.map(o=>ve(this.tensors[o],i));return Sa(s,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);oc(this.elementShape,t,"TensorList shape mismatch: ");const r=Vx(this.elementShape,this.tensors,t);return this.size()===0?Ts([],[0].concat(r)):Se(()=>{const i=this.tensors.map(s=>ve(s,r));return li(i,0)})}}function cJe(n,e,t){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const i=n.shape.slice(1);oc(i,e,"TensorList shape mismatch: ");const s=Tc(n);return new dg(s,e,r)}function uJe(n,e,t,r){return new dg([],n,e,r)}function hJe(n,e,t,r){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const i=Math.max(...e);if(r!=null&&r!==-1&&i>=r)throw new Error(`Max index must be < array size (${i}  vs. ${r})`);const s=new dg([],t,n.dtype,r),o=Tc(n,0);return e.forEach((a,l)=>{s.setItem(a,o[l])}),s}function fJe(n,e,t){let r=0;const i=e.map(u=>(r+=u,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);const s=n.shape.slice(1),o=DO(s,t),a=r===0?0:n.size/r,l=Se(()=>{const u=[];n=ve(n,[1,r,a]);for(let h=0;h<e.length;++h){const d=[0,h===0?0:i[h-1],0],p=[1,e[h],a];u[h]=ve(pn(n,d,p),o)}return n.dispose(),u}),c=new dg([],t,n.dtype,e.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dJe=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const r=F("thenBranch",n,e,t),i=F("elseBranch",n,e,t),s=F("cond",n,e,t),o=F("args",n,e,t);return(await s.data())[0]?t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[i].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const r=F("body",n,e,t),i=F("cond",n,e,t),s=F("args",n,e,t),o=await t.functionMap[i].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),a=s.map(u=>u.id);let l=await o[0].data();o.forEach(u=>{!u.kept&&a.indexOf(u.id)===-1&&u.dispose()});let c=s;for(;l[0];){const u=c;c=await t.functionMap[r].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);const h=c.map(d=>d.id);u.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()});const f=await t.functionMap[i].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);l=await f[0].data(),f.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()})}return c}case"LoopCond":{const r=F("pred",n,e,t);return[bf(r)]}case"Switch":{const r=F("pred",n,e,t);let i=F("data",n,e,t);return i.kept||(i=bf(i)),(await r.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const r=n.inputNames.find(i=>ao(i,e,t)!==void 0);if(r){const i=ao(r,e,t);return[bf(i)]}return}case"Enter":{const r=F("frameName",n,e,t),i=F("tensor",n,e,t);return t.enterFrame(r),[bf(i)]}case"Exit":{const r=F("tensor",n,e,t);return t.exitFrame(),[bf(r)]}case"NextIteration":{const r=F("tensor",n,e,t);return t.nextIteration(),[bf(r)]}case"TensorArrayV3":{const r=F("size",n,e,t),i=F("dtype",n,e,t),s=F("elementShape",n,e,t),o=F("dynamicSize",n,e,t),a=F("clearAfterRead",n,e,t),l=F("identicalElementShapes",n,e,t),c=F("name",n,e,t),u=new lJe(c,i,r,s,l,o,a);return t.addTensorArray(u),[u.idTensor,Qt(1)]}case"TensorArrayWriteV3":{const r=F("tensorArrayId",n,e,t),i=F("index",n,e,t),s=F("tensor",n,e,t),o=t.getTensorArray(r.id);return o.write(i,s),[o.idTensor]}case"TensorArrayReadV3":{const r=F("tensorArrayId",n,e,t),i=F("index",n,e,t);return[t.getTensorArray(r.id).read(i)]}case"TensorArrayGatherV3":{const r=F("tensorArrayId",n,e,t),i=F("indices",n,e,t),s=F("dtype",n,e,t);return[t.getTensorArray(r.id).gather(i,s)]}case"TensorArrayScatterV3":{const r=F("tensorArrayId",n,e,t),i=F("indices",n,e,t),s=F("tensor",n,e,t),o=t.getTensorArray(r.id);return o.scatter(i,s),[o.idTensor]}case"TensorArrayConcatV3":{const r=F("tensorArrayId",n,e,t),i=t.getTensorArray(r.id),s=F("dtype",n,e,t);return[i.concat(s)]}case"TensorArraySplitV3":{const r=F("tensorArrayId",n,e,t),i=F("tensor",n,e,t),s=F("lengths",n,e,t),o=t.getTensorArray(r.id);return o.split(s,i),[o.idTensor]}case"TensorArraySizeV3":{const r=F("tensorArrayId",n,e,t),i=t.getTensorArray(r.id);return[Qt(i.size(),"int32")]}case"TensorArrayCloseV3":{const r=F("tensorArrayId",n,e,t),i=t.getTensorArray(r.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const r=F("tensorListId",n,e,t),i=F("index",n,e,t),s=F("tensor",n,e,t),o=t.getTensorList(r.id);return o.setItem(i,s),[o.idTensor]}case"TensorListGetItem":{const r=F("tensorListId",n,e,t),i=F("index",n,e,t),s=F("elementShape",n,e,t),o=F("elementDType",n,e,t);return[t.getTensorList(r.id).getItem(i,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=F("indices",n,e,t),i=F("tensor",n,e,t),s=F("elementShape",n,e,t),o=F("numElements",n,e,t),a=hJe(i,r,s,o);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=F("elementShape",n,e,t),i=F("elementDType",n,e,t);let s;n.op==="TensorListReserve"?s="numElements":s="maxNumElements";const o=F(s,n,e,t),a=n.op==="TensorListReserve"?-1:o,l=uJe(r,i,o,a);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const r=F("tensorListId",n,e,t),i=F("indices",n,e,t),s=F("elementShape",n,e,t),o=F("elementDType",n,e,t);return[t.getTensorList(r.id).gather(i,o,s)]}case"TensorListStack":{const r=F("tensorListId",n,e,t),i=F("elementShape",n,e,t),s=F("elementDType",n,e,t),o=F("numElements",n,e,t);return[t.getTensorList(r.id).stack(i,s,o)]}case"TensorListFromTensor":{const r=F("tensor",n,e,t),i=F("elementShape",n,e,t),s=F("elementDType",n,e,t),o=cJe(r,i,s);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=F("tensorListId",n,e,t),i=t.getTensorList(r.id),s=F("dtype",n,e,t),o=F("elementShape",n,e,t);return[i.concat(s,o)]}case"TensorListPushBack":{const r=F("tensorListId",n,e,t),i=F("tensor",n,e,t),s=t.getTensorList(r.id);return s.pushBack(i),[s.idTensor]}case"TensorListPopBack":{const r=F("tensorListId",n,e,t),i=F("elementShape",n,e,t),s=F("elementDType",n,e,t);return[t.getTensorList(r.id).popBack(i,s)]}case"TensorListSplit":{const r=F("tensor",n,e,t),i=F("elementShape",n,e,t),s=F("lengths",n,e,t),o=fJe(r,s,i);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=F("tensorListId",n,e,t),i=t.getTensorList(r.id);return[Qt(i.size(),"int32")]}case"TensorListResize":{const r=F("tensorListId",n,e,t),i=F("size",n,e,t),o=t.getTensorList(r.id).resize(i);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LG(n,e,t){const[r,i]=F("fusedOps",n,e,t),s=r==="biasadd",o=!s,a=i==="prelu",l=r==="fusedbatchnorm",c=F("numArgs",n,e,t);if(s){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=F("strides",n,e,t),h=zE(n,e,t),f=F("dataFormat",n,e,t).toUpperCase(),d=F("dilations",n,e,t);let[p,m]=F("args",n,e,t);o&&(m=p,p=void 0);const g=F("leakyreluAlpha",n,e,t);return{stride:u,pad:h,dataFormat:f,dilations:d,biasArg:p,preluArg:m,activationFunc:i,leakyreluAlpha:g}}const pJe=(n,e,t,r=fo)=>{switch(n.op){case"Conv1D":{const i=F("stride",n,e,t),s=F("pad",n,e,t),o=F("dataFormat",n,e,t).toUpperCase(),a=F("dilation",n,e,t);return[r.conv1d(F("x",n,e,t),F("filter",n,e,t),i,s,o,a)]}case"Conv2D":{const i=F("strides",n,e,t),s=zE(n,e,t),o=F("dataFormat",n,e,t).toUpperCase(),a=F("dilations",n,e,t);return[r.conv2d(F("x",n,e,t),F("filter",n,e,t),[i[1],i[2]],s,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:i,pad:s,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=LG(n,e,t);return[r.fused.conv2d({x:F("x",n,e,t),filter:F("filter",n,e,t),strides:[i[1],i[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:s,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=LG(n,e,t);return[r.fused.depthwiseConv2d({x:F("x",n,e,t),filter:F("filter",n,e,t),strides:[i[1],i[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=F("outputShape",n,e,t),s=F("strides",n,e,t),o=zE(n,e,t);return[r.conv2dTranspose(F("x",n,e,t),F("filter",n,e,t),i,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=F("strides",n,e,t),s=zE(n,e,t),o=F("dilations",n,e,t),a=F("dataFormat",n,e,t).toUpperCase();return[r.depthwiseConv2d(F("input",n,e,t),F("filter",n,e,t),[i[1],i[2]],s,a,[o[1],o[2]])]}case"Conv3D":{const i=F("strides",n,e,t),s=F("pad",n,e,t),o=F("dataFormat",n,e,t).toUpperCase(),a=F("dilations",n,e,t);return[r.conv3d(F("x",n,e,t),F("filter",n,e,t),[i[1],i[2],i[3]],s,o,[a[1],a[2],a[3]])]}case"AvgPool":{const i=F("strides",n,e,t),s=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.avgPool(F("x",n,e,t),[o[1],o[2]],[i[1],i[2]],s)]}case"MaxPool":{const i=F("strides",n,e,t),s=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.maxPool(F("x",n,e,t),[o[1],o[2]],[i[1],i[2]],s)]}case"MaxPoolWithArgmax":{const i=F("strides",n,e,t),s=F("pad",n,e,t),o=F("kernelSize",n,e,t),a=F("includeBatchInIndex",n,e,t),{result:l,indexes:c}=r.maxPoolWithArgmax(F("x",n,e,t),[o[1],o[2]],[i[1],i[2]],s,a);return[l,c]}case"AvgPool3D":{const i=F("strides",n,e,t),s=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.avgPool3d(F("x",n,e,t),[o[1],o[2],o[3]],[i[1],i[2],i[3]],s)]}case"MaxPool3D":{const i=F("strides",n,e,t),s=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.maxPool3d(F("x",n,e,t),[o[1],o[2],o[3]],[i[1],i[2],i[3]],s)]}case"Dilation2D":{const i=F("strides",n,e,t),s=F("pad",n,e,t),o=F("dilations",n,e,t),a=i[1],l=i[2],c=o[1],u=o[2];return[r.dilation2d(F("x",n,e,t),F("filter",n,e,t),[a,l],s,[c,u],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mJe=(n,e,t,r=fo)=>{switch(n.op){case"Fill":{const i=F("shape",n,e,t),s=F("dtype",n,e,t),o=F("value",n,e,t);return[r.fill(i,o,s)]}case"LinSpace":{const i=F("start",n,e,t),s=F("stop",n,e,t),o=F("num",n,e,t);return[r.linspace(i,s,o)]}case"Multinomial":{const i=F("logits",n,e,t),s=F("numSamples",n,e,t),o=F("seed",n,e,t);return[r.multinomial(i,s,o)]}case"OneHot":{const i=F("indices",n,e,t),s=F("depth",n,e,t),o=F("onValue",n,e,t),a=F("offValue",n,e,t),l=F("dtype",n,e,t);return[r.oneHot(i,s,o,a,l)]}case"Ones":return[r.ones(F("shape",n,e,t),F("dtype",n,e,t))];case"OnesLike":return[r.onesLike(F("x",n,e,t))];case"RandomStandardNormal":return[r.randomStandardNormal(F("shape",n,e,t),F("dtype",n,e,t),F("seed",n,e,t))];case"RandomUniform":return[r.randomUniform(F("shape",n,e,t),F("minval",n,e,t),F("maxval",n,e,t),F("dtype",n,e,t))];case"RandomUniformInt":return[r.randomUniformInt(F("shape",n,e,t),F("minval",n,e,t),F("maxval",n,e,t),F("seed",n,e,t))];case"Range":{const i=F("start",n,e,t),s=F("stop",n,e,t),o=F("step",n,e,t);return[r.range(i,s,o,F("dtype",n,e,t))]}case"TruncatedNormal":{const i=F("shape",n,e,t),s=F("mean",n,e,t),o=F("stdDev",n,e,t),a=F("seed",n,e,t);return[r.truncatedNormal(i,s,o,F("dtype",n,e,t),a)]}case"Zeros":return[r.zeros(F("shape",n,e,t),F("dtype",n,e,t))];case"ZerosLike":return[r.zerosLike(F("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w3(n,e,t){const r=F("boxes",n,e,t),i=F("scores",n,e,t),s=F("maxOutputSize",n,e,t),o=F("iouThreshold",n,e,t),a=F("scoreThreshold",n,e,t),l=F("softNmsSigma",n,e,t);return{boxes:r,scores:i,maxOutputSize:s,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const gJe=async(n,e,t,r,i=fo)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c,softNmsSigma:u}=w3(n,e,t),h=await i.image.nonMaxSuppressionWithScoreAsync(s,o,a,l,c,u);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=w3(n,e,t),u=F("padToMaxOutputSize",n,e,t),h=await i.image.nonMaxSuppressionPaddedAsync(s,o,a,l,c,u);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=w3(n,e,t);return[await i.image.nonMaxSuppressionAsync(s,o,a,l,c)]}case"Where":{const s=i.cast(F("condition",n,e,t),"bool"),o=[await i.whereAsync(s)];return s.dispose(),o}case"ListDiff":return i.setdiff1dAsync(F("x",n,e,t),F("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yJe=(n,e,t,r=fo)=>{switch(n.op){case"LowerBound":{const i=F("sortedSequence",n,e,t),s=F("values",n,e,t);return[r.lowerBound(i,s)]}case"TopKV2":{const i=F("x",n,e,t),s=F("k",n,e,t),o=F("sorted",n,e,t),a=r.topk(i,s,o);return[a.values,a.indices]}case"UpperBound":{const i=F("sortedSequence",n,e,t),s=F("values",n,e,t);return[r.upperBound(i,s)]}case"Unique":{const i=F("x",n,e,t),s=r.unique(i);return[s.values,s.indices]}case"UniqueV2":{const i=F("x",n,e,t),s=F("axis",n,e,t),o=r.unique(i,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bJe=(n,e,t,r=fo)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const i=F("default",n,e,t);return[ao(n.name,e,t)||i];case"Placeholder":return[ao(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const u=F("x",n,e,t);return[bf(u)]}case"IdentityN":return F("x",n,e,t).map(u=>bf(u));case"Snapshot":const s=F("x",n,e,t);return[bf(s)];case"Shape":return[r.tensor1d(F("x",n,e,t).shape,"int32")];case"ShapeN":return F("x",n,e,t).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(F("x",n,e,t).size,"int32")];case"Rank":return[r.scalar(F("x",n,e,t).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=F("x",n,e,t),a=F("data",n,e,t),l=F("message",n,e,t),c=F("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vJe{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Qt(0),this.tensorMap=new Map,qi(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Qt(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),Se(()=>{const i=Tc(t),s=r.length,o=i.length;U(s===o,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${o} elements.`);for(let a=0;a<s;a++){const l=r[a],c=i[a];qi(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return Se(()=>{const i=[];for(let s=0;s<r.length;s++){const o=r[s],a=this.findWithDefault(o,t);i.push(a)}return Sa(i)})}findWithDefault(e,t){const r=this.tensorMap.get(e);return r??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wJe=async(n,e,t,r)=>{switch(n.op){case"HashTable":case"HashTableV2":{const i=r.getHashTableHandleByName(n.name);if(i!=null)return[i];{const s=F("keyDType",n,e,t),o=F("valueDType",n,e,t),a=new vJe(s,o);return r.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=F("tableHandle",n,e,t,r),s=F("keys",n,e,t),o=F("values",n,e,t);return[await r.getHashTableById(i.id).import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const i=F("tableHandle",n,e,t,r),s=F("keys",n,e,t),o=F("defaultValue",n,e,t);return[await r.getHashTableById(i.id).find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=F("tableHandle",n,e,t,r);return[r.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xJe=(n,e,t,r=fo)=>{switch(n.op){case"ResizeBilinear":{const i=F("images",n,e,t),s=F("size",n,e,t),o=F("alignCorners",n,e,t),a=F("halfPixelCenters",n,e,t);return[r.image.resizeBilinear(i,[s[0],s[1]],o,a)]}case"ResizeNearestNeighbor":{const i=F("images",n,e,t),s=F("size",n,e,t),o=F("alignCorners",n,e,t),a=F("halfPixelCenters",n,e,t);return[r.image.resizeNearestNeighbor(i,[s[0],s[1]],o,a)]}case"CropAndResize":{const i=F("image",n,e,t),s=F("boxes",n,e,t),o=F("boxInd",n,e,t),a=F("cropSize",n,e,t),l=F("method",n,e,t),c=F("extrapolationValue",n,e,t);return[r.image.cropAndResize(i,s,o,a,l,c)]}case"ImageProjectiveTransformV3":{const i=F("images",n,e,t),s=F("transforms",n,e,t),o=F("outputShape",n,e,t),a=F("fillValue",n,e,t),l=F("interpolation",n,e,t),c=F("fillMode",n,e,t);return[r.image.transform(i,s,l.toLowerCase(),c.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Je=(n,e,t,r=fo)=>{switch(n.op){case"Equal":return[r.equal(F("a",n,e,t),F("b",n,e,t))];case"NotEqual":return[r.notEqual(F("a",n,e,t),F("b",n,e,t))];case"Greater":return[r.greater(F("a",n,e,t),F("b",n,e,t))];case"GreaterEqual":return[r.greaterEqual(F("a",n,e,t),F("b",n,e,t))];case"Less":return[r.less(F("a",n,e,t),F("b",n,e,t))];case"LessEqual":return[r.lessEqual(F("a",n,e,t),F("b",n,e,t))];case"LogicalAnd":return[r.logicalAnd(F("a",n,e,t),F("b",n,e,t))];case"LogicalNot":return[r.logicalNot(F("a",n,e,t))];case"LogicalOr":return[r.logicalOr(F("a",n,e,t),F("b",n,e,t))];case"Select":case"SelectV2":return[r.where(F("condition",n,e,t),F("a",n,e,t),F("b",n,e,t))];case"BitwiseAnd":return[r.bitwiseAnd(F("a",n,e,t),F("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SJe=(n,e,t,r=fo)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(F("a",n,e,t),F("b",n,e,t),F("transposeA",n,e,t),F("transposeB",n,e,t))];case"Einsum":return[r.einsum(F("equation",n,e,t),...F("tensors",n,e,t))];case"Transpose":return[r.transpose(F("x",n,e,t),F("perm",n,e,t))];case"_FusedMatMul":const[i,s]=F("fusedOps",n,e,t),o=i==="biasadd",a=s==="prelu",l=F("numArgs",n,e,t),c=F("leakyreluAlpha",n,e,t);if(o){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,h]=F("args",n,e,t);return[r.fused.matMul({a:F("a",n,e,t),b:F("b",n,e,t),transposeA:F("transposeA",n,e,t),transposeB:F("transposeB",n,e,t),bias:u,activation:s,preluActivationWeights:h,leakyreluAlpha:c})];case"MatrixBandPart":return[r.linalg.bandPart(F("a",n,e,t),F("numLower",n,e,t),F("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CJe=(n,e,t,r=fo)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(F("x",n,e,t),F("axis",n,e,t),F("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(F("x",n,e,t),F("mean",n,e,t),F("variance",n,e,t),F("offset",n,e,t),F("scale",n,e,t),F("epsilon",n,e,t))];case"FusedBatchNormV3":return[r.batchNorm(F("x",n,e,t),F("mean",n,e,t),F("variance",n,e,t),F("offset",n,e,t),F("scale",n,e,t),F("epsilon",n,e,t))];case"LRN":return[r.localResponseNormalization(F("x",n,e,t),F("radius",n,e,t),F("bias",n,e,t),F("alpha",n,e,t),F("beta",n,e,t))];case"Softmax":return[r.softmax(F("x",n,e,t))];case"LogSoftmax":return[r.logSoftmax(F("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kJe=(n,e,t,r=fo)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:i,outputDenseValues:s}=r.raggedGather(F("paramsNestedSplits",n,e,t),F("paramsDenseValues",n,e,t),F("indices",n,e,t),F("outputRaggedRank",n,e,t));return i.concat(s)}case"RaggedRange":{const{rtNestedSplits:i,rtDenseValues:s}=r.raggedRange(F("starts",n,e,t),F("limits",n,e,t),F("splits",n,e,t));return[i,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(F("shape",n,e,t),F("values",n,e,t),F("defaultValue",n,e,t),F("rowPartitionTensors",n,e,t),F("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TJe=(n,e,t,r=fo)=>{switch(n.op){case"Max":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.max(F("x",n,e,t),a,l)]}case"Mean":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.mean(F("x",n,e,t),a,l)]}case"Min":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.min(F("x",n,e,t),a,l)]}case"Sum":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.sum(F("x",n,e,t),a,l)]}case"All":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.all(F("x",n,e,t),a,l)]}case"Any":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.any(F("x",n,e,t),a,l)]}case"ArgMax":{const a=F("axis",n,e,t);return[r.argMax(F("x",n,e,t),a)]}case"ArgMin":{const a=F("axis",n,e,t);return[r.argMin(F("x",n,e,t),a)]}case"Prod":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.prod(F("x",n,e,t),a,l)]}case"Cumprod":{const a=F("axis",n,e,t),l=F("exclusive",n,e,t),c=F("reverse",n,e,t);return[r.cumprod(F("x",n,e,t),a,l,c)]}case"Cumsum":{const a=F("axis",n,e,t),l=F("exclusive",n,e,t),c=F("reverse",n,e,t);return[r.cumsum(F("x",n,e,t),a,l,c)]}case"Bincount":const i=F("x",n,e,t),s=F("weights",n,e,t),o=F("size",n,e,t);return[r.bincount(i,s,o)];case"DenseBincount":{const a=F("x",n,e,t),l=F("weights",n,e,t),c=F("size",n,e,t),u=F("binaryOutput",n,e,t);return[r.denseBincount(a,l,c,u)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EJe=(n,e,t,r=fo)=>{switch(n.op){case"ConcatV2":case"Concat":{const i=F("n",n,e,t),s=F("axis",n,e,t);let o=F("tensors",n,e,t);return o=o.slice(0,i),[r.concat(o,s)]}case"Gather":{const i=F("x",n,e,t),s=F("indices",n,e,t);return[r.gather(i,r.cast(s,"int32"),0)]}case"GatherV2":{const i=F("axis",n,e,t),s=F("batchDims",n,e,t),o=F("x",n,e,t),a=F("indices",n,e,t);return[r.gather(o,r.cast(a,"int32"),i,s)]}case"Reverse":{const i=F("dims",n,e,t),s=[];for(let a=0;a<i.length;a++)i[a]&&s.push(a);const o=F("x",n,e,t);return[r.reverse(o,s)]}case"ReverseV2":{const i=F("axis",n,e,t),s=F("x",n,e,t);return[r.reverse(s,i)]}case"Slice":{const i=F("begin",n,e,t),s=F("size",n,e,t);return[r.slice(F("x",n,e,t),i,s)]}case"StridedSlice":{const i=F("begin",n,e,t),s=F("end",n,e,t),o=F("strides",n,e,t),a=F("beginMask",n,e,t),l=F("endMask",n,e,t),c=F("ellipsisMask",n,e,t),u=F("newAxisMask",n,e,t),h=F("shrinkAxisMask",n,e,t),f=F("x",n,e,t);return[r.stridedSlice(f,i,s,o,a,l,c,u,h)]}case"Pack":return Se(()=>{const i=F("axis",n,e,t),s=F("tensors",n,e,t),o=s[0].shape,a=r.squeeze(s[0]).shape,l=s.map(c=>{const u=Rn(c.shape,o);if(!u&&!Rn(r.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return u?c:r.reshape(c,o)});return[r.stack(l,i)]});case"Unpack":{const i=F("axis",n,e,t),s=F("tensor",n,e,t);return r.unstack(s,i)}case"Tile":{const i=F("reps",n,e,t);return[r.tile(F("x",n,e,t),i)]}case"Split":case"SplitV":{const i=F("axis",n,e,t),s=F("numOrSizeSplits",n,e,t),o=F("x",n,e,t);return r.split(o,s,i)}case"ScatterNd":{const i=F("indices",n,e,t),s=F("values",n,e,t),o=F("shape",n,e,t);return[r.scatterND(i,s,o)]}case"GatherNd":{const i=F("x",n,e,t),s=F("indices",n,e,t);return[r.gatherND(i,s)]}case"SparseToDense":{const i=F("sparseIndices",n,e,t),s=F("outputShape",n,e,t),o=F("sparseValues",n,e,t),a=F("defaultValue",n,e,t);return[r.sparseToDense(i,o,s,o.dtype===a.dtype?a:r.cast(a,o.dtype))]}case"TensorScatterUpdate":{const i=F("indices",n,e,t),s=F("values",n,e,t),o=F("tensor",n,e,t);return[r.tensorScatterUpdate(o,i,s)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IJe=(n,e,t,r=fo)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:s,emptyRowIndicator:o,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(F("indices",n,e,t),F("values",n,e,t),F("denseShape",n,e,t),F("defaultValue",n,e,t));return[i,s,o,a]}case"SparseReshape":{const{outputIndices:i,outputShape:s}=r.sparse.sparseReshape(F("inputIndices",n,e,t),F("inputShape",n,e,t),F("newShape",n,e,t));return[i,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(F("data",n,e,t),F("indices",n,e,t),F("segmentIds",n,e,t))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(F("data",n,e,t),F("indices",n,e,t),F("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AJe=(n,e,t,r=fo)=>{switch(n.op){case"FFT":return[r.fft(F("x",n,e,t))];case"IFFT":return[r.ifft(F("x",n,e,t))];case"RFFT":return[r.rfft(F("x",n,e,t))];case"IRFFT":return[r.irfft(F("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MJe=(n,e,t,r=fo)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(F("input",n,e,t),F("pattern",n,e,t),F("rewrite",n,e,t),F("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:i,nGramsSplits:s}=r.string.stringNGrams(F("data",n,e,t),F("dataSplits",n,e,t),F("separator",n,e,t),F("nGramWidths",n,e,t),F("leftPad",n,e,t),F("rightPad",n,e,t),F("padWidth",n,e,t),F("preserveShortSequences",n,e,t));return[i,s]}case"StringSplit":{const{indices:i,values:s,shape:o}=r.string.stringSplit(F("input",n,e,t),F("delimiter",n,e,t),F("skipEmpty",n,e,t));return[i,s,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(F("input",n,e,t),F("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NJe=(n,e,t,r=fo)=>{switch(n.op){case"Cast":return[r.cast(F("x",n,e,t),F("dtype",n,e,t))];case"ExpandDims":{const i=F("axis",n,e,t);return[r.expandDims(F("x",n,e,t),i)]}case"Squeeze":{const i=F("axis",n,e,t);return[r.squeeze(F("x",n,e,t),i)]}case"Reshape":return[r.reshape(F("x",n,e,t),F("shape",n,e,t))];case"EnsureShape":return[r.ensureShape(F("x",n,e,t),F("shape",n,e,t))];case"MirrorPad":return[r.mirrorPad(F("x",n,e,t),F("padding",n,e,t),F("mode",n,e,t))];case"PadV2":case"Pad":return[r.pad(F("x",n,e,t),F("padding",n,e,t),F("constantValue",n,e,t))];case"SpaceToBatchND":{const i=F("blockShape",n,e,t),s=F("paddings",n,e,t);return[r.spaceToBatchND(F("x",n,e,t),i,s)]}case"BatchToSpaceND":{const i=F("blockShape",n,e,t),s=F("crops",n,e,t);return[r.batchToSpaceND(F("x",n,e,t),i,s)]}case"DepthToSpace":{const i=F("blockSize",n,e,t),s=F("dataFormat",n,e,t).toUpperCase();return[r.depthToSpace(F("x",n,e,t),i,s)]}case"BroadcastTo":return[r.broadcastTo(F("x",n,e,t),F("shape",n,e,t))];case"BroadcastArgs":return[r.broadcastArgs(F("s0",n,e,t),F("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zG(n,e,t,r,i=Se){const s=((o,a,l)=>{switch(o.category){case"arithmetic":return i(()=>oJe(o,a,l));case"basic_math":return i(()=>aJe(o,a,l));case"control":return dJe(o,a,l);case"convolution":return i(()=>pJe(o,a,l));case"creation":return i(()=>mJe(o,a,l));case"dynamic":return gJe(o,a,l);case"evaluation":return i(()=>yJe(o,a,l));case"image":return i(()=>xJe(o,a,l));case"graph":return i(()=>bJe(o,a,l));case"logical":return i(()=>_Je(o,a,l));case"matrices":return i(()=>SJe(o,a,l));case"normalization":return i(()=>CJe(o,a,l));case"ragged":return i(()=>kJe(o,a,l));case"reduction":return i(()=>TJe(o,a,l));case"slice_join":return i(()=>EJe(o,a,l));case"sparse":return i(()=>IJe(o,a,l));case"spectral":return i(()=>AJe(o,a,l));case"string":return i(()=>MJe(o,a,l));case"transformation":return i(()=>NJe(o,a,l));case"hash_table":return wJe(o,a,l,r);case"custom":const c=bte(o.op);if(c&&c.customExecutor)return c.customExecutor(new sJe(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Qd(s)?s.then(o=>[].concat(o)):[].concat(s)}class BG{constructor(e={},t={},r={},i={},s){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=i,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VG(n,e,t,r){const i=new Set,s=[];let o=null,a=null;const l=new Set,c=new Set(Object.keys(n).map(f=>Ba(f)[0]));r=r||[];const u=new Set(r.map(f=>Ba(f.name)[0])),h=[...e];for(;h.length>0;){const f=h.pop();if(($m(f)||zJe(f)||BJe(f))&&o==null&&(o=f,a=o.children.map(d=>d.name).filter(d=>i.has(d))),i.add(f.name),t[f.name]==null&&!c.has(f.name)&&!u.has(f.name)){if(f.inputs.length===0){s.push(f.name);continue}f.inputs.forEach(d=>{l.has(d.name)||(l.add(d.name),h.push(d))})}}return{inputs:n,outputs:e,usedNodes:i,missingInputs:s,dynamicNode:o,syncInputs:a}}function $Je(n,e){const{usedNodes:t,inputs:r}=e,i=Object.keys(r).map(g=>Ba(g)[0]).map(g=>n.nodes[g]),s=n.initNodes||[],o=g=>t.has(typeof g=="string"?g:g.name);function a(g){return[...new Map(g.map(y=>[y.name,y])).values()]}const l=a([...i,...n.weights,...s]).filter(o),c=a([...l,...Object.values(n.nodes)]).filter(o),u=new Map(c.map(g=>[g.name,g])),h={};for(const g of c){h[g.name]=h[g.name]||0;for(const y of g.children)o(y)||(h[y.name]=Number.POSITIVE_INFINITY),h[y.name]=(h[y.name]||0)+1}const f=Object.entries(h).filter(([,g])=>g===0).map(([g])=>g),d=[...f];for(;f.length>0;){const g=f.pop(),y=u.get(g);for(const b of y.children.filter(o))--h[b.name]===0&&(d.push(b.name),f.push(b.name))}const p=d.map(g=>u.get(g)),m=RJe(p,l);return PJe(m,l),m}function RJe(n,e){const t=new Map(n.map(o=>[o.name,o])),r=e.map(o=>o.name),i=new Set(r);for(;r.length>0;){const o=r.pop(),a=t.get(o);for(const l of a.children)!t.has(l.name)||i.has(l.name)||(i.add(l.name),r.push(l.name))}return n.filter(o=>i.has(o.name))}class iT extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function PJe(n,e){const t=new Map(n.map((a,l)=>[a.name,l])),r=new Set(e.map(a=>a.name)),i=a=>r.has(typeof a=="string"?a:a.name),s=new Set(n.map(a=>a.name)),o=a=>s.has(typeof a=="string"?a:a.name);for(const a of n){for(const l of a.children.filter(o)){if(!t.has(l.name))throw new iT(`Child ${l.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(l.name))throw new iT(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!i(a))for(const l of a.inputs){if(!t.has(l.name))throw new iT(`Input ${l.name} of node ${a.name} is unreachable.`);if(t.get(l.name)>t.get(a.name))throw new iT(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function DJe(n){const e=new Map(n.map((a,l)=>[a.name,l])),t=Number.MAX_SAFE_INTEGER,r=n.map((a,l)=>$m(a)?t:l),i=a=>{const l=r[e.get(a.name)];return l??-1},s=n.map((a,l)=>a.children.map(i).reduce((c,u)=>Math.max(c,u),r[l])),o=new Map;for(let a=0;a<n.length;++a){const l=s[a];if(l===t)continue;const c=n[a],u=n[l];o.has(u.name)||o.set(u.name,[]),o.get(u.name).push(c)}return o}const OJe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),FJe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),LJe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function $m(n){return OJe.has(n.op)}function zJe(n){return FJe.has(n.op)}function BJe(n){return LJe.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qI{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(r=>e[r].map(i=>i.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new qI(e.functions[r],this)})}getCompilationKey(e,t){const r=e.map(s=>s.name).sort(),i=t.map(s=>s.name).sort();return r.join(this.SEPARATOR)+"--"+i.join(this.SEPARATOR)}compile(e,t){const r=VG(e,t,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:s,syncInputs:o}=r;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(i.length>0){const c=t.map(h=>h.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${u}]. Missing the following inputs: [${i}]`)}const a=$Je(this.graph,r),l=DJe(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return qi(t),t}cloneTensorList(e){return e?e.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,r])=>[t,this.cloneTensorList(r)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const i=r.map(f=>this.graph.nodes[Ba(f)[0]]),s=t.map(f=>Ba(f)[0]),o=new Set(s);let a=s.map(f=>this.graph.nodes[f]);a.length===0&&(a=this._outputs);const l=this.getCompilationKey(i,a);let c=this.compiledMap.get(l);c==null&&(c=this.compile(e,a),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=Ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const u={},h={};return Se(()=>{const f=new BG(this.weightMap,u,h,this.functionExecutorMap,this.parseNodeNameCache),d=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(y=>{const[b,_]=Ba(y,f),w=[];w[_]=e[y],d[b]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(w))});const p=this.getFrozenTensorIds(d),{orderedNodes:m,nodeLiveUntilMap:g}=c;for(const y of m){if(d[y.name])continue;const b=zG(y,d,f,this._resourceManager);if(Qd(b))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);d[y.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,d,f,p,o,g.get(y.name))}return this.parent==null&&f.dispose(p),t.map(y=>ao(y,d,f))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(i=>i.id)));return new Set(t)}checkTensorForDisposal(e,t,r,i,s,o,a){if(!($m(t)||o.has(e))){for(const l of r[e])l!=null&&(a[l.id]=(a[l.id]||0)+t.children.length);for(const l of t.inputs){if($m(l))continue;const c=PG(l.name,r,i);if(c!=null)for(const u of c){if(!u||u.kept||s.has(u.id))continue;const h=a[u.id];h===1?(u.dispose(),delete a[u.id]):h!=null&&a[u.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,r,i,s,o){function a(l){return $m(l)||s.has(l.name)}if(!($m(e)||o==null))for(const l of o){if(a(l))continue;const c=PG(l.name,t,r);for(const u of c)!u||u.kept||i.has(u.id)||u.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,r=!1,i={},s={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const o=new BG(this.weightMap,i,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,o,t,r),l=t.map(f=>ao(f,a,o)),c=l.map(f=>f.id),u=Object.keys(e).map(f=>e[f].id),h=new Set([...c,...u,...this.weightIds]);return Object.values(a).forEach(f=>{f.forEach(d=>{d&&!d.isDisposed&&!h.has(d.id)&&d.dispose()})}),this.parent==null&&o.dispose(h),l}async executeFunctionAsync(e,t,r){const i=e.reduce((s,o,a)=>(s[this.inputs[a].name]=o,s),{});return this._executeAsync(i,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,i){const s=Object.keys(e),o=s.map(w=>this.graph.nodes[Ba(w)[0]]),a=r.map(w=>Ba(w)[0]),l=new Set(a);let c=a.map(w=>this.graph.nodes[w]);c.length===0&&(c=this._outputs);const{usedNodes:u,missingInputs:h,dynamicNode:f,syncInputs:d}=VG(e,c,this.weightMap,this._initNodes),p=[...o,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:t.currentContext})),m=Object.assign({},this.weightMap);Object.keys(e).forEach(w=>{const[S,C]=Ba(w),k=[];k[C]=e[w],m[S]=k});const g={},y=this.getFrozenTensorIds(m),b={};for(;p.length>0;){const w=this.processStack(o,p,t,m,b,y,l,g,u);await Promise.all(w)}f==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const _=c.filter(w=>!$m(w)&&!ao(w.name,m,t)).map(w=>w.name);if(_.length>0){let w="";throw f!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${_}] from the provided inputs [${s}]. Consider providing the following inputs: [${h}]. ${w}`)}return m}processStack(e,t,r,i,s,o,a,l,c){const u=[];for(;t.length>0;){const h=t.pop();r.currentContext=h.contexts;let f="";if(h.node.op==="Enter"&&F("isConstant",h.node,i,r)&&([f]=yf(h.node.name,r)),i[h.node.name]==null){const d=zG(h.node,i,r,this._resourceManager);f||([f]=yf(h.node.name,r));const p=r.currentContext;Qd(d)?u.push(d.then(m=>(i[f]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(m)),r.currentContext=p,this.checkTensorForDisposal(f,h.node,i,r,o,a,l),this.processChildNodes(h.node,t,r,i,s,c),m))):(i[f]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(d)),this.checkTensorForDisposal(f,h.node,i,r,o,a,l),this.processChildNodes(h.node,t,r,i,s,c))}else this.processChildNodes(h.node,t,r,i,s,c)}return u}processChildNodes(e,t,r,i,s,o){e.children.forEach(a=>{const[l]=yf(a.name,r);s[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!ao(c,i,r))&&(s[l]=!0,t.push({contexts:r.currentContext,node:a})):a.inputNames.every(c=>!!ao(c,i,r))&&(s[l]=!0,t.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const r=e[t],[i]=Ba(t),s=this.graph.nodes[i];if(s.attrParams.shape&&s.attrParams.shape.value){const o=s.attrParams.shape.value,a=o.length===r.shape.length&&r.shape.every((l,c)=>o[c]===-1||o[c]===l);U(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&U(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var t,r;const i={};for(const s in e){const o=(r=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||r===void 0?void 0:r[s];o!=null?i[o.name]=e[s]:i[s]=e[s]}return i}checkInputs(e){const t=Object.keys(e).filter(r=>{const[i]=Ba(r);return this.graph.nodes[i]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var r,i;const s=(i=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||i===void 0?void 0:i[t];return s!=null?s.name:t},{})}checkOutputs(e){e.forEach(t=>{const[r]=Ba(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}class VJe{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UJe="?tfjs-format=file",WJe="model.json";class qB{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},r=Bz){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=r,t==null&&(this.loadOptions={}),this.resourceManager=new VJe}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Qd(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const s=this.artifacts.userDefinedMetadata;s.signature!=null&&(r=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}this.signature=r,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const i=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new qI(DG.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(i),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const s=DG.Instance.transformGraph(e.modelInitializer);this.initializer=new qI(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof jn?[e]:e,r={};return t.forEach((i,s)=>r[this.structuredOutputKeys[s]]=i),r}return e}predict(e,t){const r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,t){const r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var t;if(!(e instanceof jn)&&!Array.isArray(e)){const s=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(s!=null)for(const o in s){const a=s[o];a.resourceId!=null&&(e[o]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let i=0;return this.inputNodes.reduce((s,o)=>{var a,l,c;const u=(c=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[o])===null||c===void 0?void 0:c.resourceId;return u!=null?s[o]=this.resourceIdToCapturedInput[u]:s[o]=e[i++],s},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,r=Object.keys(t);for(let i=0;i<r.length;i++){const s=r[i],o=t[s];this.resourceIdToCapturedInput[o.resourceId]=e[i]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&nn(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Pl(n,e={},t=Bz){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=GJe(n));const r=new qB(n,e,t);return await r.load(),r}function HJe(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[r,i]=n;if(!r)throw new Error("modelJSON must be the first element of the array");if(!i||!(i instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");const s=NL(r.weightsManifest),o=AL(r,s,i);e=kI(o)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=kI(n);else throw new Error("Unknown model format");const t=new qB(e);return t.load(),t}function GJe(n){return n.endsWith("/")||(n=n+"/"),`${n}${WJe}${UJe}`}/** @license See the LICENSE file. */const jJe="4.11.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qJe=Object.freeze(Object.defineProperty({__proto__:null,GraphModel:qB,deregisterOp:vZe,loadGraphModel:Pl,loadGraphModelSync:HJe,registerOp:bZe,version_converter:jJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ah extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ah.prototype)}}class mc extends Error{constructor(e){super(e),Object.setPrototypeOf(this,mc.prototype)}}class _e extends Error{constructor(e){super(e),Object.setPrototypeOf(this,_e.prototype)}}class Ln extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ln.prototype)}}class XB extends Error{constructor(e){super(e),Object.setPrototypeOf(this,XB.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class xte{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pg(n,e){if(Array.isArray(n)){let t=[];for(let r=0;r<e;r++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function lh(n,e){if(!n)throw new XB(e)}function UG(n,e){let t=0;for(const r of n)r===e&&t++;return t}function pa(n){return n.length===1?n[0]:n}function Hr(n){return Array.isArray(n)?n:[n]}function vf(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Rm(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Ql={};function KB(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function OO(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>OO(e));else{const e=Object.keys(n);for(const t of e){const r=n[t];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?n[t]=r.value:OO(r))}}}function wC(n,e={},t={},r="object",i=!1){if(typeof n=="string"){const s=n;let o;if(s in t)o=t[s];else if(s in Ql)o=Ql[s];else if(o=e[s],o==null)throw new _e(`Unknown ${r}: ${n}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const s=n;if(s.className==null||s.config==null)throw new _e(`${r}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);const o=s.className;let a,l;if(o in t?[a,l]=t[o]:o in Ql?[a,l]=Ql.className:o in e&&([a,l]=e[o]),a==null)throw new _e(`Unknown ${r}: ${o}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const d of Object.keys(Ql))c[d]=Ql[d];for(const d of Object.keys(t))c[d]=t[d];const u=s.config;u.customObjects=c;const h=Object.assign({},Ql);for(const d of Object.keys(t))Ql[d]=t[d];OO(s.config);const f=l(a,s.config,t,i);return Ql=Object.assign({},h),f}else{const c=Object.assign({},Ql);for(const h of Object.keys(t))Ql[h]=t[h];const u=new a(s.config);return Ql=Object.assign({},c),u}}}function XJe(n,e){return n<e?-1:n>e?1:0}function sT(n,e){return-1*XJe(n,e)}function Bd(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function KJe(n){if(n==null)throw new _e(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function qy(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new _e(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function YB(n,e,t=0,r=1/0){return lh(t>=0),lh(r>=t),Array.isArray(n)&&n.length>=t&&n.length<=r&&n.every(i=>typeof i===e)}function Ws(n,e){Array.isArray(n)?(U(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,r)=>Ws(t,`element ${r+1} of ${e}`))):U(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${_te(n)}.`)}function _te(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>_te(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function YJe(n,e,t){let r=t!=null?t():io(),i;return(...o)=>{const a=t!=null?t():io();return a-r<e||(r=a,i=n(...o)),i}}function Ste(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let ZJe=0;function Cte(){return ZJe++}const oT={};function r$(n=""){return n in oT||(oT[n]=0),oT[n]+=1,n+oT[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const JJe=["channelsFirst","channelsLast"],QJe=["nearest","bilinear"],eQe=["valid","same","causal"],tQe=["max","avg"],nQe=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const P0=new Map;function es(n){qy(JJe,"DataFormat",n)}function rQe(n){qy(QJe,"InterpolationFormat",n)}function Bl(n){qy(eQe,"PaddingMode",n)}function kte(n){qy(tQe,"PoolMode",n)}const Y1=[],WG="/";function Gm(n,e){Y1.push(n);try{const t=e();return Y1.pop(),t}catch(t){throw Y1.pop(),t}}function iQe(){return Y1.length===0?"":Y1.join(WG)+WG}function Tte(n){if(!Ite(n))throw new Error("Not a valid tensor name: '"+n+"'");return iQe()+n}function Ete(n){if(!Ite(n))throw new Error("Not a valid tensor name: '"+n+"'");P0.has(n)||P0.set(n,0);const e=P0.get(n);if(P0.set(n,P0.get(n)+1),e>0){const t=`${n}_${e}`;return P0.set(t,1),t}else return n}const sQe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Ite(n){return!!n.match(sQe)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function oQe(n){return n===parseInt(n.toString(),10)}function Vd(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let r=1;for(let i=e;i<t;++i)r*=n[i];return r}function iv(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r<e&&(e=r)}return e}function op(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r>e&&(e=r)}return e}function Tu(n,e){if(e<n)throw new _e(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let r=n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let x3;function Cs(){return x3==null&&(x3=rg().epsilon()),x3}function Eu(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gh(n,e){return St(n,e)}function xC(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),ve(n,t)}function aQe(n,e){return Se(()=>{if(n.shape.length!==2)throw new _e(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=xC(n,1);return FO(t,[1,e,1])})}function lQe(n){const e=[Vd(n.shape)];return ve(n,e)}function cQe(n){if(n.rank<=1)throw new _e(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Vd(n.shape,1)];return ve(n,e)}function jm(n,e,t){return Se(()=>{switch(n.rank){case 1:return J2(n,e,t);case 2:return jM(n,[e,0],[t,n.shape[1]]);case 3:return Q2(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return Yb(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return pn(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return pn(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new _e(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function _3(n,e,t){return Se(()=>{switch(n.rank){case 1:return J2(n,e,t);case 2:return jM(n,[0,e],[n.shape[0],t]);case 3:return Q2(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return Yb(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new _e(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function aT(n,e,t,r){return Se(()=>{switch(n.rank){case 1:return J2(n,e,t);case 2:switch(r){case 1:return jm(n,e,t);case 2:return _3(n,e,t);default:throw new _e(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return jm(n,e,t);case 2:return Q2(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return _3(n,e,t);default:throw new _e(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return jm(n,e,t);case 2:return Yb(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return Yb(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return _3(n,e,t);default:throw new _e(`The axis is not within the rank of the tensor ${r}`)}default:throw new _e(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function ZB(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),li(n,e)}function HG(n,e){switch(n.rank){case 1:return WL([n,e]);case 2:return HL([n,e],0);case 3:return GL([n,e],0);case 4:return jL([n,e],0);default:throw new _e(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function FO(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new _e(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return dc(n,e)}function i$(n,e=0,t=1,r,i){return GM(n,e,t,r,i)}function yh(n,e,t,r){if(n.rank<2||e.rank<2)throw new Ln(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const i=n.shape.slice(-1)[0],s=e.shape.slice(-2)[0];if(i!==s)throw new Ln(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return wD({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?LO(n.rank,r,Eu()):null,activation:t});{const i=n.shape.slice(),s=i.pop();n=ve(n,[-1,s]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],u=Array.from({length:e.rank},(p,m)=>m===0?e.rank-2:m<=e.rank-2?m-1:m);e=ve(ir(e,u),[l,-1]);const h=[...i,...c];return ve(wD({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?LO(n.rank,r,Eu()):null,activation:t}),h)}}function Ate(n,e,t){return Se(()=>(Array.isArray(e)?e=Xi(e,"int32"):e=St(e,"int32"),K2(n,e,t)))}function _C(n){return fe(n,n)}function LO(n,e,t){const r=e.shape;if(e.rank!==1&&e.rank!==n)throw new _e(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return r.length===1?ve(e,[1,r[0],1,1,1]):ve(e,[1,r[3],r[0],r[1],r[2]]);if(t==="channelsLast")return r.length===1?ve(e,[1,1,1,1,r[0]]):ve(e,[1].concat(r))}else if(n===4){if(t==="channelsFirst")return r.length===1?ve(e,[1,r[0],1,1]):ve(e,[1,r[2],r[0],r[1]]);if(t==="channelsLast")return r.length===1?ve(e,[1,1,1,r[0]]):ve(e,[1].concat(r))}else if(n===3){if(t==="channelsFirst")return r.length===1?ve(e,[1,r[0],1]):ve(e,[1,r[1],r[0]]);if(t==="channelsLast")return r.length===1?ve(e,[1,1,r[0]]):ve(e,[1].concat(r))}else if(n<3)return e;throw new _e(`Unsupported input rank by biasAdd: ${e.rank}`)}function Uu(n,e,t){return Se(()=>(t==null&&(t=Eu()),es(t),Xe(n,LO(n.rank,e,t))))}function uQe(n,e=1){if(e!==1)throw new Ln(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return q2(n)}function hQe(n){return Se(()=>Lt(n,Xe(vs(n),1)))}function Mte(n,e,t,r){return Se(()=>Iz(n,e,t,r))}function fQe(n){return Se(()=>{const e=Xe(.5,fe(.2,n));return _a(e,0,1)})}function SC(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const dQe=["fanIn","fanOut","fanAvg"],pQe=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function mQe(n){qy(dQe,"FanMode",n)}function gQe(n){qy(pQe,"Distribution",n)}class Dc extends Dy{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Nte extends Dc{apply(e,t){return pi(e,t)}}Nte.className="Zeros";at(Nte);class JB extends Dc{apply(e,t){return ga(e,t)}}JB.className="Ones";at(JB);class $te extends Dc{constructor(e){if(super(),typeof e!="object")throw new _e(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new _e(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Se(()=>fe(Qt(this.value),ga(e,t)))}getConfig(){return{value:this.value}}}$te.className="Constant";at($te);class Rte extends Dc{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Ep(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Rte.className="RandomUniform";at(Rte);class Pte extends Dc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ln(`randomNormal does not support dType ${t}.`);return i$(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Pte.className="RandomNormal";at(Pte);class Dte extends Dc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ln(`truncatedNormal does not support dType ${t}.`);return YM(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Dte.className="TruncatedNormal";at(Dte);let Ote=class extends Dc{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return Se(()=>{if(e.length!==2||e[0]!==e[1])throw new _e("Identity matrix initializer can only be used for 2D square matrices.");return fe(this.gain,DM(e[0]))})}getConfig(){return{gain:this.gain}}};Ote.className="Identity";at(Ote);function yQe(n,e="channelsLast"){let t,r;if(es(e),n.length===2)t=n[0],r=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const i=Vd(n,2);t=n[1]*i,r=n[0]*i}else if(e==="channelsLast"){const i=Vd(n,0,n.length-2);t=n[n.length-2]*i,r=n[n.length-1]*i}}else{const i=Vd(n);t=Math.sqrt(i),r=Math.sqrt(i)}return[t,r]}class Ka extends Dc{constructor(e){if(super(),e.scale<0)throw new _e(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,mQe(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,gQe(this.distribution),this.seed=e.seed}apply(e,t){const r=yQe(e),i=r[0],s=r[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,i):this.mode==="fanOut"?o/=Math.max(1,s):o/=Math.max(1,(i+s)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ln(`${this.getClassName()} does not support dType ${t}.`);return YM(e,0,a,t,this.seed)}else{const a=Math.sqrt(3*o);return Ep(e,-a,a,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Ka.className="VarianceScaling";at(Ka);class QB extends Ka{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ka.className}}QB.className="GlorotUniform";at(QB);class e4 extends Ka{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ka.className}}e4.className="GlorotNormal";at(e4);class t4 extends Ka{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ka.className}}t4.className="HeNormal";at(t4);class n4 extends Ka{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ka.className}}n4.className="HeUniform";at(n4);class r4 extends Ka{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ka.className}}r4.className="LeCunNormal";at(r4);class i4 extends Ka{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ka.className}}i4.className="LeCunUniform";at(i4);class Fte extends Dc{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Se(()=>{if(e.length<2)throw new Ln("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const r=Ee(e.slice(0,-1)),i=e[e.length-1],s=r*i;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);const o=[Math.max(i,r),Math.min(i,r)],a=i$(o,0,1,t,this.seed),l=$z.qr(a,!1);let c=l[0];const h=l[1].flatten().stridedSlice([0],[Math.min(i,r)*Math.min(i,r)],[Math.min(i,r)+1]);return c=fe(c,h.sign()),r<i&&(c=c.transpose()),fe(Qt(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}Fte.className="Orthogonal";at(Fte);const GG={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function jG(n,e={}){return wC(n,_l.getMap().classNameMap,e,"initializer")}function Ci(n){return KB(n)}function gi(n){if(typeof n=="string"){const e=n in GG?GG[n]:n;if(e==="GlorotNormal")return new e4;if(e==="GlorotUniform")return new QB;if(e==="HeNormal")return new t4;if(e==="HeUniform")return new n4;if(e==="LeCunNormal")return new r4;if(e==="LeCunUniform")return new i4;{const t={};return t.className=e,t.config={},jG(t)}}else return n instanceof Dc?n:jG(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function zO(n){return Array.isArray(n)&&Array.isArray(n[0])}function XI(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function xn(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new _e(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function wr(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new _e(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function KI(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((r,i)=>r*i);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const qG="Variable";class bQe{constructor(e,t="float32",r=qG,i=!0,s=null){this.dtype=t??"float32",this.shape=e.shape,this.id=Cte(),r=r??qG,this.originalName=Tte(r),this.name=Ete(this.originalName),this.trainable_=i,this.constraint=s,this.val=Tz(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),vQe(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function vQe(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function BO(n){return n.map(e=>e.read())}function s4(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ks{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class kh{constructor(e,t,r,i,s,o,a){this.dtype=e,this.shape=t,this.sourceLayer=r,this.inputs=i,this.callArgs=s,this.outputTensorIndex=a,this.id=Cte(),o!=null&&(this.originalName=Tte(o),this.name=Ete(this.originalName)),this.rank=t.length}}let wQe=0,s$=class{constructor(e,t){this.callArgs=t,this.id=wQe++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const r of e.inboundLayers)r!=null&&r.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},xQe=0;class Xn extends Dy{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=xQe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const r=this.getClassName();t=vf(r)+"_"+r$(r)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let r;if(e.batchInputShape!=null)r=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),r=[s].concat(e.inputShape)}this.batchInputShape=r;let i=e.dtype;i==null&&(i=e.inputDType),i==null&&(i="float32"),this.dtype=i}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new mc(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new _e(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return pa(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return pa(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ah(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new ah(`Layer ${this.name} is not connected, no input to return.`);return pa(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new ah(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ah(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return pa(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Hr(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const r=Hr(this.inputSpec);if(t.length!==r.length)throw new _e(`Layer ${this.name} expects ${r.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let i=0;i<t.length;i++){const s=t[i],o=r[i];if(o==null)continue;const a=s.rank;if(o.ndim!=null&&a!==o.ndim)throw new _e(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new _e(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new _e(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&s.dtype!==o.dtype)throw new _e(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${s.dtype}.`);if(o.axes){const l=s.shape;for(const c in o.axes){const u=Number(c),h=o.axes[c],f=u>=0?l[u]:l[l.length+u];if(h!=null&&[h,null].indexOf(f)===-1)throw new _e(`Input ${i} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${h} but got shape ${l}.`)}}if(o.shape!=null)for(let l=0;l<o.shape.length;++l){const c=o.shape[l],u=s.shape[l];if(c!=null&&u!=null&&c!==u)throw new _e(`Input ${i} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${s.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const r=Hr(e),i=CQe(e),s=kQe(e);if(i===s)throw new _e("Arguments to apply() must be all SymbolicTensors or all Tensors");return Gm(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const a of Hr(e))o.push(a.shape);this.build(pa(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let o=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,o);const a=Hr(o),l=[];for(let c of a)r.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(o=pa(l),this.activityRegularizer!=null)throw new Ln("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=_Qe(e),a=this.computeOutputShape(o);let l;const c=SQe(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((u,h)=>new kh(c,u,this,Hr(e),t,this.name,h)):l=new kh(c,a,this,Hr(e),t,this.name),this.addInboundNode(e,l,null,null,o,a,t),this._refCount++,this.activityRegularizer!=null)throw new Ln("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((r,i)=>{r!=null&&e[i]!=null&&e[i]!==r&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new ah(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const r=JSON.stringify(t.outputShapes);e.indexOf(r)===-1&&e.push(r)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new ah(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new mc(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return KI(this.weights)}build(e){this.built=!0}getWeights(e=!1){return BO(e?this.trainableWeights:this.weights)}setWeights(e){Se(()=>{const t=this.weights;if(t.length!==e.length)throw new _e(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const r=[],i=BO(t);for(let s=0;s<i.length;++s){const o=i[s],a=t[s],l=e[s];if(!Rn(o.shape,l.shape))throw new _e(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}s4(r)})}addWeight(e,t,r,i,s,o,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new _e(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(i=l!=null?l():gi("zeros"));const c=i.apply(t,r),u=new bQe(c,r,e,o,a);return c.dispose(),s!=null&&this.addLoss(()=>s.apply(u.read())),o==null&&(o=!0),o?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Hr(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,r){if(!this.supportsMasking)return;const i=this.computeMask(e,r);if(t instanceof Array&&i instanceof Array){if(t.length!==i.length)throw new Error(`${this.name} outputs ${t.length} tensors but ${i.length} masks for those tensors`);for(let s=0;s<t.length;s++)t[s].kerasMask=i[s]}else{if(i instanceof Array)throw new Error(`{this.name} outputs a single tensor but ${i.length} masks`);if(t instanceof Array)throw new Error(`{this.name} outputs ${t.length} tensors but only one mask`);t.kerasMask=i}}addInboundNode(e,t,r,i,s,o,a=null){const l=Hr(e);t=Hr(t),r=Hr(r),i=Hr(i),s=XI(s),o=XI(o);const c=[],u=[],h=[];for(const f of l)c.push(f.sourceLayer),u.push(f.nodeIndex),h.push(f.tensorIndex);new s$({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:h,inputTensors:l,outputTensors:t,inputMasks:r,outputMasks:i,inputShapes:s,outputShapes:o},a);for(let f=0;f<t.length;f++)t[f].sourceLayer=this,t[f].nodeIndex=this.inboundNodes.length-1,t[f].tensorIndex=f}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function _Qe(n){n=Hr(n);const e=[];for(const t of n)e.push(t.shape);return pa(e)}function SQe(n){return"float32"}function Lte(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const r=e.inboundNodes[t];if(r.inboundLayers.length===0)return r.inputTensors;{const i=[];for(let s=0;s<r.inboundLayers.length;s++){const o=r.inputTensors[s],a=r.inboundLayers[s],l=r.nodeIndices[s],c=Lte(o,a,l);for(const u of c)i.indexOf(u)===-1&&i.push(u)}return i}}}function CQe(n){let e=!0;for(const t of Hr(n))if(!(t instanceof kh)){e=!1;break}return e}function kQe(n){let e=!0;for(const t of Hr(n))if(t instanceof kh){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class CC extends Xn{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:r$("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new _e("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new _e("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new _e("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=t,this.dtype=r,this.inputSpec=[{shape:t}];const i=new kh(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new s$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new _e(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}CC.className="InputLayer";at(CC);function TQe(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new _e("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new CC({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function EQe(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return St(e,n.dtype)}catch{throw new _e(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Md{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Md)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,r){if(this.id2Value[e.id]==null)this.id2Value[e.id]=EQe(e,t),this.name2Id[e.name]=e.id,r!=null&&(this.id2Mask[e.id]=r);else throw new _e(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof kh){if(this.id2Value[e.id]==null)throw new _e(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new _e(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof kh){if(this.id2Value[e.id]==null)throw new _e(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new _e(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&nn(this.id2Mask)}}const YI=new xte,ZI=new xte;function IQe(n){YI!=null&&YI.setMaxEntries(n),ZI!=null&&ZI.setMaxEntries(n)}function C1(n,e,t,r){const i=t==null?!1:t.training,s=Array.isArray(n),o=s?n:[n],a=o.map(p=>p.name),l=[],c=e.names();for(const p of a)c.indexOf(p)!==-1?l.push(e.getValue(p)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=a.join(",")+"|"+e.names().sort().join(",");let h=YI.get(u),f;if(h==null){const p=AQe(o,e);h=p.sorted,f=p.recipientCounts,YI.put(u,h),ZI.put(u,f)}f={},i||Object.assign(f,ZI.get(u));const d=new Md(e);for(let p=0;p<h.length;++p){if(r!=null){const M=xI().numTensors;M>r.maxNumTensors&&(r.maxNumTensors=M),M<r.minNumTensors&&(r.minNumTensors=M)}const m=h[p],g=m.sourceLayer;if(g instanceof CC)continue;const y=[],b=[],_=[];let w=!1;for(const M of m.inputs){const E=d.getValue(M),N=d.getMask(M);y.push(E),b.push(N),N!=null&&(w=!0),i||(f[M.name]--,f[M.name]===0&&!e.hasKey(M)&&a.indexOf(M.name)===-1&&!E.isDisposed&&M.sourceLayer.stateful!==!0&&_.push(E))}w&&(t=t||{},t.mask=b[0]);const S=Hr(g.apply(y,t));let C=null;g.supportsMasking&&(C=g.computeMask(y,b));const k=NQe(m),A=Array.isArray(k)?k:[k];for(let M=0;M<A.length;++M){d.hasKey(A[M])||d.add(A[M],S[M],Array.isArray(C)?C[0]:C);const E=a.indexOf(A[M].name);E!==-1&&(l[E]=S[M])}i||nn(_)}return d.disposeMasks(),s?l:l[0]}function AQe(n,e){U(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],r={};if(n.length===1){const i=XG(n[0],e);t=i.sorted,r=i.recipientMap}else{const i=new Set;for(const s of n){const{sorted:o,recipientMap:a}=XG(s,e);for(const l of o)i.has(l.name)||(t.push(l),i.add(l.name));for(const l in a)r[l]==null&&(r[l]=new Set),a[l].forEach(c=>r[l].add(c))}}return{sorted:t,recipientCounts:MQe(r)}}function MQe(n){const e={};for(const t in n)e[t]=n[t].size;return e}function XG(n,e){const t=new Set,r=[],i={};for(const a of e.names())t.add(a);const s=[],o=[];for(s.push(n);s.length>0;){const a=s[s.length-1];if(t.has(a.name)){s.pop();continue}const l=o[o.length-1]===s.length-1;if(a.inputs.length===0||l)s.pop(),r.push(a),t.add(a.name),l&&o.pop();else{o.push(s.length-1);for(const c of a.inputs)i[c.name]==null&&(i[c.name]=new Set),i[c.name].add(a.name),!t.has(c.name)&&s.push(c)}}return{sorted:r,recipientMap:i}}function NQe(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const i of n.sourceLayer.inboundNodes[r].outputTensors)if(i.id===n.id){t=r;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Qe=Ie();$Qe.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,IQe);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zte={kernelName:Tv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,Mw(St(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RQe={kernelName:Pg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=Or(St(t,"float32")),i=_o(Dt(Qt(1),r));return ci(Lt(n,i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PQe={kernelName:Dg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=_o(Dt(Or(St(t,"float32")),1));return Lt(n,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DQe={kernelName:_p,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=ln(t.shape,r.shape);return{a:()=>{let a=n;const l=us(t.shape,i);return l.length>0&&(a=Kt(a,l)),ve(a,t.shape)},b:()=>{let a=n;const l=us(r.shape,i);return l.length>0&&(a=Kt(a,l)),ve(a,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OQe={kernelName:Ev,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((r,i)=>{t[i]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FQe={kernelName:Iv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ur(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LQe={kernelName:Av,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ur(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zQe={kernelName:Og,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,_o(Dt(Qt(1),Or(St(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BQe={kernelName:Fg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=_o(Xe(Qt(1),Or(St(t,"float32"))));return Lt(n,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VQe={kernelName:Bg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=ln(t.shape,r.shape);return{a:()=>{const a=Xe(Or(t),Or(r));let l=fe(n,Lt(r,a));const c=us(t.shape,i);return c.length>0&&(l=Kt(l,c)),ve(l,t.shape)},b:()=>{const a=Xe(Or(t),Or(r));let l=ci(fe(n,Lt(t,a)));const c=us(r.shape,i);return c.length>0&&(l=Kt(l,c)),ve(l,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UQe={kernelName:Lg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,Xe(Or(St(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WQe={kernelName:zg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,Dt(Qt(1),Or(St(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HQe(n,e,t,r,i,s){const o=j(n,"dy","avgPool3dGrad"),a=j(e,"input","avgPool3dGrad");let l=o,c=a,u=!1;a.rank===4&&(u=!0,l=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=ve(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),U(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),U(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),na("avgPool3dGrad",i,s);const h={dy:l,input:c},f={filterSize:t,strides:r,pad:i,dimRoundingMode:s},d=ue.runKernel(GS,h,f);return u?ve(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const GQe=he({avgPool3dGrad_:HQe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jQe={kernelName:Nv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:i,strides:s,pad:o,dimRoundingMode:a}=t;return{x:()=>GQe(n,r,i,s,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qQe(n,e,t,r,i){const s=j(n,"dy","avgPoolGrad"),o=j(e,"input","avgPoolGrad");U(o.rank===s.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${s.rank})`);let a=o,l=s,c=!1;o.rank===3&&(c=!0,a=ve(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=ve(s,[1,s.shape[0],s.shape[1],s.shape[2]])),U(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),U(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const u={dy:l,input:a},h={filterSize:t,strides:r,pad:i},f=ue.runKernel(HS,u,h);return c?ve(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const XQe=he({avgPoolGrad_:qQe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KQe={kernelName:Mv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:i,strides:s,pad:o}=t;return{x:()=>XQe(n,r,i,s,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YQe={kernelName:$v,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[r,i]=e,{transposeA:s,transposeB:o}=t;return!s&&!o?{a:()=>Gn(n,i,!1,!0),b:()=>Gn(r,n,!0,!1)}:!s&&o?{a:()=>Gn(n,i,!1,!1),b:()=>Gn(n,r,!0,!1)}:s&&!o?{a:()=>Gn(i,n,!1,!0),b:()=>Gn(r,n,!1,!1)}:{a:()=>Gn(i,n,!0,!0),b:()=>Gn(n,r,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZQe={kernelName:Rv,gradFunc:(n,e,t)=>{const{blockShape:r,crops:i}=t;return{x:()=>WM(n,r,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JQe={kernelName:X7,gradFunc:(n,e,t)=>{const r=t,i=r.inputShape,s=r.shape,o=Array.from(s);for(let l=i.length-1;l>=0;l--)if(i[l]===s[l])o[l]=1;else if(i[l]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${s}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>Kt(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QQe={kernelName:Vg,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eet={kernelName:Ug,gradFunc:n=>({x:()=>ur(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tet={kernelName:Wg,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{clipValueMin:i,clipValueMax:s}=t;return{x:()=>xo(_h(Tp(r,i),Ry(r,s)),n,ur(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const net={kernelName:Pv,inputsToSave:["x"],gradFunc:zte.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ret={kernelName:Dv,saveAllInputs:!0,gradFunc:(n,e,t)=>{const r=e.map(l=>l.shape),{axis:i}=t,s=An(i,e[0].shape)[0],o=r.map(l=>l[s]);return Ga(n,o,s).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iet={kernelName:Ov,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,i]=e,{dilations:s,strides:o,pad:a,dataFormat:l}=t;return U(ep(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>XL(r.shape,n,i,o,a,l),filter:()=>Mz(r,n,i.shape,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const set={kernelName:Fv,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[r,i]=e,{strides:s,pad:o,dataFormat:a,dimRoundingMode:l}=t;return{dy:()=>tp(n,i,s,o,a,1,l),filter:()=>Mz(n,r,i.shape,s,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oet(n,e,t,r,i){let s=n;n.rank===4&&(s=ve(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=e;o.rank===4&&(o=ve(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),U(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),U(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),U(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),U(s.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${t[3]}.`),U(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const a={x:s,dy:o},l={strides:r,pad:i,filterShape:t};return ue.runKernel(ZS,a,l)}const aet=he({conv3DBackpropFilter_:oet});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cet={kernelName:Lv,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:i,pad:s}=t;U(ep(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=e;return{x:()=>LX(o.shape,n,a,i,s),filter:()=>aet(o,n,a.shape,i,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uet={kernelName:Hg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(ci(vz(St(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const het={kernelName:Gg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(wz(St(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fet={kernelName:zv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:i,exclusive:s,reverse:o}=t;return{x:()=>{const a=Lr([i],r.rank);let l=QL(n,i,s,!o);return a!=null&&(l=ir(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const det={kernelName:Bv,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:i,pad:s,dimRoundingMode:o}=t,a=r??[1,1];U(ep(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=e;return U(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),U(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),U(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),U($s(i,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${a}'.`),na("depthwiseConv2d",s,o),{x:()=>JK(l.shape,n,c,i,s,a,o),filter:()=>ZK(l,n,c.shape,i,s,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pet={kernelName:Vv,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,i]=e,s={x:r,filter:i,dy:n},o={x:r,filter:i,dy:n};return{x:()=>ue.runKernel(f_,s,t),filter:()=>ue.runKernel(d_,o,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const met={kernelName:qg,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,r={dy:n,y:t};return{x:()=>ue.runKernel(l2,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const get={kernelName:Xg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=fe(Jo(ci(Or(t))),2/Math.sqrt(Math.PI));return{x:()=>fe(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yet={kernelName:Kg,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bet={kernelName:Wv,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>ve(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vet={kernelName:Yg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,Jo(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wet={kernelName:Zg,gradFunc:n=>({x:()=>ur(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xet={kernelName:Jg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=ln(t.shape,r.shape);return{a:()=>{const a=Lt(n,St(r,"float32")),l=us(t.shape,i);return l.length>0?ve(Kt(a,l),t.shape):a},b:()=>{let a=fe(n,St(t,"float32"));const l=us(r.shape,i);l.length>0&&(a=ve(Kt(a,l),r.shape));const c=Or(r);return ci(Lt(a,St(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _et={kernelName:Hv,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:r}=t,[i,s,o,a]=e,l=a??Qt(1),c=us(s.shape,i.shape),u=[];if(s.rank===1){for(let w=0;w<i.shape.length-1;++w)u.push(i.shape[w]);u.push(1)}const h=Dt(i,s),f=fe(n,l),d=gz(Xe(o,Qt(r))),p=fe(fe(fe(d,d),d),Qt(-.5));return{x:()=>s.rank===1?ve(fe(fe(n,dc(ve(d,[1,1,1,s.shape[0]]),u)),l),i.shape):ve(fe(fe(n,d),l),i.shape),mean:()=>{let w=fe(fe(d,Qt(-1)),f);return s.rank===1&&(w=Kt(w,c)),ve(w,s.shape)},variance:()=>{let w=fe(fe(p,h),f);return s.rank===1&&(w=Kt(w,c)),ve(w,s.shape)},scale:()=>{const w=fe(h,d);let S=fe(n,w);return s.rank===1&&(S=Kt(S,c)),ve(S,s.shape)},offset:()=>{let w=n;return s.rank===1&&(w=Kt(w,c)),ve(w,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cet={kernelName:Gv,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[r,i]=e,{axis:s,batchDims:o}=t,a=An(s,r.shape)[0],l=(c,u,h)=>()=>{const f=c.shape,d=u.size,p=f.slice(0,a),m=p.length,g=f.slice(s,f.length).slice(1),y=g.length,b=KG(0,m),_=KG(m+1,m+1+y),w=YG([p,[d],g]),S=ve(h,w),C=ve(u,[d]),k=YG([[m],b,_]),A=ir(S,k);let M=kz(A,C,c.shape[a]);const E=Ph(k);return M=ir(M,E),M};if(o===1){const c=r.shape[0],u=r.split(c,0);return{x:()=>Sa(u.map((d,p)=>l(d,i.slice(p,1),n.slice(p,1))())).reshape(r.shape),indices:()=>i}}else return{x:l(r,i,n),indices:()=>i}}};function KG(n,e){const t=[];for(let r=n;r<e;++r)t.push(r);return t}function YG(n){const e=[];for(let t=0;t<n.length;++t)for(let r=0;r<n[t].length;++r)e.push(n[t][r]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ket={kernelName:Qg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>ur(t),b:()=>ur(r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tet={kernelName:ey,gradFunc:n=>({x:()=>St(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eet={kernelName:ty,gradFunc:n=>({x:()=>ur(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iet={kernelName:ny,gradFunc:n=>({x:()=>ur(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aet={kernelName:ry,gradFunc:n=>({x:()=>ur(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Met={kernelName:qv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{alpha:i}=t,s=tl(r,0);return{x:()=>xo(s,n,fe(n,i))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Net={kernelName:sy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,Xe(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $et={kernelName:iy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,St(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ret={kernelName:K7,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{axis:i}=t;return{logits:()=>{const o=Jo(r);return Dt(n,fe(Kt(n,i,!0),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pet(n,e,t,r=5,i=1,s=1,o=.5){const a={x:n,y:e,dy:t},l={depthRadius:r,bias:i,alpha:s,beta:o};return ue.runKernel(g2,a,l)}const Det=he({localResponseNormalizationBackprop_:Pet});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oet={kernelName:Qv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,i]=e,{depthRadius:s,bias:o,alpha:a,beta:l}=t;return{x:()=>Det(r,i,n,s,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bte(n,e,t,r){return e.rank<t.rank&&(e=ve(e,Fi(e.shape,r))),n.rank<t.rank&&(n=ve(n,Fi(n.shape,r))),{x:()=>fe(n,St(xu(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZG={kernelName:ew,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{reductionIndices:i}=r,s=e[0],o=e[1],a=An(i,s.shape),l=Bte(n,o,s,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fet={kernelName:oy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>fe(n,St(Tp(t,r),"float32")),b:()=>fe(n,St(S_(t,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Let(n,e,t,r,i,s,o){const a=j(n,"dy","maxPool3dGrad"),l=j(e,"input","maxPool3dGrad"),c=j(t,"output","maxPool3dGrad");let u=a,h=l,f=c,d=!1;l.rank===4&&(d=!0,u=ve(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=ve(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),f=ve(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),U(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),U(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),U(f.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`),na("maxPool3dGrad",s,o);const p={dy:u,input:h,output:f},m={filterSize:r,strides:i,pad:s,dimRoundingMode:o},g=ue.runKernel(b2,p,m);return d?ve(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const zet=he({maxPool3dGrad_:Let});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bet={kernelName:nw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,i]=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=t;return{x:()=>zet(n,r,i,s,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vet(n,e,t,r,i,s,o){const a=j(n,"dy","maxPoolGrad"),l=j(e,"input","maxPoolGrad"),c=j(t,"output","maxPoolGrad");U(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),U(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),U(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),na("maxPoolGrad",s,o);const u={dy:a,input:l,output:c},h={filterSize:r,strides:i,pad:s,dimRoundingMode:o};return ue.runKernel(y2,u,h)}const Uet=he({maxPoolGrad_:Vet});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wet={kernelName:tw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,i]=e,{filterSize:s,strides:o,pad:a}=t;return{x:()=>Uet(n,r,i,s,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Het={kernelName:rw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:i}=t,s=An(i,r.shape),a=Ji(r.shape,s)[1],l=Ee(a);return{x:()=>{const u=r.shape.slice();s.forEach(d=>{u[d]=1});const h=ve(n,u);return Lt(fe(h,ga(r.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Get={kernelName:iw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{axis:i}=r,[s,o]=e,a=An(i,s.shape),l=Bte(n,o,s,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jet={kernelName:ay,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>fe(n,St(Ry(t,r),"float32")),b:()=>fe(n,St(tl(t,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qet={kernelName:sw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:i}=t,s=i.map(o=>o[0]);return{x:()=>pn(n,s,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xet={kernelName:ly,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=ln(t.shape,r.shape);return{a:()=>{const a=us(t.shape,i);return a.length>0?ve(Kt(n,a),t.shape):n},b:()=>{const a=fe(n,ci(X2(Lt(t,r)))),l=us(r.shape,i);return l.length>0?ve(Kt(a,l),r.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ket={kernelName:cy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=ln(t.shape,r.shape);return{a:()=>{const a=fe(n,St(r,"float32")),l=us(t.shape,i);return l.length>0?ve(Kt(a,l),t.shape):a},b:()=>{const a=fe(n,St(t,"float32")),l=us(r.shape,i);return l.length>0?ve(Kt(a,l),r.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yet={kernelName:ow,gradFunc:n=>({x:()=>ci(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zet={kernelName:cw,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>pi(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jet={kernelName:lw,gradFunc:n=>({x:()=>ur(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qet={kernelName:uw,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:r}=t;return Tc(n,r).map(s=>()=>s)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JG={kernelName:hw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:i}=t,s=i.map(o=>o[0]);return{x:()=>pn(n,s,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ett={kernelName:uy,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,r,i]=e,s=t,o=r,a=ln(s.shape,o.shape);return{a:()=>{const u=St(o,"float32");let h=fe(n,fe(u,np(s,Dt(u,Qt(1)))));const f=us(s.shape,a);return f.length>0&&(h=Kt(h,f)),ve(h,s.shape)},b:()=>{const u=tl(s,0),h=xo(u,$l(s),ur(s));let f=fe(n,fe(i,h));const d=us(o.shape,a);return d.length>0&&(f=Kt(f,d)),ve(f,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ttt={kernelName:fw,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,r]=e,i=tl(t,0);return{x:()=>xo(i,n,fe(n,r)),alpha:()=>{let s=xo(i,ur(n),fe(n,t));const o=us(r.shape,n.shape);return o.length>0&&(s=Kt(s,o)),ve(s,r.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ntt(n,e,t){const r=n.shape.slice();r[t]=1;const i=ve(e,r),s=SI(n,t,!0,!1),o=SI(n,t,!0,!0),a=fe(s,o);return fe(i,a)}function rtt(n,e,t){const r=n.shape.length,i=r-t.length,s=Lr(t,r);let o=n;s!=null&&(o=ir(n,s));const a=o.shape.slice(),c=a.splice(r-t.length,t.length).reduce((f,d)=>f*d,1);a.push(c);const u=o.reshape(a);let h=ntt(u,e,i);if(h=h.reshape(o.shape),s!=null){const f=Ph(s);h=ir(h,f)}return h}const itt={kernelName:dw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:i}=t;let s=[];return i==null?s=r.shape.map((o,a)=>a):typeof i=="number"?s=[i]:s=i,{x:()=>rtt(r,n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const stt={kernelName:jg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=ln(t.shape,r.shape);return{a:()=>{const a=Lt(n,St(r,"float32")),l=us(t.shape,i);return l.length>0?ve(Kt(a,l),t.shape):a},b:()=>{let a=fe(n,St(t,"float32"));const l=us(r.shape,i);l.length>0&&(a=ve(Kt(a,l),r.shape));const c=Or(r);return ci(Lt(a,St(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ott={kernelName:hy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,ci(Or(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const att={kernelName:dy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=fe(Ry(t,6),Mw(t));return{x:()=>fe(n,St(r,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ltt={kernelName:fy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,St(Mw(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ctt={kernelName:pw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ve(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const utt={kernelName:gw,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,i={dy:n,images:r};return{images:()=>ue.runKernel(T2,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const htt={kernelName:mw,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,i={dy:n,images:r};return{images:()=>ue.runKernel(k2,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ftt={kernelName:yw,gradFunc:(n,e,t)=>{const{dims:r}=t,i=An(r,n.shape);return{x:()=>kc(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dtt={kernelName:py,gradFunc:n=>({x:()=>ur(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ptt={kernelName:my,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ci(Lt(n,fe(np(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mtt={kernelName:bw,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>St(ur(t),"float32"),t:()=>fe(n,St(t,n.dtype)),e:()=>fe(n,St(BM(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gtt={kernelName:gy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=tl(t,Qt(0)),i=Qt(aC),s=Qt(lC),o=fe(n,s),a=fe(fe(n,i),Jo(St(t,"float32")));return xo(r,o,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ytt={kernelName:wy,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,fe(t,Dt(Qt(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const btt={kernelName:vy,gradFunc:n=>({x:()=>ur(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vtt={kernelName:yy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(PM(St(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wtt={kernelName:by,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(JL(St(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xtt={kernelName:vw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{begin:i,size:s}=t,o=r.shape,[a,l]=oC(r,i,s),c=[];for(let u=0;u<n.rank;u++)c.push([a[u],o[u]-a[u]-l[u]]);return{x:()=>_u(n,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _tt={kernelName:Sw,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{dim:i}=t,s=!0,o=fe(n,r);return{logits:()=>Dt(o,fe(Kt(o,[i],s),r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Stt={kernelName:xy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,Il(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QG={kernelName:xw,gradFunc:(n,e,t)=>{const{blockShape:r,paddings:i}=t;return{x:()=>RM(n,r,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e6={kernelName:_w,gradFunc:(n,e,t)=>{const{axis:r}=t;return{x:()=>li(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ctt={kernelName:_y,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,fe(_o(St(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ktt={kernelName:R2,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,fe(St(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ttt={kernelName:Sy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=Qt(2);return{a:()=>fe(n,fe(i,Dt(t,r))),b:()=>fe(n,fe(i,Dt(r,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ett={kernelName:Iy,gradFunc:n=>({x:()=>ur(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Itt={kernelName:Cy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=ln(t.shape,r.shape);return{a:()=>{let a=n;const l=us(t.shape,i);return l.length>0&&(a=Kt(a,l)),ve(a,t.shape)},b:()=>{let a=n;const l=us(r.shape,i);return l.length>0&&(a=Kt(a,l)),ve(ci(a),r.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Att={kernelName:ww,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,i=r.shape.slice(),{axis:s}=t;An(s,r.shape).forEach(c=>{i[c]=1});const a=ve(n,i),l=fe(a,ga(r.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mtt={kernelName:ky,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,Or(PM(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ntt={kernelName:Ty,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(Dt(Qt(1),Or(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $tt={kernelName:Ey,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{reps:i}=t;return{x:()=>{let o=ur(r);if(r.rank===1)for(let a=0;a<i[0];++a)o=Xe(o,pn(n,[a*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)o=Xe(o,pn(n,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)for(let c=0;c<i[2];++c)o=Xe(o,pn(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)for(let c=0;c<i[2];++c)for(let u=0;u<i[3];++u)o=Xe(o,pn(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rtt={kernelName:Ld,gradFunc:(n,e,t)=>{const r=t,{perm:i}=r,s=Ph(i);return{x:()=>ir(n,s)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ptt={kernelName:Cw,gradFunc:(n,e,t)=>{const r=t,{axis:i}=r;return{value:()=>Sa(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dtt={kernelName:kw,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ott(n,t)}}};function Ott(n,e){const t=Uf(e,ur(e)),r=K2(n,t);let i=Tp(e,Qt(0,"int32"));const s=r.rank-i.rank;for(let a=0;a<s;++a)i=ss(i,a+1);i=_h(i,ga(r.shape,"bool"));const o=ur(r);return xo(i,r,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ftt={kernelName:Tw,gradFunc:n=>({x:()=>ur(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ltt=[zte,RQe,PQe,DQe,OQe,FQe,LQe,zQe,BQe,VQe,UQe,WQe,jQe,KQe,YQe,ZQe,JQe,QQe,eet,tet,net,ret,set,iet,cet,uet,het,fet,det,pet,stt,met,get,yet,bet,vet,xet,wet,_et,Cet,ket,Tet,Eet,Iet,Aet,Met,Net,$et,Ret,Oet,ZG,ZG,Fet,Bet,Wet,Het,Get,jet,qet,Xet,Ket,Yet,Zet,Jet,Qet,JG,JG,ett,ttt,itt,ott,att,ltt,ctt,utt,htt,ftt,dtt,ptt,mtt,gtt,ytt,btt,vtt,wtt,xtt,_tt,Stt,QG,QG,e6,e6,Ctt,Ttt,ktt,Ett,Itt,Att,Mtt,Ntt,$tt,Rtt,Ptt,Dtt,Ftt];for(const n of Ltt)Y7(n);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function o4(n,e){return Se(()=>_o(Kt(fe(n,n),e,!0)))}class kC extends Dy{getConfig(){return{}}}class Vte extends kC{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Se(()=>{const t=o4(e,this.axis),r=_a(t,0,this.maxValue);return fe(e,Lt(r,Xe(Cs(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Vte.className="MaxNorm";at(Vte);class Ute extends kC{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Se(()=>Lt(e,Xe(Cs(),o4(e,this.axis))))}getConfig(){return{axis:this.axis}}}Ute.className="UnitNorm";at(Ute);class Wte extends kC{apply(e){return Dh(e)}}Wte.className="NonNeg";at(Wte);class Hte extends kC{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Se(()=>{const t=o4(e,this.axis),r=Xe(fe(this.rate,_a(t,this.minValue,this.maxValue)),fe(1-this.rate,t));return fe(e,Lt(r,Xe(Cs(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Hte.className="MinMaxNorm";at(Hte);const t6={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Es(n){return KB(n)}function n6(n,e={}){return wC(n,_l.getMap().classNameMap,e,"constraint")}function Is(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in t6?t6[n]:n,config:{}};return n6(t)}else return n instanceof kC?n:n6(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function tm(n){if(n==null)return;const e=[],t=[],r=[];for(const i in n){const s=n[i];if(typeof s!="number"){const o=s;e.push(o.data()),t.push(i),r.push(o)}}if(e.length>0){const i=await Promise.all(e);for(let s=0;s<i.length;++s)n[t[s]]=i[s][0];nn(r)}}function Gte(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var r6;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(r6||(r6={}));const ztt=125;class G_{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Btt{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Vtt extends G_{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const r=t.size==null?0:t.size;this.seen+=r;for(const i in t){const s=t[i];if(typeof s=="number")this.totals.hasOwnProperty(i)||(this.totals[i]=0),this.totals[i]=this.totals[i]+s*r;else{let o;i in this.totals?o=this.totals[i]:this.totals[i]=0;const a=Se(()=>Xe(this.totals[i],fe(s,r)));this.totals[i]=a,o!=null&&o.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?t[r]=this.totals[r]/this.seen:Se(()=>{const i=fe(Lt(1,this.seen),this.totals[r]);t[r]=i,this.totals[r].dispose(),qi(t[r])}))}}class Utt extends G_{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const r in t)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(t[r])}async syncData(){const e=[],t=[],r=[];for(const s in this.history){const o=this.history[s];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];e.push(l.data()),t.push(s),r.push(a)}}const i=await Promise.all(e);for(let s=0;s<i.length;++s)this.history[t[s]][r[s]].dispose(),this.history[t[s]][r[s]]=i[s][0]}}class Wtt extends G_{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Wz,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=ztt),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");gI(this.yieldEvery)&&(this.maybeWait=YJe(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,r){const i=[];this.yield!=null&&(await tm(r),i.push(this.yield(e,t,r))),i.push(this.nextFrameFunc()),await Promise.all(i)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await tm(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const r=[];this.epochEnd!=null&&(await tm(t),r.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(e,t){this.batchBegin!=null&&(await tm(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const r=[];this.batchEnd!=null&&(await tm(t),r.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):gI(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(r)}async onTrainBegin(e){this.trainBegin!=null&&(await tm(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await tm(e),await this.trainEnd(e))}}function jte(n,e){return n==null&&(n={}),n instanceof G_?[n]:Array.isArray(n)&&n[0]instanceof G_?n:Hr(n).map(r=>new Wtt(r,e))}class sc{constructor(){}static registerCallbackConstructor(e,t){U(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),sc.checkForDuplicate(t),sc.constructors[e]==null&&(sc.constructors[e]=[]),sc.constructors[e].push(t)}static checkForDuplicate(e){for(const t in sc.constructors)sc.constructors[+t].forEach(i=>{if(i===e)throw new _e("Duplicate callback constructor.")})}static clear(){sc.constructors={}}static createCallbacks(e){const t=[];for(const r in sc.constructors){const i=+r;e>=i&&t.push(...sc.constructors[i])}return t.map(r=>new r)}}sc.constructors={};function qte(n,e,t,r,i,s,o,a,l){const c=new Utt,u=[new Vtt,...sc.createCallbacks(e)];n!=null&&u.push(...n),u.push(c);const h=new Btt(u);return h.setParams({epochs:t,initialEpoch:r,samples:i,steps:s,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bh(n,e={},t=!1){return wC(n,_l.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function JI(n,e){return Se(()=>{n.dtype!=="float32"&&(n=St(n,"float32"));const t=Kt(_C(n),e,!0),r=$y(t.shape,Cs()),i=_o(Uf(t,r));return Lt(n,i)})}function o$(n,e){return Se(()=>Di(_C(Dt(e,n)),-1))}function a4(n,e){return Se(()=>Di(vs(Dt(e,n)),-1))}function l4(n,e){return Se(()=>{const t=Dt(n,e),r=_a(vs(n),Cs(),Number.MAX_VALUE),i=vs(Lt(t,r));return fe(100,Di(i,-1))})}function Htt(n,e){return Se(()=>{const t=_a(e,Cs(),Number.MAX_VALUE),r=$l(Xe(1,t)),i=_a(n,Cs(),Number.MAX_VALUE),s=$l(Xe(1,i));return Di(_C(Dt(r,s)),-1)})}function Gtt(n,e){return Se(()=>{const t=Uf(0,Dt(1,fe(n,e)));return Di(_C(t),-1)})}function jtt(n,e){return Se(()=>{const t=Uf(0,Dt(1,fe(n,e)));return Di(t,-1)})}function qtt(n,e){return Se(()=>{const t=Kt(fe(n,e),-1),r=vc(fe(Dt(1,n),e),-1);return Uf(0,Xe(1,Dt(r,t)))})}function Xtt(n,e){return Se(()=>{const t=Math.log(2),r=Dt(e,n),i=Dt(Xe(r,Iw(fe(-2,r))),t);return Di(i,-1)})}function j_(n,e,t=!1){return Se(()=>{if(t)e=eC(e);else{const r=Kt(e,e.shape.length-1,!0);e=Lt(e,r)}return e=_a(e,Cs(),1-Cs()),ci(Kt(fe(St(n,"float32"),$l(e)),e.shape.length-1))})}function QI(n,e,t=!1){return Se(()=>{const r=St(X2(lQe(n)),"int32");e=_a(e,Cs(),1-Cs());const i=e.shape,s=ve(Xb(r,i[i.length-1]),i);return j_(s,e,t)})}function Ktt(n,e){if(!Rn(n.shape,e.shape))throw new _e(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return Se(()=>{const t=Dh(e),r=ci(vs(e));return Xe(Dt(t,fe(e,n)),FM(Jo(r)))})}function a$(n,e){return Se(()=>{let t;return t=_a(e,Cs(),1-Cs()),t=$l(Lt(t,Dt(1,t))),Di(Ktt(n,t),-1)})}function Ytt(n,e){return Se(()=>{const t=_a(n,Cs(),1),r=_a(e,Cs(),1);return Kt(fe(n,$l(Lt(t,r))),-1)})}function Ztt(n,e){return Se(()=>{const t=$l(Xe(Cs(),e));return Di(Dt(e,fe(n,t)),-1)})}function Xte(n,e){return Se(()=>{const t=JI(n,-1),r=JI(e,-1),i=fe(t,r);return ci(Kt(i,-1))})}const eA={meanSquaredError:o$,meanAbsoluteError:a4,meanAbsolutePercentageError:l4,meanSquaredLogarithmicError:Htt,squaredHinge:Gtt,hinge:jtt,categoricalHinge:qtt,logcosh:Xtt,categoricalCrossentropy:j_,sparseCategoricalCrossentropy:QI,binaryCrossentropy:a$,kullbackLeiblerDivergence:Ytt,poisson:Ztt,cosineProximity:Xte};function S3(n){if(typeof n=="string"){if(n in eA)return eA[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new _e(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Kte(n,e){return Se(()=>{const t=fe(.5,Rl(e)),r=gh(tl(e,t),n.dtype);return Di(xu(n,r),-1)})}function Yte(n,e){return Se(()=>gh(xu(ig(n,-1),ig(e,-1)),"float32"))}function Jtt(n,e){return Se(()=>St(Kt(_h(xu(n,1),xu(e,1))),"float32"))}function Qtt(n,e){return Se(()=>St(Kt(_h(xu(n,0),xu(e,1))),"float32"))}function ent(n,e){return Se(()=>{const t=Jtt(n,e),r=Qtt(n,e),i=Xe(t,r);return St(xo(tl(i,0),Lt(t,i),0),"float32")})}function tnt(n,e){return a$(n,e)}function nnt(n,e){return n.rank===e.rank&&(n=br(n,[n.rank-1])),e=ig(e,-1),e.dtype!==n.dtype&&(e=St(e,n.dtype)),St(xu(n,e),"float32")}const rnt=o$,int=o$,snt=a4,ont=a4,ant=l4,lnt=l4,Zte=j_,cnt=Xte,Jte=QI,tA={binaryAccuracy:Kte,categoricalAccuracy:Yte,precision:ent,categoricalCrossentropy:Zte,sparseCategoricalCrossentropy:Jte,mse:rnt,MSE:int,mae:snt,MAE:ont,mape:ant,MAPE:lnt,cosine:cnt};function unt(n){if(typeof n=="string"&&n in tA)return tA[n];if(typeof n!="string"&&n!=null)return n;throw new _e(`Unknown metric ${n}`)}function lT(n){if(lh(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(eA))if(eA[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(tA))if(tA[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hnt(n){const e={Adagrad:()=>wd.adagrad(.01),Adadelta:()=>wd.adadelta(1,.95,Cs()),Adam:()=>wd.adam(.001,.9,.999,Cs()),Adamax:()=>wd.adamax(.002,.9,.999,Cs(),0),RMSProp:()=>wd.rmsprop(.001,.9,0,Cs()),SGD:()=>wd.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new _e(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const i6=1*1024*1024;function s6(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!VO(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const r=JSON.stringify(n);r.length>i6&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${i6}.`)}}function VO(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!VO(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!VO(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fnt(n,e,t,r=console.log){const i=pnt(n),s=["Layer (type)","Input Shape","Output shape","Param #"];i?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(u=>Math.floor(e*u)));let o;if(!i){s.push("Receives inputs"),o=[];for(const u in n.nodesByDepth)o.push(...n.nodesByDepth[u])}r("_".repeat(e)),nA(s,t,r),r("=".repeat(e));const a=n.layers;for(let u=0;u<a.length;++u)i?mnt(a[u],t,r):gnt(a[u],t,o,r),r((u===a.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=dnt(n),c=KI(n.nonTrainableWeights);r(`Total params: ${l+c}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${c}`),r("_".repeat(e))}function dnt(n){let e;return n.collectedTrainableWeights!=null?e=KI(n.collectedTrainableWeights):e=KI(n.trainableWeights),e}function pnt(n){let e=!0;const t=[],r=[];for(const i in n.nodesByDepth)t.push(n.nodesByDepth[i]);for(const i of t){if(i.length>1||i.length===1&&i[0].inboundLayers.length>1){e=!1;break}r.push(...i)}if(e)for(const i of n.layers){let s=!1;for(const o of i.inboundNodes)if(r.indexOf(o)!==-1)if(s){e=!1;break}else s=!0;if(!e)break}return e}function nA(n,e,t=console.log){let r="";for(let i=0;i<n.length;++i)i>0&&(r=r.slice(0,r.length-1)+" "),r+=n[i],r=r.slice(0,e[i]),r+=" ".repeat(e[i]-r.length);t(r)}function mnt(n,e,t){let r,i;try{i=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const s=n.name,o=n.getClassName(),a=[`${s} (${o})`,i,r,n.countParams().toString()];nA(a,e,t)}function gnt(n,e,t,r){let i,s;try{s=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{s="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}const o=[];for(const h of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let f=0;f<h.inboundLayers.length;++f){const d=h.inboundLayers[f].name,p=h.nodeIndices[f],m=h.tensorIndices[f];o.push(`${d}[${p}][${m}]`)}const a=n.name,l=n.getClassName(),c=o.length===0?"":o[0],u=[`${a} (${l})`,s,i,n.countParams().toString(),c];nA(u,e,r);for(let h=1;h<o.length;++h)nA(["","","","",o[h]],e,r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Qte(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function rA(n,e){if(n===null)return null;if(typeof n=="string")return Rm(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let i=0;i<r;++i){const s=n[i];Qte(e,i,s)?t.push(s):t.push(rA(s,e))}return t}else{const t={};for(const r of Object.keys(n)){const i=n[r];if(r==="name"&&typeof i=="string")t[r]=i;else{const s=Rm(r);t[s]=rA(i,s)}}return t}}function UO(n,e){if(n==null)return null;if(typeof n=="string")return vf(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let i=0;i<r;++i){const s=n[i];Qte(e,i,s)?t.push(s):t.push(UO(s,e))}return t}else{const t={};for(const r of Object.keys(n)){const i=n[r],s=vf(r);(r==="name"||r==="className")&&typeof i=="string"?t[s]=i:t[s]=UO(i,r)}return t}}/** @license See the LICENSE file. */const ene="4.11.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ynt=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class iu extends Xn{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const b=this.getClassName().toLowerCase();this.name=r$(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Bd(this.inputs).length!==this.inputs.length)throw new _e(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Bd(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const _=b.sourceLayer,w=b.nodeIndex,S=b.tensorIndex;this.outputLayers.push(_),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(S)}for(const b of this.inputs){const _=b.sourceLayer,w=b.nodeIndex,S=b.tensorIndex;lh(w===0,"input layer has >1 nodes"),lh(S===0,"input layer has >1 tensors"),this.inputLayers.push(_),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(S)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const _=this.inputLayers[b];if(!(_ instanceof CC))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${_.getClassName()}.`);this.inputNames.push(_.name),this.feedInputShapes.push(_.batchInputShape),this.feedInputNames.push(_.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const t={},r={},i={},s={},o={},a=[],l=(b,_,w,S,C,k)=>{(S==null||C==null||k==null)&&(S=b.sourceLayer,C=b.nodeIndex,k=b.tensorIndex);const A=S.inboundNodes[C];if(w.indexOf(A)!==-1)throw new mc(`The tensor ${b.name} at layer "${S.name}" is part of a cycle.`);if(_.indexOf(A)!==-1)return;this.containerNodes.add(iu.nodeKey(S,C)),S.id in o||(o[S.id]=Object.keys(o).length),w.indexOf(A)===-1&&w.push(A);const M=A.inboundLayers.length;for(let E=0;E<M;E++){const N=A.inputTensors[E],O=A.inboundLayers[E],R=A.nodeIndices[E],D=A.tensorIndices[E];l(N,_,w,O,R,D)}for(_.push(A);w.indexOf(A)>=0;)w.splice(w.indexOf(A),1);a.push(A)},c=[],u=[];for(const b of this.outputs)l(b,c,u);const h=a.slice().reverse();for(const b of h){r[b.id]=b,b.id in t||(t[b.id]=0);let _=t[b.id];const w=i[b.outboundLayer.id]==null?0:i[b.outboundLayer.id];_=Math.max(_,w),i[b.outboundLayer.id]=_,s[b.outboundLayer.id]=b.outboundLayer,t[b.id]=_;for(let S=0;S<b.inboundLayers.length;S++){const C=b.inboundLayers[S],k=b.nodeIndices[S],A=C.inboundNodes[k],M=t[A.id]==null?0:t[A.id];t[A.id]=Math.max(_+1,M),r[A.id]=A}}const f={};for(const b in t){const _=t[b];_ in f||(f[_]=[]),f[_].push(r[b])}const d={};for(const b in i){const _=i[b];_ in d||(d[_]=[]),d[_].push(s[b])}let p=Object.keys(d).map(b=>parseInt(b,10)).sort(sT);this.layers=[];for(const b of p){const _=d[b];_.sort((w,S)=>{const C=o[w.id],k=o[S.id];return C<k?-1:C>k?1:0});for(const w of _)w instanceof iu&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=d,p=Object.keys(f).map(b=>parseInt(b,10)).sort(sT);const m=this.inputs.slice(),g=[];for(const b of p)for(const _ of f[b]){const w=_.outboundLayer;if(w!=null){for(const S of _.inputTensors)if(m.indexOf(S)===-1)throw new mc(`Graph disconnected: cannot obtain value for tensor ${S} at layer "${w.name}". The following previous layers were accessed without issue: ${g}`);for(const S of _.outputTensors)m.push(S);g.push(w.name)}}this.nodesByDepth=f;const y=this.layers.map(b=>b.name);for(const b of y){const _=y.filter(w=>w===b).length;if(_!==1)throw new mc(`The name "${b}" is used ${_} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new s$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(r=>r.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new _e("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.layers)t.push(...r.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const r={};let i=0;const s=ynt(e);s&&this.parseWeights(e);for(const a of this.layers)for(const[l,c]of a.weights.entries()){const u=s?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(r[u]!=null)throw new _e(`Duplicate weight name: ${u}`);r[u]=c,i++}const o=[];for(const a in e){let l=a;if(r[a]==null){const c=a.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(r[l]!=null)o.push([r[l],e[a]]);else if(t)throw new _e(`Provided weight data has no target variable: ${a}`);delete r[l]}if(t){const a=[];for(const l in r)a.push(l);if(a.length>0)throw new _e(`${a.length} of ${i} weights are not set: ${a}`)}s4(o)}parseWeights(e){for(const t in Object.keys(e)){const r=t.split("/"),i=["vars","layer_checkpoint_dependencies"],s=r.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!i.includes(o)).join("/");s!==t&&(e[s]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${ene}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const r=UO(this.updatedConfig());return t?JSON.stringify(r):r}call(e,t){return Se(()=>{e=Hr(e);const r=new Md;for(let i=0;i<this.inputs.length;++i)r.add(this.inputs[i],e[i]);return C1(this.outputs,r,t)})}computeMask(e,t){return Se(()=>{e=Hr(e);let r;return t==null?r=pg(null,e.length):r=Hr(t),this.runInternalGraph(e,r)[1]})}computeOutputShape(e){const t=XI(e);if(t.length!==this.inputLayers.length)throw new _e(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<t.length;a++){const l=this.inputLayers[a],c=t[a],u=l.name+"_0_0";r[u]=c}const i=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(sT);if(i.length>1)for(const a of i){const l=this.nodesByDepth[a];for(const c of l){const u=c.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(u.id)!==-1)continue;const h=[];for(let m=0;m<c.inboundLayers.length;m++){const g=c.inboundLayers[m],y=c.nodeIndices[m],b=c.tensorIndices[m],_=`${g.name}_${y}_${b}`,w=r[_];h.push(w)}const f=u.computeOutputShape(pa(h)),d=XI(f),p=u.inboundNodes.indexOf(c);for(let m=0;m<d.length;m++){const g=`${u.name}_${p}_${m}`;r[g]=d[m]}}}const s=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],c=this.outputLayersNodeIndices[a],u=this.outputLayersTensorIndices[a],h=`${l.name}_${c}_${u}`;o.push(h)}for(let a=0;a<o.length;a++){const l=o[a];lh(l in r),s.push(r[l])}return pa(s)}runInternalGraph(e,t){t==null&&(t=pg(null,e.length));const r={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],u=e[l],h=t[l];r[c.id]=[u,h]}const i=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(sT);for(const l of i){const c=this.nodesByDepth[l];for(const u of c){const h=u.outboundLayer,f=u.inputTensors,d=u.outputTensors,p=new Array;for(const m of f)m.id in r&&p.push(r[m.id]);if(p.length===f.length){let m={},g,y,b,_;if(u.callArgs!=null&&(m=u.callArgs),p.length===1){const[w,S]=p[0];m.mask==null&&(m.mask=S),b=Hr(h.call(w,m)),_=Hr(h.computeMask(w,S)),g=[w],y=[S]}else g=p.map(w=>w[0]),y=p.map(w=>w[1]),m.mask==null&&(m.mask=y),b=Hr(h.call(g,m)),_=Hr(h.computeMask(g,y));if(h.activityRegularizer)throw new Ln("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<d.length;++w){const S=d[w],C=b[w],k=_[w];r[S.id]=[C,k]}}}}const s=[],o=[],a=[];for(const l of this.outputs){lh(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[c,u]=r[l.id];a.push(c.shape),s.push(c),o.push(u)}return[s,o,a]}buildNodeConversionMap(e){const t={};let r;for(const i of this.layers){r=i instanceof iu?1:0;for(let s=0;s<i.inboundNodes.length;s++){const o=iu.nodeKey(i,s);this.containerNodes.has(o)&&(t[o]=r,r+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new _e("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const r of this.layers)if(r.name===e)return r;throw new _e(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new _e(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return Se(()=>{const e=[];for(const t of this.layers)for(let r=0;r<t.inboundNodes.length;++r){const i=iu.nodeKey(t,r);this.containerNodes.has(i)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),r=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let h=0;h<o.inboundNodes.length;h++){const f=o.inboundNodes[h],d=iu.nodeKey(o,h);let p={};if(this.containerNodes.has(d)){if(f.callArgs)try{JSON.stringify(f.callArgs),p=f.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${f.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(f.inboundLayers.length>0){const m=[];for(let g=0;g<f.inboundLayers.length;g++){const y=f.inboundLayers[g],b=f.nodeIndices[g],_=f.tensorIndices[g],w=iu.nodeKey(y,b);let S=t[w];S==null&&(S=0),m.push([y.name,S,_,p])}c.push(m)}}}const u={};u.name=o.name,u.className=a,u.config=l,u.inboundNodes=c,r.push(u)}e.layers=r;const i=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],c=iu.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const h=this.inputLayersTensorIndices[o];i.push([a.name,u,h])}e.inputLayers=i;const s=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],c=iu.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const h=this.outputLayersTensorIndices[o];s.push([a.name,u,h])}return e.outputLayers=s,e}static fromConfig(e,t,r={},i=!1){const s={},o={};function a(g,y){g.name in o?o[g.name].push(y):o[g.name]=[y]}function l(g,y){const b=[];let _;for(const w of y){const S=w[0],C=w[1],k=w[2];if(_=w[3]==null?{}:w[3],!(S in s)){a(g,y);return}const A=s[S];if(A.inboundNodes.length<=C){a(g,y);return}const M=A.inboundNodes[C];b.push(M.outputTensors[k])}b.length>0&&g.apply(pa(b),_)}function c(g){const y=g.name,b=bh(g,t.customObjects!=null?t.customObjects:{});b.setFastWeightInitDuringBuild(i),s[y]=b,g.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new _e(`Corrupted configuration, expected array for nodeData: ${w}`);a(b,w)})}const u=t.name,h=t.layers;for(const g of h)c(g);for(;!KJe(o);)for(const g of h){const y=s[g.name];if(y.name in o){const b=o[y.name];delete o[y.name];for(const _ of b)l(y,_)}}const f=[],d=[],p=t.inputLayers;for(const g of p){const y=g[0],b=g[1],_=g[2];lh(y in s);const S=s[y].inboundNodes[b].outputTensors;f.push(S[_])}const m=t.outputLayers;for(const g of m){const y=g[0],b=g[1],_=g[2];lh(y in s);const S=s[y].inboundNodes[b].outputTensors;d.push(S[_])}return new e({inputs:f,outputs:d,name:u})}get stateful(){if(this._stateful)throw new _e("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Se(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bnt(n,e,t){const r=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(i=>null);if(r===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const i=[];return e.forEach(s=>{s in n?i.push(n[s]):i.push(null)}),i}else throw new Error(`The model has multiple (${r}) outputs, so ${t} must be either an array with ${r} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function tne(n,e){return bnt(n,e,"classWeight")}async function nne(n,e,t,r){if(e!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){const i=Se(()=>{if(n.shape.length===1)return mh(n);if(n.shape.length===2){if(n.shape[1]>1)return ig(n,1);if(n.shape[1]===1)return ve(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await i.data());nn(i);const o=[];return s.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(t[a])}),Xi(o,"float32")}else return null}function vnt(n,e){return fe(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const wnt=32;function rne(n,e){let t,r;const i=e;t=i.xs,r=i.ys,U(t!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const s=o6("input",n.inputNames,t),o=o6("output",n.outputNames,r),a=s[0].shape[0];U(s.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),U(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<s.length;l++)U(s[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${s[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)U(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:s,ys:o}}function o6(n,e,t){if(t instanceof jn)return[t];if(Array.isArray(t))return U(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const r=[];for(const i of e){if(t[i]==null)throw new _e(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);r.push(t[i])}return r}}function xnt(n){if(n.length===3)throw new Ln("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function _nt(n,e,t){const r=t.batchesPerEpoch!=null;if(U(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),U(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),U(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),U(!r||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),U(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const i=t.validationData!=null;let s,o;if(i)if(a6(t.validationData))U(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const g=xnt(t.validationData);s=g.xs,o=g.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;i?c=l.slice().concat(l.map(g=>"val_"+g)):c=l.slice();const u=jte(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:f,history:d}=qte(u,h,t.epochs,null,null,Snt(e,t),null,i,c);f.setModel(n),n.history=d,await f.onTrainBegin(),n.stopTraining_=!1;let p=t.initialEpoch==null?0:t.initialEpoch,m=await e.iterator();for(;p<t.epochs;){const g={};await f.onEpochBegin(p);let y=0,b=0;for(r||(m=await e.iterator());!r||y<t.batchesPerEpoch;){const _=await m.next();if(r&&_.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(_.value!=null){const{xs:w,ys:S}=rne(n,_.value),C={};C.batch=b,C.size=w[0].shape[0],await f.onBatchBegin(b,C);const k=[];if(t.classWeight!=null){const E=tne(t.classWeight,n.outputNames);for(let N=0;N<E.length;++N)k.push(await nne(S[N],null,E[N]))}const A=w.concat(S).concat(k),M=a(A);nn(A);for(let E=0;E<l.length;++E){const N=l[E],O=M[E];C[N]=O,qi(O)}await f.onBatchEnd(b,C),Gte(C),b++,y++}if(r?y>=t.batchesPerEpoch:_.done){if(i){let w;a6(t.validationData)?w=Hr(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):w=Hr(n.evaluate(s,o,{batchSize:t.validationBatchSize==null?wnt:t.validationBatchSize,verbose:0}));for(let S=0;S<n.metricsNames.length;++S)g[`val_${n.metricsNames[S]}`]=w[S]}break}if(n.stopTraining_)break}if(await f.onEpochEnd(p,g),p++,n.stopTraining_)break}return await f.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function Snt(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function a6(n){return typeof n.iterator=="function"}function Cnt(n){return typeof n.next=="function"}async function knt(n,e,t){t=t||{};const r=t.batches!=null,i=n.testFunction;let s=[];if(t.verbose>0)throw new Ln("Verbose mode is not implemented yet.");U(!r||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=Cnt(e)?e:await e.iterator();let a=0,l=0;for(;!r||l<t.batches;){const c=await o.next();if(s=Se(()=>{if(c.value){const{xs:u,ys:h}=rne(n,c.value),f=u.concat(h),d=Se(()=>i(f));if(nn(f),l===0)for(let m=0;m<d.length;++m)s.push(Qt(0));const p=f[0].shape[0];for(let m=0;m<d.length;++m){const g=d[m],y=s[m];s[m]=Se(()=>Xe(s[m],fe(p,g))),l>0&&nn(y)}nn(d),a+=p,++l}return s}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<s.length;++c){const u=s[c];s[c]=Lt(s[c],a),nn(u)}return pa(s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function C3(n){U(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Ux(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(r=>jm(r,e,t-e)):jm(n,e,t-e)}function WO(n,e){return Se(()=>n==null?null:Array.isArray(n)?n.map(t=>WO(t,e)):Ate(n,e.dtype==="int32"?e:St(e,"int32")))}function k3(n,e){const t=[];let r=0,i=null;for(;r<n;)i=r+e,i>=n&&(i=n),t.push([r,i]),r=i;return t}function ine(n){const e=[];n instanceof jn&&(n=[n]);for(let t=0;t<n.length;++t){const r=n[t];if(r.rank===1)e.push(xC(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function Yc(n,e){if(n==null)return;const t=[];if(e instanceof jn)t.push(e.id);else if(Array.isArray(e))e.forEach(i=>t.push(i.id));else if(e!=null)for(const i in e){const s=e[i];t.push(s.id)}const r=[];if(n instanceof jn)t.indexOf(n.id)===-1&&r.push(n);else if(Array.isArray(n))n.forEach(i=>{t.indexOf(i.id)===-1&&r.push(i)});else if(n!=null)for(const i in n){const s=n[i];t.indexOf(s.id)===-1&&r.push(s)}r.forEach(i=>{i.isDisposed||i.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Tnt(n){return n instanceof jn}function HO(n){return Array.isArray(n)}function l6(n){return!Tnt(n)&&!HO(n)}function c6(n,e,t,r=!0,i=""){if(e==null||e.length===0){if(n!=null){let o=!1;if(HO(n)&&n.length>0)o=!0;else if(l6(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new _e(`Error when checking model ${i} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(o=>null);let s;if(l6(n)){n=n,s=[];for(const o of e){if(n[o]==null)throw new _e(`No data provided for "${o}". Need data for each key in: ${e}`);s.push(n[o])}}else if(HO(n)){if(n=n,n.length!==e.length)throw new _e(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);s=n}else{if(n=n,e.length>1)throw new _e(`The model ${i} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);s=[n]}if(s=ine(s),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=s[o];if(a.shape.length!==t[o].length)throw new _e(`Error when checking ${i}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<t[o].length;++l){if(l===0&&!r)continue;const c=a.shape[l],u=t[o][l];if(u!=null&&u>=0&&c!==u)throw new _e(`${i} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${i} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function Ent(n,e,t){const r=Bd(n.map(s=>s.shape[0]));r.sort();const i=Bd(e.map(s=>s.shape[0]));if(i.sort(),r.length>1)throw new _e(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(s=>s.shape))}`);if(i.length>1)throw new _e(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(r.length>0&&i.length>0&&!Rn(r,i))throw new _e(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${i[0]} target sample(s).`)}function Int(n,e,t){const r=[o$,a$,j_];for(let i=0;i<n.length;++i){const s=n[i],o=e[i],a=t[i];if(o!=null){if(o===j_&&s.shape[s.shape.length-1]===1)throw new _e(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(o)!==-1){const l=s.shape.slice(1),c=a.slice(1);for(let u=0;u<l.length;++u){const h=l[u],f=c[u];if(f!=null&&h!==f)throw new _e(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function u6(n,e,t,r=!0,i=""){let s;if(Array.isArray(n)){if(n.length!==e.length)throw new _e(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);s=n}else{if(e.length>1)throw new _e(`The model expects ${e.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);s=[n]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=s[o];if(a.shape.length!==t[o].length)throw new _e(`Error when checking ${i}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<t[o].length;++l){if(l===0&&!r)continue;const c=a.shape[l],u=t[o][l];if(u!=null&&u!==c)throw new _e(`Error when checking ${i}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function Ant(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(r=>t);{const r=[];for(const i of e){let s=t.hasOwnProperty(i)?t[i]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}const Mnt="layers-model";class Ud extends iu{constructor(e){super(e),this.isTraining=!1}summary(e,t,r=console.log){if(!this.built)throw new _e("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");fnt(this,e,t,r)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=hnt(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Hf))throw new _e("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new _e(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(S3(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new _e(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>S3(a))}else{const o=S3(e.loss);this.outputs.forEach(a=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Gm("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(r.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const i=Ant(e.metrics,this.outputNames),s=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};Gm("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(r.indexOf(o)!==-1)continue;const a=i[o];(c=>{const u="";let h,f,d;for(const p of c){if(typeof p=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(p)!==-1){const g=this.internalOutputShapes[o];g[g.length-1]===1||this.lossFunctions[o]===a$?["accuracy","acc"].indexOf(p)!==-1?f=Kte:["crossentropy","ce"].indexOf(p)!==-1&&(f=tnt):this.lossFunctions[o]===QI?["accuracy","acc"].indexOf(p)!==-1?f=nnt:["crossentropy","ce"].indexOf(p)!==-1&&(f=Jte):["accuracy","acc"].indexOf(p)!==-1?f=Yte:["crossentropy","ce"].indexOf(p)!==-1&&(f=Zte);let y;["accuracy","acc"].indexOf(p)!==-1?y="acc":["crossentropy","ce"].indexOf(p)!==-1&&(y="ce"),d=f,h=u+y}else d=unt(p),h=u+lT(p);let m;Gm(h,()=>{m=d}),s(o,h,m)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,r={}){const i=r.batchSize==null?32:r.batchSize;C3(i);const s=!0,o=this.standardizeUserDataXY(e,t,s,i);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,a,i,r.verbose,r.steps);return pa(c)}finally{Yc(o[0],e),Yc(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),knt(this,e,t)}checkNumSamples(e,t,r,i="steps"){let s;if(r!=null){if(s=null,t!=null)throw new _e(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new _e(`Either the input data should have a defined shape, or ${i} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new _e("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(t),i=r?t:[t],s=this.retrieveSymbolicTensors(i),o=new Md;if(e instanceof jn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new _e(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],e[l])}else for(const l of this.inputs){const c=e[l.name];if(c==null)throw new _e(`No value is provided for the model's input ${l.name}`);o.add(l,c)}const a=C1(s,o);return r?a:a[0]}retrieveSymbolicTensors(e){const t=pg(null,e.length);let r=e.length;for(const i of this.layers){const s=Array.isArray(i.output)?i.output:[i.output],o=s.map(a=>a.name);for(let a=0;a<e.length;++a){const l=o.indexOf(e[a]);if(l!==-1&&(t[a]=s[l],r--),r===0)break}if(r===0)break}if(r>0){const i=[];throw t.forEach((s,o)=>{s==null&&i.push(e[o])}),new _e(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return t}predictLoop(e,t=32,r=!1){return Se(()=>{const i=this.checkNumSamples(e);if(r)throw new Ln("Verbose predictLoop() is not implemented yet.");const s=k3(i,t),o=this.outputs.map(a=>[]);for(let a=0;a<s.length;++a)Se(()=>{const c=s[a][0],u=s[a][1],h=Ux(e,c,u),f=[];if(Array.isArray(h))for(let p=0;p<h.length;++p)f.push({key:this.inputs[p],value:h[p]});else f.push({key:this.inputs[0],value:h});const d=new Md(f);return C1(this.outputs,d)}).forEach((c,u)=>o[u].push(c));return pa(o.map(a=>li(a,0)))})}predict(e,t={}){const r=ine(e);u6(r,this.inputNames,this.feedInputShapes,!1);try{const i=t.batchSize==null?32:t.batchSize;return C3(i),this.predictLoop(r,i)}finally{Yc(r,e)}}predictOnBatch(e){u6(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,r=!0,i){if(this.optimizer_==null)throw new mc("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===QI?s.push(a.slice(0,a.length-1).concat([1])):s.push(a)}if(e=c6(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=c6(t,this.feedOutputNames,s,!1,"target"),Ent(e,t),Int(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&i!=null&&i>0&&e[0].shape[0]%i!==0)throw new _e(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,r,i,s=!0,o){const[a,l]=this.standardizeUserDataXY(e,t,s,o);if(r!=null)throw new Error("sample weight is not supported yet.");let c=null;if(i!=null){const u=tne(i,this.outputNames);c=[];for(let h=0;h<u.length;++h)c.push(await nne(l[h],null,u[h]))}return[a,l,c]}testLoop(e,t,r,i=0,s){return Se(()=>{const o=this.checkNumSamples(t,r,s,"steps"),a=[];if(i>0)throw new Ln("Verbose mode is not implemented yet.");if(s!=null)throw new Ln("steps mode in testLoop() is not implemented yet");{const l=k3(o,r),c=Xi(Tu(0,o));for(let u=0;u<l.length;++u){const h=l[u][0],f=l[u][1],d=jm(c,h,f-h),p=WO(t,d),m=e(p);if(u===0)for(let g=0;g<m.length;++g)a.push(Qt(0));for(let g=0;g<m.length;++g){const y=m[g];a[g]=Xe(a[g],fe(f-h,y))}}for(let u=0;u<a.length;++u)a[u]=Lt(a[u],o)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let r=0;r<e.length;++r){const i=e[r];let s=i;if(UG(e,i)>1){const o=UG(e.slice(0,r),i);s+=`_${o}`}t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const h=[];for(let m=0;m<this.inputs.length;++m)h.push({key:this.inputs[m],value:r[m]});const f=new Md(h),d=C1(this.outputs,f,{training:!0});let p;for(let m=0;m<this.lossFunctions.length;++m){const g=this.lossFunctions[m];let y=g(i[m],d[m]);s[m]!=null&&(y=vnt(y,s[m]));const b=Di(y);t.push(b),m===0?p=y:p=Xe(p,y)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=t[m];else{const y=this.metricsTensors[m][0],b=this.metricsTensors[m][1];g=Di(y(i[b],d[b]))}qi(g),o.push(g)}return p=Di(p),this.calculateLosses().forEach(m=>{p=Xe(p,m)}),p},l=this.collectedTrainableWeights.map(h=>h.read()),c=!0;return[this.optimizer_.minimize(a,c,l)].concat(o)}}makeTestFunction(){this.testFunction=e=>Se(()=>{const t=[];let r;const i=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let c=0;c<this.inputs.length;++c)o.push({key:this.inputs[c],value:i[c]});const a=new Md(o),l=C1(this.outputs,a);for(let c=0;c<this.lossFunctions.length;++c){const u=this.lossFunctions[c],h=Di(u(s[c],l[c]));c===0?r=h:r=Xe(r,h),t.push(r)}for(let c=0;c<this.metricsTensors.length;++c){const u=this.metricsTensors[c][0],h=this.metricsTensors[c][1],f=Di(u(s[h],l[h]));t.push(f)}return t})}async fit(e,t,r={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let i,s,o,a,l,c,u,h,f;try{const d=r.batchSize==null?32:r.batchSize;C3(d);const p=!1,m=await this.standardizeUserData(e,t,r.sampleWeight,r.classWeight,p,d);i=m[0],s=m[1],f=m[2];let g=!1,y;if(r.validationData!=null&&r.validationData.length>0){if(g=!0,r.validationData.length===2)l=r.validationData[0],c=r.validationData[1];else throw r.validationData.length===3?new Ln("validationData including sample weights is not supported yet."):new _e(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);const M=!0,E=await this.standardizeUserData(l,c,null,null,M,d);u=E[0],h=E[1],y=u.concat(h)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){g=!0;const M=Math.floor(i[0].shape[0]*(1-r.validationSplit)),E=i[0].shape[0];u=Ux(i,M,E),o=i,i=Ux(i,0,M),h=Ux(s,M,E),a=s,s=Ux(s,0,M),y=u.concat(h)}else r.validationSteps!=null&&(g=!0);const b=i.concat(s).concat(f);this.checkTrainableWeightsConsistency();const _=this.makeTrainFunction(),w=this.getDedupedMetricsNames();let S,C;g?(this.makeTestFunction(),S=this.testFunction,C=w.slice().concat(w.map(M=>"val_"+M))):(S=null,y=[],C=w.slice());const k=jte(r.callbacks,r.yieldEvery);return await this.fitLoop(_,b,w,d,r.epochs,r.verbose,k,S,y,r.shuffle,C,r.initialEpoch,null,null)}finally{this.isTraining=!1,Yc(i,e),Yc(s,t),Yc(o,e),Yc(a,t),Yc(u,l),Yc(h,c),f!=null&&nn(f)}}async fitLoop(e,t,r,i,s,o,a,l,c,u,h,f,d,p){i==null&&(i=32),s==null&&(s=1),u==null&&(u=!0),f==null&&(f=0);let m=!1;if(l!=null&&c!=null&&(m=!0),p!=null&&(m=!0,d==null))throw new _e("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(t,i,d,"steps_per_epoch");let y;g!=null&&(y=Tu(0,g)),o==null&&(o=1);const{callbackList:b,history:_}=qte(a,o,s,f,g,d,i,m,h);b.setModel(this),this.history=_,await b.onTrainBegin(),this.stopTraining_=!1;for(let w=f;w<s;++w){await b.onEpochBegin(w);const S={};if(d!=null)throw new Ln("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new Ln("batch shuffling is not implemneted yet");u&&gL(y);const C=Xi(y),k=k3(g,i);for(let A=0;A<k.length;++A){const M={};if(await b.onBatchBegin(A,M),Se(()=>{const E=k[A][0],N=k[A][1],O=jm(C,E,N-E);M.batch=A,M.size=N-E;const R=WO(t,O),D=e(R);for(let z=0;z<r.length;++z){const B=r[z],X=D[z];M[B]=X,qi(X)}if(A===k.length-1&&m){const z=this.testLoop(l,c,i);for(let B=0;B<r.length;++B){const X=r[B],H=z[B];qi(H),S["val_"+X]=H}}}),await b.onBatchEnd(A,M),Gte(M),this.stopTraining_)break}C.dispose()}if(await b.onEpochEnd(w,S),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return _nt(this,e,t)}async trainOnBatch(e,t){const r=await this.standardizeUserData(e,t),i=r[0],s=r[1],a=this.makeTrainFunction()(i.concat(s)),l=[];for(const c of a){const u=await c.data();l.push(u[0])}return nn(a),Yc(r[0],e),Yc(r[1],t),pa(l)}getNamedWeights(e){const t=[],r=e!=null&&e.trainableOnly,i=r?this.trainableWeights:this.weights,s=this.getWeights(r);for(let o=0;o<i.length;++o)r&&!i[o].trainable||t.push({name:i[o].originalName,tensor:s[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=xI().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-xI().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=vf(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>vf(t))}else{const t=Object.keys(this.loss);e={};const r=this.loss;for(const i of t)if(typeof r[i]=="string")e[i]=vf(r[i]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[vf(lT(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>vf(lT(e)));{const e={};for(const t in this.metrics)e[t]=vf(lT(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=rA(e.optimizer_config),r=bh(t);let i;if(typeof e.loss=="string")i=Rm(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(o=>Rm(o));else if(e.loss!=null){i={};for(const o in e.loss)i[o]=Rm(e.loss[o])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(o=>Rm(o));else if(e.metrics!=null){s={};for(const o in e.metrics)s[o]=Rm(e.metrics[o])}this.compile({loss:i,metrics:s,optimizer:r})}async save(e,t){if(typeof e=="string"){const c=gX(e);if(c.length===0)throw new _e(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new _e(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new _e("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await pD(this.getNamedWeights(t)),i=!1,s=null,a={modelTopology:this.toJSON(s,i),format:Mnt,generatedBy:`TensorFlow.js tfjs-layers v${ene}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:u,specs:h}=await pD(await this.optimizer.getWeights(),c);r.specs.push(...h),r.data=pX([r.data,u])}return this.userDefinedMetadata!=null&&(s6(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=r.data,a.weightSpecs=r.specs,e.save(a)}setUserDefinedMetadata(e){s6(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Ud.className="Model";at(Ud);class sne extends Ud{}sne.className="Functional";at(sne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function q_(n,e){if(e==null&&(e={}),typeof n=="string"){const t=yX(n,e);if(t.length===0)t.push(hY(n,e));else if(t.length>1)throw new _e(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return Nnt(n,void 0,e)}async function Nnt(n,e,t){if(t==null&&(t={}),n.load==null)throw new _e("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await n.load();let i=r.modelTopology;i.model_config!=null&&(i=i.model_config);const s=t.strict==null?!0:t.strict,o=r.weightData!=null&&r.weightSpecs!=null&&s,a=bh(rA(i),e,o),l=r.trainingConfig;if(l!=null&&a.loadTrainingConfig(l),r.userDefinedMetadata!=null&&a.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new _e("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:c,optimizerWeights:u}=$nt(r.weightData,r.weightSpecs);a.loadWeights(c,s),a.optimizer!=null&&u.length>0&&await a.optimizer.setWeights(u),nn(c),nn(u.map(h=>h.tensor))}return a}function $nt(n,e){const t=EL(n,e),r={},i=[];return e.forEach(s=>{s.group==="optimizer"?i.push({name:s.name,tensor:t[s.name]}):r[s.name]=t[s.name]}),{modelWeights:r,optimizerWeights:i}}class sv extends Ud{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:r$("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new _e(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof sv||e instanceof Ud;let r;if(t){if(r=e,r.outputs.length!==1)throw new _e("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new _e("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new _e("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=TQe({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(t)this.outputs=r.outputs,this.inputs=r.inputs;else{if(e.inboundNodes.length!==1)throw new _e(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new _e("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=Lte(this.outputs[0])}this.inboundNodes=[],new s$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:pg(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(wr(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ud({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,r=console.log){this.built||this.build(),super.summary(e,t,r)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,r={}){if(!this.built)throw new mc("The model needs to be compiled before being used.");return this.model.evaluate(e,t,r)}async evaluateDataset(e,t){if(!this.built)throw new mc("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,r={}){if(!this.built)throw new mc("The model needs to be compiled before being used.");return this.model.fit(e,t,r)}async fitDataset(e,t){if(!this.built)throw new mc("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,r={},i=!1){let s,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new _e("Legacy serialization format not supported yet.");s=t}else U(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,o=t;const a=new e(o);if(!(a instanceof sv))throw new Ln(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of s){const u=bh(l,void 0,i);i&&u.setFastWeightInitDuringBuild(!0),a.add(u)}return a}set stopTraining(e){if(this.model==null)throw new _e("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new _e("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const r={};r.className=t.getClassName(),r.config=t.getConfig(),e.push(r)}return{name:this.name,layers:e}}}sv.className="Sequential";at(sv);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Rnt(n){return new sv(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Ia=class extends Dy{getConfig(){return{}}};class one extends Ia{apply(e,t=1){return uQe(e,t)}}one.className="elu";at(one);class ane extends Ia{apply(e){return yz(e)}}ane.className="selu";at(ane);class lne extends Ia{apply(e){return Dh(e)}}lne.className="relu";at(lne);class cne extends Ia{apply(e){return Se(()=>rp(6,Dh(e)))}}cne.className="relu6";at(cne);class une extends Ia{apply(e){return e}}une.className="linear";at(une);class hne extends Ia{apply(e){return Il(e)}}hne.className="sigmoid";at(hne);class fne extends Ia{apply(e){return fQe(e)}}fne.className="hardSigmoid";at(fne);class dne extends Ia{apply(e){return Iw(e)}}dne.className="softplus";at(dne);class pne extends Ia{apply(e){return hQe(e)}}pne.className="softsign";at(pne);class mne extends Ia{apply(e){return jb(e)}}mne.className="tanh";at(mne);let c4=class extends Ia{apply(e,t=-1){return eC(e,t)}};c4.className="softmax";at(c4);class gne extends Ia{apply(e,t=-1){return tz(e,t)}}gne.className="logSoftmax";at(gne);class yne extends Ia{apply(e,t=1){return Se(()=>fe(Il(fe(e,t)),e))}}yne.className="swish";at(yne);class bne extends Ia{apply(e){return Se(()=>fe(e,jb(Iw(e))))}}bne.className="mish";at(bne);function ap(n){return n.getClassName()}function T3(n,e={}){return wC(n,_l.getMap().classNameMap,e,"activation")}function lp(n){if(n==null){const e={};return e.className="linear",e.config={},T3(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},T3(e)}else return n instanceof Ia?n:T3(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Pnt(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class vne extends Dy{}class wne extends vne{constructor(e){super(),Pnt(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return Se(()=>{let t=pi([1]);return this.hasL1&&(t=Xe(t,Kt(fe(this.l1,vs(e))))),this.hasL2&&(t=Xe(t,Kt(fe(this.l2,_C(e))))),ve(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}wne.className="L1L2";at(wne);const h6={l1l2:"L1L2"};function jr(n){return KB(n)}function f6(n,e={}){return wC(n,_l.getMap().classNameMap,e,"regularizer")}function vi(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in h6?h6[n]:n,config:{}};return f6(t)}else return n instanceof vne?n:f6(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class xne extends Xn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=xn(e);let r=Dh(e);return this.maxValue!=null&&(r=_a(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}xne.className="ReLU";at(xne);class _ne extends Xn{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=xn(e);return OM(r,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}_ne.className="LeakyReLU";at(_ne);class Sne extends Xn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=gi(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=vi(e.alphaRegularizer),this.alphaConstraint=Is(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new _e(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=wr(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const i of this.sharedAxes)t[i-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let i=1;i<e.length;++i)r[i]=e[i];this.inputSpec=[new ks({ndim:e.length,axes:r})],this.built=!0}call(e,t){return e=xn(e),HM(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Ci(this.alphaInitializer),alphaRegularizer:jr(this.alphaRegularizer),alphaConstraint:Es(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}Sne.className="PReLU";at(Sne);class Cne extends Xn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Ln(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=xn(e);return q2(r)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Cne.className="ELU";at(Cne);class kne extends Xn{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const r=xn(e);return fe(r,St(tl(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}kne.className="ThresholdedReLU";at(kne);class Tne extends Xn{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new c4().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return Se(()=>{let r=xn(e);const i=t.mask;if(i!=null){const s=fe(Dt(ga(r.shape),St(i,r.dtype)),Qt(-1e9));r=Xe(r,s)}return this.axis instanceof Array?this.axis.length>1?Jo(Dt(r,zM(r,this.axis,!0))):this.softmax(r,this.axis[0]):this.softmax(r,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}Tne.className="Softmax";at(Tne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function $b(n,e,t){if(typeof n=="number")return pg(n,e);if(n.length!==e)throw new _e(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let r=0;r<e;++r){const i=n[r];if(!oQe(i))throw new _e(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`)}return n}function wu(n,e,t,r,i=1){if(n==null)return n;const s=e+(e-1)*(i-1);let o;return t==="same"?o=n:o=n-s+1,Math.floor((o+r-1)/r)}function ch(n,e,t,r){if(n==null)return null;if(r==="valid")n=n*e+op([t-e,0]);else if(r==="same")n=n*e;else throw new _e(`Unsupport padding mode: ${r}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function u4(n,e){return Se(()=>(es(e),e==="channelsFirst"?ir(n,[0,2,3,1]):n))}function Ene(n,e){return Se(()=>(es(e),e==="channelsFirst"?ir(n,[0,2,3,4,1]):n))}function Dnt(n,e,t,r=1,i="valid",s,o=1){return Se(()=>{if(s==null&&(s=Eu()),es(s),n.shape.length!==3)throw new _e(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new _e(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new _e(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(s==="channelsFirst"&&(n=ir(n,[0,2,1])),i==="causal")throw new Ln("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=qL(n,e,r,i==="same"?"same":"valid","NWC",o);return t!=null&&(a=Uu(a,t)),a})}function d6(n,e,t,r=[1,1],i="valid",s,o,a=null){return Se(()=>{if(s==null&&(s=Eu()),es(s),n.rank!==3&&n.rank!==4)throw new _e(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new _e(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=u4(n,s);if(i==="causal")throw new Ln("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=YK({x:l,filter:e,strides:r,pad:i==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:a}),s==="channelsFirst"&&(l=ir(l,[0,3,1,2])),l})}function Ont(n,e,t,r=[1,1,1],i="valid",s,o){return Se(()=>{if(s==null&&(s=Eu()),es(s),n.rank!==4&&n.rank!==5)throw new _e(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new _e(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=Ene(n,s);if(i==="causal")throw new Ln("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=YL(a,e,r,i==="same"?"same":"valid","NDHWC",o),t!=null&&(a=Uu(a,t)),s==="channelsFirst"&&(a=ir(a,[0,4,1,2,3])),a})}class l$ extends Xn{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",l$.verifyArgs(t),this.rank=e,Ws(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Ln(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=$b(t.kernelSize,e,"kernelSize"),this.strides=$b(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Bl(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,es(this.dataFormat),this.activation=lp(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=gi(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Is(t.biasConstraint),this.biasRegularizer=vi(t.biasRegularizer),this.activityRegularizer=vi(t.activityRegularizer),this.dilationRate=$b(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new _e(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new _e(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new _e(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(lh("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!YB(e.kernelSize,"number",1,3))throw new _e(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ap(this.activation),useBias:this.useBias,biasInitializer:Ci(this.biasInitializer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),biasConstraint:Es(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Zw extends l${constructor(e,t){super(e,t),this.kernel=null,Zw.verifyArgs(t),this.filters=t.filters,Ws(this.filters,"filters"),this.kernelInitializer=gi(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Is(t.kernelConstraint),this.kernelRegularizer=vi(t.kernelRegularizer)}build(e){e=wr(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new _e(`The channel dimension of the input should be defined. Found ${e[t]}`);const r=e[t],i=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:r}}],this.built=!0}call(e,t){return Se(()=>{e=xn(e);let r;const i=this.bias==null?null:this.bias.read(),s=Ste(this.activation.getClassName());if(s!=null&&this.rank===2)r=d6(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)r=Dnt(e,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=d6(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=Ont(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Ln("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(e){e=wr(e);const t=[],r=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<r.length;++s){const o=wu(r[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);t.push(o)}let i=[e[0]];return this.dataFormat==="channelsLast"?(i=i.concat(t),i.push(this.filters)):(i.push(this.filters),i=i.concat(t)),i}getConfig(){const e={filters:this.filters,kernelInitializer:Ci(this.kernelInitializer),kernelRegularizer:jr(this.kernelRegularizer),kernelConstraint:Es(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new _e(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class TC extends Zw{constructor(e){super(2,e),TC.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!YB(e.kernelSize,"number",1,2))throw new _e(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}TC.className="Conv2D";at(TC);class EC extends Zw{constructor(e){super(3,e),EC.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new _e(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}EC.className="Conv3D";at(EC);class Ine extends TC{constructor(e){if(super(e),this.inputSpec=[new ks({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new _e(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=wr(e),e.length!==4)throw new _e("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new _e("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],i=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ks({ndim:4,axes:{[t]:r}})],this.built=!0}call(e,t){return Se(()=>{let r=xn(e);if(r.shape.length!==4)throw new _e(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const i=r.shape,s=i[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=i[o],c=i[a],u=this.kernelSize[0],h=this.kernelSize[1],f=this.strides[0],d=this.strides[1],p=ch(l,f,u,this.padding),m=ch(c,d,h,this.padding),g=[s,p,m,this.filters];this.dataFormat!=="channelsLast"&&(r=ir(r,[0,2,3,1]));let y=KL(r,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=ir(y,[0,3,1,2])),this.bias!=null&&(y=Uu(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(e){e=wr(e);const t=e.slice();let r,i,s;this.dataFormat==="channelsFirst"?(r=1,i=2,s=3):(r=3,i=1,s=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return t[r]=this.filters,t[i]=ch(t[i],l,o,this.padding),t[s]=ch(t[s],c,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Ine.className="Conv2DTranspose";at(Ine);class Ane extends EC{constructor(e){if(super(e),this.inputSpec=[new ks({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new _e(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=wr(e),e.length!==5)throw new _e("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new _e("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],i=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ks({ndim:5,axes:{[t]:r}})],this.built=!0}call(e,t){return Se(()=>{let r=xn(e);if(r.shape.length!==5)throw new _e(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const i=r.shape,s=i[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const c=i[l],u=i[o],h=i[a],f=this.kernelSize[0],d=this.kernelSize[1],p=this.kernelSize[2],m=this.strides[0],g=this.strides[1],y=this.strides[2],b=ch(c,m,f,this.padding),_=ch(u,g,d,this.padding),w=ch(h,y,p,this.padding),S=[s,b,_,w,this.filters];this.dataFormat!=="channelsLast"&&(r=ir(r,[0,2,3,4,1]));let C=ZL(r,this.kernel.read(),S,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(C=ir(C,[0,4,1,2,3])),this.bias!==null&&(C=Uu(C,this.bias.read(),this.dataFormat)),this.activation!==null&&(C=this.activation.apply(C)),C})}computeOutputShape(e){e=wr(e);const t=e.slice();let r,i,s,o;this.dataFormat==="channelsFirst"?(r=1,i=2,s=3,o=4):(r=4,i=1,s=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],u=this.strides[0],h=this.strides[1],f=this.strides[2];return t[r]=this.filters,t[i]=ch(t[i],u,a,this.padding),t[s]=ch(t[s],h,l,this.padding),t[o]=ch(t[o],f,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Ane.className="Conv3DTranspose";at(Ane);class Mne extends Zw{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new _e("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new _e("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new _e(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=gi(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=vi(t.depthwiseRegularizer),this.depthwiseConstraint=Is(t.depthwiseConstraint),this.pointwiseInitializer=gi(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=vi(t.pointwiseRegularizer),this.pointwiseConstraint=Is(t.pointwiseConstraint)}build(e){if(e=wr(e),e.length<this.rank+2)throw new _e(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new _e(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const r=e[t],i=this.kernelSize.concat([r,this.depthMultiplier]),s=[];for(let a=0;a<this.rank;++a)s.push(1);s.push(r*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new ks({ndim:this.rank+2,axes:{[t]:r}})],this.built=!0}call(e,t){return Se(()=>{e=xn(e);let r;if(this.rank===1)throw new Ln("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=ir(e,[0,2,3,1])),r=bz(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=Uu(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=ir(r,[0,3,1,2])),r})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Ci(this.depthwiseInitializer),e.pointwiseInitializer=Ci(this.pointwiseInitializer),e.depthwiseRegularizer=jr(this.depthwiseRegularizer),e.pointwiseRegularizer=jr(this.pointwiseRegularizer),e.depthwiseConstraint=Es(this.depthwiseConstraint),e.pointwiseConstraint=Es(this.pointwiseConstraint),e}}Mne.className="SeparableConv";class Nne extends Mne{constructor(e){super(2,e)}}Nne.className="SeparableConv2D";at(Nne);class c$ extends Zw{constructor(e){super(1,e),c$.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!YB(e.kernelSize,"number",1,1))throw new _e(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}c$.className="Conv1D";at(c$);class $ne extends Xn{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Se(()=>{if(e=xn(e),this.dataFormat==="channelsLast"){const r=aT(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return aT(r,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const r=aT(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return aT(r,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}$ne.className="Cropping2D";at($ne);class Rne extends Xn{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,es(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,rQe(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],r=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,r]}else{const t=e[1]==null?null:this.size[0]*e[1],r=e[2]==null?null:this.size[1]*e[2];return[e[0],t,r,e[3]]}}call(e,t){return Se(()=>{let r=xn(e);const i=r.shape;if(this.dataFormat==="channelsFirst"){r=ir(r,[0,2,3,1]);const s=this.size[0]*i[2],o=this.size[1]*i[3],a=this.interpolation==="nearest"?Ss.resizeNearestNeighbor(r,[s,o]):Ss.resizeBilinear(r,[s,o]);return ir(a,[0,3,1,2])}else{const s=this.size[0]*i[1],o=this.size[1]*i[2];return this.interpolation==="nearest"?Ss.resizeNearestNeighbor(r,[s,o]):Ss.resizeBilinear(r,[s,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}Rne.className="UpSampling2D";at(Rne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Fnt(n,e,t=[1,1],r="valid",i,s){return Se(()=>{i==null&&(i=Eu()),es(i);let o=u4(n,i);if(n.rank!==4)throw new _e(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new _e(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=j2(o,e,t,r==="same"?"same":"valid","NHWC",s),i==="channelsFirst"&&(o=ir(o,[0,3,1,2])),o})}class Pne extends l${constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=gi(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Is(e.depthwiseConstraint),this.depthwiseRegularizer=vi(e.depthwiseRegularizer)}build(e){if(e=wr(e),e.length<4)throw new _e(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new _e(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const r=e[t],i=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",i,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Se(()=>{e=xn(e);let r=Fnt(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=Uu(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(e){e=wr(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=wu(t,this.kernelSize[0],this.padding,this.strides[0]),o=wu(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],i,s,o]:[e[0],s,o,i]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Ci(this.depthwiseInitializer),e.depthwiseRegularizer=jr(this.depthwiseRegularizer),e.depthwiseConstraint=Es(this.depthwiseRegularizer),e}}Pne.className="DepthwiseConv2D";at(Pne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Dne(n,e,t,r){if(Array.isArray(n)){if(e!=null||t!=null)throw new _e("When inputs is an array, neither initialState or constants should be provided");r!=null&&(t=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function i(s){return s==null||Array.isArray(s)?s:[s]}return e=i(e),t=i(t),{inputs:n,initialState:e,constants:t}}function One(n,e,t,r=!1,i,s,o=!1,a=!1){return Se(()=>{const l=e.shape.length;if(l<3)throw new _e(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(Tu(2,l));if(e=ir(e,c),s!=null)throw new Ln("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),i!=null&&(i=St(St(i,"bool"),"float32"),i.rank===l-1&&(i=ss(i,-1)),i=ir(i,c)),r&&(e=kc(e,0),i!=null&&(i=kc(i,0)));const u=[];let h,f=t;const d=e.shape[0],p=Tc(e);let m;i!=null&&(m=Tc(i));for(let y=0;y<d;++y){const b=p[y],_=Se(()=>n(b,f));if(i==null)h=_[0],f=_[1];else{const w=Se(()=>{const S=m[y],C=Dt(Rl(S),S),k=Xe(fe(_[0],S),fe(f[0],C)),A=f.map((M,E)=>Xe(fe(_[1][E],S),fe(M,C)));return{output:k,newStates:A}});h=w.output,f=w.newStates}a&&u.push(h)}let g;return a&&(g=Sa(u,1)),[h,g,f]})}class Rp extends Xn{constructor(e){super(e);let t;if(e.cell==null)throw new _e("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new d4({cells:e.cell}):t=e.cell,t.stateSize==null)throw new _e("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new ks({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Tu(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){zO(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const r=t[0];let i;if(this.returnSequences?i=[e[0],e[1],r]:i=[e[0],r],this.returnState){const s=[];for(const o of t)s.push([e[0],o]);return[i].concat(s)}else return i}computeMask(e,t){return Se(()=>{Array.isArray(t)&&(t=t[0]);const r=this.returnSequences?t:null;if(this.returnState){const i=this.states.map(s=>null);return[r].concat(i)}else return r})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let r=0;r<e;++r)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Ln("Constants support is not implemented in RNN yet.");zO(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new ks({shape:[t,null,...r]});const i=[e[0]].concat(e.slice(2));this.cell.build(i);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!Rn(this.stateSpec.map(o=>o.shape[o.shape.length-1]),s))throw new _e(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(o=>new ks({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){Se(()=>{if(!this.stateful)throw new ah("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new _e("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>pi([r,i])):this.states_=[pi([r,this.cell.stateSize])];else if(e==null)nn(this.states_),this.keptStates!=null&&(nn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>pi([r,i])):this.states_[0]=pi([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new _e(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):nn(this.states_);for(let i=0;i<this.states_.length;++i){const s=e[i],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,a=[r,o];if(!Rn(s.shape,a))throw new _e(`State ${i} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s.shape}`);this.states_[i]=s}}this.states_=this.states_.map(i=>qi(i.clone()))})}apply(e,t){let r=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const s=Dne(e,r,i,this.numConstants);e=s.inputs,r=s.initialState,i=s.constants;let o=[],a=[];if(r!=null){t.initialState=r,o=o.concat(r),this.stateSpec=[];for(const c of r)this.stateSpec.push(new ks({shape:c.shape}));a=a.concat(this.stateSpec)}if(i!=null&&(t.constants=i,o=o.concat(i),this.numConstants=i.length),o[0]instanceof kh){const c=[e].concat(o),u=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=u;const f=super.apply(c,t);return this.inputSpec=h,f}else return super.apply(e,t)}call(e,t){return Se(()=>{const r=t==null?null:t.mask,i=t==null?null:t.training;let s=t==null?null:t.initialState;e=xn(e),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==o)throw new _e(`RNN Layer has ${o} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:i},c=One((p,m)=>{const g=this.cell.call([p].concat(m),a);return[g[0],g.slice(1)]},e,s,this.goBackwards,r,null,this.unroll,this.returnSequences),u=c[0],h=c[1],f=c[2];this.stateful&&this.resetStates(f,i);const d=this.returnSequences?h:u;return this.returnState?[d].concat(f):d})}getInitialState(e){return Se(()=>{let t=pi(e.shape);return t=Kt(t,[1,2]),t=xC(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?FO(t,[1,r]):t):this.cell.stateSize>1?[FO(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===Rp.className&&(t.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),e),t)}static fromConfig(e,t,r={}){const i=t.cell,s=bh(i,r);return new e(Object.assign(t,{cell:s}))}}Rp.className="RNN";at(Rp);class u$ extends Xn{}class h4 extends u${constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ws(this.units,"units"),this.activation=lp(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=gi(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gi(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gi(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vi(e.kernelRegularizer),this.recurrentRegularizer=vi(e.recurrentRegularizer),this.biasRegularizer=vi(e.biasRegularizer),this.kernelConstraint=Is(e.kernelConstraint),this.recurrentConstraint=Is(e.recurrentConstraint),this.biasConstraint=Is(e.biasConstraint),this.dropout=iv([1,op([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=iv([1,op([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=wr(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Se(()=>{if(e=e,e.length!==2)throw new _e(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];const i=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=cp({ones:()=>Rl(e),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=cp({ones:()=>Rl(r),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));let s;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?s=yh(fe(e,o),this.kernel.read()):s=yh(e,this.kernel.read()),this.bias!=null&&(s=Uu(s,this.bias.read())),a!=null&&(r=fe(r,a));let l=Xe(s,yh(r,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ap(this.activation),useBias:this.useBias,kernelInitializer:Ci(this.kernelInitializer),recurrentInitializer:Ci(this.recurrentInitializer),biasInitializer:Ci(this.biasInitializer),kernelRegularizer:jr(this.kernelRegularizer),recurrentRegularizer:jr(this.recurrentRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Es(this.kernelConstraint),recurrentConstraint:Es(this.recurrentConstraint),biasConstraint:Es(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}h4.className="SimpleRNNCell";at(h4);class Fne extends Rp{constructor(e){e.cell=new h4(e),super(e)}call(e,t){return Se(()=>{this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,i=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:r,training:i,initialState:s})})}static fromConfig(e,t){return new e(t)}}Fne.className="SimpleRNN";at(Fne);class f4 extends u${constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new _e("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Ws(this.units,"units"),this.activation=lp(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=lp(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=gi(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gi(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gi(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vi(e.kernelRegularizer),this.recurrentRegularizer=vi(e.recurrentRegularizer),this.biasRegularizer=vi(e.biasRegularizer),this.kernelConstraint=Is(e.kernelConstraint),this.recurrentConstraint=Is(e.recurrentConstraint),this.biasConstraint=Is(e.biasConstraint),this.dropout=iv([1,op([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=iv([1,op([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=wr(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Se(()=>{if(e=e,e.length!==2)throw new _e(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training==null?!1:t.training;let i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=cp({ones:()=>Rl(e),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=cp({ones:()=>Rl(i),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,c;0<this.dropout&&this.dropout<1&&(e=fe(e,s[0]));let u=yh(e,this.kernel.read());this.useBias&&(u=Uu(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=fe(i,o[0]));const h=this.recurrentKernel.read(),[f,d]=Ga(h,[2*this.units,this.units],h.rank-1),p=yh(i,f),[m,g,y]=Ga(u,3,u.rank-1),[b,_]=Ga(p,2,p.rank-1);a=this.recurrentActivation.apply(Xe(m,b)),l=this.recurrentActivation.apply(Xe(g,_));const w=yh(fe(l,i),d);c=this.activation.apply(Xe(y,w));const S=Xe(fe(a,i),fe(Xe(1,ci(a)),c));return[S,S]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ap(this.activation),recurrentActivation:ap(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ci(this.kernelInitializer),recurrentInitializer:Ci(this.recurrentInitializer),biasInitializer:Ci(this.biasInitializer),kernelRegularizer:jr(this.kernelRegularizer),recurrentRegularizer:jr(this.recurrentRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Es(this.kernelConstraint),recurrentConstraint:Es(this.recurrentConstraint),biasConstraint:Es(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}f4.className="GRUCell";at(f4);class Lne extends Rp{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new f4(e),super(e)}call(e,t){return Se(()=>{this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,i=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:r,training:i,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Lne.className="GRU";at(Lne);class h$ extends u${constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ws(this.units,"units"),this.activation=lp(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=lp(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=gi(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gi(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gi(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=vi(e.kernelRegularizer),this.recurrentRegularizer=vi(e.recurrentRegularizer),this.biasRegularizer=vi(e.biasRegularizer),this.kernelConstraint=Is(e.kernelConstraint),this.recurrentConstraint=Is(e.recurrentConstraint),this.biasConstraint=Is(e.biasConstraint),this.dropout=iv([1,op([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=iv([1,op([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=wr(e);const r=e[e.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let i;if(this.useBias){if(this.unitForgetBias){const s=this.biasInitializer,o=this.units;i=new(t=class extends Dc{apply(l,c){const u=s.apply([o]),h=new JB().apply([o]),f=s.apply([o*2]);return HG(HG(u,h),f)}},t.className="CustomInit",t)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Se(()=>{const r=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new _e(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let i=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=cp({ones:()=>Rl(e),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=cp({ones:()=>Rl(i),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,c,u,h;0<this.dropout&&this.dropout<1&&(e=fe(e,o[0]));let f=yh(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=fe(i,a[0])),f=Xe(f,yh(i,this.recurrentKernel.read())),this.useBias&&(f=Uu(f,this.bias.read()));const[d,p,m,g]=Ga(f,4,f.rank-1);l=this.recurrentActivation.apply(d),c=this.recurrentActivation.apply(p),u=Xe(fe(c,s),fe(l,this.activation.apply(m))),h=this.recurrentActivation.apply(g);const y=fe(h,this.activation.apply(u));return[y,y,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ap(this.activation),recurrentActivation:ap(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ci(this.kernelInitializer),recurrentInitializer:Ci(this.recurrentInitializer),biasInitializer:Ci(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:jr(this.kernelRegularizer),recurrentRegularizer:jr(this.recurrentRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Es(this.kernelConstraint),recurrentConstraint:Es(this.recurrentConstraint),biasConstraint:Es(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}h$.className="LSTMCell";at(h$);class zne extends Rp{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new h$(e),super(e)}call(e,t){return Se(()=>{this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,i=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:r,training:i,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}zne.className="LSTM";at(zne);class d4 extends u${constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Se(()=>{e=e;let r=e.slice(1);const i=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?i.push(r.splice(0,a.stateSize.length)):i.push(r.splice(0,1));i.reverse();const s=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];r=i[a],a===0?o=[e[0]].concat(r):o=[o[0]].concat(r),o=l.call(o,t),s.push(o.slice(1))}r=[];for(const a of s.slice().reverse())r.push(...a);return[o[0]].concat(r)})}build(e){zO(e)&&(e=e[0]),e=e;let t;this.cells.forEach((r,i)=>{Gm(`RNNCell_${i}`,()=>{r.build(e),Array.isArray(r.stateSize)?t=r.stateSize[0]:t=r.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=s=>({className:s.getClassName(),config:s.getConfig()}),i={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),i)}static fromConfig(e,t,r={}){const i=[];for(const s of t.cells)i.push(bh(s,r));return new e({cells:i})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.cells)t.push(...r.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return BO(e)}setWeights(e){const t=[];for(const r of this.cells){const i=r.weights.length,s=e.splice(i);for(let o=0;o<r.weights.length;++o)t.push([r.weights[o],s[o]])}s4(t)}}d4.className="StackedRNNCells";at(d4);function cp(n){const{ones:e,rate:t,training:r=!1,count:i=1,dropoutFunc:s}=n,o=()=>s!=null?s(e(),t):Mte(e(),t),a=()=>SC(o,e,r);return!i||i<=1?qi(a().clone()):Array(i).fill(void 0).map(a).map(c=>qi(c.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var Lnt=globalThis&&globalThis.__rest||function(n,e){var t={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&e.indexOf(r)<0&&(t[r]=n[r]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,r=Object.getOwnPropertySymbols(n);i<r.length;i++)e.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(n,r[i])&&(t[r[i]]=n[r[i]]);return t};class Bne extends Rp{constructor(e){if(e.unroll)throw new Ln("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Ln("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new ks({ndim:5})]}call(e,t){return Se(()=>{if(this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new _e("ConvRNN2D cell does not support constants");const r=t==null?null:t.mask,i=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:r,training:i,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Se(()=>{const{stateSize:t}=this.cell,r=e.shape,i=this.computeSingleOutputShape(r),s=[i[0],...i.slice(2)],o=pi(s);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){Se(()=>{if(!this.stateful)throw new ah("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,i=this.computeSingleOutputShape(r),s=[i[0],...i.slice(2)];if(r[0]==null)throw new _e("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>pi(s)):this.states_=[pi(s)];else if(e==null)nn(this.states_),this.keptStates!=null&&(nn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>pi(s)):this.states_[0]=pi(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new _e(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):nn(this.states_);for(let a=0;a<this.states_.length;++a){const l=e[a],c=s;if(!Rn(l.shape,c))throw new _e(`State ${a} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>qi(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:r,kernelSize:i,padding:s,strides:o,dilationRate:a}=this.cell,l=t==="channelsFirst",c=e[l?3:2],u=e[l?4:3],h=wu(c,i[0],s,o[0],a[0]),f=wu(u,i[1],s,o[1],a[1]);return[...e.slice(0,2),...l?[r,h,f]:[h,f,r]]}}Bne.className="ConvRNN2D";class p4 extends h${constructor(e){const{filters:t,kernelSize:r,strides:i,padding:s,dataFormat:o,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Ws(this.filters,"filters"),this.kernelSize=$b(r,2,"kernelSize"),this.kernelSize.forEach(l=>Ws(l,"kernelSize")),this.strides=$b(i||1,2,"strides"),this.strides.forEach(l=>Ws(l,"strides")),this.padding=s||"valid",Bl(this.padding),this.dataFormat=o||"channelsLast",es(this.dataFormat),this.dilationRate=$b(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>Ws(l,"dilationRate"))}build(e){var t;e=wr(e);const r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new _e(`The channel dimension of the input should be defined. Found ${e[r]}`);const i=e[r],s=4,o=this.kernelSize.concat([i,this.filters*s]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,u=this.filters;l=new(t=class extends Dc{apply(f,d){const p=c.apply([u]),m=ga([u]),g=c.apply([u*2]);return ZB([p,m,g])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Se(()=>{if(e.length!==3)throw new _e(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training||!1,i=e[0],s=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=cp({ones:()=>Rl(i),rate:this.dropout,training:r,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(ge,ae,Ne)=>!ae||!ae[Ne]?ge:fe(ae[Ne],ge);let u=c(i,l,0),h=c(i,l,1),f=c(i,l,2),d=c(i,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=cp({ones:()=>Rl(s),rate:this.recurrentDropout,training:r,count:a,dropoutFunc:this.dropoutFunc}));const p=this.recurrentDropoutMask;let m=c(s,p,0),g=c(s,p,1),y=c(s,p,2),b=c(s,p,3);const _=3,[w,S,C,k]=Ga(this.kernel.read(),a,_),[A,M,E,N]=this.useBias?Ga(this.bias.read(),a):[null,null,null,null];u=this.inputConv(u,w,A,this.padding),h=this.inputConv(h,S,M,this.padding),f=this.inputConv(f,C,E,this.padding),d=this.inputConv(d,k,N,this.padding);const[O,R,D,z]=Ga(this.recurrentKernel.read(),a,_);m=this.recurrentConv(m,O),g=this.recurrentConv(g,R),y=this.recurrentConv(y,D),b=this.recurrentConv(b,z);const B=this.recurrentActivation.apply(Xe(u,m)),X=this.recurrentActivation.apply(Xe(h,g)),H=Xe(fe(X,o),fe(B,this.activation.apply(Xe(f,y)))),te=fe(this.recurrentActivation.apply(Xe(d,b)),this.activation.apply(H));return[te,te,H]})}getConfig(){const e=super.getConfig(),t=Lnt(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},t),r)}inputConv(e,t,r,i){const s=tp(e,t,this.strides,i||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?Uu(s,r,this.dataFormat):s}recurrentConv(e,t){return tp(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}p4.className="ConvLSTM2DCell";at(p4);class Vne extends Bne{constructor(e){const t=new p4(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}Vne.className="ConvLSTM2D";at(Vne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class m4 extends Xn{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,r=[];for(let i=0;i<this.noiseShape.length;++i)r.push(this.noiseShape[i]==null?t[i]:this.noiseShape[i]);return r}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=xn(e);if(0<this.rate&&this.rate<1){const i=t.training==null?!1:t.training,s=this.getNoiseShape(r);return SC(()=>Mte(r,this.rate,s,this.seed),()=>r,i)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}m4.className="Dropout";at(m4);class Une extends m4{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}Une.className="SpatialDropout1D";at(Une);class g4 extends Xn{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Ws(this.units,"units"),this.activation=lp(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=gi(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=gi(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Is(e.kernelConstraint),this.biasConstraint=Is(e.biasConstraint),this.kernelRegularizer=vi(e.kernelRegularizer),this.biasRegularizer=vi(e.biasRegularizer),this.activityRegularizer=vi(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=wr(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=wr(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=xn(e),i=Ste(this.activation.getClassName());let s;return i!=null?s=yh(r,this.kernel.read(),i,this.bias?this.bias.read():null):(s=yh(r,this.kernel.read()),this.bias!=null&&(s=Uu(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){const e={units:this.units,activation:ap(this.activation),useBias:this.useBias,kernelInitializer:Ci(this.kernelInitializer),biasInitializer:Ci(this.biasInitializer),kernelRegularizer:jr(this.kernelRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Es(this.kernelConstraint),biasConstraint:Es(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}g4.className="Dense";at(g4);class Wne extends Xn{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=wr(e);for(const t of e.slice(1))if(t==null)throw new _e(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Vd(e,1)]}call(e,t){return Se(()=>{this.invokeCallHook(e,t);let r=xn(e);if(this.dataFormat==="channelsFirst"&&r.rank>1){const i=[0];for(let s=2;s<r.rank;++s)i.push(s);i.push(1),r=ir(r,i)}return cQe(r)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}Wne.className="Flatten";at(Wne);class Hne extends Xn{constructor(e){super(e),this.supportsMasking=!0,this.activation=lp(e.activation)}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=xn(e);return this.activation.apply(r)})}getConfig(){const e={activation:ap(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}Hne.className="Activation";at(Hne);class Gne extends Xn{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Se(()=>(e=xn(e),aQe(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}Gne.className="RepeatVector";at(Gne);let jne=class extends Xn{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const r="Total size of new array must be unchanged.",i=t.slice();let s=1,o=null;for(let l=0;l<i.length;++l){const c=i[l];if(this.isUnknown(c))if(o===null)o=l;else throw new _e("Can only specifiy one unknown dimension.");else s*=c}const a=Vd(e);if(o!==null){if(s===0||a%s!==0)throw new _e(r);i[o]=a/s}else if(a!==s)throw new _e(r);return i}computeOutputShape(e){let t=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=xn(e),i=r.shape,s=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return ve(r,s)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};jne.className="Reshape";at(jne);class qne extends Xn{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Tu(1,e.dims.length+1);if(!Rn(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ks({ndim:this.dims.length+1})]}computeOutputShape(e){e=wr(e);const t=e.slice();return this.dims.forEach((r,i)=>{t[i+1]=e[r]}),t}call(e,t){return ir(xn(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}qne.className="Permute";at(qne);class Xne extends Xn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const r=xn(e),i=-1;return _I(qb(r,this.maskValue),i)}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=xn(e),i=-1,s=!0,o=_I(qb(r,this.maskValue),i,s);return fe(r,St(o,r.dtype))})}}Xne.className="Masking";at(Xne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Kne extends Xn{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Hr(e.inputLength))}this.inputDim=e.inputDim,Ws(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Ws(this.outputDim,"outputDim"),this.embeddingsInitializer=gi(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=vi(e.embeddingsRegularizer),this.activityRegularizer=vi(e.activityRegularizer),this.embeddingsConstraint=Is(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Se(()=>this.maskZero?(e=xn(e),qb(e,ur(e))):null)}computeOutputShape(e){if(e=wr(e),this.inputLength==null)return[...e,this.outputDim];const t=Hr(this.inputLength);if(t.length!==e.length-1)throw new _e(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let i=0;i<t.length;++i){const s=t[i],o=e[i+1];if(s!=null&&o!=null&&s!==o)throw new _e(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[r]=o),r++}}return[e[0],...t,this.outputDim]}call(e,t){return Se(()=>{this.invokeCallHook(e,t);let r=xn(e);r.dtype!=="int32"&&(r=gh(r,"int32"));const i=Ate(this.embeddings.read(),ve(r,[r.size]));return ve(i,wr(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ci(this.embeddingsInitializer),embeddingsRegularizer:jr(this.embeddingsRegularizer),activityRegularizer:jr(this.activityRegularizer),embeddingsConstraint:Es(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}Kne.className="Embedding";at(Kne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Xy extends Xn{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Ln}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const r=e.slice(0,e.length-t.length);for(let i=0;i<t.length;++i){const s=e[e.length-t.length+i],o=t[i];if(s==null||o==null||s<0||o<0)r.push(null);else if(s===1)r.push(o);else if(o===1)r.push(s);else{if(s!==o)throw new _e("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));r.push(s)}}return r}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[wr(e)]),e=e,e.length<2)throw new _e(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=Bd(t),t.length>1)throw new _e(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let r=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){const o=e[s]==null?null:e[s].slice(1);r=this.computeElementwiseOpOutputShape(r,o)}const i=e.map(s=>s.length);e.indexOf(null)===-1&&Bd(i).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Se(()=>{if(e=e,this.reshapeRequired){const r=[],i=e.map(s=>s.rank);if(i.indexOf(null)===-1){const s=op(i);for(let o of e){const a=o.rank;for(let l=0;l<s-a;++l)o=xC(o,1);r.push(o)}return this.mergeFunction(r)}else{let s=!1;for(const l of e){const c=l.rank;if(c==null){const u=l.shape,h=u[0],f=u.slice(1).concat([h]);let d=ve(l,[h].concat(Vd(u.slice(1))));d=ir(d,[1,0]),d=ve(d,f),r.push(d),s=!0}else if(c>1){const u=Tu(1,c).concat([0]);r.push(ir(l,u)),s=!0}else r.push(l)}let o=this.mergeFunction(r);const a=o.rank;if(s){if(a==null){const l=o.shape,c=l.length,u=l[c-1],h=[u].concat(l.slice(0,l.length-1));o=ve(ir(ve(o,[-1,u]),[1,0]),h)}else if(a>1){const l=[a-1].concat(Tu(0,a-1));o=ir(o,l)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let i=1;i<e.length;++i){const s=e[i]==null?null:e[i].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let r=[];for(const i of e)i!=null&&i[0]!==null&&r.push(i[0]);return r=Bd(r),r.length===1?t=r.concat(t):t=[null].concat(t),t}computeMask(e,t){return Se(()=>{if(t==null)return null;if(!Array.isArray(t))throw new _e("`mask` should be an Array");if(!Array.isArray(e))throw new _e("`inputs` should be an Array");if(t.length!==e.length)throw new _e(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(i=>i==null))return null;t=t.map(i=>i==null?i:ss(i,0));let r=t[0];for(let i=1;i<t.length-1;++i)r=_h(r,t[i]);return r})}}let Yne=class extends Xy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=Xe(t,e[r]);return t})}};Yne.className="Add";at(Yne);let Zne=class extends Xy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=fe(t,e[r]);return t})}};Zne.className="Multiply";at(Zne);class Jne extends Xy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=Xe(t,e[r]);return fe(1/e.length,t)})}}Jne.className="Average";at(Jne);class Qne extends Xy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=Uf(t,e[r]);return t})}}Qne.className="Maximum";at(Qne);class ere extends Xy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=rp(t,e[r]);return t})}}ere.className="Minimum";at(ere);class tre extends Xy{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new _e("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const i of e)if(i!=null){t=!1;break}if(t)return;const r=[];for(let i=0;i<e.length;++i){const s=e[i].slice();s.splice(this.axis,1);let o=!1;for(const a of r)if(Rn(a,s)){o=!0;break}o||r.push(s)}if(r.length>1)throw new _e("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Se(()=>ZB(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new _e("A `Concatenate` layer should be called on a list of inputs.");const t=e,r=t[0].slice(),i=this.axis<0?r.length+this.axis:this.axis;for(const s of t.slice(1)){if(r[i]==null||s[i]==null){r[i]=null;break}r[i]+=s[i]}return r}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new _e("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new _e("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new _e(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Se(()=>{let r=!0;if(t.forEach(o=>{if(o!=null){r=!1;return}}),r)return null;const i=[];for(let o=0;o<e.length;++o)t[o]==null?i.push(St(Rl(e[o]),"bool")):t[o].rank<e[o].rank?i.push(ss(t[o],-1)):i.push(t[o]);const s=li(i,this.axis);return OL(s,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}tre.className="Concatenate";at(tre);function Wx(n,e){for(;n<0;)n+=e;return n}function znt(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new Ln("batchDot is not implemented for tensors of 4D or higher rank yet");if(U(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),U(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new Ln("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,i=e.shape.length;t==null&&(t=[r-1,i-2]);const s=t;return Se(()=>{let o;if(r>i){o=r-i;const l=[];for(let c=0;c<o;++c)l.push(1);e=ve(e,e.shape.concat(l))}else if(i>r){o=i-r;const l=[];for(let c=0;c<o;++c)l.push(1);n=ve(n,n.shape.concat(l))}else o=0;let a;if(n.shape.length===2&&e.shape.length===2)s[0]===s[1]?a=Kt(fe(n,e),s[0]):a=Kt(fe(ir(n,[1,0]),e),s[1]);else{const l=s[0]!==n.shape.length-1,c=s[1]===e.shape.length-1;a=Gn(n,e,l,c)}if(o>0){let l;r>i?l=r+i-3:l=r-1;const c=[];for(let u=l;u<l+o;++u)c.push(u);a=br(a,c)}return a.shape.length===1&&(a=ss(a,1)),a})}class nre extends Xy{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){U(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],r=e[1];if(t.length>3||r.length>3)throw new Ln("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,r);if(t[i[0]]!==r[i[1]])throw new _e(`Dimension incompatibility: ${t[i[0]]} !== ${r[i[1]]}`)}mergeFunction(e){if(e.length!==2)throw new _e(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],r=e[1],i;return Array.isArray(this.axes)?i=this.axes.map((s,o)=>Wx(s,e[o].shape.length)):i=[Wx(this.axes,t.shape.length),Wx(this.axes,r.shape.length)],this.normalize&&(t=JI(t,i[0]),r=JI(r,i[1])),znt(t,r,i)}interpretAxes(e,t){let r;return Array.isArray(this.axes)?r=this.axes:r=[Wx(this.axes,e.length),Wx(this.axes,t.length)],r}computeOutputShape(e){U(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),r=e[1].slice();if(t.length>3||r.length>3)throw new Ln("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,r);t.splice(i[0],1),r.splice(i[1],1),r.splice(0,1);const s=t.concat(r);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}nre.className="Dot";at(nre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class rre extends Xn{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=xn(e);return SC(()=>Xe(i$(r.shape,0,this.stddev),r),()=>r,t.training||!1)})}}rre.className="GaussianNoise";at(rre);class ire extends Xn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=xn(e);return this.rate>0&&this.rate<1?SC(()=>{const s=Math.sqrt(this.rate/(1-this.rate));return fe(r,i$(r.shape,1,s))},()=>r,t.training||!1):r})}}ire.className="GaussianDropout";at(ire);class sre extends Xn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||xn(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Se(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(e);return SC(()=>{const s=xn(e),o=1.6732632423543772,a=1.0507009873554805,l=-o*a;let c=Tp(Ep(r),this.rate);c=gh(c,"float32");const u=((1-this.rate)*(1+this.rate*l**2))**-.5,h=-u*l*this.rate,f=Xe(fe(s,c),fe(Xe(c,-1),l));return Xe(fe(f,u),h)},()=>xn(e),t.training||!1)}return e})}}sre.className="AlphaDropout";at(sre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function X_(n,e,t,r,i,s=.001){let o;if(n.rank===2)o=zL(n,e,t,r,i,s);else if(n.rank===3)o=BL(n,e,t,r,i,s);else if(n.rank===4)o=VL(n,e,t,r,i,s);else throw new Ln(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function Bnt(n,e,t,r,i=.001){return Se(()=>{const s=Z2(n,r),o=s.mean,a=s.variance;return[X_(n,o,a,t,e,i),o,a]})}function Vnt(n,e,t,r,i=.001){return Se(()=>{const s=Z2(n,r),o=s.mean,a=s.variance,l=[];for(const p of Tu(0,n.rank))r.indexOf(p)!==-1?l.push(1):l.push(n.shape[p]);const c=ve(o,l),u=ve(a,l),h=e==null?null:ve(e,l),f=t==null?null:ve(t,l);return[X_(n,c,u,f,h,i),o,a]})}function Unt(n,e,t,r,i=.001){return Rn(r.slice().sort(),Tu(0,n.rank-1))?Bnt(n,e,t,r,i):Vnt(n,e,t,r,i)}class ore extends Xn{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=gi(e.betaInitializer||"zeros"),this.gammaInitializer=gi(e.gammaInitializer||"ones"),this.movingMeanInitializer=gi(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=gi(e.movingVarianceInitializer||"ones"),this.betaConstraint=Is(e.betaConstraint),this.gammaConstraint=Is(e.gammaConstraint),this.betaRegularizer=vi(e.betaRegularizer),this.gammaRegularizer=vi(e.gammaRegularizer)}build(e){e=wr(e);const t=this.axis>=0?this.axis:this.axis+e.length,r=e[t];if(r==null)throw new _e(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new ks({ndim:e.length,axes:{[t]:r}})];const i=[r];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Se(()=>{const r=t.training==null?!1:t.training,i=xn(e),s=i.shape,o=s.length,a=Tu(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const c=pg(1,o);c[l]=s[l];const u=a.slice();u.sort();const h=!Rn(u,Tu(0,o).slice(0,o-1)),f=()=>{if(h){const b=ve(this.movingMean.read(),c),_=ve(this.movingVariance.read(),c),w=this.center?ve(this.beta.read(),c):null,S=this.scale?ve(this.gamma.read(),c):null;return X_(i,b,_,w,S,this.epsilon)}else return X_(i,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return f();const[d,p,m]=Unt(i,this.gamma.read(),this.beta.read(),a,this.epsilon),g=(b,_,w)=>{Se(()=>{const S=1-w,C=b.read(),k=fe(Dt(C,_),S);b.write(Dt(C,k))})};return(()=>{g(this.movingMean,p,this.momentum),g(this.movingVariance,m,this.momentum)})(),d})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ci(this.betaInitializer),gammaInitializer:Ci(this.gammaInitializer),movingMeanInitializer:Ci(this.movingMeanInitializer),movingVarianceInitializer:Ci(this.movingVarianceInitializer),betaRegularizer:jr(this.betaRegularizer),gammaRegularizer:jr(this.gammaRegularizer),betaConstraint:Es(this.betaConstraint),gammaConstraint:Es(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}ore.className="BatchNormalization";at(ore);class are extends Xn{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=gi(e.betaInitializer||"zeros"),this.gammaInitializer=gi(e.gammaInitializer||"ones"),this.betaRegularizer=vi(e.betaRegularizer),this.gammaRegularizer=vi(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=wr(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(const s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==Bd(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(s=>e[s]),i=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,i):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,i):this.beta=null,this.built=!0}call(e,t){const r=xn(e),i=r.shape,s=i.length;return Se(()=>{let{mean:a,variance:l}=Z2(r,this.axis,!0);const c=pg(1,s);for(const m of this.axis)c[m]=i[m];const u=m=>m!=null&&m.shape.length!==s?ve(m,c):m;let h=this.scale?u(this.gamma.read()):null,f=this.center?u(this.beta.read()):null;const d=[],p=[];for(let m=0;m<s;++m)this.axis.indexOf(m)!==-1?(d.push(i[m]),p.push(1)):(d.push(1),p.push(i[m]));return a=dc(a,d),l=dc(l,d),h!=null&&(h=dc(h,p)),f!=null&&(f=dc(f,p)),X_(r,a,l,f,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ci(this.betaInitializer),gammaInitializer:Ci(this.gammaInitializer),betaRegularizer:jr(this.betaRegularizer),gammaRegularizer:jr(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}are.className="LayerNormalization";at(are);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Wnt(n,e,t){return Se(()=>{if(n.rank!==4)throw new _e(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new _e("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Eu()),t!=="channelsLast"&&t!=="channelsFirst")throw new _e(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return t==="channelsFirst"?r=[[0,0],[0,0],e[0],e[1]]:r=[[0,0],e[0],e[1],[0,0]],_u(n,r)})}class lre extends Xn{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Eu():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new _e(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,r;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new _e(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new _e(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[t,r]}this.inputSpec=[new ks({ndim:4})]}computeOutputShape(e){e=wr(e);let t,r;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?r=e[3]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],e[1],t,r]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?r=e[2]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],t,r,e[3]])}call(e,t){return Se(()=>Wnt(xn(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}lre.className="ZeroPadding2D";at(lre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function f$(n,e,t,r,i,s){return Se(()=>{es(i),kte(s),Bl(r),t==null&&(t=[1,1]),r==null&&(r="valid"),i==null&&(i=Eu()),s==null&&(s="max"),n=u4(n,i);let o;const a=r==="same"?"same":"valid";return s==="max"?o=UM(n,e,t,a):o=$M(n,e,t,a),i==="channelsFirst"&&(o=ir(o,[0,3,1,2])),o})}function cre(n,e,t,r,i,s){return Se(()=>{es(i),kte(s),Bl(r),t==null&&(t=[1,1,1]),r==null&&(r="valid"),i==null&&(i=Eu()),s==null&&(s="max"),n=Ene(n,i);let o;const a=r==="same"?"same":"valid";return s==="max"?o=rz(n,e,t,a):o=LL(n,e,t,a),i==="channelsFirst"&&(o=ir(o,[0,4,1,2,3])),o})}class ure extends Xn{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new _e(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Ws(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new _e(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Ws(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Bl(this.padding),this.inputSpec=[new ks({ndim:3})]}computeOutputShape(e){e=wr(e);const t=wu(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Se(()=>{this.invokeCallHook(e,t),e=xC(xn(e),2);const r=this.poolingFunction(xn(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return br(r,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class hre extends ure{constructor(e){super(e)}poolingFunction(e,t,r,i,s){return es(s),Bl(i),f$(e,t,r,i,s,"max")}}hre.className="MaxPooling1D";at(hre);class fre extends ure{constructor(e){super(e)}poolingFunction(e,t,r,i,s){return es(s),Bl(i),f$(e,t,r,i,s,"avg")}}fre.className="AveragePooling1D";at(fre);class dre extends Xn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new _e(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Ws(this.poolSize,"poolSize"),Ws(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,es(this.dataFormat),Bl(this.padding),this.inputSpec=[new ks({ndim:4})]}computeOutputShape(e){e=wr(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=wu(t,this.poolSize[0],this.padding,this.strides[0]),r=wu(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r]:[e[0],t,r,e[3]]}call(e,t){return Se(()=>(this.invokeCallHook(e,t),this.poolingFunction(xn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class pre extends dre{constructor(e){super(e)}poolingFunction(e,t,r,i,s){return es(s),Bl(i),f$(e,t,r,i,s,"max")}}pre.className="MaxPooling2D";at(pre);class mre extends dre{constructor(e){super(e)}poolingFunction(e,t,r,i,s){return es(s),Bl(i),f$(e,t,r,i,s,"avg")}}mre.className="AveragePooling2D";at(mre);class gre extends Xn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new _e(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Ws(this.poolSize,"poolSize"),Ws(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,es(this.dataFormat),Bl(this.padding),this.inputSpec=[new ks({ndim:5})]}computeOutputShape(e){e=wr(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=wu(t,this.poolSize[0],this.padding,this.strides[0]),r=wu(r,this.poolSize[1],this.padding,this.strides[1]),i=wu(i,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r,i]:[e[0],t,r,i,e[4]]}call(e,t){return Se(()=>(this.invokeCallHook(e,t),this.poolingFunction(xn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class yre extends gre{constructor(e){super(e)}poolingFunction(e,t,r,i,s){return es(s),Bl(i),cre(e,t,r,i,s,"max")}}yre.className="MaxPooling3D";at(yre);class bre extends gre{constructor(e){super(e)}poolingFunction(e,t,r,i,s){return es(s),Bl(i),cre(e,t,r,i,s,"avg")}}bre.className="AveragePooling3D";at(bre);class vre extends Xn{constructor(e){super(e),this.inputSpec=[new ks({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Ln}}class wre extends vre{constructor(e){super(e||{})}call(e,t){return Se(()=>{const r=xn(e);return Di(r,1)})}}wre.className="GlobalAveragePooling1D";at(wre);class xre extends vre{constructor(e){super(e||{})}call(e,t){return Se(()=>{const r=xn(e);return vc(r,1)})}}xre.className="GlobalMaxPooling1D";at(xre);class _re extends Xn{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,es(this.dataFormat),this.inputSpec=[new ks({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Ln}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Sre extends _re{call(e,t){return Se(()=>{const r=xn(e);return this.dataFormat==="channelsLast"?Di(r,[1,2]):Di(r,[2,3])})}}Sre.className="GlobalAveragePooling2D";at(Sre);class Cre extends _re{call(e,t){return Se(()=>{const r=xn(e);return this.dataFormat==="channelsLast"?vc(r,[1,2]):vc(r,[2,3])})}}Cre.className="GlobalMaxPooling2D";at(Cre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class kre extends Xn{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,r={}){const i=t.layer,s=bh(i,r);delete t.layer;const o={layer:s};return Object.assign(o,t),new e(o)}}class Tre extends kre{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=wr(e),e.length<3)throw new _e(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=wr(e);const t=[e[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(t),i=e[1];return[r[0],i].concat(r.slice(1))}call(e,t){return Se(()=>(e=xn(e),One((o,a)=>[xn(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}Tre.className="TimeDistributed";at(Tre);function Hnt(n){qy(nQe,"BidirectionalMergeMode",n)}const Gnt="concat";class Ere extends kre{constructor(e){super(e);const t=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=t,this.forwardLayer=bh(r),t.goBackwards=t.goBackwards!==!0;const i={};if(i.className=e.layer.getClassName(),i.config=t,this.backwardLayer=bh(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Gnt:e.mergeMode,Hnt(this.mergeMode),e.weights)throw new Ln("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,r=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let r,i,s;return this.returnState&&(s=t.slice(1)),r=t[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,i=[r]):this.mergeMode==null?i=[r,r.slice()]:i=[r],this.returnState?this.mergeMode==null?i.concat(s).concat(s.slice()):[r].concat(s).concat(s.slice()):pa(i)}apply(e,t){let r=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const s=Dne(e,r,i,this.numConstants);if(e=s.inputs,r=s.initialState,i=s.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(r==null||r.length===0)&&i==null)return super.apply(e,t);const o=[],a=[];if(r!=null){const c=r.length;if(c%2>0)throw new _e("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=r,o.push(...r);const u=r.map(h=>new ks({shape:h.shape}));this.forwardLayer.stateSpec=u.slice(0,c/2),this.backwardLayer.stateSpec=u.slice(c/2),a.push(...u)}if(i!=null)throw new Ln("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof kh;for(const c of o)if(c instanceof kh!==l)throw new _e("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[e].concat(o),u=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=u;const f=super.apply(c,t);return this.inputSpec=h,f}else return super.apply(e,t)}call(e,t){return Se(()=>{const r=t.initialState;let i,s;if(r==null)i=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const l=r.slice(0,r.length/2),c=r.slice(r.length/2);i=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:c}))}let o;this.returnState&&(Array.isArray(i)&&(o=i.slice(1).concat(s.slice(1))),i=i[0],s=s[0]),this.returnSequences&&(s=kc(s,1));let a;return this.mergeMode==="concat"?a=ZB([i,s]):this.mergeMode==="sum"?a=Xe(i,s):this.mergeMode==="ave"?a=fe(.5,Xe(i,s)):this.mergeMode==="mul"?a=fe(i,s):this.mergeMode==null&&(a=[i,s]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Gm(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Gm(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[t,t]:r=t:this.mergeMode==null?r=[null,null]:r=null,this.returnState){const s=this.forwardLayer.states.map(o=>null);return Array.isArray(r)?r.concat(s).concat(s):[r].concat(s).concat(s)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const r=bh(t.layer);if(delete t.layer,t.numConstants!=null)throw new Ln("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=t;return i.layer=r,new e(i)}}Ere.className="Bidirectional";at(Ere);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ire extends Xn{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Se(()=>(e=xn(e),e.dtype!=="float32"&&(e=gh(e,"float32")),Xe(fe(e,this.scale),this.offset)))}}Ire.className="Rescaling";at(Ire);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:jnt,cropAndResize:qnt}=Ss;class Are extends Xn{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,r,i,s,o,a,l){return Se(()=>{let c,u=!1;const h=t/o,f=r/a,d=(i+t)/o,p=(s+r)/a,m=[h,f,d,p],g=[];e.rank===3?(u=!0,c=Sa([e])):c=e;for(let S=0;S<c.shape[0];S++)g.push(m);const y=Ts(g,[g.length,4]),b=og(0,g.length,1,"int32"),w=qnt(c,y,b,[i,s],"nearest");return gh(u?xn(Tc(w)):w,l)})}upsize(e,t,r,i){return Se(()=>{const s=jnt(e,[t,r]);return gh(s,i)})}call(e,t){return Se(()=>{const r=xn(e),i=r.dtype,s=r.shape,o=s[s.length-3],a=s[s.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let c=0;return a!==this.width&&(c=Math.floor((a-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(r,l,c,this.height,this.width,o,a,i):this.upsize(e,this.height,this.width,i)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=wr(e);const t=e.length-3,r=e.length-2;return e[t]=this.height,e[r]=this.width,e}}Are.className="CenterCrop";at(Are);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Xnt(n,e,t,r){let i=xn(n);if(i.dtype!=="int32"&&(i=gh(i,"int32")),e==="int")return i;const s=i.shape;if(i.rank===0&&(i=ss(i,-1)),e==="oneHot"&&i.shape[i.shape.length-1]!==1&&(i=ss(i,-1)),i.rank>2)throw new _e(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${s} which would result in output rank ${i.rank}.`);const o=["multiHot","oneHot"].includes(e),a=i;let l;if(typeof r<"u"&&e==="count"?l=CI(a,r,t,o):l=CI(a,[],t,o),e!=="tfIdf")return l;if(r)return fe(l,r);throw new _e("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Mre extends Xn{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=wr(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Se(()=>{e=xn(e),e.dtype!=="int32"&&(e=gh(e,"int32"));let r;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new _e(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);r=xn(t.countWeights)}const i=vc(e),s=__(e),o=tl(this.numTokens,i).bufferSync().get(0),a=Tp(s,0).bufferSync().get(0);if(!(o&&a))throw new _e(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Xnt(e,this.outputMode,this.numTokens,r)})}}Mre.className="CategoryEncoding";at(Mre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Knt=["bilinear","nearest"],p6=new Set(Knt);class Nre extends Xn{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(p6.has(e.interpolation))this.interpolation=e.interpolation;else throw new _e(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=wr(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Se(()=>{const r=[this.height,this.width];if(this.interpolation==="bilinear")return Ss.resizeBilinear(e,r,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Ss.resizeNearestNeighbor(e,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...p6]} are supported`)})}}Nre.className="Resizing";at(Nre);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class $re{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}$re.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Rre extends Xn{constructor(e){super(e),this.randomGenerator=new $re(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}Rre.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Ynt=["bilinear","nearest"],m6=new Set(Ynt);class Pre extends Rre{constructor(e){super(e);const{factor:t,interpolation:r="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new _e(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new _e(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new _e(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(r)if(m6.has(r))this.interpolation=r;else throw new _e(`Invalid interpolation parameter: ${r} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=wr(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return Se(()=>{const r=xn(e);this.imgHeight=r.shape[r.shape.length-3];const i=r.shape[r.shape.length-2];this.widthFactor=Ep([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let s=this.widthFactor.dataSync()[0]*i;s=Math.round(s);const o=[this.imgHeight,s];switch(this.interpolation){case"bilinear":return Ss.resizeBilinear(e,o);case"nearest":return Ss.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...m6]} are supported`)}})}}Pre.className="RandomWidth";at(Pre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function g6(n){return new g4(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function Znt(n,e){return Dre(n,e)}function Dre(n,e,t=new Map,r=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(r.has(n))throw new Error("Circular references are not supported.");if(t.has(n))return t.get(n);const i=e(n);if(i.recurse&&i.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse)if(d$(n)){const s=Array.isArray(n)?[]:{};r.add(n);for(const o in n){const a=n[o],l=Dre(a,e,t,r);s[o]=l}return r.delete(n),n.__proto__&&(s.__proto__=n.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return t.set(n,i.value),i.value}function Jnt(n,e=Fre){return Ore(n,e)}function Ore(n,e,t=new Set){const r=n[0];if(t.has(r))throw new Error("Circular references are not supported.");const i=e(n);if(i.recurse&&i.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse)if(d$(r)){const s=Array.isArray(r)?[]:{};t.add(r);for(const o in r){const a=n.map(c=>c[o]),l=Ore(a,e,t);s[o]=l}return t.delete(r),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return i.value}function Fre(n){return n===null?null:d$(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}function d$(n){let e=!1;if(Ie().get("IS_BROWSER"))e=n instanceof TextDecoder;else{const{StringDecoder:t}=require("string_decoder");e=n instanceof t}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof jn)&&!(n instanceof Promise)&&!e)}function Qnt(n){return n==null||ert(n)||Array.isArray(n)||typeof n=="object"&&n instanceof jn||xs(n)}function ert(n){return n===null||typeof n!="object"&&typeof n!="function"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function trt(n){return Znt(n,nrt)}function nrt(n){return n instanceof jn?{value:n.clone(),recurse:!1}:d$(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class Lre{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),r=this.get(t);return this.set(t,this.pop()),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class p$ extends Lre{constructor(){super(p$.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,t=new Array(e),r=this.length();for(let i=0;i<r;i++)t[i]=this.get(this.wrap(this.begin+i));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}}p$.INITIAL_CAPACITY=32;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function rrt(n){return new srt(n)}function zre(n){return new art(n)}function irt(n,e){return new Bre(n,e)}class Vl{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let r=await e.next();for(;!r.done;)t.push(r.value),r=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),r=e(t.value);for(;!t.done&&r;)t=await this.next(),r=e(t.value)}handleErrors(e){return new prt(this,e)}filter(e){return new frt(this,e)}map(e){return new drt(this,e)}mapAsync(e){return new y6(this,e)}serialMapAsync(e){return new y6(this,e).serial()}flatmap(e){return new grt(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new hrt(this,e,t)}columnMajorBatch(e,t=!0,r=Fre){return this.rowMajorBatch(e,t).map(s=>Jnt(s,r))}concatenate(e,t){return new Bre(rrt([this,e]),t)}take(e){return e<0||e==null?this:new urt(this,e)}skip(e){return e<0||e==null?this:new crt(this,e)}prefetch(e){return new Vre(this,e)}shuffle(e,t){return new yrt(this,e,t)}serial(){return new lrt(this)}}class srt extends Vl{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:trt(e),done:!1}}}class art extends Vl{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class lrt extends Vl{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class crt extends Vl{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;nn(e.value)}return this.upstream.next()}}class urt extends Vl{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class hrt extends Vl{constructor(e,t,r=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class frt extends Vl{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;nn(e.value)}}}class drt extends Vl{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=$f(e.value),r=this.transform(e.value),i=$f(r);for(const s of t)MM(s,i)||s.dispose();return{value:r,done:!1}}}class prt extends Vl{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class y6 extends Vl{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=$f(e.value),r=await this.transform(e.value),i=$f(r);for(const s of t)MM(s,i)||s.dispose();return{value:r,done:!1}}}class mrt extends Vl{constructor(){super(),this.outputQueue=new p$,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class grt extends mrt{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=$f(e.value),r=this.transform(e.value),i=$f(r);this.outputQueue.pushAll(r);for(const s of t)MM(s,i)||s.dispose();return!0}}class Bre extends Vl{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const r=await this.moreIterators.next();if(r.done)return{value:null,done:!0};this.iterator=r.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var b6;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(b6||(b6={}));class Vre extends Vl{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new Lre(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class yrt extends Vre{constructor(e,t,r){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Aw.alea(r||io().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let Ure=class{constructor(){this.size=null}batch(e,t=!0){const r=this;U(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let i;return this.size===1/0||this.size==null?i=this.size:t?i=Math.ceil(this.size/e):i=Math.floor(this.size/e),ru(async()=>(await r.iterator()).columnMajorBatch(e,t,brt),i)}concatenate(e){const t=this;let r;return this.size===1/0||e.size===1/0?r=1/0:this.size!=null&&e.size!=null?r=this.size+e.size:r=null,ru(async()=>(await t.iterator()).concatenate(await e.iterator()),r)}filter(e){const t=this;let r;return this.size===1/0?r=1/0:r=null,ru(async()=>(await t.iterator()).filter(i=>Se(()=>e(i))),r)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return ru(async()=>(await t.iterator()).map(r=>Se(()=>e(r))),this.size)}mapAsync(e){const t=this;return ru(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return ru(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let r;return this.size!=null&&e>0?r=this.size*e:e===0?r=0:this.size!=null&&(e===void 0||e<0)?r=1/0:r=null,ru(async()=>{const i=zre(async()=>({value:await t.iterator(),done:!1}));return irt(i.take(e))},r)}skip(e){const t=this;let r;return this.size!=null&&e>=0&&this.size>=e?r=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?r=0:r=null,ru(async()=>(await t.iterator()).skip(e),r)}shuffle(e,t,r=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const i=this,s=Aw.alea(t||io().toString());return ru(async()=>{let o=s.int32();return r&&(o+=s.int32()),(await i.iterator()).shuffle(e,o.toString())},this.size)}take(e){const t=this;let r;return this.size!=null&&this.size>e?r=e:this.size!=null&&this.size<=e?r=this.size:r=null,ru(async()=>(await t.iterator()).take(e),r)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Ure.MAX_BUFFER_SIZE=1e4;function ru(n,e=null){return new class extends Ure{constructor(){super(...arguments),this.size=e}async iterator(){return n()}}}function brt(n){if(n===null)return null;const e=n[0];return Qnt(e)?{value:vrt(n),recurse:!1}:{value:null,recurse:!0}}function vrt(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof jn?Sa(n):Ts(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function wrt(n){return ru(async()=>{const e=await n();return zre(()=>e.next())})}var GO={exports:{}};const xrt=My(qJe),_rt=My(YY);/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(function(n,e){(function(t,r){r(e,xrt,_rt)})(gt,function(t,r,i){const s={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class o{constructor(l,c){this.modelPath=c||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(l)}/model.json`}getPrefix(l){return l==="lite_mobilenet_v2"?`ssd${l}`:`ssd_${l}`}async load(){this.model=await r.loadGraphModel(this.modelPath);const l=i.zeros([1,300,300,3],"int32"),c=await this.model.executeAsync(l);await Promise.all(c.map(u=>u.data())),c.map(u=>u.dispose()),l.dispose()}async infer(l,c,u){const h=i.tidy(()=>(l instanceof i.Tensor||(l=i.browser.fromPixels(l)),i.expandDims(l))),f=h.shape[1],d=h.shape[2],p=await this.model.executeAsync(h),m=p[0].dataSync(),g=p[1].dataSync();h.dispose(),i.dispose(p);const[y,b]=this.calculateMaxScores(m,p[0].shape[1],p[0].shape[2]),_=i.getBackend();i.getBackend()==="webgl"&&i.setBackend("cpu");const w=i.tidy(()=>{const C=i.tensor2d(g,[p[1].shape[1],p[1].shape[3]]);return i.image.nonMaxSuppression(C,y,c,u,u)}),S=w.dataSync();return w.dispose(),_!==i.getBackend()&&i.setBackend(_),this.buildDetectedObjects(d,f,g,y,S,b)}buildDetectedObjects(l,c,u,h,f,d){const p=f.length,m=[];for(let g=0;g<p;g++){const y=[];for(let C=0;C<4;C++)y[C]=u[4*f[g]+C];const b=y[0]*c,_=y[1]*l,w=y[2]*c,S=y[3]*l;y[0]=_,y[1]=b,y[2]=S-_,y[3]=w-b,m.push({bbox:y,class:s[d[f[g]]+1].displayName,score:h[f[g]]})}return m}calculateMaxScores(l,c,u){const h=[],f=[];for(let d=0;d<c;d++){let p=Number.MIN_VALUE,m=-1;for(let g=0;g<u;g++)l[d*u+g]>p&&(p=l[d*u+g],m=g);h[d]=p,f[d]=m}return[h,f]}async detect(l,c=20,u=.5){return this.infer(l,c,u)}dispose(){this.model!=null&&this.model.dispose()}}t.ObjectDetection=o,t.load=async function(a={}){if(i==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const l=a.base||"lite_mobilenet_v2",c=a.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(l)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${l}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const u=new o(l,c);return await u.load(),u},t.version="2.2.3",Object.defineProperty(t,"__esModule",{value:!0})})})(GO,GO.exports);var v6=GO.exports;/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */function IC(n){return n+.5|0}const Nd=(n,e,t)=>Math.max(Math.min(n,t),e);function k1(n){return Nd(IC(n*2.55),0,255)}function Wd(n){return Nd(IC(n*255),0,255)}function wf(n){return Nd(IC(n/2.55)/100,0,1)}function w6(n){return Nd(IC(n*100),0,100)}const ec={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},jO=[..."0123456789ABCDEF"],Srt=n=>jO[n&15],Crt=n=>jO[(n&240)>>4]+jO[n&15],cT=n=>(n&240)>>4===(n&15),krt=n=>cT(n.r)&&cT(n.g)&&cT(n.b)&&cT(n.a);function Trt(n){var e=n.length,t;return n[0]==="#"&&(e===4||e===5?t={r:255&ec[n[1]]*17,g:255&ec[n[2]]*17,b:255&ec[n[3]]*17,a:e===5?ec[n[4]]*17:255}:(e===7||e===9)&&(t={r:ec[n[1]]<<4|ec[n[2]],g:ec[n[3]]<<4|ec[n[4]],b:ec[n[5]]<<4|ec[n[6]],a:e===9?ec[n[7]]<<4|ec[n[8]]:255})),t}const Ert=(n,e)=>n<255?e(n):"";function Irt(n){var e=krt(n)?Srt:Crt;return n?"#"+e(n.r)+e(n.g)+e(n.b)+Ert(n.a,e):void 0}const Art=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function Wre(n,e,t){const r=e*Math.min(t,1-t),i=(s,o=(s+n/30)%12)=>t-r*Math.max(Math.min(o-3,9-o,1),-1);return[i(0),i(8),i(4)]}function Mrt(n,e,t){const r=(i,s=(i+n/60)%6)=>t-t*e*Math.max(Math.min(s,4-s,1),0);return[r(5),r(3),r(1)]}function Nrt(n,e,t){const r=Wre(n,1,.5);let i;for(e+t>1&&(i=1/(e+t),e*=i,t*=i),i=0;i<3;i++)r[i]*=1-e-t,r[i]+=e;return r}function $rt(n,e,t,r,i){return n===i?(e-t)/r+(e<t?6:0):e===i?(t-n)/r+2:(n-e)/r+4}function y4(n){const t=n.r/255,r=n.g/255,i=n.b/255,s=Math.max(t,r,i),o=Math.min(t,r,i),a=(s+o)/2;let l,c,u;return s!==o&&(u=s-o,c=a>.5?u/(2-s-o):u/(s+o),l=$rt(t,r,i,u,s),l=l*60+.5),[l|0,c||0,a]}function b4(n,e,t,r){return(Array.isArray(e)?n(e[0],e[1],e[2]):n(e,t,r)).map(Wd)}function v4(n,e,t){return b4(Wre,n,e,t)}function Rrt(n,e,t){return b4(Nrt,n,e,t)}function Prt(n,e,t){return b4(Mrt,n,e,t)}function Hre(n){return(n%360+360)%360}function Drt(n){const e=Art.exec(n);let t=255,r;if(!e)return;e[5]!==r&&(t=e[6]?k1(+e[5]):Wd(+e[5]));const i=Hre(+e[2]),s=+e[3]/100,o=+e[4]/100;return e[1]==="hwb"?r=Rrt(i,s,o):e[1]==="hsv"?r=Prt(i,s,o):r=v4(i,s,o),{r:r[0],g:r[1],b:r[2],a:t}}function Ort(n,e){var t=y4(n);t[0]=Hre(t[0]+e),t=v4(t),n.r=t[0],n.g=t[1],n.b=t[2]}function Frt(n){if(!n)return;const e=y4(n),t=e[0],r=w6(e[1]),i=w6(e[2]);return n.a<255?`hsla(${t}, ${r}%, ${i}%, ${wf(n.a)})`:`hsl(${t}, ${r}%, ${i}%)`}const x6={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},_6={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};function Lrt(){const n={},e=Object.keys(_6),t=Object.keys(x6);let r,i,s,o,a;for(r=0;r<e.length;r++){for(o=a=e[r],i=0;i<t.length;i++)s=t[i],a=a.replace(s,x6[s]);s=parseInt(_6[o],16),n[a]=[s>>16&255,s>>8&255,s&255]}return n}let uT;function zrt(n){uT||(uT=Lrt(),uT.transparent=[0,0,0,0]);const e=uT[n.toLowerCase()];return e&&{r:e[0],g:e[1],b:e[2],a:e.length===4?e[3]:255}}const Brt=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;function Vrt(n){const e=Brt.exec(n);let t=255,r,i,s;if(e){if(e[7]!==r){const o=+e[7];t=e[8]?k1(o):Nd(o*255,0,255)}return r=+e[1],i=+e[3],s=+e[5],r=255&(e[2]?k1(r):Nd(r,0,255)),i=255&(e[4]?k1(i):Nd(i,0,255)),s=255&(e[6]?k1(s):Nd(s,0,255)),{r,g:i,b:s,a:t}}}function Urt(n){return n&&(n.a<255?`rgba(${n.r}, ${n.g}, ${n.b}, ${wf(n.a)})`:`rgb(${n.r}, ${n.g}, ${n.b})`)}const E3=n=>n<=.0031308?n*12.92:Math.pow(n,1/2.4)*1.055-.055,D0=n=>n<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4);function Wrt(n,e,t){const r=D0(wf(n.r)),i=D0(wf(n.g)),s=D0(wf(n.b));return{r:Wd(E3(r+t*(D0(wf(e.r))-r))),g:Wd(E3(i+t*(D0(wf(e.g))-i))),b:Wd(E3(s+t*(D0(wf(e.b))-s))),a:n.a+t*(e.a-n.a)}}function hT(n,e,t){if(n){let r=y4(n);r[e]=Math.max(0,Math.min(r[e]+r[e]*t,e===0?360:1)),r=v4(r),n.r=r[0],n.g=r[1],n.b=r[2]}}function Gre(n,e){return n&&Object.assign(e||{},n)}function S6(n){var e={r:0,g:0,b:0,a:255};return Array.isArray(n)?n.length>=3&&(e={r:n[0],g:n[1],b:n[2],a:255},n.length>3&&(e.a=Wd(n[3]))):(e=Gre(n,{r:0,g:0,b:0,a:1}),e.a=Wd(e.a)),e}function Hrt(n){return n.charAt(0)==="r"?Vrt(n):Drt(n)}let jre=class qO{constructor(e){if(e instanceof qO)return e;const t=typeof e;let r;t==="object"?r=S6(e):t==="string"&&(r=Trt(e)||zrt(e)||Hrt(e)),this._rgb=r,this._valid=!!r}get valid(){return this._valid}get rgb(){var e=Gre(this._rgb);return e&&(e.a=wf(e.a)),e}set rgb(e){this._rgb=S6(e)}rgbString(){return this._valid?Urt(this._rgb):void 0}hexString(){return this._valid?Irt(this._rgb):void 0}hslString(){return this._valid?Frt(this._rgb):void 0}mix(e,t){if(e){const r=this.rgb,i=e.rgb;let s;const o=t===s?.5:t,a=2*o-1,l=r.a-i.a,c=((a*l===-1?a:(a+l)/(1+a*l))+1)/2;s=1-c,r.r=255&c*r.r+s*i.r+.5,r.g=255&c*r.g+s*i.g+.5,r.b=255&c*r.b+s*i.b+.5,r.a=o*r.a+(1-o)*i.a,this.rgb=r}return this}interpolate(e,t){return e&&(this._rgb=Wrt(this._rgb,e._rgb,t)),this}clone(){return new qO(this.rgb)}alpha(e){return this._rgb.a=Wd(e),this}clearer(e){const t=this._rgb;return t.a*=1-e,this}greyscale(){const e=this._rgb,t=IC(e.r*.3+e.g*.59+e.b*.11);return e.r=e.g=e.b=t,this}opaquer(e){const t=this._rgb;return t.a*=1+e,this}negate(){const e=this._rgb;return e.r=255-e.r,e.g=255-e.g,e.b=255-e.b,this}lighten(e){return hT(this._rgb,2,e),this}darken(e){return hT(this._rgb,2,-e),this}saturate(e){return hT(this._rgb,1,e),this}desaturate(e){return hT(this._rgb,1,-e),this}rotate(e){return Ort(this._rgb,e),this}};/*!
 * Chart.js v4.2.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */function sf(){}const Grt=(()=>{let n=0;return()=>n++})();function Nr(n){return n===null||typeof n>"u"}function mi(n){if(Array.isArray&&Array.isArray(n))return!0;const e=Object.prototype.toString.call(n);return e.slice(0,7)==="[object"&&e.slice(-6)==="Array]"}function rr(n){return n!==null&&Object.prototype.toString.call(n)==="[object Object]"}function Yi(n){return(typeof n=="number"||n instanceof Number)&&isFinite(+n)}function gl(n,e){return Yi(n)?n:e}function Wn(n,e){return typeof n>"u"?e:n}const jrt=(n,e)=>typeof n=="string"&&n.endsWith("%")?parseFloat(n)/100:+n/e,qre=(n,e)=>typeof n=="string"&&n.endsWith("%")?parseFloat(n)/100*e:+n;function si(n,e,t){if(n&&typeof n.call=="function")return n.apply(t,e)}function Dr(n,e,t,r){let i,s,o;if(mi(n))if(s=n.length,r)for(i=s-1;i>=0;i--)e.call(t,n[i],i);else for(i=0;i<s;i++)e.call(t,n[i],i);else if(rr(n))for(o=Object.keys(n),s=o.length,i=0;i<s;i++)e.call(t,n[o[i]],o[i])}function iA(n,e){let t,r,i,s;if(!n||!e||n.length!==e.length)return!1;for(t=0,r=n.length;t<r;++t)if(i=n[t],s=e[t],i.datasetIndex!==s.datasetIndex||i.index!==s.index)return!1;return!0}function sA(n){if(mi(n))return n.map(sA);if(rr(n)){const e=Object.create(null),t=Object.keys(n),r=t.length;let i=0;for(;i<r;++i)e[t[i]]=sA(n[t[i]]);return e}return n}function Xre(n){return["__proto__","prototype","constructor"].indexOf(n)===-1}function qrt(n,e,t,r){if(!Xre(n))return;const i=e[n],s=t[n];rr(i)&&rr(s)?K_(i,s,r):e[n]=sA(s)}function K_(n,e,t){const r=mi(e)?e:[e],i=r.length;if(!rr(n))return n;t=t||{};const s=t.merger||qrt;let o;for(let a=0;a<i;++a){if(o=r[a],!rr(o))continue;const l=Object.keys(o);for(let c=0,u=l.length;c<u;++c)s(l[c],n,o,t)}return n}function Z1(n,e){return K_(n,e,{merger:Xrt})}function Xrt(n,e,t){if(!Xre(n))return;const r=e[n],i=t[n];rr(r)&&rr(i)?Z1(r,i):Object.prototype.hasOwnProperty.call(e,n)||(e[n]=sA(i))}const C6={"":n=>n,x:n=>n.x,y:n=>n.y};function Krt(n){const e=n.split("."),t=[];let r="";for(const i of e)r+=i,r.endsWith("\\")?r=r.slice(0,-1)+".":(t.push(r),r="");return t}function Yrt(n){const e=Krt(n);return t=>{for(const r of e){if(r==="")break;t=t&&t[r]}return t}}function up(n,e){return(C6[e]||(C6[e]=Yrt(e)))(n)}function w4(n){return n.charAt(0).toUpperCase()+n.slice(1)}const Ic=n=>typeof n<"u",hp=n=>typeof n=="function",k6=(n,e)=>{if(n.size!==e.size)return!1;for(const t of n)if(!e.has(t))return!1;return!0};function Zrt(n){return n.type==="mouseup"||n.type==="click"||n.type==="contextmenu"}const Ti=Math.PI,yi=2*Ti,Jrt=yi+Ti,oA=Number.POSITIVE_INFINITY,Qrt=Ti/180,Zi=Ti/2,nm=Ti/4,T6=Ti*2/3,$d=Math.log10,vh=Math.sign;function J1(n,e,t){return Math.abs(n-e)<t}function E6(n){const e=Math.round(n);n=J1(n,e,n/1e3)?e:n;const t=Math.pow(10,Math.floor($d(n))),r=n/t;return(r<=1?1:r<=2?2:r<=5?5:10)*t}function eit(n){const e=[],t=Math.sqrt(n);let r;for(r=1;r<t;r++)n%r===0&&(e.push(r),e.push(n/r));return t===(t|0)&&e.push(t),e.sort((i,s)=>i-s).pop(),e}function ov(n){return!isNaN(parseFloat(n))&&isFinite(n)}function tit(n,e){const t=Math.round(n);return t-e<=n&&t+e>=n}function Kre(n,e,t){let r,i,s;for(r=0,i=n.length;r<i;r++)s=n[r][t],isNaN(s)||(e.min=Math.min(e.min,s),e.max=Math.max(e.max,s))}function mu(n){return n*(Ti/180)}function x4(n){return n*(180/Ti)}function I6(n){if(!Yi(n))return;let e=1,t=0;for(;Math.round(n*e)/e!==n;)e*=10,t++;return t}function Yre(n,e){const t=e.x-n.x,r=e.y-n.y,i=Math.sqrt(t*t+r*r);let s=Math.atan2(r,t);return s<-.5*Ti&&(s+=yi),{angle:s,distance:i}}function XO(n,e){return Math.sqrt(Math.pow(e.x-n.x,2)+Math.pow(e.y-n.y,2))}function nit(n,e){return(n-e+Jrt)%yi-Ti}function yl(n){return(n%yi+yi)%yi}function Y_(n,e,t,r){const i=yl(n),s=yl(e),o=yl(t),a=yl(s-i),l=yl(o-i),c=yl(i-s),u=yl(i-o);return i===s||i===o||r&&s===o||a>l&&c<u}function Yo(n,e,t){return Math.max(e,Math.min(t,n))}function rit(n){return Yo(n,-32768,32767)}function Tf(n,e,t,r=1e-6){return n>=Math.min(e,t)-r&&n<=Math.max(e,t)+r}function _4(n,e,t){t=t||(o=>n[o]<e);let r=n.length-1,i=0,s;for(;r-i>1;)s=i+r>>1,t(s)?i=s:r=s;return{lo:i,hi:r}}const Lm=(n,e,t,r)=>_4(n,t,r?i=>{const s=n[i][e];return s<t||s===t&&n[i+1][e]===t}:i=>n[i][e]<t),iit=(n,e,t)=>_4(n,t,r=>n[r][e]>=t);function sit(n,e,t){let r=0,i=n.length;for(;r<i&&n[r]<e;)r++;for(;i>r&&n[i-1]>t;)i--;return r>0||i<n.length?n.slice(r,i):n}const Zre=["push","pop","shift","splice","unshift"];function oit(n,e){if(n._chartjs){n._chartjs.listeners.push(e);return}Object.defineProperty(n,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),Zre.forEach(t=>{const r="_onData"+w4(t),i=n[t];Object.defineProperty(n,t,{configurable:!0,enumerable:!1,value(...s){const o=i.apply(this,s);return n._chartjs.listeners.forEach(a=>{typeof a[r]=="function"&&a[r](...s)}),o}})})}function A6(n,e){const t=n._chartjs;if(!t)return;const r=t.listeners,i=r.indexOf(e);i!==-1&&r.splice(i,1),!(r.length>0)&&(Zre.forEach(s=>{delete n[s]}),delete n._chartjs)}function Jre(n){const e=new Set;let t,r;for(t=0,r=n.length;t<r;++t)e.add(n[t]);return e.size===r?n:Array.from(e)}const Qre=function(){return typeof window>"u"?function(n){return n()}:window.requestAnimationFrame}();function eie(n,e){let t=[],r=!1;return function(...i){t=i,r||(r=!0,Qre.call(window,()=>{r=!1,n.apply(e,t)}))}}function ait(n,e){let t;return function(...r){return e?(clearTimeout(t),t=setTimeout(n,e,r)):n.apply(this,r),e}}const S4=n=>n==="start"?"left":n==="end"?"right":"center",Bo=(n,e,t)=>n==="start"?e:n==="end"?t:(e+t)/2,lit=(n,e,t,r)=>n===(r?"left":"right")?t:n==="center"?(e+t)/2:e;function tie(n,e,t){const r=e.length;let i=0,s=r;if(n._sorted){const{iScale:o,_parsed:a}=n,l=o.axis,{min:c,max:u,minDefined:h,maxDefined:f}=o.getUserBounds();h&&(i=Yo(Math.min(Lm(a,o.axis,c).lo,t?r:Lm(e,l,o.getPixelForValue(c)).lo),0,r-1)),f?s=Yo(Math.max(Lm(a,o.axis,u,!0).hi+1,t?0:Lm(e,l,o.getPixelForValue(u),!0).hi+1),i,r)-i:s=r-i}return{start:i,count:s}}function nie(n){const{xScale:e,yScale:t,_scaleRanges:r}=n,i={xmin:e.min,xmax:e.max,ymin:t.min,ymax:t.max};if(!r)return n._scaleRanges=i,!0;const s=r.xmin!==e.min||r.xmax!==e.max||r.ymin!==t.min||r.ymax!==t.max;return Object.assign(r,i),s}const fT=n=>n===0||n===1,M6=(n,e,t)=>-(Math.pow(2,10*(n-=1))*Math.sin((n-e)*yi/t)),N6=(n,e,t)=>Math.pow(2,-10*n)*Math.sin((n-e)*yi/t)+1,Q1={linear:n=>n,easeInQuad:n=>n*n,easeOutQuad:n=>-n*(n-2),easeInOutQuad:n=>(n/=.5)<1?.5*n*n:-.5*(--n*(n-2)-1),easeInCubic:n=>n*n*n,easeOutCubic:n=>(n-=1)*n*n+1,easeInOutCubic:n=>(n/=.5)<1?.5*n*n*n:.5*((n-=2)*n*n+2),easeInQuart:n=>n*n*n*n,easeOutQuart:n=>-((n-=1)*n*n*n-1),easeInOutQuart:n=>(n/=.5)<1?.5*n*n*n*n:-.5*((n-=2)*n*n*n-2),easeInQuint:n=>n*n*n*n*n,easeOutQuint:n=>(n-=1)*n*n*n*n+1,easeInOutQuint:n=>(n/=.5)<1?.5*n*n*n*n*n:.5*((n-=2)*n*n*n*n+2),easeInSine:n=>-Math.cos(n*Zi)+1,easeOutSine:n=>Math.sin(n*Zi),easeInOutSine:n=>-.5*(Math.cos(Ti*n)-1),easeInExpo:n=>n===0?0:Math.pow(2,10*(n-1)),easeOutExpo:n=>n===1?1:-Math.pow(2,-10*n)+1,easeInOutExpo:n=>fT(n)?n:n<.5?.5*Math.pow(2,10*(n*2-1)):.5*(-Math.pow(2,-10*(n*2-1))+2),easeInCirc:n=>n>=1?n:-(Math.sqrt(1-n*n)-1),easeOutCirc:n=>Math.sqrt(1-(n-=1)*n),easeInOutCirc:n=>(n/=.5)<1?-.5*(Math.sqrt(1-n*n)-1):.5*(Math.sqrt(1-(n-=2)*n)+1),easeInElastic:n=>fT(n)?n:M6(n,.075,.3),easeOutElastic:n=>fT(n)?n:N6(n,.075,.3),easeInOutElastic(n){return fT(n)?n:n<.5?.5*M6(n*2,.1125,.45):.5+.5*N6(n*2-1,.1125,.45)},easeInBack(n){return n*n*((1.70158+1)*n-1.70158)},easeOutBack(n){return(n-=1)*n*((1.70158+1)*n+1.70158)+1},easeInOutBack(n){let e=1.70158;return(n/=.5)<1?.5*(n*n*(((e*=1.525)+1)*n-e)):.5*((n-=2)*n*(((e*=1.525)+1)*n+e)+2)},easeInBounce:n=>1-Q1.easeOutBounce(1-n),easeOutBounce(n){return n<1/2.75?7.5625*n*n:n<2/2.75?7.5625*(n-=1.5/2.75)*n+.75:n<2.5/2.75?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375},easeInOutBounce:n=>n<.5?Q1.easeInBounce(n*2)*.5:Q1.easeOutBounce(n*2-1)*.5+.5};function rie(n){if(n&&typeof n=="object"){const e=n.toString();return e==="[object CanvasPattern]"||e==="[object CanvasGradient]"}return!1}function $6(n){return rie(n)?n:new jre(n)}function I3(n){return rie(n)?n:new jre(n).saturate(.5).darken(.1).hexString()}const cit=["x","y","borderWidth","radius","tension"],uit=["color","borderColor","backgroundColor"];function hit(n){n.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),n.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:e=>e!=="onProgress"&&e!=="onComplete"&&e!=="fn"}),n.set("animations",{colors:{type:"color",properties:uit},numbers:{type:"number",properties:cit}}),n.describe("animations",{_fallback:"animation"}),n.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:e=>e|0}}}})}function fit(n){n.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})}const R6=new Map;function dit(n,e){e=e||{};const t=n+JSON.stringify(e);let r=R6.get(t);return r||(r=new Intl.NumberFormat(n,e),R6.set(t,r)),r}function AC(n,e,t){return dit(e,t).format(n)}const iie={values(n){return mi(n)?n:""+n},numeric(n,e,t){if(n===0)return"0";const r=this.chart.options.locale;let i,s=n;if(t.length>1){const c=Math.max(Math.abs(t[0].value),Math.abs(t[t.length-1].value));(c<1e-4||c>1e15)&&(i="scientific"),s=pit(n,t)}const o=$d(Math.abs(s)),a=Math.max(Math.min(-1*Math.floor(o),20),0),l={notation:i,minimumFractionDigits:a,maximumFractionDigits:a};return Object.assign(l,this.options.ticks.format),AC(n,r,l)},logarithmic(n,e,t){if(n===0)return"0";const r=t[e].significand||n/Math.pow(10,Math.floor($d(n)));return[1,2,3,5,10,15].includes(r)||e>.8*t.length?iie.numeric.call(this,n,e,t):""}};function pit(n,e){let t=e.length>3?e[2].value-e[1].value:e[1].value-e[0].value;return Math.abs(t)>=1&&n!==Math.floor(n)&&(t=n-Math.floor(n)),t}var m$={formatters:iie};function mit(n){n.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(e,t)=>t.lineWidth,tickColor:(e,t)=>t.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:m$.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),n.route("scale.ticks","color","","color"),n.route("scale.grid","color","","borderColor"),n.route("scale.border","color","","borderColor"),n.route("scale.title","color","","color"),n.describe("scale",{_fallback:!1,_scriptable:e=>!e.startsWith("before")&&!e.startsWith("after")&&e!=="callback"&&e!=="parser",_indexable:e=>e!=="borderDash"&&e!=="tickBorderDash"&&e!=="dash"}),n.describe("scales",{_fallback:"scale"}),n.describe("scale.ticks",{_scriptable:e=>e!=="backdropPadding"&&e!=="callback",_indexable:e=>e!=="backdropPadding"})}const mg=Object.create(null),KO=Object.create(null);function e_(n,e){if(!e)return n;const t=e.split(".");for(let r=0,i=t.length;r<i;++r){const s=t[r];n=n[s]||(n[s]=Object.create(null))}return n}function A3(n,e,t){return typeof e=="string"?K_(e_(n,e),t):K_(e_(n,""),e)}class git{constructor(e,t){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=r=>r.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(r,i)=>I3(i.backgroundColor),this.hoverBorderColor=(r,i)=>I3(i.borderColor),this.hoverColor=(r,i)=>I3(i.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(e),this.apply(t)}set(e,t){return A3(this,e,t)}get(e){return e_(this,e)}describe(e,t){return A3(KO,e,t)}override(e,t){return A3(mg,e,t)}route(e,t,r,i){const s=e_(this,e),o=e_(this,r),a="_"+t;Object.defineProperties(s,{[a]:{value:s[t],writable:!0},[t]:{enumerable:!0,get(){const l=this[a],c=o[i];return rr(l)?Object.assign({},c,l):Wn(l,c)},set(l){this[a]=l}}})}apply(e){e.forEach(t=>t(this))}}var as=new git({_scriptable:n=>!n.startsWith("on"),_indexable:n=>n!=="events",hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[hit,fit,mit]);function yit(n){return!n||Nr(n.size)||Nr(n.family)?null:(n.style?n.style+" ":"")+(n.weight?n.weight+" ":"")+n.size+"px "+n.family}function aA(n,e,t,r,i){let s=e[i];return s||(s=e[i]=n.measureText(i).width,t.push(i)),s>r&&(r=s),r}function bit(n,e,t,r){r=r||{};let i=r.data=r.data||{},s=r.garbageCollect=r.garbageCollect||[];r.font!==e&&(i=r.data={},s=r.garbageCollect=[],r.font=e),n.save(),n.font=e;let o=0;const a=t.length;let l,c,u,h,f;for(l=0;l<a;l++)if(h=t[l],h!=null&&mi(h)!==!0)o=aA(n,i,s,o,h);else if(mi(h))for(c=0,u=h.length;c<u;c++)f=h[c],f!=null&&!mi(f)&&(o=aA(n,i,s,o,f));n.restore();const d=s.length/2;if(d>t.length){for(l=0;l<d;l++)delete i[s[l]];s.splice(0,d)}return o}function rm(n,e,t){const r=n.currentDevicePixelRatio,i=t!==0?Math.max(t/2,.5):0;return Math.round((e-i)*r)/r+i}function P6(n,e){e=e||n.getContext("2d"),e.save(),e.resetTransform(),e.clearRect(0,0,n.width,n.height),e.restore()}function YO(n,e,t,r){sie(n,e,t,r,null)}function sie(n,e,t,r,i){let s,o,a,l,c,u,h,f;const d=e.pointStyle,p=e.rotation,m=e.radius;let g=(p||0)*Qrt;if(d&&typeof d=="object"&&(s=d.toString(),s==="[object HTMLImageElement]"||s==="[object HTMLCanvasElement]")){n.save(),n.translate(t,r),n.rotate(g),n.drawImage(d,-d.width/2,-d.height/2,d.width,d.height),n.restore();return}if(!(isNaN(m)||m<=0)){switch(n.beginPath(),d){default:i?n.ellipse(t,r,i/2,m,0,0,yi):n.arc(t,r,m,0,yi),n.closePath();break;case"triangle":u=i?i/2:m,n.moveTo(t+Math.sin(g)*u,r-Math.cos(g)*m),g+=T6,n.lineTo(t+Math.sin(g)*u,r-Math.cos(g)*m),g+=T6,n.lineTo(t+Math.sin(g)*u,r-Math.cos(g)*m),n.closePath();break;case"rectRounded":c=m*.516,l=m-c,o=Math.cos(g+nm)*l,h=Math.cos(g+nm)*(i?i/2-c:l),a=Math.sin(g+nm)*l,f=Math.sin(g+nm)*(i?i/2-c:l),n.arc(t-h,r-a,c,g-Ti,g-Zi),n.arc(t+f,r-o,c,g-Zi,g),n.arc(t+h,r+a,c,g,g+Zi),n.arc(t-f,r+o,c,g+Zi,g+Ti),n.closePath();break;case"rect":if(!p){l=Math.SQRT1_2*m,u=i?i/2:l,n.rect(t-u,r-l,2*u,2*l);break}g+=nm;case"rectRot":h=Math.cos(g)*(i?i/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(i?i/2:m),n.moveTo(t-h,r-a),n.lineTo(t+f,r-o),n.lineTo(t+h,r+a),n.lineTo(t-f,r+o),n.closePath();break;case"crossRot":g+=nm;case"cross":h=Math.cos(g)*(i?i/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(i?i/2:m),n.moveTo(t-h,r-a),n.lineTo(t+h,r+a),n.moveTo(t+f,r-o),n.lineTo(t-f,r+o);break;case"star":h=Math.cos(g)*(i?i/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(i?i/2:m),n.moveTo(t-h,r-a),n.lineTo(t+h,r+a),n.moveTo(t+f,r-o),n.lineTo(t-f,r+o),g+=nm,h=Math.cos(g)*(i?i/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(i?i/2:m),n.moveTo(t-h,r-a),n.lineTo(t+h,r+a),n.moveTo(t+f,r-o),n.lineTo(t-f,r+o);break;case"line":o=i?i/2:Math.cos(g)*m,a=Math.sin(g)*m,n.moveTo(t-o,r-a),n.lineTo(t+o,r+a);break;case"dash":n.moveTo(t,r),n.lineTo(t+Math.cos(g)*(i?i/2:m),r+Math.sin(g)*m);break;case!1:n.closePath();break}n.fill(),e.borderWidth>0&&n.stroke()}}function Z_(n,e,t){return t=t||.5,!e||n&&n.x>e.left-t&&n.x<e.right+t&&n.y>e.top-t&&n.y<e.bottom+t}function g$(n,e){n.save(),n.beginPath(),n.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),n.clip()}function y$(n){n.restore()}function vit(n,e,t,r,i){if(!e)return n.lineTo(t.x,t.y);if(i==="middle"){const s=(e.x+t.x)/2;n.lineTo(s,e.y),n.lineTo(s,t.y)}else i==="after"!=!!r?n.lineTo(e.x,t.y):n.lineTo(t.x,e.y);n.lineTo(t.x,t.y)}function wit(n,e,t,r){if(!e)return n.lineTo(t.x,t.y);n.bezierCurveTo(r?e.cp1x:e.cp2x,r?e.cp1y:e.cp2y,r?t.cp2x:t.cp1x,r?t.cp2y:t.cp1y,t.x,t.y)}function gg(n,e,t,r,i,s={}){const o=mi(e)?e:[e],a=s.strokeWidth>0&&s.strokeColor!=="";let l,c;for(n.save(),n.font=i.string,xit(n,s),l=0;l<o.length;++l)c=o[l],s.backdrop&&Sit(n,s.backdrop),a&&(s.strokeColor&&(n.strokeStyle=s.strokeColor),Nr(s.strokeWidth)||(n.lineWidth=s.strokeWidth),n.strokeText(c,t,r,s.maxWidth)),n.fillText(c,t,r,s.maxWidth),_it(n,t,r,c,s),r+=i.lineHeight;n.restore()}function xit(n,e){e.translation&&n.translate(e.translation[0],e.translation[1]),Nr(e.rotation)||n.rotate(e.rotation),e.color&&(n.fillStyle=e.color),e.textAlign&&(n.textAlign=e.textAlign),e.textBaseline&&(n.textBaseline=e.textBaseline)}function _it(n,e,t,r,i){if(i.strikethrough||i.underline){const s=n.measureText(r),o=e-s.actualBoundingBoxLeft,a=e+s.actualBoundingBoxRight,l=t-s.actualBoundingBoxAscent,c=t+s.actualBoundingBoxDescent,u=i.strikethrough?(l+c)/2:c;n.strokeStyle=n.fillStyle,n.beginPath(),n.lineWidth=i.decorationWidth||2,n.moveTo(o,u),n.lineTo(a,u),n.stroke()}}function Sit(n,e){const t=n.fillStyle;n.fillStyle=e.color,n.fillRect(e.left,e.top,e.width,e.height),n.fillStyle=t}function Hd(n,e){const{x:t,y:r,w:i,h:s,radius:o}=e;n.arc(t+o.topLeft,r+o.topLeft,o.topLeft,-Zi,Ti,!0),n.lineTo(t,r+s-o.bottomLeft),n.arc(t+o.bottomLeft,r+s-o.bottomLeft,o.bottomLeft,Ti,Zi,!0),n.lineTo(t+i-o.bottomRight,r+s),n.arc(t+i-o.bottomRight,r+s-o.bottomRight,o.bottomRight,Zi,0,!0),n.lineTo(t+i,r+o.topRight),n.arc(t+i-o.topRight,r+o.topRight,o.topRight,0,-Zi,!0),n.lineTo(t+o.topLeft,r)}const Cit=/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,kit=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function Tit(n,e){const t=(""+n).match(Cit);if(!t||t[1]==="normal")return e*1.2;switch(n=+t[2],t[3]){case"px":return n;case"%":n/=100;break}return e*n}const Eit=n=>+n||0;function C4(n,e){const t={},r=rr(e),i=r?Object.keys(e):e,s=rr(n)?r?o=>Wn(n[o],n[e[o]]):o=>n[o]:()=>n;for(const o of i)t[o]=Eit(s(o));return t}function oie(n){return C4(n,{top:"y",right:"x",bottom:"y",left:"x"})}function Gd(n){return C4(n,["topLeft","topRight","bottomLeft","bottomRight"])}function ea(n){const e=oie(n);return e.width=e.left+e.right,e.height=e.top+e.bottom,e}function Hs(n,e){n=n||{},e=e||as.font;let t=Wn(n.size,e.size);typeof t=="string"&&(t=parseInt(t,10));let r=Wn(n.style,e.style);r&&!(""+r).match(kit)&&(console.warn('Invalid font style specified: "'+r+'"'),r=void 0);const i={family:Wn(n.family,e.family),lineHeight:Tit(Wn(n.lineHeight,e.lineHeight),t),size:t,style:r,weight:Wn(n.weight,e.weight),string:""};return i.string=yit(i),i}function dT(n,e,t,r){let i=!0,s,o,a;for(s=0,o=n.length;s<o;++s)if(a=n[s],a!==void 0&&(e!==void 0&&typeof a=="function"&&(a=a(e),i=!1),t!==void 0&&mi(a)&&(a=a[t%a.length],i=!1),a!==void 0))return r&&!i&&(r.cacheable=!1),a}function Iit(n,e,t){const{min:r,max:i}=n,s=qre(e,(i-r)/2),o=(a,l)=>t&&a===0?0:a+l;return{min:o(r,-Math.abs(s)),max:o(i,s)}}function Pp(n,e){return Object.assign(Object.create(n),e)}function k4(n,e=[""],t=n,r,i=()=>n[0]){Ic(r)||(r=uie("_fallback",n));const s={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:n,_rootScopes:t,_fallback:r,_getTarget:i,override:o=>k4([o,...n],e,t,r)};return new Proxy(s,{deleteProperty(o,a){return delete o[a],delete o._keys,delete n[0][a],!0},get(o,a){return lie(o,a,()=>Oit(a,e,n,o))},getOwnPropertyDescriptor(o,a){return Reflect.getOwnPropertyDescriptor(o._scopes[0],a)},getPrototypeOf(){return Reflect.getPrototypeOf(n[0])},has(o,a){return O6(o).includes(a)},ownKeys(o){return O6(o)},set(o,a,l){const c=o._storage||(o._storage=i());return o[a]=c[a]=l,delete o._keys,!0}})}function av(n,e,t,r){const i={_cacheable:!1,_proxy:n,_context:e,_subProxy:t,_stack:new Set,_descriptors:aie(n,r),setContext:s=>av(n,s,t,r),override:s=>av(n.override(s),e,t,r)};return new Proxy(i,{deleteProperty(s,o){return delete s[o],delete n[o],!0},get(s,o,a){return lie(s,o,()=>Mit(s,o,a))},getOwnPropertyDescriptor(s,o){return s._descriptors.allKeys?Reflect.has(n,o)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(n,o)},getPrototypeOf(){return Reflect.getPrototypeOf(n)},has(s,o){return Reflect.has(n,o)},ownKeys(){return Reflect.ownKeys(n)},set(s,o,a){return n[o]=a,delete s[o],!0}})}function aie(n,e={scriptable:!0,indexable:!0}){const{_scriptable:t=e.scriptable,_indexable:r=e.indexable,_allKeys:i=e.allKeys}=n;return{allKeys:i,scriptable:t,indexable:r,isScriptable:hp(t)?t:()=>t,isIndexable:hp(r)?r:()=>r}}const Ait=(n,e)=>n?n+w4(e):e,T4=(n,e)=>rr(e)&&n!=="adapters"&&(Object.getPrototypeOf(e)===null||e.constructor===Object);function lie(n,e,t){if(Object.prototype.hasOwnProperty.call(n,e))return n[e];const r=t();return n[e]=r,r}function Mit(n,e,t){const{_proxy:r,_context:i,_subProxy:s,_descriptors:o}=n;let a=r[e];return hp(a)&&o.isScriptable(e)&&(a=Nit(e,a,n,t)),mi(a)&&a.length&&(a=$it(e,a,n,o.isIndexable)),T4(e,a)&&(a=av(a,i,s&&s[e],o)),a}function Nit(n,e,t,r){const{_proxy:i,_context:s,_subProxy:o,_stack:a}=t;if(a.has(n))throw new Error("Recursion detected: "+Array.from(a).join("->")+"->"+n);return a.add(n),e=e(s,o||r),a.delete(n),T4(n,e)&&(e=E4(i._scopes,i,n,e)),e}function $it(n,e,t,r){const{_proxy:i,_context:s,_subProxy:o,_descriptors:a}=t;if(Ic(s.index)&&r(n))e=e[s.index%e.length];else if(rr(e[0])){const l=e,c=i._scopes.filter(u=>u!==l);e=[];for(const u of l){const h=E4(c,i,n,u);e.push(av(h,s,o&&o[n],a))}}return e}function cie(n,e,t){return hp(n)?n(e,t):n}const Rit=(n,e)=>n===!0?e:typeof n=="string"?up(e,n):void 0;function Pit(n,e,t,r,i){for(const s of e){const o=Rit(t,s);if(o){n.add(o);const a=cie(o._fallback,t,i);if(Ic(a)&&a!==t&&a!==r)return a}else if(o===!1&&Ic(r)&&t!==r)return null}return!1}function E4(n,e,t,r){const i=e._rootScopes,s=cie(e._fallback,t,r),o=[...n,...i],a=new Set;a.add(r);let l=D6(a,o,t,s||t,r);return l===null||Ic(s)&&s!==t&&(l=D6(a,o,s,l,r),l===null)?!1:k4(Array.from(a),[""],i,s,()=>Dit(e,t,r))}function D6(n,e,t,r,i){for(;t;)t=Pit(n,e,t,r,i);return t}function Dit(n,e,t){const r=n._getTarget();e in r||(r[e]={});const i=r[e];return mi(i)&&rr(t)?t:i||{}}function Oit(n,e,t,r){let i;for(const s of e)if(i=uie(Ait(s,n),t),Ic(i))return T4(n,i)?E4(t,r,n,i):i}function uie(n,e){for(const t of e){if(!t)continue;const r=t[n];if(Ic(r))return r}}function O6(n){let e=n._keys;return e||(e=n._keys=Fit(n._scopes)),e}function Fit(n){const e=new Set;for(const t of n)for(const r of Object.keys(t).filter(i=>!i.startsWith("_")))e.add(r);return Array.from(e)}function hie(n,e,t,r){const{iScale:i}=n,{key:s="r"}=this._parsing,o=new Array(r);let a,l,c,u;for(a=0,l=r;a<l;++a)c=a+t,u=e[c],o[a]={r:i.parse(up(u,s),c)};return o}const Lit=Number.EPSILON||1e-14,lv=(n,e)=>e<n.length&&!n[e].skip&&n[e],fie=n=>n==="x"?"y":"x";function zit(n,e,t,r){const i=n.skip?e:n,s=e,o=t.skip?e:t,a=XO(s,i),l=XO(o,s);let c=a/(a+l),u=l/(a+l);c=isNaN(c)?0:c,u=isNaN(u)?0:u;const h=r*c,f=r*u;return{previous:{x:s.x-h*(o.x-i.x),y:s.y-h*(o.y-i.y)},next:{x:s.x+f*(o.x-i.x),y:s.y+f*(o.y-i.y)}}}function Bit(n,e,t){const r=n.length;let i,s,o,a,l,c=lv(n,0);for(let u=0;u<r-1;++u)if(l=c,c=lv(n,u+1),!(!l||!c)){if(J1(e[u],0,Lit)){t[u]=t[u+1]=0;continue}i=t[u]/e[u],s=t[u+1]/e[u],a=Math.pow(i,2)+Math.pow(s,2),!(a<=9)&&(o=3/Math.sqrt(a),t[u]=i*o*e[u],t[u+1]=s*o*e[u])}}function Vit(n,e,t="x"){const r=fie(t),i=n.length;let s,o,a,l=lv(n,0);for(let c=0;c<i;++c){if(o=a,a=l,l=lv(n,c+1),!a)continue;const u=a[t],h=a[r];o&&(s=(u-o[t])/3,a[`cp1${t}`]=u-s,a[`cp1${r}`]=h-s*e[c]),l&&(s=(l[t]-u)/3,a[`cp2${t}`]=u+s,a[`cp2${r}`]=h+s*e[c])}}function Uit(n,e="x"){const t=fie(e),r=n.length,i=Array(r).fill(0),s=Array(r);let o,a,l,c=lv(n,0);for(o=0;o<r;++o)if(a=l,l=c,c=lv(n,o+1),!!l){if(c){const u=c[e]-l[e];i[o]=u!==0?(c[t]-l[t])/u:0}s[o]=a?c?vh(i[o-1])!==vh(i[o])?0:(i[o-1]+i[o])/2:i[o-1]:i[o]}Bit(n,i,s),Vit(n,s,e)}function pT(n,e,t){return Math.max(Math.min(n,t),e)}function Wit(n,e){let t,r,i,s,o,a=Z_(n[0],e);for(t=0,r=n.length;t<r;++t)o=s,s=a,a=t<r-1&&Z_(n[t+1],e),s&&(i=n[t],o&&(i.cp1x=pT(i.cp1x,e.left,e.right),i.cp1y=pT(i.cp1y,e.top,e.bottom)),a&&(i.cp2x=pT(i.cp2x,e.left,e.right),i.cp2y=pT(i.cp2y,e.top,e.bottom)))}function Hit(n,e,t,r,i){let s,o,a,l;if(e.spanGaps&&(n=n.filter(c=>!c.skip)),e.cubicInterpolationMode==="monotone")Uit(n,i);else{let c=r?n[n.length-1]:n[0];for(s=0,o=n.length;s<o;++s)a=n[s],l=zit(c,a,n[Math.min(s+1,o-(r?0:1))%o],e.tension),a.cp1x=l.previous.x,a.cp1y=l.previous.y,a.cp2x=l.next.x,a.cp2y=l.next.y,c=a}e.capBezierPoints&&Wit(n,t)}function die(){return typeof window<"u"&&typeof document<"u"}function I4(n){let e=n.parentNode;return e&&e.toString()==="[object ShadowRoot]"&&(e=e.host),e}function lA(n,e,t){let r;return typeof n=="string"?(r=parseInt(n,10),n.indexOf("%")!==-1&&(r=r/100*e.parentNode[t])):r=n,r}const b$=n=>n.ownerDocument.defaultView.getComputedStyle(n,null);function Git(n,e){return b$(n).getPropertyValue(e)}const jit=["top","right","bottom","left"];function qm(n,e,t){const r={};t=t?"-"+t:"";for(let i=0;i<4;i++){const s=jit[i];r[s]=parseFloat(n[e+"-"+s+t])||0}return r.width=r.left+r.right,r.height=r.top+r.bottom,r}const qit=(n,e,t)=>(n>0||e>0)&&(!t||!t.shadowRoot);function Xit(n,e){const t=n.touches,r=t&&t.length?t[0]:n,{offsetX:i,offsetY:s}=r;let o=!1,a,l;if(qit(i,s,n.target))a=i,l=s;else{const c=e.getBoundingClientRect();a=r.clientX-c.left,l=r.clientY-c.top,o=!0}return{x:a,y:l,box:o}}function vm(n,e){if("native"in n)return n;const{canvas:t,currentDevicePixelRatio:r}=e,i=b$(t),s=i.boxSizing==="border-box",o=qm(i,"padding"),a=qm(i,"border","width"),{x:l,y:c,box:u}=Xit(n,t),h=o.left+(u&&a.left),f=o.top+(u&&a.top);let{width:d,height:p}=e;return s&&(d-=o.width+a.width,p-=o.height+a.height),{x:Math.round((l-h)/d*t.width/r),y:Math.round((c-f)/p*t.height/r)}}function Kit(n,e,t){let r,i;if(e===void 0||t===void 0){const s=I4(n);if(!s)e=n.clientWidth,t=n.clientHeight;else{const o=s.getBoundingClientRect(),a=b$(s),l=qm(a,"border","width"),c=qm(a,"padding");e=o.width-c.width-l.width,t=o.height-c.height-l.height,r=lA(a.maxWidth,s,"clientWidth"),i=lA(a.maxHeight,s,"clientHeight")}}return{width:e,height:t,maxWidth:r||oA,maxHeight:i||oA}}const mT=n=>Math.round(n*10)/10;function Yit(n,e,t,r){const i=b$(n),s=qm(i,"margin"),o=lA(i.maxWidth,n,"clientWidth")||oA,a=lA(i.maxHeight,n,"clientHeight")||oA,l=Kit(n,e,t);let{width:c,height:u}=l;if(i.boxSizing==="content-box"){const f=qm(i,"border","width"),d=qm(i,"padding");c-=d.width+f.width,u-=d.height+f.height}return c=Math.max(0,c-s.width),u=Math.max(0,r?c/r:u-s.height),c=mT(Math.min(c,o,l.maxWidth)),u=mT(Math.min(u,a,l.maxHeight)),c&&!u&&(u=mT(c/2)),(e!==void 0||t!==void 0)&&r&&l.height&&u>l.height&&(u=l.height,c=mT(Math.floor(u*r))),{width:c,height:u}}function F6(n,e,t){const r=e||1,i=Math.floor(n.height*r),s=Math.floor(n.width*r);n.height=Math.floor(n.height),n.width=Math.floor(n.width);const o=n.canvas;return o.style&&(t||!o.style.height&&!o.style.width)&&(o.style.height=`${n.height}px`,o.style.width=`${n.width}px`),n.currentDevicePixelRatio!==r||o.height!==i||o.width!==s?(n.currentDevicePixelRatio=r,o.height=i,o.width=s,n.ctx.setTransform(r,0,0,r,0,0),!0):!1}const Zit=function(){let n=!1;try{const e={get passive(){return n=!0,!1}};window.addEventListener("test",null,e),window.removeEventListener("test",null,e)}catch{}return n}();function L6(n,e){const t=Git(n,e),r=t&&t.match(/^(\d+)(\.\d+)?px$/);return r?+r[1]:void 0}function wm(n,e,t,r){return{x:n.x+t*(e.x-n.x),y:n.y+t*(e.y-n.y)}}function Jit(n,e,t,r){return{x:n.x+t*(e.x-n.x),y:r==="middle"?t<.5?n.y:e.y:r==="after"?t<1?n.y:e.y:t>0?e.y:n.y}}function Qit(n,e,t,r){const i={x:n.cp2x,y:n.cp2y},s={x:e.cp1x,y:e.cp1y},o=wm(n,i,t),a=wm(i,s,t),l=wm(s,e,t),c=wm(o,a,t),u=wm(a,l,t);return wm(c,u,t)}const est=function(n,e){return{x(t){return n+n+e-t},setWidth(t){e=t},textAlign(t){return t==="center"?t:t==="right"?"left":"right"},xPlus(t,r){return t-r},leftForLtr(t,r){return t-r}}},tst=function(){return{x(n){return n},setWidth(n){},textAlign(n){return n},xPlus(n,e){return n+e},leftForLtr(n,e){return n}}};function Rb(n,e,t){return n?est(e,t):tst()}function pie(n,e){let t,r;(e==="ltr"||e==="rtl")&&(t=n.canvas.style,r=[t.getPropertyValue("direction"),t.getPropertyPriority("direction")],t.setProperty("direction",e,"important"),n.prevTextDirection=r)}function mie(n,e){e!==void 0&&(delete n.prevTextDirection,n.canvas.style.setProperty("direction",e[0],e[1]))}function gie(n){return n==="angle"?{between:Y_,compare:nit,normalize:yl}:{between:Tf,compare:(e,t)=>e-t,normalize:e=>e}}function z6({start:n,end:e,count:t,loop:r,style:i}){return{start:n%t,end:e%t,loop:r&&(e-n+1)%t===0,style:i}}function nst(n,e,t){const{property:r,start:i,end:s}=t,{between:o,normalize:a}=gie(r),l=e.length;let{start:c,end:u,loop:h}=n,f,d;if(h){for(c+=l,u+=l,f=0,d=l;f<d&&o(a(e[c%l][r]),i,s);++f)c--,u--;c%=l,u%=l}return u<c&&(u+=l),{start:c,end:u,loop:h,style:n.style}}function yie(n,e,t){if(!t)return[n];const{property:r,start:i,end:s}=t,o=e.length,{compare:a,between:l,normalize:c}=gie(r),{start:u,end:h,loop:f,style:d}=nst(n,e,t),p=[];let m=!1,g=null,y,b,_;const w=()=>l(i,_,y)&&a(i,_)!==0,S=()=>a(s,y)===0||l(s,_,y),C=()=>m||w(),k=()=>!m||S();for(let A=u,M=u;A<=h;++A)b=e[A%o],!b.skip&&(y=c(b[r]),y!==_&&(m=l(y,i,s),g===null&&C()&&(g=a(y,i)===0?A:M),g!==null&&k()&&(p.push(z6({start:g,end:A,loop:f,count:o,style:d})),g=null),M=A,_=y));return g!==null&&p.push(z6({start:g,end:h,loop:f,count:o,style:d})),p}function bie(n,e){const t=[],r=n.segments;for(let i=0;i<r.length;i++){const s=yie(r[i],n.points,e);s.length&&t.push(...s)}return t}function rst(n,e,t,r){let i=0,s=e-1;if(t&&!r)for(;i<e&&!n[i].skip;)i++;for(;i<e&&n[i].skip;)i++;for(i%=e,t&&(s+=i);s>i&&n[s%e].skip;)s--;return s%=e,{start:i,end:s}}function ist(n,e,t,r){const i=n.length,s=[];let o=e,a=n[e],l;for(l=e+1;l<=t;++l){const c=n[l%i];c.skip||c.stop?a.skip||(r=!1,s.push({start:e%i,end:(l-1)%i,loop:r}),e=o=c.stop?l:null):(o=l,a.skip&&(e=l)),a=c}return o!==null&&s.push({start:e%i,end:o%i,loop:r}),s}function sst(n,e){const t=n.points,r=n.options.spanGaps,i=t.length;if(!i)return[];const s=!!n._loop,{start:o,end:a}=rst(t,i,s,r);if(r===!0)return B6(n,[{start:o,end:a,loop:s}],t,e);const l=a<o?a+i:a,c=!!n._fullLoop&&o===0&&a===i-1;return B6(n,ist(t,o,l,c),t,e)}function B6(n,e,t,r){return!r||!r.setContext||!t?e:ost(n,e,t,r)}function ost(n,e,t,r){const i=n._chart.getContext(),s=V6(n.options),{_datasetIndex:o,options:{spanGaps:a}}=n,l=t.length,c=[];let u=s,h=e[0].start,f=h;function d(p,m,g,y){const b=a?-1:1;if(p!==m){for(p+=l;t[p%l].skip;)p-=b;for(;t[m%l].skip;)m+=b;p%l!==m%l&&(c.push({start:p%l,end:m%l,loop:g,style:y}),u=y,h=m%l)}}for(const p of e){h=a?h:p.start;let m=t[h%l],g;for(f=h+1;f<=p.end;f++){const y=t[f%l];g=V6(r.setContext(Pp(i,{type:"segment",p0:m,p1:y,p0DataIndex:(f-1)%l,p1DataIndex:f%l,datasetIndex:o}))),ast(g,u)&&d(h,f-1,p.loop,u),m=y,u=g}h<f-1&&d(h,f-1,p.loop,u)}return c}function V6(n){return{backgroundColor:n.backgroundColor,borderCapStyle:n.borderCapStyle,borderDash:n.borderDash,borderDashOffset:n.borderDashOffset,borderJoinStyle:n.borderJoinStyle,borderWidth:n.borderWidth,borderColor:n.borderColor}}function ast(n,e){return e&&JSON.stringify(n)!==JSON.stringify(e)}/*!
 * Chart.js v4.2.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */class lst{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(e,t,r,i){const s=t.listeners[i],o=t.duration;s.forEach(a=>a({chart:e,initial:t.initial,numSteps:o,currentStep:Math.min(r-t.start,o)}))}_refresh(){this._request||(this._running=!0,this._request=Qre.call(window,()=>{this._update(),this._request=null,this._running&&this._refresh()}))}_update(e=Date.now()){let t=0;this._charts.forEach((r,i)=>{if(!r.running||!r.items.length)return;const s=r.items;let o=s.length-1,a=!1,l;for(;o>=0;--o)l=s[o],l._active?(l._total>r.duration&&(r.duration=l._total),l.tick(e),a=!0):(s[o]=s[s.length-1],s.pop());a&&(i.draw(),this._notify(i,r,e,"progress")),s.length||(r.running=!1,this._notify(i,r,e,"complete"),r.initial=!1),t+=s.length}),this._lastDate=e,t===0&&(this._running=!1)}_getAnims(e){const t=this._charts;let r=t.get(e);return r||(r={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},t.set(e,r)),r}listen(e,t,r){this._getAnims(e).listeners[t].push(r)}add(e,t){!t||!t.length||this._getAnims(e).items.push(...t)}has(e){return this._getAnims(e).items.length>0}start(e){const t=this._charts.get(e);t&&(t.running=!0,t.start=Date.now(),t.duration=t.items.reduce((r,i)=>Math.max(r,i._duration),0),this._refresh())}running(e){if(!this._running)return!1;const t=this._charts.get(e);return!(!t||!t.running||!t.items.length)}stop(e){const t=this._charts.get(e);if(!t||!t.items.length)return;const r=t.items;let i=r.length-1;for(;i>=0;--i)r[i].cancel();t.items=[],this._notify(e,t,Date.now(),"complete")}remove(e){return this._charts.delete(e)}}var ff=new lst;const U6="transparent",cst={boolean(n,e,t){return t>.5?e:n},color(n,e,t){const r=$6(n||U6),i=r.valid&&$6(e||U6);return i&&i.valid?i.mix(r,t).hexString():e},number(n,e,t){return n+(e-n)*t}};class ust{constructor(e,t,r,i){const s=t[r];i=dT([e.to,i,s,e.from]);const o=dT([e.from,s,i]);this._active=!0,this._fn=e.fn||cst[e.type||typeof o],this._easing=Q1[e.easing]||Q1.linear,this._start=Math.floor(Date.now()+(e.delay||0)),this._duration=this._total=Math.floor(e.duration),this._loop=!!e.loop,this._target=t,this._prop=r,this._from=o,this._to=i,this._promises=void 0}active(){return this._active}update(e,t,r){if(this._active){this._notify(!1);const i=this._target[this._prop],s=r-this._start,o=this._duration-s;this._start=r,this._duration=Math.floor(Math.max(o,e.duration)),this._total+=s,this._loop=!!e.loop,this._to=dT([e.to,t,i,e.from]),this._from=dT([e.from,i,t])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(e){const t=e-this._start,r=this._duration,i=this._prop,s=this._from,o=this._loop,a=this._to;let l;if(this._active=s!==a&&(o||t<r),!this._active){this._target[i]=a,this._notify(!0);return}if(t<0){this._target[i]=s;return}l=t/r%2,l=o&&l>1?2-l:l,l=this._easing(Math.min(1,Math.max(0,l))),this._target[i]=this._fn(s,a,l)}wait(){const e=this._promises||(this._promises=[]);return new Promise((t,r)=>{e.push({res:t,rej:r})})}_notify(e){const t=e?"res":"rej",r=this._promises||[];for(let i=0;i<r.length;i++)r[i][t]()}}class vie{constructor(e,t){this._chart=e,this._properties=new Map,this.configure(t)}configure(e){if(!rr(e))return;const t=Object.keys(as.animation),r=this._properties;Object.getOwnPropertyNames(e).forEach(i=>{const s=e[i];if(!rr(s))return;const o={};for(const a of t)o[a]=s[a];(mi(s.properties)&&s.properties||[i]).forEach(a=>{(a===i||!r.has(a))&&r.set(a,o)})})}_animateOptions(e,t){const r=t.options,i=fst(e,r);if(!i)return[];const s=this._createAnimations(i,r);return r.$shared&&hst(e.options.$animations,r).then(()=>{e.options=r},()=>{}),s}_createAnimations(e,t){const r=this._properties,i=[],s=e.$animations||(e.$animations={}),o=Object.keys(t),a=Date.now();let l;for(l=o.length-1;l>=0;--l){const c=o[l];if(c.charAt(0)==="$")continue;if(c==="options"){i.push(...this._animateOptions(e,t));continue}const u=t[c];let h=s[c];const f=r.get(c);if(h)if(f&&h.active()){h.update(f,u,a);continue}else h.cancel();if(!f||!f.duration){e[c]=u;continue}s[c]=h=new ust(f,e,c,u),i.push(h)}return i}update(e,t){if(this._properties.size===0){Object.assign(e,t);return}const r=this._createAnimations(e,t);if(r.length)return ff.add(this._chart,r),!0}}function hst(n,e){const t=[],r=Object.keys(e);for(let i=0;i<r.length;i++){const s=n[r[i]];s&&s.active()&&t.push(s.wait())}return Promise.all(t)}function fst(n,e){if(!e)return;let t=n.options;if(!t){n.options=e;return}return t.$shared&&(n.options=t=Object.assign({},t,{$shared:!1,$animations:{}})),t}function W6(n,e){const t=n&&n.options||{},r=t.reverse,i=t.min===void 0?e:0,s=t.max===void 0?e:0;return{start:r?s:i,end:r?i:s}}function dst(n,e,t){if(t===!1)return!1;const r=W6(n,t),i=W6(e,t);return{top:i.end,right:r.end,bottom:i.start,left:r.start}}function pst(n){let e,t,r,i;return rr(n)?(e=n.top,t=n.right,r=n.bottom,i=n.left):e=t=r=i=n,{top:e,right:t,bottom:r,left:i,disabled:n===!1}}function wie(n,e){const t=[],r=n._getSortedDatasetMetas(e);let i,s;for(i=0,s=r.length;i<s;++i)t.push(r[i].index);return t}function H6(n,e,t,r={}){const i=n.keys,s=r.mode==="single";let o,a,l,c;if(e!==null){for(o=0,a=i.length;o<a;++o){if(l=+i[o],l===t){if(r.all)continue;break}c=n.values[l],Yi(c)&&(s||e===0||vh(e)===vh(c))&&(e+=c)}return e}}function mst(n){const e=Object.keys(n),t=new Array(e.length);let r,i,s;for(r=0,i=e.length;r<i;++r)s=e[r],t[r]={x:s,y:n[s]};return t}function G6(n,e){const t=n&&n.options.stacked;return t||t===void 0&&e.stack!==void 0}function gst(n,e,t){return`${n.id}.${e.id}.${t.stack||t.type}`}function yst(n){const{min:e,max:t,minDefined:r,maxDefined:i}=n.getUserBounds();return{min:r?e:Number.NEGATIVE_INFINITY,max:i?t:Number.POSITIVE_INFINITY}}function bst(n,e,t){const r=n[e]||(n[e]={});return r[t]||(r[t]={})}function j6(n,e,t,r){for(const i of e.getMatchingVisibleMetas(r).reverse()){const s=n[i.index];if(t&&s>0||!t&&s<0)return i.index}return null}function q6(n,e){const{chart:t,_cachedMeta:r}=n,i=t._stacks||(t._stacks={}),{iScale:s,vScale:o,index:a}=r,l=s.axis,c=o.axis,u=gst(s,o,r),h=e.length;let f;for(let d=0;d<h;++d){const p=e[d],{[l]:m,[c]:g}=p,y=p._stacks||(p._stacks={});f=y[c]=bst(i,u,m),f[a]=g,f._top=j6(f,o,!0,r.type),f._bottom=j6(f,o,!1,r.type);const b=f._visualValues||(f._visualValues={});b[a]=g}}function M3(n,e){const t=n.scales;return Object.keys(t).filter(r=>t[r].axis===e).shift()}function vst(n,e){return Pp(n,{active:!1,dataset:void 0,datasetIndex:e,index:e,mode:"default",type:"dataset"})}function wst(n,e,t){return Pp(n,{active:!1,dataIndex:e,parsed:void 0,raw:void 0,element:t,index:e,mode:"default",type:"data"})}function Hx(n,e){const t=n.controller.index,r=n.vScale&&n.vScale.axis;if(r){e=e||n._parsed;for(const i of e){const s=i._stacks;if(!s||s[r]===void 0||s[r][t]===void 0)return;delete s[r][t],s[r]._visualValues!==void 0&&s[r]._visualValues[t]!==void 0&&delete s[r]._visualValues[t]}}}const N3=n=>n==="reset"||n==="none",X6=(n,e)=>e?n:Object.assign({},n),xst=(n,e,t)=>n&&!e.hidden&&e._stacked&&{keys:wie(t,!0),values:null};class xc{constructor(e,t){this.chart=e,this._ctx=e.ctx,this.index=t,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const e=this._cachedMeta;this.configure(),this.linkScales(),e._stacked=G6(e.vScale,e),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled("filler")&&console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}updateIndex(e){this.index!==e&&Hx(this._cachedMeta),this.index=e}linkScales(){const e=this.chart,t=this._cachedMeta,r=this.getDataset(),i=(h,f,d,p)=>h==="x"?f:h==="r"?p:d,s=t.xAxisID=Wn(r.xAxisID,M3(e,"x")),o=t.yAxisID=Wn(r.yAxisID,M3(e,"y")),a=t.rAxisID=Wn(r.rAxisID,M3(e,"r")),l=t.indexAxis,c=t.iAxisID=i(l,s,o,a),u=t.vAxisID=i(l,o,s,a);t.xScale=this.getScaleForId(s),t.yScale=this.getScaleForId(o),t.rScale=this.getScaleForId(a),t.iScale=this.getScaleForId(c),t.vScale=this.getScaleForId(u)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(e){return this.chart.scales[e]}_getOtherScale(e){const t=this._cachedMeta;return e===t.iScale?t.vScale:t.iScale}reset(){this._update("reset")}_destroy(){const e=this._cachedMeta;this._data&&A6(this._data,this),e._stacked&&Hx(e)}_dataCheck(){const e=this.getDataset(),t=e.data||(e.data=[]),r=this._data;if(rr(t))this._data=mst(t);else if(r!==t){if(r){A6(r,this);const i=this._cachedMeta;Hx(i),i._parsed=[]}t&&Object.isExtensible(t)&&oit(t,this),this._syncList=[],this._data=t}}addElements(){const e=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(e.dataset=new this.datasetElementType)}buildOrUpdateElements(e){const t=this._cachedMeta,r=this.getDataset();let i=!1;this._dataCheck();const s=t._stacked;t._stacked=G6(t.vScale,t),t.stack!==r.stack&&(i=!0,Hx(t),t.stack=r.stack),this._resyncElements(e),(i||s!==t._stacked)&&q6(this,t._parsed)}configure(){const e=this.chart.config,t=e.datasetScopeKeys(this._type),r=e.getOptionScopes(this.getDataset(),t,!0);this.options=e.createResolver(r,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(e,t){const{_cachedMeta:r,_data:i}=this,{iScale:s,_stacked:o}=r,a=s.axis;let l=e===0&&t===i.length?!0:r._sorted,c=e>0&&r._parsed[e-1],u,h,f;if(this._parsing===!1)r._parsed=i,r._sorted=!0,f=i;else{mi(i[e])?f=this.parseArrayData(r,i,e,t):rr(i[e])?f=this.parseObjectData(r,i,e,t):f=this.parsePrimitiveData(r,i,e,t);const d=()=>h[a]===null||c&&h[a]<c[a];for(u=0;u<t;++u)r._parsed[u+e]=h=f[u],l&&(d()&&(l=!1),c=h);r._sorted=l}o&&q6(this,f)}parsePrimitiveData(e,t,r,i){const{iScale:s,vScale:o}=e,a=s.axis,l=o.axis,c=s.getLabels(),u=s===o,h=new Array(i);let f,d,p;for(f=0,d=i;f<d;++f)p=f+r,h[f]={[a]:u||s.parse(c[p],p),[l]:o.parse(t[p],p)};return h}parseArrayData(e,t,r,i){const{xScale:s,yScale:o}=e,a=new Array(i);let l,c,u,h;for(l=0,c=i;l<c;++l)u=l+r,h=t[u],a[l]={x:s.parse(h[0],u),y:o.parse(h[1],u)};return a}parseObjectData(e,t,r,i){const{xScale:s,yScale:o}=e,{xAxisKey:a="x",yAxisKey:l="y"}=this._parsing,c=new Array(i);let u,h,f,d;for(u=0,h=i;u<h;++u)f=u+r,d=t[f],c[u]={x:s.parse(up(d,a),f),y:o.parse(up(d,l),f)};return c}getParsed(e){return this._cachedMeta._parsed[e]}getDataElement(e){return this._cachedMeta.data[e]}applyStack(e,t,r){const i=this.chart,s=this._cachedMeta,o=t[e.axis],a={keys:wie(i,!0),values:t._stacks[e.axis]._visualValues};return H6(a,o,s.index,{mode:r})}updateRangeFromParsed(e,t,r,i){const s=r[t.axis];let o=s===null?NaN:s;const a=i&&r._stacks[t.axis];i&&a&&(i.values=a,o=H6(i,s,this._cachedMeta.index)),e.min=Math.min(e.min,o),e.max=Math.max(e.max,o)}getMinMax(e,t){const r=this._cachedMeta,i=r._parsed,s=r._sorted&&e===r.iScale,o=i.length,a=this._getOtherScale(e),l=xst(t,r,this.chart),c={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:u,max:h}=yst(a);let f,d;function p(){d=i[f];const m=d[a.axis];return!Yi(d[e.axis])||u>m||h<m}for(f=0;f<o&&!(!p()&&(this.updateRangeFromParsed(c,e,d,l),s));++f);if(s){for(f=o-1;f>=0;--f)if(!p()){this.updateRangeFromParsed(c,e,d,l);break}}return c}getAllParsedValues(e){const t=this._cachedMeta._parsed,r=[];let i,s,o;for(i=0,s=t.length;i<s;++i)o=t[i][e.axis],Yi(o)&&r.push(o);return r}getMaxOverflow(){return!1}getLabelAndValue(e){const t=this._cachedMeta,r=t.iScale,i=t.vScale,s=this.getParsed(e);return{label:r?""+r.getLabelForValue(s[r.axis]):"",value:i?""+i.getLabelForValue(s[i.axis]):""}}_update(e){const t=this._cachedMeta;this.update(e||"default"),t._clip=pst(Wn(this.options.clip,dst(t.xScale,t.yScale,this.getMaxOverflow())))}update(e){}draw(){const e=this._ctx,t=this.chart,r=this._cachedMeta,i=r.data||[],s=t.chartArea,o=[],a=this._drawStart||0,l=this._drawCount||i.length-a,c=this.options.drawActiveElementsOnTop;let u;for(r.dataset&&r.dataset.draw(e,s,a,l),u=a;u<a+l;++u){const h=i[u];h.hidden||(h.active&&c?o.push(h):h.draw(e,s))}for(u=0;u<o.length;++u)o[u].draw(e,s)}getStyle(e,t){const r=t?"active":"default";return e===void 0&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(r):this.resolveDataElementOptions(e||0,r)}getContext(e,t,r){const i=this.getDataset();let s;if(e>=0&&e<this._cachedMeta.data.length){const o=this._cachedMeta.data[e];s=o.$context||(o.$context=wst(this.getContext(),e,o)),s.parsed=this.getParsed(e),s.raw=i.data[e],s.index=s.dataIndex=e}else s=this.$context||(this.$context=vst(this.chart.getContext(),this.index)),s.dataset=i,s.index=s.datasetIndex=this.index;return s.active=!!t,s.mode=r,s}resolveDatasetElementOptions(e){return this._resolveElementOptions(this.datasetElementType.id,e)}resolveDataElementOptions(e,t){return this._resolveElementOptions(this.dataElementType.id,t,e)}_resolveElementOptions(e,t="default",r){const i=t==="active",s=this._cachedDataOpts,o=e+"-"+t,a=s[o],l=this.enableOptionSharing&&Ic(r);if(a)return X6(a,l);const c=this.chart.config,u=c.datasetElementScopeKeys(this._type,e),h=i?[`${e}Hover`,"hover",e,""]:[e,""],f=c.getOptionScopes(this.getDataset(),u),d=Object.keys(as.elements[e]),p=()=>this.getContext(r,i,t),m=c.resolveNamedOptions(f,d,p,h);return m.$shared&&(m.$shared=l,s[o]=Object.freeze(X6(m,l))),m}_resolveAnimations(e,t,r){const i=this.chart,s=this._cachedDataOpts,o=`animation-${t}`,a=s[o];if(a)return a;let l;if(i.options.animation!==!1){const u=this.chart.config,h=u.datasetAnimationScopeKeys(this._type,t),f=u.getOptionScopes(this.getDataset(),h);l=u.createResolver(f,this.getContext(e,r,t))}const c=new vie(i,l&&l.animations);return l&&l._cacheable&&(s[o]=Object.freeze(c)),c}getSharedOptions(e){if(e.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},e))}includeOptions(e,t){return!t||N3(e)||this.chart._animationsDisabled}_getSharedOptions(e,t){const r=this.resolveDataElementOptions(e,t),i=this._sharedOptions,s=this.getSharedOptions(r),o=this.includeOptions(t,s)||s!==i;return this.updateSharedOptions(s,t,r),{sharedOptions:s,includeOptions:o}}updateElement(e,t,r,i){N3(i)?Object.assign(e,r):this._resolveAnimations(t,i).update(e,r)}updateSharedOptions(e,t,r){e&&!N3(t)&&this._resolveAnimations(void 0,t).update(e,r)}_setStyle(e,t,r,i){e.active=i;const s=this.getStyle(t,i);this._resolveAnimations(t,r,i).update(e,{options:!i&&this.getSharedOptions(s)||s})}removeHoverStyle(e,t,r){this._setStyle(e,r,"active",!1)}setHoverStyle(e,t,r){this._setStyle(e,r,"active",!0)}_removeDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!1)}_setDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!0)}_resyncElements(e){const t=this._data,r=this._cachedMeta.data;for(const[a,l,c]of this._syncList)this[a](l,c);this._syncList=[];const i=r.length,s=t.length,o=Math.min(s,i);o&&this.parse(0,o),s>i?this._insertElements(i,s-i,e):s<i&&this._removeElements(s,i-s)}_insertElements(e,t,r=!0){const i=this._cachedMeta,s=i.data,o=e+t;let a;const l=c=>{for(c.length+=t,a=c.length-1;a>=o;a--)c[a]=c[a-t]};for(l(s),a=e;a<o;++a)s[a]=new this.dataElementType;this._parsing&&l(i._parsed),this.parse(e,t),r&&this.updateElements(s,e,t,"reset")}updateElements(e,t,r,i){}_removeElements(e,t){const r=this._cachedMeta;if(this._parsing){const i=r._parsed.splice(e,t);r._stacked&&Hx(r,i)}r.data.splice(e,t)}_sync(e){if(this._parsing)this._syncList.push(e);else{const[t,r,i]=e;this[t](r,i)}this.chart._dataChanges.push([this.index,...e])}_onDataPush(){const e=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-e,e])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(e,t){t&&this._sync(["_removeElements",e,t]);const r=arguments.length-2;r&&this._sync(["_insertElements",e,r])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}Nt(xc,"defaults",{}),Nt(xc,"datasetElementType",null),Nt(xc,"dataElementType",null);function _st(n,e){if(!n._cache.$bar){const t=n.getMatchingVisibleMetas(e);let r=[];for(let i=0,s=t.length;i<s;i++)r=r.concat(t[i].controller.getAllParsedValues(n));n._cache.$bar=Jre(r.sort((i,s)=>i-s))}return n._cache.$bar}function Sst(n){const e=n.iScale,t=_st(e,n.type);let r=e._length,i,s,o,a;const l=()=>{o===32767||o===-32768||(Ic(a)&&(r=Math.min(r,Math.abs(o-a)||r)),a=o)};for(i=0,s=t.length;i<s;++i)o=e.getPixelForValue(t[i]),l();for(a=void 0,i=0,s=e.ticks.length;i<s;++i)o=e.getPixelForTick(i),l();return r}function Cst(n,e,t,r){const i=t.barThickness;let s,o;return Nr(i)?(s=e.min*t.categoryPercentage,o=t.barPercentage):(s=i*r,o=1),{chunk:s/r,ratio:o,start:e.pixels[n]-s/2}}function kst(n,e,t,r){const i=e.pixels,s=i[n];let o=n>0?i[n-1]:null,a=n<i.length-1?i[n+1]:null;const l=t.categoryPercentage;o===null&&(o=s-(a===null?e.end-e.start:a-s)),a===null&&(a=s+s-o);const c=s-(s-Math.min(o,a))/2*l;return{chunk:Math.abs(a-o)/2*l/r,ratio:t.barPercentage,start:c}}function Tst(n,e,t,r){const i=t.parse(n[0],r),s=t.parse(n[1],r),o=Math.min(i,s),a=Math.max(i,s);let l=o,c=a;Math.abs(o)>Math.abs(a)&&(l=a,c=o),e[t.axis]=c,e._custom={barStart:l,barEnd:c,start:i,end:s,min:o,max:a}}function xie(n,e,t,r){return mi(n)?Tst(n,e,t,r):e[t.axis]=t.parse(n,r),e}function K6(n,e,t,r){const i=n.iScale,s=n.vScale,o=i.getLabels(),a=i===s,l=[];let c,u,h,f;for(c=t,u=t+r;c<u;++c)f=e[c],h={},h[i.axis]=a||i.parse(o[c],c),l.push(xie(f,h,s,c));return l}function $3(n){return n&&n.barStart!==void 0&&n.barEnd!==void 0}function Est(n,e,t){return n!==0?vh(n):(e.isHorizontal()?1:-1)*(e.min>=t?1:-1)}function Ist(n){let e,t,r,i,s;return n.horizontal?(e=n.base>n.x,t="left",r="right"):(e=n.base<n.y,t="bottom",r="top"),e?(i="end",s="start"):(i="start",s="end"),{start:t,end:r,reverse:e,top:i,bottom:s}}function Ast(n,e,t,r){let i=e.borderSkipped;const s={};if(!i){n.borderSkipped=s;return}if(i===!0){n.borderSkipped={top:!0,right:!0,bottom:!0,left:!0};return}const{start:o,end:a,reverse:l,top:c,bottom:u}=Ist(n);i==="middle"&&t&&(n.enableBorderRadius=!0,(t._top||0)===r?i=c:(t._bottom||0)===r?i=u:(s[Y6(u,o,a,l)]=!0,i=c)),s[Y6(i,o,a,l)]=!0,n.borderSkipped=s}function Y6(n,e,t,r){return r?(n=Mst(n,e,t),n=Z6(n,t,e)):n=Z6(n,e,t),n}function Mst(n,e,t){return n===e?t:n===t?e:n}function Z6(n,e,t){return n==="start"?e:n==="end"?t:n}function Nst(n,{inflateAmount:e},t){n.inflateAmount=e==="auto"?t===1?.33:0:e}class BE extends xc{parsePrimitiveData(e,t,r,i){return K6(e,t,r,i)}parseArrayData(e,t,r,i){return K6(e,t,r,i)}parseObjectData(e,t,r,i){const{iScale:s,vScale:o}=e,{xAxisKey:a="x",yAxisKey:l="y"}=this._parsing,c=s.axis==="x"?a:l,u=o.axis==="x"?a:l,h=[];let f,d,p,m;for(f=r,d=r+i;f<d;++f)m=t[f],p={},p[s.axis]=s.parse(up(m,c),f),h.push(xie(up(m,u),p,o,f));return h}updateRangeFromParsed(e,t,r,i){super.updateRangeFromParsed(e,t,r,i);const s=r._custom;s&&t===this._cachedMeta.vScale&&(e.min=Math.min(e.min,s.min),e.max=Math.max(e.max,s.max))}getMaxOverflow(){return 0}getLabelAndValue(e){const t=this._cachedMeta,{iScale:r,vScale:i}=t,s=this.getParsed(e),o=s._custom,a=$3(o)?"["+o.start+", "+o.end+"]":""+i.getLabelForValue(s[i.axis]);return{label:""+r.getLabelForValue(s[r.axis]),value:a}}initialize(){this.enableOptionSharing=!0,super.initialize();const e=this._cachedMeta;e.stack=this.getDataset().stack}update(e){const t=this._cachedMeta;this.updateElements(t.data,0,t.data.length,e)}updateElements(e,t,r,i){const s=i==="reset",{index:o,_cachedMeta:{vScale:a}}=this,l=a.getBasePixel(),c=a.isHorizontal(),u=this._getRuler(),{sharedOptions:h,includeOptions:f}=this._getSharedOptions(t,i);for(let d=t;d<t+r;d++){const p=this.getParsed(d),m=s||Nr(p[a.axis])?{base:l,head:l}:this._calculateBarValuePixels(d),g=this._calculateBarIndexPixels(d,u),y=(p._stacks||{})[a.axis],b={horizontal:c,base:m.base,enableBorderRadius:!y||$3(p._custom)||o===y._top||o===y._bottom,x:c?m.head:g.center,y:c?g.center:m.head,height:c?g.size:Math.abs(m.size),width:c?Math.abs(m.size):g.size};f&&(b.options=h||this.resolveDataElementOptions(d,e[d].active?"active":i));const _=b.options||e[d].options;Ast(b,_,y,o),Nst(b,_,u.ratio),this.updateElement(e[d],d,b,i)}}_getStacks(e,t){const{iScale:r}=this._cachedMeta,i=r.getMatchingVisibleMetas(this._type).filter(l=>l.controller.options.grouped),s=r.options.stacked,o=[],a=l=>{const c=l.controller.getParsed(t),u=c&&c[l.vScale.axis];if(Nr(u)||isNaN(u))return!0};for(const l of i)if(!(t!==void 0&&a(l))&&((s===!1||o.indexOf(l.stack)===-1||s===void 0&&l.stack===void 0)&&o.push(l.stack),l.index===e))break;return o.length||o.push(void 0),o}_getStackCount(e){return this._getStacks(void 0,e).length}_getStackIndex(e,t,r){const i=this._getStacks(e,r),s=t!==void 0?i.indexOf(t):-1;return s===-1?i.length-1:s}_getRuler(){const e=this.options,t=this._cachedMeta,r=t.iScale,i=[];let s,o;for(s=0,o=t.data.length;s<o;++s)i.push(r.getPixelForValue(this.getParsed(s)[r.axis],s));const a=e.barThickness;return{min:a||Sst(t),pixels:i,start:r._startPixel,end:r._endPixel,stackCount:this._getStackCount(),scale:r,grouped:e.grouped,ratio:a?1:e.categoryPercentage*e.barPercentage}}_calculateBarValuePixels(e){const{_cachedMeta:{vScale:t,_stacked:r,index:i},options:{base:s,minBarLength:o}}=this,a=s||0,l=this.getParsed(e),c=l._custom,u=$3(c);let h=l[t.axis],f=0,d=r?this.applyStack(t,l,r):h,p,m;d!==h&&(f=d-h,d=h),u&&(h=c.barStart,d=c.barEnd-c.barStart,h!==0&&vh(h)!==vh(c.barEnd)&&(f=0),f+=h);const g=!Nr(s)&&!u?s:f;let y=t.getPixelForValue(g);if(this.chart.getDataVisibility(e)?p=t.getPixelForValue(f+d):p=y,m=p-y,Math.abs(m)<o){m=Est(m,t,a)*o,h===a&&(y-=m/2);const b=t.getPixelForDecimal(0),_=t.getPixelForDecimal(1),w=Math.min(b,_),S=Math.max(b,_);y=Math.max(Math.min(y,S),w),p=y+m,r&&!u&&(l._stacks[t.axis]._visualValues[i]=t.getValueForPixel(p)-t.getValueForPixel(y))}if(y===t.getPixelForValue(a)){const b=vh(m)*t.getLineWidthForValue(a)/2;y+=b,m-=b}return{size:m,base:y,head:p,center:p+m/2}}_calculateBarIndexPixels(e,t){const r=t.scale,i=this.options,s=i.skipNull,o=Wn(i.maxBarThickness,1/0);let a,l;if(t.grouped){const c=s?this._getStackCount(e):t.stackCount,u=i.barThickness==="flex"?kst(e,t,i,c):Cst(e,t,i,c),h=this._getStackIndex(this.index,this._cachedMeta.stack,s?e:void 0);a=u.start+u.chunk*h+u.chunk/2,l=Math.min(o,u.chunk*u.ratio)}else a=r.getPixelForValue(this.getParsed(e)[r.axis],e),l=Math.min(o,t.min*t.ratio);return{base:a-l/2,head:a+l/2,center:a,size:l}}draw(){const e=this._cachedMeta,t=e.vScale,r=e.data,i=r.length;let s=0;for(;s<i;++s)this.getParsed(s)[t.axis]!==null&&r[s].draw(this._ctx)}}Nt(BE,"id","bar"),Nt(BE,"defaults",{datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}}),Nt(BE,"overrides",{scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}});class VE extends xc{initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(e,t,r,i){const s=super.parsePrimitiveData(e,t,r,i);for(let o=0;o<s.length;o++)s[o]._custom=this.resolveDataElementOptions(o+r).radius;return s}parseArrayData(e,t,r,i){const s=super.parseArrayData(e,t,r,i);for(let o=0;o<s.length;o++){const a=t[r+o];s[o]._custom=Wn(a[2],this.resolveDataElementOptions(o+r).radius)}return s}parseObjectData(e,t,r,i){const s=super.parseObjectData(e,t,r,i);for(let o=0;o<s.length;o++){const a=t[r+o];s[o]._custom=Wn(a&&a.r&&+a.r,this.resolveDataElementOptions(o+r).radius)}return s}getMaxOverflow(){const e=this._cachedMeta.data;let t=0;for(let r=e.length-1;r>=0;--r)t=Math.max(t,e[r].size(this.resolveDataElementOptions(r))/2);return t>0&&t}getLabelAndValue(e){const t=this._cachedMeta,r=this.chart.data.labels||[],{xScale:i,yScale:s}=t,o=this.getParsed(e),a=i.getLabelForValue(o.x),l=s.getLabelForValue(o.y),c=o._custom;return{label:r[e]||"",value:"("+a+", "+l+(c?", "+c:"")+")"}}update(e){const t=this._cachedMeta.data;this.updateElements(t,0,t.length,e)}updateElements(e,t,r,i){const s=i==="reset",{iScale:o,vScale:a}=this._cachedMeta,{sharedOptions:l,includeOptions:c}=this._getSharedOptions(t,i),u=o.axis,h=a.axis;for(let f=t;f<t+r;f++){const d=e[f],p=!s&&this.getParsed(f),m={},g=m[u]=s?o.getPixelForDecimal(.5):o.getPixelForValue(p[u]),y=m[h]=s?a.getBasePixel():a.getPixelForValue(p[h]);m.skip=isNaN(g)||isNaN(y),c&&(m.options=l||this.resolveDataElementOptions(f,d.active?"active":i),s&&(m.options.radius=0)),this.updateElement(d,f,m,i)}}resolveDataElementOptions(e,t){const r=this.getParsed(e);let i=super.resolveDataElementOptions(e,t);i.$shared&&(i=Object.assign({},i,{$shared:!1}));const s=i.radius;return t!=="active"&&(i.radius=0),i.radius+=Wn(r&&r._custom,s),i}}Nt(VE,"id","bubble"),Nt(VE,"defaults",{datasetElementType:!1,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}}),Nt(VE,"overrides",{scales:{x:{type:"linear"},y:{type:"linear"}}});function $st(n,e,t){let r=1,i=1,s=0,o=0;if(e<yi){const a=n,l=a+e,c=Math.cos(a),u=Math.sin(a),h=Math.cos(l),f=Math.sin(l),d=(_,w,S)=>Y_(_,a,l,!0)?1:Math.max(w,w*t,S,S*t),p=(_,w,S)=>Y_(_,a,l,!0)?-1:Math.min(w,w*t,S,S*t),m=d(0,c,h),g=d(Zi,u,f),y=p(Ti,c,h),b=p(Ti+Zi,u,f);r=(m-y)/2,i=(g-b)/2,s=-(m+y)/2,o=-(g+b)/2}return{ratioX:r,ratioY:i,offsetX:s,offsetY:o}}class _b extends xc{constructor(e,t){super(e,t),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(e,t){const r=this.getDataset().data,i=this._cachedMeta;if(this._parsing===!1)i._parsed=r;else{let s=l=>+r[l];if(rr(r[e])){const{key:l="value"}=this._parsing;s=c=>+up(r[c],l)}let o,a;for(o=e,a=e+t;o<a;++o)i._parsed[o]=s(o)}}_getRotation(){return mu(this.options.rotation-90)}_getCircumference(){return mu(this.options.circumference)}_getRotationExtents(){let e=yi,t=-yi;for(let r=0;r<this.chart.data.datasets.length;++r)if(this.chart.isDatasetVisible(r)&&this.chart.getDatasetMeta(r).type===this._type){const i=this.chart.getDatasetMeta(r).controller,s=i._getRotation(),o=i._getCircumference();e=Math.min(e,s),t=Math.max(t,s+o)}return{rotation:e,circumference:t-e}}update(e){const t=this.chart,{chartArea:r}=t,i=this._cachedMeta,s=i.data,o=this.getMaxBorderWidth()+this.getMaxOffset(s)+this.options.spacing,a=Math.max((Math.min(r.width,r.height)-o)/2,0),l=Math.min(jrt(this.options.cutout,a),1),c=this._getRingWeight(this.index),{circumference:u,rotation:h}=this._getRotationExtents(),{ratioX:f,ratioY:d,offsetX:p,offsetY:m}=$st(h,u,l),g=(r.width-o)/f,y=(r.height-o)/d,b=Math.max(Math.min(g,y)/2,0),_=qre(this.options.radius,b),w=Math.max(_*l,0),S=(_-w)/this._getVisibleDatasetWeightTotal();this.offsetX=p*_,this.offsetY=m*_,i.total=this.calculateTotal(),this.outerRadius=_-S*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-S*c,0),this.updateElements(s,0,s.length,e)}_circumference(e,t){const r=this.options,i=this._cachedMeta,s=this._getCircumference();return t&&r.animation.animateRotate||!this.chart.getDataVisibility(e)||i._parsed[e]===null||i.data[e].hidden?0:this.calculateCircumference(i._parsed[e]*s/yi)}updateElements(e,t,r,i){const s=i==="reset",o=this.chart,a=o.chartArea,c=o.options.animation,u=(a.left+a.right)/2,h=(a.top+a.bottom)/2,f=s&&c.animateScale,d=f?0:this.innerRadius,p=f?0:this.outerRadius,{sharedOptions:m,includeOptions:g}=this._getSharedOptions(t,i);let y=this._getRotation(),b;for(b=0;b<t;++b)y+=this._circumference(b,s);for(b=t;b<t+r;++b){const _=this._circumference(b,s),w=e[b],S={x:u+this.offsetX,y:h+this.offsetY,startAngle:y,endAngle:y+_,circumference:_,outerRadius:p,innerRadius:d};g&&(S.options=m||this.resolveDataElementOptions(b,w.active?"active":i)),y+=_,this.updateElement(w,b,S,i)}}calculateTotal(){const e=this._cachedMeta,t=e.data;let r=0,i;for(i=0;i<t.length;i++){const s=e._parsed[i];s!==null&&!isNaN(s)&&this.chart.getDataVisibility(i)&&!t[i].hidden&&(r+=Math.abs(s))}return r}calculateCircumference(e){const t=this._cachedMeta.total;return t>0&&!isNaN(e)?yi*(Math.abs(e)/t):0}getLabelAndValue(e){const t=this._cachedMeta,r=this.chart,i=r.data.labels||[],s=AC(t._parsed[e],r.options.locale);return{label:i[e]||"",value:s}}getMaxBorderWidth(e){let t=0;const r=this.chart;let i,s,o,a,l;if(!e){for(i=0,s=r.data.datasets.length;i<s;++i)if(r.isDatasetVisible(i)){o=r.getDatasetMeta(i),e=o.data,a=o.controller;break}}if(!e)return 0;for(i=0,s=e.length;i<s;++i)l=a.resolveDataElementOptions(i),l.borderAlign!=="inner"&&(t=Math.max(t,l.borderWidth||0,l.hoverBorderWidth||0));return t}getMaxOffset(e){let t=0;for(let r=0,i=e.length;r<i;++r){const s=this.resolveDataElementOptions(r);t=Math.max(t,s.offset||0,s.hoverOffset||0)}return t}_getRingWeightOffset(e){let t=0;for(let r=0;r<e;++r)this.chart.isDatasetVisible(r)&&(t+=this._getRingWeight(r));return t}_getRingWeight(e){return Math.max(Wn(this.chart.data.datasets[e].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}Nt(_b,"id","doughnut"),Nt(_b,"defaults",{datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"}),Nt(_b,"descriptors",{_scriptable:e=>e!=="spacing",_indexable:e=>e!=="spacing"}),Nt(_b,"overrides",{aspectRatio:1,plugins:{legend:{labels:{generateLabels(e){const t=e.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:r,color:i}}=e.legend.options;return t.labels.map((s,o)=>{const l=e.getDatasetMeta(0).controller.getStyle(o);return{text:s,fillStyle:l.backgroundColor,strokeStyle:l.borderColor,fontColor:i,lineWidth:l.borderWidth,pointStyle:r,hidden:!e.getDataVisibility(o),index:o}})}return[]}},onClick(e,t,r){r.chart.toggleDataVisibility(t.index),r.chart.update()}}}});class UE extends xc{initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(e){const t=this._cachedMeta,{dataset:r,data:i=[],_dataset:s}=t,o=this.chart._animationsDisabled;let{start:a,count:l}=tie(t,i,o);this._drawStart=a,this._drawCount=l,nie(t)&&(a=0,l=i.length),r._chart=this.chart,r._datasetIndex=this.index,r._decimated=!!s._decimated,r.points=i;const c=this.resolveDatasetElementOptions(e);this.options.showLine||(c.borderWidth=0),c.segment=this.options.segment,this.updateElement(r,void 0,{animated:!o,options:c},e),this.updateElements(i,a,l,e)}updateElements(e,t,r,i){const s=i==="reset",{iScale:o,vScale:a,_stacked:l,_dataset:c}=this._cachedMeta,{sharedOptions:u,includeOptions:h}=this._getSharedOptions(t,i),f=o.axis,d=a.axis,{spanGaps:p,segment:m}=this.options,g=ov(p)?p:Number.POSITIVE_INFINITY,y=this.chart._animationsDisabled||s||i==="none",b=t+r,_=e.length;let w=t>0&&this.getParsed(t-1);for(let S=0;S<_;++S){const C=e[S],k=y?C:{};if(S<t||S>=b){k.skip=!0;continue}const A=this.getParsed(S),M=Nr(A[d]),E=k[f]=o.getPixelForValue(A[f],S),N=k[d]=s||M?a.getBasePixel():a.getPixelForValue(l?this.applyStack(a,A,l):A[d],S);k.skip=isNaN(E)||isNaN(N)||M,k.stop=S>0&&Math.abs(A[f]-w[f])>g,m&&(k.parsed=A,k.raw=c.data[S]),h&&(k.options=u||this.resolveDataElementOptions(S,C.active?"active":i)),y||this.updateElement(C,S,k,i),w=A}}getMaxOverflow(){const e=this._cachedMeta,t=e.dataset,r=t.options&&t.options.borderWidth||0,i=e.data||[];if(!i.length)return r;const s=i[0].size(this.resolveDataElementOptions(0)),o=i[i.length-1].size(this.resolveDataElementOptions(i.length-1));return Math.max(r,s,o)/2}draw(){const e=this._cachedMeta;e.dataset.updateControlPoints(this.chart.chartArea,e.iScale.axis),super.draw()}}Nt(UE,"id","line"),Nt(UE,"defaults",{datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1}),Nt(UE,"overrides",{scales:{_index_:{type:"category"},_value_:{type:"linear"}}});class WE extends xc{constructor(e,t){super(e,t),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(e){const t=this._cachedMeta,r=this.chart,i=r.data.labels||[],s=AC(t._parsed[e].r,r.options.locale);return{label:i[e]||"",value:s}}parseObjectData(e,t,r,i){return hie.bind(this)(e,t,r,i)}update(e){const t=this._cachedMeta.data;this._updateRadius(),this.updateElements(t,0,t.length,e)}getMinMax(){const e=this._cachedMeta,t={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return e.data.forEach((r,i)=>{const s=this.getParsed(i).r;!isNaN(s)&&this.chart.getDataVisibility(i)&&(s<t.min&&(t.min=s),s>t.max&&(t.max=s))}),t}_updateRadius(){const e=this.chart,t=e.chartArea,r=e.options,i=Math.min(t.right-t.left,t.bottom-t.top),s=Math.max(i/2,0),o=Math.max(r.cutoutPercentage?s/100*r.cutoutPercentage:1,0),a=(s-o)/e.getVisibleDatasetCount();this.outerRadius=s-a*this.index,this.innerRadius=this.outerRadius-a}updateElements(e,t,r,i){const s=i==="reset",o=this.chart,l=o.options.animation,c=this._cachedMeta.rScale,u=c.xCenter,h=c.yCenter,f=c.getIndexAngle(0)-.5*Ti;let d=f,p;const m=360/this.countVisibleElements();for(p=0;p<t;++p)d+=this._computeAngle(p,i,m);for(p=t;p<t+r;p++){const g=e[p];let y=d,b=d+this._computeAngle(p,i,m),_=o.getDataVisibility(p)?c.getDistanceFromCenterForValue(this.getParsed(p).r):0;d=b,s&&(l.animateScale&&(_=0),l.animateRotate&&(y=b=f));const w={x:u,y:h,innerRadius:0,outerRadius:_,startAngle:y,endAngle:b,options:this.resolveDataElementOptions(p,g.active?"active":i)};this.updateElement(g,p,w,i)}}countVisibleElements(){const e=this._cachedMeta;let t=0;return e.data.forEach((r,i)=>{!isNaN(this.getParsed(i).r)&&this.chart.getDataVisibility(i)&&t++}),t}_computeAngle(e,t,r){return this.chart.getDataVisibility(e)?mu(this.resolveDataElementOptions(e,t).angle||r):0}}Nt(WE,"id","polarArea"),Nt(WE,"defaults",{dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0}),Nt(WE,"overrides",{aspectRatio:1,plugins:{legend:{labels:{generateLabels(e){const t=e.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:r,color:i}}=e.legend.options;return t.labels.map((s,o)=>{const l=e.getDatasetMeta(0).controller.getStyle(o);return{text:s,fillStyle:l.backgroundColor,strokeStyle:l.borderColor,fontColor:i,lineWidth:l.borderWidth,pointStyle:r,hidden:!e.getDataVisibility(o),index:o}})}return[]}},onClick(e,t,r){r.chart.toggleDataVisibility(t.index),r.chart.update()}}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}});class ZO extends _b{}Nt(ZO,"id","pie"),Nt(ZO,"defaults",{cutout:0,rotation:0,circumference:360,radius:"100%"});class HE extends xc{getLabelAndValue(e){const t=this._cachedMeta.vScale,r=this.getParsed(e);return{label:t.getLabels()[e],value:""+t.getLabelForValue(r[t.axis])}}parseObjectData(e,t,r,i){return hie.bind(this)(e,t,r,i)}update(e){const t=this._cachedMeta,r=t.dataset,i=t.data||[],s=t.iScale.getLabels();if(r.points=i,e!=="resize"){const o=this.resolveDatasetElementOptions(e);this.options.showLine||(o.borderWidth=0);const a={_loop:!0,_fullLoop:s.length===i.length,options:o};this.updateElement(r,void 0,a,e)}this.updateElements(i,0,i.length,e)}updateElements(e,t,r,i){const s=this._cachedMeta.rScale,o=i==="reset";for(let a=t;a<t+r;a++){const l=e[a],c=this.resolveDataElementOptions(a,l.active?"active":i),u=s.getPointPositionForValue(a,this.getParsed(a).r),h=o?s.xCenter:u.x,f=o?s.yCenter:u.y,d={x:h,y:f,angle:u.angle,skip:isNaN(h)||isNaN(f),options:c};this.updateElement(l,a,d,i)}}}Nt(HE,"id","radar"),Nt(HE,"defaults",{datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}}),Nt(HE,"overrides",{aspectRatio:1,scales:{r:{type:"radialLinear"}}});class GE extends xc{getLabelAndValue(e){const t=this._cachedMeta,r=this.chart.data.labels||[],{xScale:i,yScale:s}=t,o=this.getParsed(e),a=i.getLabelForValue(o.x),l=s.getLabelForValue(o.y);return{label:r[e]||"",value:"("+a+", "+l+")"}}update(e){const t=this._cachedMeta,{data:r=[]}=t,i=this.chart._animationsDisabled;let{start:s,count:o}=tie(t,r,i);if(this._drawStart=s,this._drawCount=o,nie(t)&&(s=0,o=r.length),this.options.showLine){const{dataset:a,_dataset:l}=t;a._chart=this.chart,a._datasetIndex=this.index,a._decimated=!!l._decimated,a.points=r;const c=this.resolveDatasetElementOptions(e);c.segment=this.options.segment,this.updateElement(a,void 0,{animated:!i,options:c},e)}this.updateElements(r,s,o,e)}addElements(){const{showLine:e}=this.options;!this.datasetElementType&&e&&(this.datasetElementType=this.chart.registry.getElement("line")),super.addElements()}updateElements(e,t,r,i){const s=i==="reset",{iScale:o,vScale:a,_stacked:l,_dataset:c}=this._cachedMeta,u=this.resolveDataElementOptions(t,i),h=this.getSharedOptions(u),f=this.includeOptions(i,h),d=o.axis,p=a.axis,{spanGaps:m,segment:g}=this.options,y=ov(m)?m:Number.POSITIVE_INFINITY,b=this.chart._animationsDisabled||s||i==="none";let _=t>0&&this.getParsed(t-1);for(let w=t;w<t+r;++w){const S=e[w],C=this.getParsed(w),k=b?S:{},A=Nr(C[p]),M=k[d]=o.getPixelForValue(C[d],w),E=k[p]=s||A?a.getBasePixel():a.getPixelForValue(l?this.applyStack(a,C,l):C[p],w);k.skip=isNaN(M)||isNaN(E)||A,k.stop=w>0&&Math.abs(C[d]-_[d])>y,g&&(k.parsed=C,k.raw=c.data[w]),f&&(k.options=h||this.resolveDataElementOptions(w,S.active?"active":i)),b||this.updateElement(S,w,k,i),_=C}this.updateSharedOptions(h,i,u)}getMaxOverflow(){const e=this._cachedMeta,t=e.data||[];if(!this.options.showLine){let a=0;for(let l=t.length-1;l>=0;--l)a=Math.max(a,t[l].size(this.resolveDataElementOptions(l))/2);return a>0&&a}const r=e.dataset,i=r.options&&r.options.borderWidth||0;if(!t.length)return i;const s=t[0].size(this.resolveDataElementOptions(0)),o=t[t.length-1].size(this.resolveDataElementOptions(t.length-1));return Math.max(i,s,o)/2}}Nt(GE,"id","scatter"),Nt(GE,"defaults",{datasetElementType:!1,dataElementType:"point",showLine:!1,fill:!1}),Nt(GE,"overrides",{interaction:{mode:"point"},scales:{x:{type:"linear"},y:{type:"linear"}}});function im(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}class A4{static override(e){Object.assign(A4.prototype,e)}constructor(e){this.options=e||{}}init(){}formats(){return im()}parse(){return im()}format(){return im()}add(){return im()}diff(){return im()}startOf(){return im()}endOf(){return im()}}var _ie={_date:A4};function Rst(n,e,t,r){const{controller:i,data:s,_sorted:o}=n,a=i._cachedMeta.iScale;if(a&&e===a.axis&&e!=="r"&&o&&s.length){const l=a._reversePixels?iit:Lm;if(r){if(i._sharedOptions){const c=s[0],u=typeof c.getRange=="function"&&c.getRange(e);if(u){const h=l(s,e,t-u),f=l(s,e,t+u);return{lo:h.lo,hi:f.hi}}}}else return l(s,e,t)}return{lo:0,hi:s.length-1}}function MC(n,e,t,r,i){const s=n.getSortedVisibleDatasetMetas(),o=t[e];for(let a=0,l=s.length;a<l;++a){const{index:c,data:u}=s[a],{lo:h,hi:f}=Rst(s[a],e,o,i);for(let d=h;d<=f;++d){const p=u[d];p.skip||r(p,c,d)}}}function Pst(n){const e=n.indexOf("x")!==-1,t=n.indexOf("y")!==-1;return function(r,i){const s=e?Math.abs(r.x-i.x):0,o=t?Math.abs(r.y-i.y):0;return Math.sqrt(Math.pow(s,2)+Math.pow(o,2))}}function R3(n,e,t,r,i){const s=[];return!i&&!n.isPointInArea(e)||MC(n,t,e,function(a,l,c){!i&&!Z_(a,n.chartArea,0)||a.inRange(e.x,e.y,r)&&s.push({element:a,datasetIndex:l,index:c})},!0),s}function Dst(n,e,t,r){let i=[];function s(o,a,l){const{startAngle:c,endAngle:u}=o.getProps(["startAngle","endAngle"],r),{angle:h}=Yre(o,{x:e.x,y:e.y});Y_(h,c,u)&&i.push({element:o,datasetIndex:a,index:l})}return MC(n,t,e,s),i}function Ost(n,e,t,r,i,s){let o=[];const a=Pst(t);let l=Number.POSITIVE_INFINITY;function c(u,h,f){const d=u.inRange(e.x,e.y,i);if(r&&!d)return;const p=u.getCenterPoint(i);if(!(!!s||n.isPointInArea(p))&&!d)return;const g=a(e,p);g<l?(o=[{element:u,datasetIndex:h,index:f}],l=g):g===l&&o.push({element:u,datasetIndex:h,index:f})}return MC(n,t,e,c),o}function P3(n,e,t,r,i,s){return!s&&!n.isPointInArea(e)?[]:t==="r"&&!r?Dst(n,e,t,i):Ost(n,e,t,r,i,s)}function J6(n,e,t,r,i){const s=[],o=t==="x"?"inXRange":"inYRange";let a=!1;return MC(n,t,e,(l,c,u)=>{l[o](e[t],i)&&(s.push({element:l,datasetIndex:c,index:u}),a=a||l.inRange(e.x,e.y,i))}),r&&!a?[]:s}var Fst={evaluateInteractionItems:MC,modes:{index(n,e,t,r){const i=vm(e,n),s=t.axis||"x",o=t.includeInvisible||!1,a=t.intersect?R3(n,i,s,r,o):P3(n,i,s,!1,r,o),l=[];return a.length?(n.getSortedVisibleDatasetMetas().forEach(c=>{const u=a[0].index,h=c.data[u];h&&!h.skip&&l.push({element:h,datasetIndex:c.index,index:u})}),l):[]},dataset(n,e,t,r){const i=vm(e,n),s=t.axis||"xy",o=t.includeInvisible||!1;let a=t.intersect?R3(n,i,s,r,o):P3(n,i,s,!1,r,o);if(a.length>0){const l=a[0].datasetIndex,c=n.getDatasetMeta(l).data;a=[];for(let u=0;u<c.length;++u)a.push({element:c[u],datasetIndex:l,index:u})}return a},point(n,e,t,r){const i=vm(e,n),s=t.axis||"xy",o=t.includeInvisible||!1;return R3(n,i,s,r,o)},nearest(n,e,t,r){const i=vm(e,n),s=t.axis||"xy",o=t.includeInvisible||!1;return P3(n,i,s,t.intersect,r,o)},x(n,e,t,r){const i=vm(e,n);return J6(n,i,"x",t.intersect,r)},y(n,e,t,r){const i=vm(e,n);return J6(n,i,"y",t.intersect,r)}}};const Sie=["left","top","right","bottom"];function Gx(n,e){return n.filter(t=>t.pos===e)}function Q6(n,e){return n.filter(t=>Sie.indexOf(t.pos)===-1&&t.box.axis===e)}function jx(n,e){return n.sort((t,r)=>{const i=e?r:t,s=e?t:r;return i.weight===s.weight?i.index-s.index:i.weight-s.weight})}function Lst(n){const e=[];let t,r,i,s,o,a;for(t=0,r=(n||[]).length;t<r;++t)i=n[t],{position:s,options:{stack:o,stackWeight:a=1}}=i,e.push({index:t,box:i,pos:s,horizontal:i.isHorizontal(),weight:i.weight,stack:o&&s+o,stackWeight:a});return e}function zst(n){const e={};for(const t of n){const{stack:r,pos:i,stackWeight:s}=t;if(!r||!Sie.includes(i))continue;const o=e[r]||(e[r]={count:0,placed:0,weight:0,size:0});o.count++,o.weight+=s}return e}function Bst(n,e){const t=zst(n),{vBoxMaxWidth:r,hBoxMaxHeight:i}=e;let s,o,a;for(s=0,o=n.length;s<o;++s){a=n[s];const{fullSize:l}=a.box,c=t[a.stack],u=c&&a.stackWeight/c.weight;a.horizontal?(a.width=u?u*r:l&&e.availableWidth,a.height=i):(a.width=r,a.height=u?u*i:l&&e.availableHeight)}return t}function Vst(n){const e=Lst(n),t=jx(e.filter(c=>c.box.fullSize),!0),r=jx(Gx(e,"left"),!0),i=jx(Gx(e,"right")),s=jx(Gx(e,"top"),!0),o=jx(Gx(e,"bottom")),a=Q6(e,"x"),l=Q6(e,"y");return{fullSize:t,leftAndTop:r.concat(s),rightAndBottom:i.concat(l).concat(o).concat(a),chartArea:Gx(e,"chartArea"),vertical:r.concat(i).concat(l),horizontal:s.concat(o).concat(a)}}function e5(n,e,t,r){return Math.max(n[t],e[t])+Math.max(n[r],e[r])}function Cie(n,e){n.top=Math.max(n.top,e.top),n.left=Math.max(n.left,e.left),n.bottom=Math.max(n.bottom,e.bottom),n.right=Math.max(n.right,e.right)}function Ust(n,e,t,r){const{pos:i,box:s}=t,o=n.maxPadding;if(!rr(i)){t.size&&(n[i]-=t.size);const h=r[t.stack]||{size:0,count:1};h.size=Math.max(h.size,t.horizontal?s.height:s.width),t.size=h.size/h.count,n[i]+=t.size}s.getPadding&&Cie(o,s.getPadding());const a=Math.max(0,e.outerWidth-e5(o,n,"left","right")),l=Math.max(0,e.outerHeight-e5(o,n,"top","bottom")),c=a!==n.w,u=l!==n.h;return n.w=a,n.h=l,t.horizontal?{same:c,other:u}:{same:u,other:c}}function Wst(n){const e=n.maxPadding;function t(r){const i=Math.max(e[r]-n[r],0);return n[r]+=i,i}n.y+=t("top"),n.x+=t("left"),t("right"),t("bottom")}function Hst(n,e){const t=e.maxPadding;function r(i){const s={left:0,top:0,right:0,bottom:0};return i.forEach(o=>{s[o]=Math.max(e[o],t[o])}),s}return r(n?["left","right"]:["top","bottom"])}function T1(n,e,t,r){const i=[];let s,o,a,l,c,u;for(s=0,o=n.length,c=0;s<o;++s){a=n[s],l=a.box,l.update(a.width||e.w,a.height||e.h,Hst(a.horizontal,e));const{same:h,other:f}=Ust(e,t,a,r);c|=h&&i.length,u=u||f,l.fullSize||i.push(a)}return c&&T1(i,e,t,r)||u}function gT(n,e,t,r,i){n.top=t,n.left=e,n.right=e+r,n.bottom=t+i,n.width=r,n.height=i}function t5(n,e,t,r){const i=t.padding;let{x:s,y:o}=e;for(const a of n){const l=a.box,c=r[a.stack]||{count:1,placed:0,weight:1},u=a.stackWeight/c.weight||1;if(a.horizontal){const h=e.w*u,f=c.size||l.height;Ic(c.start)&&(o=c.start),l.fullSize?gT(l,i.left,o,t.outerWidth-i.right-i.left,f):gT(l,e.left+c.placed,o,h,f),c.start=o,c.placed+=h,o=l.bottom}else{const h=e.h*u,f=c.size||l.width;Ic(c.start)&&(s=c.start),l.fullSize?gT(l,s,i.top,f,t.outerHeight-i.bottom-i.top):gT(l,s,e.top+c.placed,f,h),c.start=s,c.placed+=h,s=l.right}}e.x=s,e.y=o}var gc={addBox(n,e){n.boxes||(n.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||"top",e.weight=e.weight||0,e._layers=e._layers||function(){return[{z:0,draw(t){e.draw(t)}}]},n.boxes.push(e)},removeBox(n,e){const t=n.boxes?n.boxes.indexOf(e):-1;t!==-1&&n.boxes.splice(t,1)},configure(n,e,t){e.fullSize=t.fullSize,e.position=t.position,e.weight=t.weight},update(n,e,t,r){if(!n)return;const i=ea(n.options.layout.padding),s=Math.max(e-i.width,0),o=Math.max(t-i.height,0),a=Vst(n.boxes),l=a.vertical,c=a.horizontal;Dr(n.boxes,m=>{typeof m.beforeLayout=="function"&&m.beforeLayout()});const u=l.reduce((m,g)=>g.box.options&&g.box.options.display===!1?m:m+1,0)||1,h=Object.freeze({outerWidth:e,outerHeight:t,padding:i,availableWidth:s,availableHeight:o,vBoxMaxWidth:s/2/u,hBoxMaxHeight:o/2}),f=Object.assign({},i);Cie(f,ea(r));const d=Object.assign({maxPadding:f,w:s,h:o,x:i.left,y:i.top},i),p=Bst(l.concat(c),h);T1(a.fullSize,d,h,p),T1(l,d,h,p),T1(c,d,h,p)&&T1(l,d,h,p),Wst(d),t5(a.leftAndTop,d,h,p),d.x+=d.w,d.y+=d.h,t5(a.rightAndBottom,d,h,p),n.chartArea={left:d.left,top:d.top,right:d.left+d.w,bottom:d.top+d.h,height:d.h,width:d.w},Dr(a.chartArea,m=>{const g=m.box;Object.assign(g,n.chartArea),g.update(d.w,d.h,{left:0,top:0,right:0,bottom:0})})}};class kie{acquireContext(e,t){}releaseContext(e){return!1}addEventListener(e,t,r){}removeEventListener(e,t,r){}getDevicePixelRatio(){return 1}getMaximumSize(e,t,r,i){return t=Math.max(0,t||e.width),r=r||e.height,{width:t,height:Math.max(0,i?Math.floor(t/i):r)}}isAttached(e){return!0}updateConfig(e){}}class Gst extends kie{acquireContext(e){return e&&e.getContext&&e.getContext("2d")||null}updateConfig(e){e.options.animation=!1}}const jE="$chartjs",jst={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},n5=n=>n===null||n==="";function qst(n,e){const t=n.style,r=n.getAttribute("height"),i=n.getAttribute("width");if(n[jE]={initial:{height:r,width:i,style:{display:t.display,height:t.height,width:t.width}}},t.display=t.display||"block",t.boxSizing=t.boxSizing||"border-box",n5(i)){const s=L6(n,"width");s!==void 0&&(n.width=s)}if(n5(r))if(n.style.height==="")n.height=n.width/(e||2);else{const s=L6(n,"height");s!==void 0&&(n.height=s)}return n}const Tie=Zit?{passive:!0}:!1;function Xst(n,e,t){n.addEventListener(e,t,Tie)}function Kst(n,e,t){n.canvas.removeEventListener(e,t,Tie)}function Yst(n,e){const t=jst[n.type]||n.type,{x:r,y:i}=vm(n,e);return{type:t,chart:e,native:n,x:r!==void 0?r:null,y:i!==void 0?i:null}}function cA(n,e){for(const t of n)if(t===e||t.contains(e))return!0}function Zst(n,e,t){const r=n.canvas,i=new MutationObserver(s=>{let o=!1;for(const a of s)o=o||cA(a.addedNodes,r),o=o&&!cA(a.removedNodes,r);o&&t()});return i.observe(document,{childList:!0,subtree:!0}),i}function Jst(n,e,t){const r=n.canvas,i=new MutationObserver(s=>{let o=!1;for(const a of s)o=o||cA(a.removedNodes,r),o=o&&!cA(a.addedNodes,r);o&&t()});return i.observe(document,{childList:!0,subtree:!0}),i}const J_=new Map;let r5=0;function Eie(){const n=window.devicePixelRatio;n!==r5&&(r5=n,J_.forEach((e,t)=>{t.currentDevicePixelRatio!==n&&e()}))}function Qst(n,e){J_.size||window.addEventListener("resize",Eie),J_.set(n,e)}function eot(n){J_.delete(n),J_.size||window.removeEventListener("resize",Eie)}function tot(n,e,t){const r=n.canvas,i=r&&I4(r);if(!i)return;const s=eie((a,l)=>{const c=i.clientWidth;t(a,l),c<i.clientWidth&&t()},window),o=new ResizeObserver(a=>{const l=a[0],c=l.contentRect.width,u=l.contentRect.height;c===0&&u===0||s(c,u)});return o.observe(i),Qst(n,s),o}function D3(n,e,t){t&&t.disconnect(),e==="resize"&&eot(n)}function not(n,e,t){const r=n.canvas,i=eie(s=>{n.ctx!==null&&t(Yst(s,n))},n);return Xst(r,e,i),i}class rot extends kie{acquireContext(e,t){const r=e&&e.getContext&&e.getContext("2d");return r&&r.canvas===e?(qst(e,t),r):null}releaseContext(e){const t=e.canvas;if(!t[jE])return!1;const r=t[jE].initial;["height","width"].forEach(s=>{const o=r[s];Nr(o)?t.removeAttribute(s):t.setAttribute(s,o)});const i=r.style||{};return Object.keys(i).forEach(s=>{t.style[s]=i[s]}),t.width=t.width,delete t[jE],!0}addEventListener(e,t,r){this.removeEventListener(e,t);const i=e.$proxies||(e.$proxies={}),o={attach:Zst,detach:Jst,resize:tot}[t]||not;i[t]=o(e,t,r)}removeEventListener(e,t){const r=e.$proxies||(e.$proxies={}),i=r[t];if(!i)return;({attach:D3,detach:D3,resize:D3}[t]||Kst)(e,t,i),r[t]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(e,t,r,i){return Yit(e,t,r,i)}isAttached(e){const t=I4(e);return!!(t&&t.isConnected)}}function iot(n){return!die()||typeof OffscreenCanvas<"u"&&n instanceof OffscreenCanvas?Gst:rot}class Ac{constructor(){Nt(this,"active",!1)}tooltipPosition(e){const{x:t,y:r}=this.getProps(["x","y"],e);return{x:t,y:r}}hasValue(){return ov(this.x)&&ov(this.y)}getProps(e,t){const r=this.$animations;if(!t||!r)return this;const i={};return e.forEach(s=>{i[s]=r[s]&&r[s].active()?r[s]._to:this[s]}),i}}Nt(Ac,"defaults",{}),Nt(Ac,"defaultRoutes");function sot(n,e){const t=n.options.ticks,r=oot(n),i=Math.min(t.maxTicksLimit||r,r),s=t.major.enabled?lot(e):[],o=s.length,a=s[0],l=s[o-1],c=[];if(o>i)return cot(e,c,s,o/i),c;const u=aot(s,e,i);if(o>0){let h,f;const d=o>1?Math.round((l-a)/(o-1)):null;for(yT(e,c,u,Nr(d)?0:a-d,a),h=0,f=o-1;h<f;h++)yT(e,c,u,s[h],s[h+1]);return yT(e,c,u,l,Nr(d)?e.length:l+d),c}return yT(e,c,u),c}function oot(n){const e=n.options.offset,t=n._tickSize(),r=n._length/t+(e?0:1),i=n._maxLength/t;return Math.floor(Math.min(r,i))}function aot(n,e,t){const r=uot(n),i=e.length/t;if(!r)return Math.max(i,1);const s=eit(r);for(let o=0,a=s.length-1;o<a;o++){const l=s[o];if(l>i)return l}return Math.max(i,1)}function lot(n){const e=[];let t,r;for(t=0,r=n.length;t<r;t++)n[t].major&&e.push(t);return e}function cot(n,e,t,r){let i=0,s=t[0],o;for(r=Math.ceil(r),o=0;o<n.length;o++)o===s&&(e.push(n[o]),i++,s=t[i*r])}function yT(n,e,t,r,i){const s=Wn(r,0),o=Math.min(Wn(i,n.length),n.length);let a=0,l,c,u;for(t=Math.ceil(t),i&&(l=i-r,t=l/Math.floor(l/t)),u=s;u<0;)a++,u=Math.round(s+a*t);for(c=Math.max(s,0);c<o;c++)c===u&&(e.push(n[c]),a++,u=Math.round(s+a*t))}function uot(n){const e=n.length;let t,r;if(e<2)return!1;for(r=n[0],t=1;t<e;++t)if(n[t]-n[t-1]!==r)return!1;return r}const hot=n=>n==="left"?"right":n==="right"?"left":n,i5=(n,e,t)=>e==="top"||e==="left"?n[e]+t:n[e]-t,s5=(n,e)=>Math.min(e||n,n);function o5(n,e){const t=[],r=n.length/e,i=n.length;let s=0;for(;s<i;s+=r)t.push(n[Math.floor(s)]);return t}function fot(n,e,t){const r=n.ticks.length,i=Math.min(e,r-1),s=n._startPixel,o=n._endPixel,a=1e-6;let l=n.getPixelForTick(i),c;if(!(t&&(r===1?c=Math.max(l-s,o-l):e===0?c=(n.getPixelForTick(1)-l)/2:c=(l-n.getPixelForTick(i-1))/2,l+=i<e?c:-c,l<s-a||l>o+a)))return l}function dot(n,e){Dr(n,t=>{const r=t.gc,i=r.length/2;let s;if(i>e){for(s=0;s<i;++s)delete t.data[r[s]];r.splice(0,i)}})}function qx(n){return n.drawTicks?n.tickLength:0}function a5(n,e){if(!n.display)return 0;const t=Hs(n.font,e),r=ea(n.padding);return(mi(n.text)?n.text.length:1)*t.lineHeight+r.height}function pot(n,e){return Pp(n,{scale:e,type:"scale"})}function mot(n,e,t){return Pp(n,{tick:t,index:e,type:"tick"})}function got(n,e,t){let r=S4(n);return(t&&e!=="right"||!t&&e==="right")&&(r=hot(r)),r}function yot(n,e,t,r){const{top:i,left:s,bottom:o,right:a,chart:l}=n,{chartArea:c,scales:u}=l;let h=0,f,d,p;const m=o-i,g=a-s;if(n.isHorizontal()){if(d=Bo(r,s,a),rr(t)){const y=Object.keys(t)[0],b=t[y];p=u[y].getPixelForValue(b)+m-e}else t==="center"?p=(c.bottom+c.top)/2+m-e:p=i5(n,t,e);f=a-s}else{if(rr(t)){const y=Object.keys(t)[0],b=t[y];d=u[y].getPixelForValue(b)-g+e}else t==="center"?d=(c.left+c.right)/2-g+e:d=i5(n,t,e);p=Bo(r,o,i),h=t==="left"?-Zi:Zi}return{titleX:d,titleY:p,maxWidth:f,rotation:h}}class Ky extends Ac{constructor(e){super(),this.id=e.id,this.type=e.type,this.options=void 0,this.ctx=e.ctx,this.chart=e.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(e){this.options=e.setContext(this.getContext()),this.axis=e.axis,this._userMin=this.parse(e.min),this._userMax=this.parse(e.max),this._suggestedMin=this.parse(e.suggestedMin),this._suggestedMax=this.parse(e.suggestedMax)}parse(e,t){return e}getUserBounds(){let{_userMin:e,_userMax:t,_suggestedMin:r,_suggestedMax:i}=this;return e=gl(e,Number.POSITIVE_INFINITY),t=gl(t,Number.NEGATIVE_INFINITY),r=gl(r,Number.POSITIVE_INFINITY),i=gl(i,Number.NEGATIVE_INFINITY),{min:gl(e,r),max:gl(t,i),minDefined:Yi(e),maxDefined:Yi(t)}}getMinMax(e){let{min:t,max:r,minDefined:i,maxDefined:s}=this.getUserBounds(),o;if(i&&s)return{min:t,max:r};const a=this.getMatchingVisibleMetas();for(let l=0,c=a.length;l<c;++l)o=a[l].controller.getMinMax(this,e),i||(t=Math.min(t,o.min)),s||(r=Math.max(r,o.max));return t=s&&t>r?r:t,r=i&&t>r?t:r,{min:gl(t,gl(r,t)),max:gl(r,gl(t,r))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const e=this.chart.data;return this.options.labels||(this.isHorizontal()?e.xLabels:e.yLabels)||e.labels||[]}getLabelItems(e=this.chart.chartArea){return this._labelItems||(this._labelItems=this._computeLabelItems(e))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){si(this.options.beforeUpdate,[this])}update(e,t,r){const{beginAtZero:i,grace:s,ticks:o}=this.options,a=o.sampleSize;this.beforeUpdate(),this.maxWidth=e,this.maxHeight=t,this._margins=r=Object.assign({left:0,right:0,top:0,bottom:0},r),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+r.left+r.right:this.height+r.top+r.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=Iit(this,s,i),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const l=a<this.ticks.length;this._convertTicksToLabels(l?o5(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&&(o.autoSkip||o.source==="auto")&&(this.ticks=sot(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),l&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let e=this.options.reverse,t,r;this.isHorizontal()?(t=this.left,r=this.right):(t=this.top,r=this.bottom,e=!e),this._startPixel=t,this._endPixel=r,this._reversePixels=e,this._length=r-t,this._alignToPixels=this.options.alignToPixels}afterUpdate(){si(this.options.afterUpdate,[this])}beforeSetDimensions(){si(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){si(this.options.afterSetDimensions,[this])}_callHooks(e){this.chart.notifyPlugins(e,this.getContext()),si(this.options[e],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){si(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(e){const t=this.options.ticks;let r,i,s;for(r=0,i=e.length;r<i;r++)s=e[r],s.label=si(t.callback,[s.value,r,e],this)}afterTickToLabelConversion(){si(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){si(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const e=this.options,t=e.ticks,r=s5(this.ticks.length,e.ticks.maxTicksLimit),i=t.minRotation||0,s=t.maxRotation;let o=i,a,l,c;if(!this._isVisible()||!t.display||i>=s||r<=1||!this.isHorizontal()){this.labelRotation=i;return}const u=this._getLabelSizes(),h=u.widest.width,f=u.highest.height,d=Yo(this.chart.width-h,0,this.maxWidth);a=e.offset?this.maxWidth/r:d/(r-1),h+6>a&&(a=d/(r-(e.offset?.5:1)),l=this.maxHeight-qx(e.grid)-t.padding-a5(e.title,this.chart.options.font),c=Math.sqrt(h*h+f*f),o=x4(Math.min(Math.asin(Yo((u.highest.height+6)/a,-1,1)),Math.asin(Yo(l/c,-1,1))-Math.asin(Yo(f/c,-1,1)))),o=Math.max(i,Math.min(s,o))),this.labelRotation=o}afterCalculateLabelRotation(){si(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){si(this.options.beforeFit,[this])}fit(){const e={width:0,height:0},{chart:t,options:{ticks:r,title:i,grid:s}}=this,o=this._isVisible(),a=this.isHorizontal();if(o){const l=a5(i,t.options.font);if(a?(e.width=this.maxWidth,e.height=qx(s)+l):(e.height=this.maxHeight,e.width=qx(s)+l),r.display&&this.ticks.length){const{first:c,last:u,widest:h,highest:f}=this._getLabelSizes(),d=r.padding*2,p=mu(this.labelRotation),m=Math.cos(p),g=Math.sin(p);if(a){const y=r.mirror?0:g*h.width+m*f.height;e.height=Math.min(this.maxHeight,e.height+y+d)}else{const y=r.mirror?0:m*h.width+g*f.height;e.width=Math.min(this.maxWidth,e.width+y+d)}this._calculatePadding(c,u,g,m)}}this._handleMargins(),a?(this.width=this._length=t.width-this._margins.left-this._margins.right,this.height=e.height):(this.width=e.width,this.height=this._length=t.height-this._margins.top-this._margins.bottom)}_calculatePadding(e,t,r,i){const{ticks:{align:s,padding:o},position:a}=this.options,l=this.labelRotation!==0,c=a!=="top"&&this.axis==="x";if(this.isHorizontal()){const u=this.getPixelForTick(0)-this.left,h=this.right-this.getPixelForTick(this.ticks.length-1);let f=0,d=0;l?c?(f=i*e.width,d=r*t.height):(f=r*e.height,d=i*t.width):s==="start"?d=t.width:s==="end"?f=e.width:s!=="inner"&&(f=e.width/2,d=t.width/2),this.paddingLeft=Math.max((f-u+o)*this.width/(this.width-u),0),this.paddingRight=Math.max((d-h+o)*this.width/(this.width-h),0)}else{let u=t.height/2,h=e.height/2;s==="start"?(u=0,h=e.height):s==="end"&&(u=t.height,h=0),this.paddingTop=u+o,this.paddingBottom=h+o}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){si(this.options.afterFit,[this])}isHorizontal(){const{axis:e,position:t}=this.options;return t==="top"||t==="bottom"||e==="x"}isFullSize(){return this.options.fullSize}_convertTicksToLabels(e){this.beforeTickToLabelConversion(),this.generateTickLabels(e);let t,r;for(t=0,r=e.length;t<r;t++)Nr(e[t].label)&&(e.splice(t,1),r--,t--);this.afterTickToLabelConversion()}_getLabelSizes(){let e=this._labelSizes;if(!e){const t=this.options.ticks.sampleSize;let r=this.ticks;t<r.length&&(r=o5(r,t)),this._labelSizes=e=this._computeLabelSizes(r,r.length,this.options.ticks.maxTicksLimit)}return e}_computeLabelSizes(e,t,r){const{ctx:i,_longestTextCache:s}=this,o=[],a=[],l=Math.floor(t/s5(t,r));let c=0,u=0,h,f,d,p,m,g,y,b,_,w,S;for(h=0;h<t;h+=l){if(p=e[h].label,m=this._resolveTickFontOptions(h),i.font=g=m.string,y=s[g]=s[g]||{data:{},gc:[]},b=m.lineHeight,_=w=0,!Nr(p)&&!mi(p))_=aA(i,y.data,y.gc,_,p),w=b;else if(mi(p))for(f=0,d=p.length;f<d;++f)S=p[f],!Nr(S)&&!mi(S)&&(_=aA(i,y.data,y.gc,_,S),w+=b);o.push(_),a.push(w),c=Math.max(_,c),u=Math.max(w,u)}dot(s,t);const C=o.indexOf(c),k=a.indexOf(u),A=M=>({width:o[M]||0,height:a[M]||0});return{first:A(0),last:A(t-1),widest:A(C),highest:A(k),widths:o,heights:a}}getLabelForValue(e){return e}getPixelForValue(e,t){return NaN}getValueForPixel(e){}getPixelForTick(e){const t=this.ticks;return e<0||e>t.length-1?null:this.getPixelForValue(t[e].value)}getPixelForDecimal(e){this._reversePixels&&(e=1-e);const t=this._startPixel+e*this._length;return rit(this._alignToPixels?rm(this.chart,t,0):t)}getDecimalForPixel(e){const t=(e-this._startPixel)/this._length;return this._reversePixels?1-t:t}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:e,max:t}=this;return e<0&&t<0?t:e>0&&t>0?e:0}getContext(e){const t=this.ticks||[];if(e>=0&&e<t.length){const r=t[e];return r.$context||(r.$context=mot(this.getContext(),e,r))}return this.$context||(this.$context=pot(this.chart.getContext(),this))}_tickSize(){const e=this.options.ticks,t=mu(this.labelRotation),r=Math.abs(Math.cos(t)),i=Math.abs(Math.sin(t)),s=this._getLabelSizes(),o=e.autoSkipPadding||0,a=s?s.widest.width+o:0,l=s?s.highest.height+o:0;return this.isHorizontal()?l*r>a*i?a/r:l/i:l*i<a*r?l/r:a/i}_isVisible(){const e=this.options.display;return e!=="auto"?!!e:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(e){const t=this.axis,r=this.chart,i=this.options,{grid:s,position:o,border:a}=i,l=s.offset,c=this.isHorizontal(),h=this.ticks.length+(l?1:0),f=qx(s),d=[],p=a.setContext(this.getContext()),m=p.display?p.width:0,g=m/2,y=function(B){return rm(r,B,m)};let b,_,w,S,C,k,A,M,E,N,O,R;if(o==="top")b=y(this.bottom),k=this.bottom-f,M=b-g,N=y(e.top)+g,R=e.bottom;else if(o==="bottom")b=y(this.top),N=e.top,R=y(e.bottom)-g,k=b+g,M=this.top+f;else if(o==="left")b=y(this.right),C=this.right-f,A=b-g,E=y(e.left)+g,O=e.right;else if(o==="right")b=y(this.left),E=e.left,O=y(e.right)-g,C=b+g,A=this.left+f;else if(t==="x"){if(o==="center")b=y((e.top+e.bottom)/2+.5);else if(rr(o)){const B=Object.keys(o)[0],X=o[B];b=y(this.chart.scales[B].getPixelForValue(X))}N=e.top,R=e.bottom,k=b+g,M=k+f}else if(t==="y"){if(o==="center")b=y((e.left+e.right)/2);else if(rr(o)){const B=Object.keys(o)[0],X=o[B];b=y(this.chart.scales[B].getPixelForValue(X))}C=b-g,A=C-f,E=e.left,O=e.right}const D=Wn(i.ticks.maxTicksLimit,h),z=Math.max(1,Math.ceil(h/D));for(_=0;_<h;_+=z){const B=this.getContext(_),X=s.setContext(B),H=a.setContext(B),te=X.lineWidth,ge=X.color,ae=H.dash||[],Ne=H.dashOffset,Te=X.tickWidth,De=X.tickColor,be=X.tickBorderDash||[],Ke=X.tickBorderDashOffset;w=fot(this,_,l),w!==void 0&&(S=rm(r,w,te),c?C=A=E=O=S:k=M=N=R=S,d.push({tx1:C,ty1:k,tx2:A,ty2:M,x1:E,y1:N,x2:O,y2:R,width:te,color:ge,borderDash:ae,borderDashOffset:Ne,tickWidth:Te,tickColor:De,tickBorderDash:be,tickBorderDashOffset:Ke}))}return this._ticksLength=h,this._borderValue=b,d}_computeLabelItems(e){const t=this.axis,r=this.options,{position:i,ticks:s}=r,o=this.isHorizontal(),a=this.ticks,{align:l,crossAlign:c,padding:u,mirror:h}=s,f=qx(r.grid),d=f+u,p=h?-u:d,m=-mu(this.labelRotation),g=[];let y,b,_,w,S,C,k,A,M,E,N,O,R="middle";if(i==="top")C=this.bottom-p,k=this._getXAxisLabelAlignment();else if(i==="bottom")C=this.top+p,k=this._getXAxisLabelAlignment();else if(i==="left"){const z=this._getYAxisLabelAlignment(f);k=z.textAlign,S=z.x}else if(i==="right"){const z=this._getYAxisLabelAlignment(f);k=z.textAlign,S=z.x}else if(t==="x"){if(i==="center")C=(e.top+e.bottom)/2+d;else if(rr(i)){const z=Object.keys(i)[0],B=i[z];C=this.chart.scales[z].getPixelForValue(B)+d}k=this._getXAxisLabelAlignment()}else if(t==="y"){if(i==="center")S=(e.left+e.right)/2-d;else if(rr(i)){const z=Object.keys(i)[0],B=i[z];S=this.chart.scales[z].getPixelForValue(B)}k=this._getYAxisLabelAlignment(f).textAlign}t==="y"&&(l==="start"?R="top":l==="end"&&(R="bottom"));const D=this._getLabelSizes();for(y=0,b=a.length;y<b;++y){_=a[y],w=_.label;const z=s.setContext(this.getContext(y));A=this.getPixelForTick(y)+s.labelOffset,M=this._resolveTickFontOptions(y),E=M.lineHeight,N=mi(w)?w.length:1;const B=N/2,X=z.color,H=z.textStrokeColor,te=z.textStrokeWidth;let ge=k;o?(S=A,k==="inner"&&(y===b-1?ge=this.options.reverse?"left":"right":y===0?ge=this.options.reverse?"right":"left":ge="center"),i==="top"?c==="near"||m!==0?O=-N*E+E/2:c==="center"?O=-D.highest.height/2-B*E+E:O=-D.highest.height+E/2:c==="near"||m!==0?O=E/2:c==="center"?O=D.highest.height/2-B*E:O=D.highest.height-N*E,h&&(O*=-1),m!==0&&!z.showLabelBackdrop&&(S+=E/2*Math.sin(m))):(C=A,O=(1-N)*E/2);let ae;if(z.showLabelBackdrop){const Ne=ea(z.backdropPadding),Te=D.heights[y],De=D.widths[y];let be=O-Ne.top,Ke=0-Ne.left;switch(R){case"middle":be-=Te/2;break;case"bottom":be-=Te;break}switch(k){case"center":Ke-=De/2;break;case"right":Ke-=De;break}ae={left:Ke,top:be,width:De+Ne.width,height:Te+Ne.height,color:z.backdropColor}}g.push({label:w,font:M,textOffset:O,options:{rotation:m,color:X,strokeColor:H,strokeWidth:te,textAlign:ge,textBaseline:R,translation:[S,C],backdrop:ae}})}return g}_getXAxisLabelAlignment(){const{position:e,ticks:t}=this.options;if(-mu(this.labelRotation))return e==="top"?"left":"right";let i="center";return t.align==="start"?i="left":t.align==="end"?i="right":t.align==="inner"&&(i="inner"),i}_getYAxisLabelAlignment(e){const{position:t,ticks:{crossAlign:r,mirror:i,padding:s}}=this.options,o=this._getLabelSizes(),a=e+s,l=o.widest.width;let c,u;return t==="left"?i?(u=this.right+s,r==="near"?c="left":r==="center"?(c="center",u+=l/2):(c="right",u+=l)):(u=this.right-a,r==="near"?c="right":r==="center"?(c="center",u-=l/2):(c="left",u=this.left)):t==="right"?i?(u=this.left+s,r==="near"?c="right":r==="center"?(c="center",u-=l/2):(c="left",u-=l)):(u=this.left+a,r==="near"?c="left":r==="center"?(c="center",u+=l/2):(c="right",u=this.right)):c="right",{textAlign:c,x:u}}_computeLabelArea(){if(this.options.ticks.mirror)return;const e=this.chart,t=this.options.position;if(t==="left"||t==="right")return{top:0,left:this.left,bottom:e.height,right:this.right};if(t==="top"||t==="bottom")return{top:this.top,left:0,bottom:this.bottom,right:e.width}}drawBackground(){const{ctx:e,options:{backgroundColor:t},left:r,top:i,width:s,height:o}=this;t&&(e.save(),e.fillStyle=t,e.fillRect(r,i,s,o),e.restore())}getLineWidthForValue(e){const t=this.options.grid;if(!this._isVisible()||!t.display)return 0;const i=this.ticks.findIndex(s=>s.value===e);return i>=0?t.setContext(this.getContext(i)).lineWidth:0}drawGrid(e){const t=this.options.grid,r=this.ctx,i=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(e));let s,o;const a=(l,c,u)=>{!u.width||!u.color||(r.save(),r.lineWidth=u.width,r.strokeStyle=u.color,r.setLineDash(u.borderDash||[]),r.lineDashOffset=u.borderDashOffset,r.beginPath(),r.moveTo(l.x,l.y),r.lineTo(c.x,c.y),r.stroke(),r.restore())};if(t.display)for(s=0,o=i.length;s<o;++s){const l=i[s];t.drawOnChartArea&&a({x:l.x1,y:l.y1},{x:l.x2,y:l.y2},l),t.drawTicks&&a({x:l.tx1,y:l.ty1},{x:l.tx2,y:l.ty2},{color:l.tickColor,width:l.tickWidth,borderDash:l.tickBorderDash,borderDashOffset:l.tickBorderDashOffset})}}drawBorder(){const{chart:e,ctx:t,options:{border:r,grid:i}}=this,s=r.setContext(this.getContext()),o=r.display?s.width:0;if(!o)return;const a=i.setContext(this.getContext(0)).lineWidth,l=this._borderValue;let c,u,h,f;this.isHorizontal()?(c=rm(e,this.left,o)-o/2,u=rm(e,this.right,a)+a/2,h=f=l):(h=rm(e,this.top,o)-o/2,f=rm(e,this.bottom,a)+a/2,c=u=l),t.save(),t.lineWidth=s.width,t.strokeStyle=s.color,t.beginPath(),t.moveTo(c,h),t.lineTo(u,f),t.stroke(),t.restore()}drawLabels(e){if(!this.options.ticks.display)return;const r=this.ctx,i=this._computeLabelArea();i&&g$(r,i);const s=this.getLabelItems(e);for(const o of s){const a=o.options,l=o.font,c=o.label,u=o.textOffset;gg(r,c,0,u,l,a)}i&&y$(r)}drawTitle(){const{ctx:e,options:{position:t,title:r,reverse:i}}=this;if(!r.display)return;const s=Hs(r.font),o=ea(r.padding),a=r.align;let l=s.lineHeight/2;t==="bottom"||t==="center"||rr(t)?(l+=o.bottom,mi(r.text)&&(l+=s.lineHeight*(r.text.length-1))):l+=o.top;const{titleX:c,titleY:u,maxWidth:h,rotation:f}=yot(this,l,t,a);gg(e,r.text,0,0,s,{color:r.color,maxWidth:h,rotation:f,textAlign:got(a,t,i),textBaseline:"middle",translation:[c,u]})}draw(e){this._isVisible()&&(this.drawBackground(),this.drawGrid(e),this.drawBorder(),this.drawTitle(),this.drawLabels(e))}_layers(){const e=this.options,t=e.ticks&&e.ticks.z||0,r=Wn(e.grid&&e.grid.z,-1),i=Wn(e.border&&e.border.z,0);return!this._isVisible()||this.draw!==Ky.prototype.draw?[{z:t,draw:s=>{this.draw(s)}}]:[{z:r,draw:s=>{this.drawBackground(),this.drawGrid(s),this.drawTitle()}},{z:i,draw:()=>{this.drawBorder()}},{z:t,draw:s=>{this.drawLabels(s)}}]}getMatchingVisibleMetas(e){const t=this.chart.getSortedVisibleDatasetMetas(),r=this.axis+"AxisID",i=[];let s,o;for(s=0,o=t.length;s<o;++s){const a=t[s];a[r]===this.id&&(!e||a.type===e)&&i.push(a)}return i}_resolveTickFontOptions(e){const t=this.options.ticks.setContext(this.getContext(e));return Hs(t.font)}_maxDigits(){const e=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/e}}class bT{constructor(e,t,r){this.type=e,this.scope=t,this.override=r,this.items=Object.create(null)}isForType(e){return Object.prototype.isPrototypeOf.call(this.type.prototype,e.prototype)}register(e){const t=Object.getPrototypeOf(e);let r;wot(t)&&(r=this.register(t));const i=this.items,s=e.id,o=this.scope+"."+s;if(!s)throw new Error("class does not have id: "+e);return s in i||(i[s]=e,bot(e,o,r),this.override&&as.override(e.id,e.overrides)),o}get(e){return this.items[e]}unregister(e){const t=this.items,r=e.id,i=this.scope;r in t&&delete t[r],i&&r in as[i]&&(delete as[i][r],this.override&&delete mg[r])}}function bot(n,e,t){const r=K_(Object.create(null),[t?as.get(t):{},as.get(e),n.defaults]);as.set(e,r),n.defaultRoutes&&vot(e,n.defaultRoutes),n.descriptors&&as.describe(e,n.descriptors)}function vot(n,e){Object.keys(e).forEach(t=>{const r=t.split("."),i=r.pop(),s=[n].concat(r).join("."),o=e[t].split("."),a=o.pop(),l=o.join(".");as.route(s,i,l,a)})}function wot(n){return"id"in n&&"defaults"in n}class xot{constructor(){this.controllers=new bT(xc,"datasets",!0),this.elements=new bT(Ac,"elements"),this.plugins=new bT(Object,"plugins"),this.scales=new bT(Ky,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...e){this._each("register",e)}remove(...e){this._each("unregister",e)}addControllers(...e){this._each("register",e,this.controllers)}addElements(...e){this._each("register",e,this.elements)}addPlugins(...e){this._each("register",e,this.plugins)}addScales(...e){this._each("register",e,this.scales)}getController(e){return this._get(e,this.controllers,"controller")}getElement(e){return this._get(e,this.elements,"element")}getPlugin(e){return this._get(e,this.plugins,"plugin")}getScale(e){return this._get(e,this.scales,"scale")}removeControllers(...e){this._each("unregister",e,this.controllers)}removeElements(...e){this._each("unregister",e,this.elements)}removePlugins(...e){this._each("unregister",e,this.plugins)}removeScales(...e){this._each("unregister",e,this.scales)}_each(e,t,r){[...t].forEach(i=>{const s=r||this._getRegistryForType(i);r||s.isForType(i)||s===this.plugins&&i.id?this._exec(e,s,i):Dr(i,o=>{const a=r||this._getRegistryForType(o);this._exec(e,a,o)})})}_exec(e,t,r){const i=w4(e);si(r["before"+i],[],r),t[e](r),si(r["after"+i],[],r)}_getRegistryForType(e){for(let t=0;t<this._typedRegistries.length;t++){const r=this._typedRegistries[t];if(r.isForType(e))return r}return this.plugins}_get(e,t,r){const i=t.get(e);if(i===void 0)throw new Error('"'+e+'" is not a registered '+r+".");return i}}var sh=new xot;class _ot{constructor(){this._init=[]}notify(e,t,r,i){t==="beforeInit"&&(this._init=this._createDescriptors(e,!0),this._notify(this._init,e,"install"));const s=i?this._descriptors(e).filter(i):this._descriptors(e),o=this._notify(s,e,t,r);return t==="afterDestroy"&&(this._notify(s,e,"stop"),this._notify(this._init,e,"uninstall")),o}_notify(e,t,r,i){i=i||{};for(const s of e){const o=s.plugin,a=o[r],l=[t,i,s.options];if(si(a,l,o)===!1&&i.cancelable)return!1}return!0}invalidate(){Nr(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(e){if(this._cache)return this._cache;const t=this._cache=this._createDescriptors(e);return this._notifyStateChanges(e),t}_createDescriptors(e,t){const r=e&&e.config,i=Wn(r.options&&r.options.plugins,{}),s=Sot(r);return i===!1&&!t?[]:kot(e,s,i,t)}_notifyStateChanges(e){const t=this._oldCache||[],r=this._cache,i=(s,o)=>s.filter(a=>!o.some(l=>a.plugin.id===l.plugin.id));this._notify(i(t,r),e,"stop"),this._notify(i(r,t),e,"start")}}function Sot(n){const e={},t=[],r=Object.keys(sh.plugins.items);for(let s=0;s<r.length;s++)t.push(sh.getPlugin(r[s]));const i=n.plugins||[];for(let s=0;s<i.length;s++){const o=i[s];t.indexOf(o)===-1&&(t.push(o),e[o.id]=!0)}return{plugins:t,localIds:e}}function Cot(n,e){return!e&&n===!1?null:n===!0?{}:n}function kot(n,{plugins:e,localIds:t},r,i){const s=[],o=n.getContext();for(const a of e){const l=a.id,c=Cot(r[l],i);c!==null&&s.push({plugin:a,options:Tot(n.config,{plugin:a,local:t[l]},c,o)})}return s}function Tot(n,{plugin:e,local:t},r,i){const s=n.pluginScopeKeys(e),o=n.getOptionScopes(r,s);return t&&e.defaults&&o.push(e.defaults),n.createResolver(o,i,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function JO(n,e){const t=as.datasets[n]||{};return((e.datasets||{})[n]||{}).indexAxis||e.indexAxis||t.indexAxis||"x"}function Eot(n,e){let t=n;return n==="_index_"?t=e:n==="_value_"&&(t=e==="x"?"y":"x"),t}function Iot(n,e){return n===e?"_index_":"_value_"}function Aot(n){if(n==="top"||n==="bottom")return"x";if(n==="left"||n==="right")return"y"}function uA(n,e){if(n==="x"||n==="y"||n==="r"||(n=e.axis||Aot(e.position)||n.length>1&&uA(n[0].toLowerCase(),e),n))return n;throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`)}function Mot(n,e){const t=mg[n.type]||{scales:{}},r=e.scales||{},i=JO(n.type,e),s=Object.create(null);return Object.keys(r).forEach(o=>{const a=r[o];if(!rr(a))return console.error(`Invalid scale configuration for scale: ${o}`);if(a._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${o}`);const l=uA(o,a),c=Iot(l,i),u=t.scales||{};s[o]=Z1(Object.create(null),[{axis:l},a,u[l],u[c]])}),n.data.datasets.forEach(o=>{const a=o.type||n.type,l=o.indexAxis||JO(a,e),u=(mg[a]||{}).scales||{};Object.keys(u).forEach(h=>{const f=Eot(h,l),d=o[f+"AxisID"]||f;s[d]=s[d]||Object.create(null),Z1(s[d],[{axis:f},r[d],u[h]])})}),Object.keys(s).forEach(o=>{const a=s[o];Z1(a,[as.scales[a.type],as.scale])}),s}function Iie(n){const e=n.options||(n.options={});e.plugins=Wn(e.plugins,{}),e.scales=Mot(n,e)}function Aie(n){return n=n||{},n.datasets=n.datasets||[],n.labels=n.labels||[],n}function Not(n){return n=n||{},n.data=Aie(n.data),Iie(n),n}const l5=new Map,Mie=new Set;function vT(n,e){let t=l5.get(n);return t||(t=e(),l5.set(n,t),Mie.add(t)),t}const Xx=(n,e,t)=>{const r=up(e,t);r!==void 0&&n.add(r)};class $ot{constructor(e){this._config=Not(e),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(e){this._config.type=e}get data(){return this._config.data}set data(e){this._config.data=Aie(e)}get options(){return this._config.options}set options(e){this._config.options=e}get plugins(){return this._config.plugins}update(){const e=this._config;this.clearCache(),Iie(e)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(e){return vT(e,()=>[[`datasets.${e}`,""]])}datasetAnimationScopeKeys(e,t){return vT(`${e}.transition.${t}`,()=>[[`datasets.${e}.transitions.${t}`,`transitions.${t}`],[`datasets.${e}`,""]])}datasetElementScopeKeys(e,t){return vT(`${e}-${t}`,()=>[[`datasets.${e}.elements.${t}`,`datasets.${e}`,`elements.${t}`,""]])}pluginScopeKeys(e){const t=e.id,r=this.type;return vT(`${r}-plugin-${t}`,()=>[[`plugins.${t}`,...e.additionalOptionScopes||[]]])}_cachedScopes(e,t){const r=this._scopeCache;let i=r.get(e);return(!i||t)&&(i=new Map,r.set(e,i)),i}getOptionScopes(e,t,r){const{options:i,type:s}=this,o=this._cachedScopes(e,r),a=o.get(t);if(a)return a;const l=new Set;t.forEach(u=>{e&&(l.add(e),u.forEach(h=>Xx(l,e,h))),u.forEach(h=>Xx(l,i,h)),u.forEach(h=>Xx(l,mg[s]||{},h)),u.forEach(h=>Xx(l,as,h)),u.forEach(h=>Xx(l,KO,h))});const c=Array.from(l);return c.length===0&&c.push(Object.create(null)),Mie.has(t)&&o.set(t,c),c}chartOptionScopes(){const{options:e,type:t}=this;return[e,mg[t]||{},as.datasets[t]||{},{type:t},as,KO]}resolveNamedOptions(e,t,r,i=[""]){const s={$shared:!0},{resolver:o,subPrefixes:a}=c5(this._resolverCache,e,i);let l=o;if(Pot(o,t)){s.$shared=!1,r=hp(r)?r():r;const c=this.createResolver(e,r,a);l=av(o,r,c)}for(const c of t)s[c]=l[c];return s}createResolver(e,t,r=[""],i){const{resolver:s}=c5(this._resolverCache,e,r);return rr(t)?av(s,t,void 0,i):s}}function c5(n,e,t){let r=n.get(e);r||(r=new Map,n.set(e,r));const i=t.join();let s=r.get(i);return s||(s={resolver:k4(e,t),subPrefixes:t.filter(a=>!a.toLowerCase().includes("hover"))},r.set(i,s)),s}const Rot=n=>rr(n)&&Object.getOwnPropertyNames(n).reduce((e,t)=>e||hp(n[t]),!1);function Pot(n,e){const{isScriptable:t,isIndexable:r}=aie(n);for(const i of e){const s=t(i),o=r(i),a=(o||s)&&n[i];if(s&&(hp(a)||Rot(a))||o&&mi(a))return!0}return!1}var Dot="4.2.1";const Oot=["top","bottom","left","right","chartArea"];function u5(n,e){return n==="top"||n==="bottom"||Oot.indexOf(n)===-1&&e==="x"}function h5(n,e){return function(t,r){return t[n]===r[n]?t[e]-r[e]:t[n]-r[n]}}function f5(n){const e=n.chart,t=e.options.animation;e.notifyPlugins("afterRender"),si(t&&t.onComplete,[n],e)}function Fot(n){const e=n.chart,t=e.options.animation;si(t&&t.onProgress,[n],e)}function Nie(n){return die()&&typeof n=="string"?n=document.getElementById(n):n&&n.length&&(n=n[0]),n&&n.canvas&&(n=n.canvas),n}const qE={},d5=n=>{const e=Nie(n);return Object.values(qE).filter(t=>t.canvas===e).pop()};function Lot(n,e,t){const r=Object.keys(n);for(const i of r){const s=+i;if(s>=e){const o=n[i];delete n[i],(t>0||s>e)&&(n[s+t]=o)}}}function zot(n,e,t,r){return!t||n.type==="mouseout"?null:r?e:n}function Bot(n){const{xScale:e,yScale:t}=n;if(e&&t)return{left:e.left,right:e.right,top:t.top,bottom:t.bottom}}class cu{static register(...e){sh.add(...e),p5()}static unregister(...e){sh.remove(...e),p5()}constructor(e,t){const r=this.config=new $ot(t),i=Nie(e),s=d5(i);if(s)throw new Error("Canvas is already in use. Chart with ID '"+s.id+"' must be destroyed before the canvas with ID '"+s.canvas.id+"' can be reused.");const o=r.createResolver(r.chartOptionScopes(),this.getContext());this.platform=new(r.platform||iot(i)),this.platform.updateConfig(r);const a=this.platform.acquireContext(i,o.aspectRatio),l=a&&a.canvas,c=l&&l.height,u=l&&l.width;if(this.id=Grt(),this.ctx=a,this.canvas=l,this.width=u,this.height=c,this._options=o,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new _ot,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=ait(h=>this.update(h),o.resizeDelay||0),this._dataChanges=[],qE[this.id]=this,!a||!l){console.error("Failed to create chart: can't acquire context from the given item");return}ff.listen(this,"complete",f5),ff.listen(this,"progress",Fot),this._initialize(),this.attached&&this.update()}get aspectRatio(){const{options:{aspectRatio:e,maintainAspectRatio:t},width:r,height:i,_aspectRatio:s}=this;return Nr(e)?t&&s?s:i?r/i:null:e}get data(){return this.config.data}set data(e){this.config.data=e}get options(){return this._options}set options(e){this.config.options=e}get registry(){return sh}_initialize(){return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():F6(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}clear(){return P6(this.canvas,this.ctx),this}stop(){return ff.stop(this),this}resize(e,t){ff.running(this)?this._resizeBeforeDraw={width:e,height:t}:this._resize(e,t)}_resize(e,t){const r=this.options,i=this.canvas,s=r.maintainAspectRatio&&this.aspectRatio,o=this.platform.getMaximumSize(i,e,t,s),a=r.devicePixelRatio||this.platform.getDevicePixelRatio(),l=this.width?"resize":"attach";this.width=o.width,this.height=o.height,this._aspectRatio=this.aspectRatio,F6(this,a,!0)&&(this.notifyPlugins("resize",{size:o}),si(r.onResize,[this,o],this),this.attached&&this._doResize(l)&&this.render())}ensureScalesHaveIDs(){const t=this.options.scales||{};Dr(t,(r,i)=>{r.id=i})}buildOrUpdateScales(){const e=this.options,t=e.scales,r=this.scales,i=Object.keys(r).reduce((o,a)=>(o[a]=!1,o),{});let s=[];t&&(s=s.concat(Object.keys(t).map(o=>{const a=t[o],l=uA(o,a),c=l==="r",u=l==="x";return{options:a,dposition:c?"chartArea":u?"bottom":"left",dtype:c?"radialLinear":u?"category":"linear"}}))),Dr(s,o=>{const a=o.options,l=a.id,c=uA(l,a),u=Wn(a.type,o.dtype);(a.position===void 0||u5(a.position,c)!==u5(o.dposition))&&(a.position=o.dposition),i[l]=!0;let h=null;if(l in r&&r[l].type===u)h=r[l];else{const f=sh.getScale(u);h=new f({id:l,type:u,ctx:this.ctx,chart:this}),r[h.id]=h}h.init(a,e)}),Dr(i,(o,a)=>{o||delete r[a]}),Dr(r,o=>{gc.configure(this,o,o.options),gc.addBox(this,o)})}_updateMetasets(){const e=this._metasets,t=this.data.datasets.length,r=e.length;if(e.sort((i,s)=>i.index-s.index),r>t){for(let i=t;i<r;++i)this._destroyDatasetMeta(i);e.splice(t,r-t)}this._sortedMetasets=e.slice(0).sort(h5("order","index"))}_removeUnreferencedMetasets(){const{_metasets:e,data:{datasets:t}}=this;e.length>t.length&&delete this._stacks,e.forEach((r,i)=>{t.filter(s=>s===r._dataset).length===0&&this._destroyDatasetMeta(i)})}buildOrUpdateControllers(){const e=[],t=this.data.datasets;let r,i;for(this._removeUnreferencedMetasets(),r=0,i=t.length;r<i;r++){const s=t[r];let o=this.getDatasetMeta(r);const a=s.type||this.config.type;if(o.type&&o.type!==a&&(this._destroyDatasetMeta(r),o=this.getDatasetMeta(r)),o.type=a,o.indexAxis=s.indexAxis||JO(a,this.options),o.order=s.order||0,o.index=r,o.label=""+s.label,o.visible=this.isDatasetVisible(r),o.controller)o.controller.updateIndex(r),o.controller.linkScales();else{const l=sh.getController(a),{datasetElementType:c,dataElementType:u}=as.datasets[a];Object.assign(l,{dataElementType:sh.getElement(u),datasetElementType:c&&sh.getElement(c)}),o.controller=new l(this,r),e.push(o.controller)}}return this._updateMetasets(),e}_resetElements(){Dr(this.data.datasets,(e,t)=>{this.getDatasetMeta(t).controller.reset()},this)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(e){const t=this.config;t.update();const r=this._options=t.createResolver(t.chartOptionScopes(),this.getContext()),i=this._animationsDisabled=!r.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),this.notifyPlugins("beforeUpdate",{mode:e,cancelable:!0})===!1)return;const s=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let o=0;for(let c=0,u=this.data.datasets.length;c<u;c++){const{controller:h}=this.getDatasetMeta(c),f=!i&&s.indexOf(h)===-1;h.buildOrUpdateElements(f),o=Math.max(+h.getMaxOverflow(),o)}o=this._minPadding=r.layout.autoPadding?o:0,this._updateLayout(o),i||Dr(s,c=>{c.reset()}),this._updateDatasets(e),this.notifyPlugins("afterUpdate",{mode:e}),this._layers.sort(h5("z","_idx"));const{_active:a,_lastEvent:l}=this;l?this._eventHandler(l,!0):a.length&&this._updateHoverStyles(a,a,!0),this.render()}_updateScales(){Dr(this.scales,e=>{gc.removeBox(this,e)}),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const e=this.options,t=new Set(Object.keys(this._listeners)),r=new Set(e.events);(!k6(t,r)||!!this._responsiveListeners!==e.responsive)&&(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:e}=this,t=this._getUniformDataChanges()||[];for(const{method:r,start:i,count:s}of t){const o=r==="_removeElements"?-s:s;Lot(e,i,o)}}_getUniformDataChanges(){const e=this._dataChanges;if(!e||!e.length)return;this._dataChanges=[];const t=this.data.datasets.length,r=s=>new Set(e.filter(o=>o[0]===s).map((o,a)=>a+","+o.splice(1).join(","))),i=r(0);for(let s=1;s<t;s++)if(!k6(i,r(s)))return;return Array.from(i).map(s=>s.split(",")).map(s=>({method:s[1],start:+s[2],count:+s[3]}))}_updateLayout(e){if(this.notifyPlugins("beforeLayout",{cancelable:!0})===!1)return;gc.update(this,this.width,this.height,e);const t=this.chartArea,r=t.width<=0||t.height<=0;this._layers=[],Dr(this.boxes,i=>{r&&i.position==="chartArea"||(i.configure&&i.configure(),this._layers.push(...i._layers()))},this),this._layers.forEach((i,s)=>{i._idx=s}),this.notifyPlugins("afterLayout")}_updateDatasets(e){if(this.notifyPlugins("beforeDatasetsUpdate",{mode:e,cancelable:!0})!==!1){for(let t=0,r=this.data.datasets.length;t<r;++t)this.getDatasetMeta(t).controller.configure();for(let t=0,r=this.data.datasets.length;t<r;++t)this._updateDataset(t,hp(e)?e({datasetIndex:t}):e);this.notifyPlugins("afterDatasetsUpdate",{mode:e})}}_updateDataset(e,t){const r=this.getDatasetMeta(e),i={meta:r,index:e,mode:t,cancelable:!0};this.notifyPlugins("beforeDatasetUpdate",i)!==!1&&(r.controller._update(t),i.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",i))}render(){this.notifyPlugins("beforeRender",{cancelable:!0})!==!1&&(ff.has(this)?this.attached&&!ff.running(this)&&ff.start(this):(this.draw(),f5({chart:this})))}draw(){let e;if(this._resizeBeforeDraw){const{width:r,height:i}=this._resizeBeforeDraw;this._resize(r,i),this._resizeBeforeDraw=null}if(this.clear(),this.width<=0||this.height<=0||this.notifyPlugins("beforeDraw",{cancelable:!0})===!1)return;const t=this._layers;for(e=0;e<t.length&&t[e].z<=0;++e)t[e].draw(this.chartArea);for(this._drawDatasets();e<t.length;++e)t[e].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(e){const t=this._sortedMetasets,r=[];let i,s;for(i=0,s=t.length;i<s;++i){const o=t[i];(!e||o.visible)&&r.push(o)}return r}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0})===!1)return;const e=this.getSortedVisibleDatasetMetas();for(let t=e.length-1;t>=0;--t)this._drawDataset(e[t]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(e){const t=this.ctx,r=e._clip,i=!r.disabled,s=Bot(e)||this.chartArea,o={meta:e,index:e.index,cancelable:!0};this.notifyPlugins("beforeDatasetDraw",o)!==!1&&(i&&g$(t,{left:r.left===!1?0:s.left-r.left,right:r.right===!1?this.width:s.right+r.right,top:r.top===!1?0:s.top-r.top,bottom:r.bottom===!1?this.height:s.bottom+r.bottom}),e.controller.draw(),i&&y$(t),o.cancelable=!1,this.notifyPlugins("afterDatasetDraw",o))}isPointInArea(e){return Z_(e,this.chartArea,this._minPadding)}getElementsAtEventForMode(e,t,r,i){const s=Fst.modes[t];return typeof s=="function"?s(this,e,r,i):[]}getDatasetMeta(e){const t=this.data.datasets[e],r=this._metasets;let i=r.filter(s=>s&&s._dataset===t).pop();return i||(i={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:t&&t.order||0,index:e,_dataset:t,_parsed:[],_sorted:!1},r.push(i)),i}getContext(){return this.$context||(this.$context=Pp(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(e){const t=this.data.datasets[e];if(!t)return!1;const r=this.getDatasetMeta(e);return typeof r.hidden=="boolean"?!r.hidden:!t.hidden}setDatasetVisibility(e,t){const r=this.getDatasetMeta(e);r.hidden=!t}toggleDataVisibility(e){this._hiddenIndices[e]=!this._hiddenIndices[e]}getDataVisibility(e){return!this._hiddenIndices[e]}_updateVisibility(e,t,r){const i=r?"show":"hide",s=this.getDatasetMeta(e),o=s.controller._resolveAnimations(void 0,i);Ic(t)?(s.data[t].hidden=!r,this.update()):(this.setDatasetVisibility(e,r),o.update(s,{visible:r}),this.update(a=>a.datasetIndex===e?i:void 0))}hide(e,t){this._updateVisibility(e,t,!1)}show(e,t){this._updateVisibility(e,t,!0)}_destroyDatasetMeta(e){const t=this._metasets[e];t&&t.controller&&t.controller._destroy(),delete this._metasets[e]}_stop(){let e,t;for(this.stop(),ff.remove(this),e=0,t=this.data.datasets.length;e<t;++e)this._destroyDatasetMeta(e)}destroy(){this.notifyPlugins("beforeDestroy");const{canvas:e,ctx:t}=this;this._stop(),this.config.clearCache(),e&&(this.unbindEvents(),P6(e,t),this.platform.releaseContext(t),this.canvas=null,this.ctx=null),delete qE[this.id],this.notifyPlugins("afterDestroy")}toBase64Image(...e){return this.canvas.toDataURL(...e)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const e=this._listeners,t=this.platform,r=(s,o)=>{t.addEventListener(this,s,o),e[s]=o},i=(s,o,a)=>{s.offsetX=o,s.offsetY=a,this._eventHandler(s)};Dr(this.options.events,s=>r(s,i))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const e=this._responsiveListeners,t=this.platform,r=(l,c)=>{t.addEventListener(this,l,c),e[l]=c},i=(l,c)=>{e[l]&&(t.removeEventListener(this,l,c),delete e[l])},s=(l,c)=>{this.canvas&&this.resize(l,c)};let o;const a=()=>{i("attach",a),this.attached=!0,this.resize(),r("resize",s),r("detach",o)};o=()=>{this.attached=!1,i("resize",s),this._stop(),this._resize(0,0),r("attach",a)},t.isAttached(this.canvas)?a():o()}unbindEvents(){Dr(this._listeners,(e,t)=>{this.platform.removeEventListener(this,t,e)}),this._listeners={},Dr(this._responsiveListeners,(e,t)=>{this.platform.removeEventListener(this,t,e)}),this._responsiveListeners=void 0}updateHoverStyle(e,t,r){const i=r?"set":"remove";let s,o,a,l;for(t==="dataset"&&(s=this.getDatasetMeta(e[0].datasetIndex),s.controller["_"+i+"DatasetHoverStyle"]()),a=0,l=e.length;a<l;++a){o=e[a];const c=o&&this.getDatasetMeta(o.datasetIndex).controller;c&&c[i+"HoverStyle"](o.element,o.datasetIndex,o.index)}}getActiveElements(){return this._active||[]}setActiveElements(e){const t=this._active||[],r=e.map(({datasetIndex:s,index:o})=>{const a=this.getDatasetMeta(s);if(!a)throw new Error("No dataset found at index "+s);return{datasetIndex:s,element:a.data[o],index:o}});!iA(r,t)&&(this._active=r,this._lastEvent=null,this._updateHoverStyles(r,t))}notifyPlugins(e,t,r){return this._plugins.notify(this,e,t,r)}isPluginEnabled(e){return this._plugins._cache.filter(t=>t.plugin.id===e).length===1}_updateHoverStyles(e,t,r){const i=this.options.hover,s=(l,c)=>l.filter(u=>!c.some(h=>u.datasetIndex===h.datasetIndex&&u.index===h.index)),o=s(t,e),a=r?e:s(e,t);o.length&&this.updateHoverStyle(o,i.mode,!1),a.length&&i.mode&&this.updateHoverStyle(a,i.mode,!0)}_eventHandler(e,t){const r={event:e,replay:t,cancelable:!0,inChartArea:this.isPointInArea(e)},i=o=>(o.options.events||this.options.events).includes(e.native.type);if(this.notifyPlugins("beforeEvent",r,i)===!1)return;const s=this._handleEvent(e,t,r.inChartArea);return r.cancelable=!1,this.notifyPlugins("afterEvent",r,i),(s||r.changed)&&this.render(),this}_handleEvent(e,t,r){const{_active:i=[],options:s}=this,o=t,a=this._getActiveElements(e,i,r,o),l=Zrt(e),c=zot(e,this._lastEvent,r,l);r&&(this._lastEvent=null,si(s.onHover,[e,a,this],this),l&&si(s.onClick,[e,a,this],this));const u=!iA(a,i);return(u||t)&&(this._active=a,this._updateHoverStyles(a,i,t)),this._lastEvent=c,u}_getActiveElements(e,t,r,i){if(e.type==="mouseout")return[];if(!r)return t;const s=this.options.hover;return this.getElementsAtEventForMode(e,s.mode,s,i)}}Nt(cu,"defaults",as),Nt(cu,"instances",qE),Nt(cu,"overrides",mg),Nt(cu,"registry",sh),Nt(cu,"version",Dot),Nt(cu,"getChart",d5);function p5(){return Dr(cu.instances,n=>n._plugins.invalidate())}function Vot(n,e,t){const{startAngle:r,pixelMargin:i,x:s,y:o,outerRadius:a,innerRadius:l}=e;let c=i/a;n.beginPath(),n.arc(s,o,a,r-c,t+c),l>i?(c=i/l,n.arc(s,o,l,t+c,r-c,!0)):n.arc(s,o,i,t+Zi,r-Zi),n.closePath(),n.clip()}function Uot(n){return C4(n,["outerStart","outerEnd","innerStart","innerEnd"])}function Wot(n,e,t,r){const i=Uot(n.options.borderRadius),s=(t-e)/2,o=Math.min(s,r*e/2),a=l=>{const c=(t-Math.min(s,l))*r/2;return Yo(l,0,Math.min(s,c))};return{outerStart:a(i.outerStart),outerEnd:a(i.outerEnd),innerStart:Yo(i.innerStart,0,o),innerEnd:Yo(i.innerEnd,0,o)}}function O0(n,e,t,r){return{x:t+n*Math.cos(e),y:r+n*Math.sin(e)}}function hA(n,e,t,r,i,s){const{x:o,y:a,startAngle:l,pixelMargin:c,innerRadius:u}=e,h=Math.max(e.outerRadius+r+t-c,0),f=u>0?u+r+t+c:0;let d=0;const p=i-l;if(r){const z=u>0?u-r:0,B=h>0?h-r:0,X=(z+B)/2,H=X!==0?p*X/(X+r):p;d=(p-H)/2}const m=Math.max(.001,p*h-t/Ti)/h,g=(p-m)/2,y=l+g+d,b=i-g-d,{outerStart:_,outerEnd:w,innerStart:S,innerEnd:C}=Wot(e,f,h,b-y),k=h-_,A=h-w,M=y+_/k,E=b-w/A,N=f+S,O=f+C,R=y+S/N,D=b-C/O;if(n.beginPath(),s){const z=(M+E)/2;if(n.arc(o,a,h,M,z),n.arc(o,a,h,z,E),w>0){const te=O0(A,E,o,a);n.arc(te.x,te.y,w,E,b+Zi)}const B=O0(O,b,o,a);if(n.lineTo(B.x,B.y),C>0){const te=O0(O,D,o,a);n.arc(te.x,te.y,C,b+Zi,D+Math.PI)}const X=(b-C/f+(y+S/f))/2;if(n.arc(o,a,f,b-C/f,X,!0),n.arc(o,a,f,X,y+S/f,!0),S>0){const te=O0(N,R,o,a);n.arc(te.x,te.y,S,R+Math.PI,y-Zi)}const H=O0(k,y,o,a);if(n.lineTo(H.x,H.y),_>0){const te=O0(k,M,o,a);n.arc(te.x,te.y,_,y-Zi,M)}}else{n.moveTo(o,a);const z=Math.cos(M)*h+o,B=Math.sin(M)*h+a;n.lineTo(z,B);const X=Math.cos(E)*h+o,H=Math.sin(E)*h+a;n.lineTo(X,H)}n.closePath()}function Hot(n,e,t,r,i){const{fullCircles:s,startAngle:o,circumference:a}=e;let l=e.endAngle;if(s){hA(n,e,t,r,l,i);for(let c=0;c<s;++c)n.fill();isNaN(a)||(l=o+(a%yi||yi))}return hA(n,e,t,r,l,i),n.fill(),l}function Got(n,e,t,r,i){const{fullCircles:s,startAngle:o,circumference:a,options:l}=e,{borderWidth:c,borderJoinStyle:u}=l,h=l.borderAlign==="inner";if(!c)return;h?(n.lineWidth=c*2,n.lineJoin=u||"round"):(n.lineWidth=c,n.lineJoin=u||"bevel");let f=e.endAngle;if(s){hA(n,e,t,r,f,i);for(let d=0;d<s;++d)n.stroke();isNaN(a)||(f=o+(a%yi||yi))}h&&Vot(n,e,f),s||(hA(n,e,t,r,f,i),n.stroke())}class XE extends Ac{constructor(e){super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,e&&Object.assign(this,e)}inRange(e,t,r){const i=this.getProps(["x","y"],r),{angle:s,distance:o}=Yre(i,{x:e,y:t}),{startAngle:a,endAngle:l,innerRadius:c,outerRadius:u,circumference:h}=this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],r),f=this.options.spacing/2,p=Wn(h,l-a)>=yi||Y_(s,a,l),m=Tf(o,c+f,u+f);return p&&m}getCenterPoint(e){const{x:t,y:r,startAngle:i,endAngle:s,innerRadius:o,outerRadius:a}=this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius"],e),{offset:l,spacing:c}=this.options,u=(i+s)/2,h=(o+a+c+l)/2;return{x:t+Math.cos(u)*h,y:r+Math.sin(u)*h}}tooltipPosition(e){return this.getCenterPoint(e)}draw(e){const{options:t,circumference:r}=this,i=(t.offset||0)/4,s=(t.spacing||0)/2,o=t.circular;if(this.pixelMargin=t.borderAlign==="inner"?.33:0,this.fullCircles=r>yi?Math.floor(r/yi):0,r===0||this.innerRadius<0||this.outerRadius<0)return;e.save();const a=(this.startAngle+this.endAngle)/2;e.translate(Math.cos(a)*i,Math.sin(a)*i);const l=1-Math.sin(Math.min(Ti,r||0)),c=i*l;e.fillStyle=t.backgroundColor,e.strokeStyle=t.borderColor,Hot(e,this,c,s,o),Got(e,this,c,s,o),e.restore()}}Nt(XE,"id","arc"),Nt(XE,"defaults",{borderAlign:"center",borderColor:"#fff",borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0}),Nt(XE,"defaultRoutes",{backgroundColor:"backgroundColor"});function $ie(n,e,t=e){n.lineCap=Wn(t.borderCapStyle,e.borderCapStyle),n.setLineDash(Wn(t.borderDash,e.borderDash)),n.lineDashOffset=Wn(t.borderDashOffset,e.borderDashOffset),n.lineJoin=Wn(t.borderJoinStyle,e.borderJoinStyle),n.lineWidth=Wn(t.borderWidth,e.borderWidth),n.strokeStyle=Wn(t.borderColor,e.borderColor)}function jot(n,e,t){n.lineTo(t.x,t.y)}function qot(n){return n.stepped?vit:n.tension||n.cubicInterpolationMode==="monotone"?wit:jot}function Rie(n,e,t={}){const r=n.length,{start:i=0,end:s=r-1}=t,{start:o,end:a}=e,l=Math.max(i,o),c=Math.min(s,a),u=i<o&&s<o||i>a&&s>a;return{count:r,start:l,loop:e.loop,ilen:c<l&&!u?r+c-l:c-l}}function Xot(n,e,t,r){const{points:i,options:s}=e,{count:o,start:a,loop:l,ilen:c}=Rie(i,t,r),u=qot(s);let{move:h=!0,reverse:f}=r||{},d,p,m;for(d=0;d<=c;++d)p=i[(a+(f?c-d:d))%o],!p.skip&&(h?(n.moveTo(p.x,p.y),h=!1):u(n,m,p,f,s.stepped),m=p);return l&&(p=i[(a+(f?c:0))%o],u(n,m,p,f,s.stepped)),!!l}function Kot(n,e,t,r){const i=e.points,{count:s,start:o,ilen:a}=Rie(i,t,r),{move:l=!0,reverse:c}=r||{};let u=0,h=0,f,d,p,m,g,y;const b=w=>(o+(c?a-w:w))%s,_=()=>{m!==g&&(n.lineTo(u,g),n.lineTo(u,m),n.lineTo(u,y))};for(l&&(d=i[b(0)],n.moveTo(d.x,d.y)),f=0;f<=a;++f){if(d=i[b(f)],d.skip)continue;const w=d.x,S=d.y,C=w|0;C===p?(S<m?m=S:S>g&&(g=S),u=(h*u+w)/++h):(_(),n.lineTo(w,S),p=C,h=0,m=g=S),y=S}_()}function QO(n){const e=n.options,t=e.borderDash&&e.borderDash.length;return!n._decimated&&!n._loop&&!e.tension&&e.cubicInterpolationMode!=="monotone"&&!e.stepped&&!t?Kot:Xot}function Yot(n){return n.stepped?Jit:n.tension||n.cubicInterpolationMode==="monotone"?Qit:wm}function Zot(n,e,t,r){let i=e._path;i||(i=e._path=new Path2D,e.path(i,t,r)&&i.closePath()),$ie(n,e.options),n.stroke(i)}function Jot(n,e,t,r){const{segments:i,options:s}=e,o=QO(e);for(const a of i)$ie(n,s,a.style),n.beginPath(),o(n,e,a,{start:t,end:t+r-1})&&n.closePath(),n.stroke()}const Qot=typeof Path2D=="function";function eat(n,e,t,r){Qot&&!e.options.segment?Zot(n,e,t,r):Jot(n,e,t,r)}class Rd extends Ac{constructor(e){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,e&&Object.assign(this,e)}updateControlPoints(e,t){const r=this.options;if((r.tension||r.cubicInterpolationMode==="monotone")&&!r.stepped&&!this._pointsUpdated){const i=r.spanGaps?this._loop:this._fullLoop;Hit(this._points,r,e,i,t),this._pointsUpdated=!0}}set points(e){this._points=e,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=sst(this,this.options.segment))}first(){const e=this.segments,t=this.points;return e.length&&t[e[0].start]}last(){const e=this.segments,t=this.points,r=e.length;return r&&t[e[r-1].end]}interpolate(e,t){const r=this.options,i=e[t],s=this.points,o=bie(this,{property:t,start:i,end:i});if(!o.length)return;const a=[],l=Yot(r);let c,u;for(c=0,u=o.length;c<u;++c){const{start:h,end:f}=o[c],d=s[h],p=s[f];if(d===p){a.push(d);continue}const m=Math.abs((i-d[t])/(p[t]-d[t])),g=l(d,p,m,r.stepped);g[t]=e[t],a.push(g)}return a.length===1?a[0]:a}pathSegment(e,t,r){return QO(this)(e,this,t,r)}path(e,t,r){const i=this.segments,s=QO(this);let o=this._loop;t=t||0,r=r||this.points.length-t;for(const a of i)o&=s(e,this,a,{start:t,end:t+r-1});return!!o}draw(e,t,r,i){const s=this.options||{};(this.points||[]).length&&s.borderWidth&&(e.save(),eat(e,this,r,i),e.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}Nt(Rd,"id","line"),Nt(Rd,"defaults",{borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0}),Nt(Rd,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"}),Nt(Rd,"descriptors",{_scriptable:!0,_indexable:e=>e!=="borderDash"&&e!=="fill"});function m5(n,e,t,r){const i=n.options,{[t]:s}=n.getProps([t],r);return Math.abs(e-s)<i.radius+i.hitRadius}class KE extends Ac{constructor(e){super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,e&&Object.assign(this,e)}inRange(e,t,r){const i=this.options,{x:s,y:o}=this.getProps(["x","y"],r);return Math.pow(e-s,2)+Math.pow(t-o,2)<Math.pow(i.hitRadius+i.radius,2)}inXRange(e,t){return m5(this,e,"x",t)}inYRange(e,t){return m5(this,e,"y",t)}getCenterPoint(e){const{x:t,y:r}=this.getProps(["x","y"],e);return{x:t,y:r}}size(e){e=e||this.options||{};let t=e.radius||0;t=Math.max(t,t&&e.hoverRadius||0);const r=t&&e.borderWidth||0;return(t+r)*2}draw(e,t){const r=this.options;this.skip||r.radius<.1||!Z_(this,t,this.size(r)/2)||(e.strokeStyle=r.borderColor,e.lineWidth=r.borderWidth,e.fillStyle=r.backgroundColor,YO(e,r,this.x,this.y))}getRange(){const e=this.options||{};return e.radius+e.hitRadius}}Nt(KE,"id","point"),Nt(KE,"defaults",{borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0}),Nt(KE,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"});function Pie(n,e){const{x:t,y:r,base:i,width:s,height:o}=n.getProps(["x","y","base","width","height"],e);let a,l,c,u,h;return n.horizontal?(h=o/2,a=Math.min(t,i),l=Math.max(t,i),c=r-h,u=r+h):(h=s/2,a=t-h,l=t+h,c=Math.min(r,i),u=Math.max(r,i)),{left:a,top:c,right:l,bottom:u}}function Pd(n,e,t,r){return n?0:Yo(e,t,r)}function tat(n,e,t){const r=n.options.borderWidth,i=n.borderSkipped,s=oie(r);return{t:Pd(i.top,s.top,0,t),r:Pd(i.right,s.right,0,e),b:Pd(i.bottom,s.bottom,0,t),l:Pd(i.left,s.left,0,e)}}function nat(n,e,t){const{enableBorderRadius:r}=n.getProps(["enableBorderRadius"]),i=n.options.borderRadius,s=Gd(i),o=Math.min(e,t),a=n.borderSkipped,l=r||rr(i);return{topLeft:Pd(!l||a.top||a.left,s.topLeft,0,o),topRight:Pd(!l||a.top||a.right,s.topRight,0,o),bottomLeft:Pd(!l||a.bottom||a.left,s.bottomLeft,0,o),bottomRight:Pd(!l||a.bottom||a.right,s.bottomRight,0,o)}}function rat(n){const e=Pie(n),t=e.right-e.left,r=e.bottom-e.top,i=tat(n,t/2,r/2),s=nat(n,t/2,r/2);return{outer:{x:e.left,y:e.top,w:t,h:r,radius:s},inner:{x:e.left+i.l,y:e.top+i.t,w:t-i.l-i.r,h:r-i.t-i.b,radius:{topLeft:Math.max(0,s.topLeft-Math.max(i.t,i.l)),topRight:Math.max(0,s.topRight-Math.max(i.t,i.r)),bottomLeft:Math.max(0,s.bottomLeft-Math.max(i.b,i.l)),bottomRight:Math.max(0,s.bottomRight-Math.max(i.b,i.r))}}}}function O3(n,e,t,r){const i=e===null,s=t===null,a=n&&!(i&&s)&&Pie(n,r);return a&&(i||Tf(e,a.left,a.right))&&(s||Tf(t,a.top,a.bottom))}function iat(n){return n.topLeft||n.topRight||n.bottomLeft||n.bottomRight}function sat(n,e){n.rect(e.x,e.y,e.w,e.h)}function F3(n,e,t={}){const r=n.x!==t.x?-e:0,i=n.y!==t.y?-e:0,s=(n.x+n.w!==t.x+t.w?e:0)-r,o=(n.y+n.h!==t.y+t.h?e:0)-i;return{x:n.x+r,y:n.y+i,w:n.w+s,h:n.h+o,radius:n.radius}}class YE extends Ac{constructor(e){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,e&&Object.assign(this,e)}draw(e){const{inflateAmount:t,options:{borderColor:r,backgroundColor:i}}=this,{inner:s,outer:o}=rat(this),a=iat(o.radius)?Hd:sat;e.save(),(o.w!==s.w||o.h!==s.h)&&(e.beginPath(),a(e,F3(o,t,s)),e.clip(),a(e,F3(s,-t,o)),e.fillStyle=r,e.fill("evenodd")),e.beginPath(),a(e,F3(s,t)),e.fillStyle=i,e.fill(),e.restore()}inRange(e,t,r){return O3(this,e,t,r)}inXRange(e,t){return O3(this,e,null,t)}inYRange(e,t){return O3(this,null,e,t)}getCenterPoint(e){const{x:t,y:r,base:i,horizontal:s}=this.getProps(["x","y","base","horizontal"],e);return{x:s?(t+i)/2:t,y:s?r:(r+i)/2}}getRange(e){return e==="x"?this.width/2:this.height/2}}Nt(YE,"id","bar"),Nt(YE,"defaults",{borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0}),Nt(YE,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"});function oat(n,e,t){const r=n.segments,i=n.points,s=e.points,o=[];for(const a of r){let{start:l,end:c}=a;c=M4(l,c,i);const u=eF(t,i[l],i[c],a.loop);if(!e.segments){o.push({source:a,target:u,start:i[l],end:i[c]});continue}const h=bie(e,u);for(const f of h){const d=eF(t,s[f.start],s[f.end],f.loop),p=yie(a,i,d);for(const m of p)o.push({source:m,target:f,start:{[t]:g5(u,d,"start",Math.max)},end:{[t]:g5(u,d,"end",Math.min)}})}}return o}function eF(n,e,t,r){if(r)return;let i=e[n],s=t[n];return n==="angle"&&(i=yl(i),s=yl(s)),{property:n,start:i,end:s}}function aat(n,e){const{x:t=null,y:r=null}=n||{},i=e.points,s=[];return e.segments.forEach(({start:o,end:a})=>{a=M4(o,a,i);const l=i[o],c=i[a];r!==null?(s.push({x:l.x,y:r}),s.push({x:c.x,y:r})):t!==null&&(s.push({x:t,y:l.y}),s.push({x:t,y:c.y}))}),s}function M4(n,e,t){for(;e>n;e--){const r=t[e];if(!isNaN(r.x)&&!isNaN(r.y))break}return e}function g5(n,e,t,r){return n&&e?r(n[t],e[t]):n?n[t]:e?e[t]:0}function Die(n,e){let t=[],r=!1;return mi(n)?(r=!0,t=n):t=aat(n,e),t.length?new Rd({points:t,options:{tension:0},_loop:r,_fullLoop:r}):null}function y5(n){return n&&n.fill!==!1}function lat(n,e,t){let i=n[e].fill;const s=[e];let o;if(!t)return i;for(;i!==!1&&s.indexOf(i)===-1;){if(!Yi(i))return i;if(o=n[i],!o)return!1;if(o.visible)return i;s.push(i),i=o.fill}return!1}function cat(n,e,t){const r=dat(n);if(rr(r))return isNaN(r.value)?!1:r;let i=parseFloat(r);return Yi(i)&&Math.floor(i)===i?uat(r[0],e,i,t):["origin","start","end","stack","shape"].indexOf(r)>=0&&r}function uat(n,e,t,r){return(n==="-"||n==="+")&&(t=e+t),t===e||t<0||t>=r?!1:t}function hat(n,e){let t=null;return n==="start"?t=e.bottom:n==="end"?t=e.top:rr(n)?t=e.getPixelForValue(n.value):e.getBasePixel&&(t=e.getBasePixel()),t}function fat(n,e,t){let r;return n==="start"?r=t:n==="end"?r=e.options.reverse?e.min:e.max:rr(n)?r=n.value:r=e.getBaseValue(),r}function dat(n){const e=n.options,t=e.fill;let r=Wn(t&&t.target,t);return r===void 0&&(r=!!e.backgroundColor),r===!1||r===null?!1:r===!0?"origin":r}function pat(n){const{scale:e,index:t,line:r}=n,i=[],s=r.segments,o=r.points,a=mat(e,t);a.push(Die({x:null,y:e.bottom},r));for(let l=0;l<s.length;l++){const c=s[l];for(let u=c.start;u<=c.end;u++)gat(i,o[u],a)}return new Rd({points:i,options:{}})}function mat(n,e){const t=[],r=n.getMatchingVisibleMetas("line");for(let i=0;i<r.length;i++){const s=r[i];if(s.index===e)break;s.hidden||t.unshift(s.dataset)}return t}function gat(n,e,t){const r=[];for(let i=0;i<t.length;i++){const s=t[i],{first:o,last:a,point:l}=yat(s,e,"x");if(!(!l||o&&a)){if(o)r.unshift(l);else if(n.push(l),!a)break}}n.push(...r)}function yat(n,e,t){const r=n.interpolate(e,t);if(!r)return{};const i=r[t],s=n.segments,o=n.points;let a=!1,l=!1;for(let c=0;c<s.length;c++){const u=s[c],h=o[u.start][t],f=o[u.end][t];if(Tf(i,h,f)){a=i===h,l=i===f;break}}return{first:a,last:l,point:r}}class Oie{constructor(e){this.x=e.x,this.y=e.y,this.radius=e.radius}pathSegment(e,t,r){const{x:i,y:s,radius:o}=this;return t=t||{start:0,end:yi},e.arc(i,s,o,t.end,t.start,!0),!r.bounds}interpolate(e){const{x:t,y:r,radius:i}=this,s=e.angle;return{x:t+Math.cos(s)*i,y:r+Math.sin(s)*i,angle:s}}}function bat(n){const{chart:e,fill:t,line:r}=n;if(Yi(t))return vat(e,t);if(t==="stack")return pat(n);if(t==="shape")return!0;const i=wat(n);return i instanceof Oie?i:Die(i,r)}function vat(n,e){const t=n.getDatasetMeta(e);return t&&n.isDatasetVisible(e)?t.dataset:null}function wat(n){return(n.scale||{}).getPointPositionForValue?_at(n):xat(n)}function xat(n){const{scale:e={},fill:t}=n,r=hat(t,e);if(Yi(r)){const i=e.isHorizontal();return{x:i?r:null,y:i?null:r}}return null}function _at(n){const{scale:e,fill:t}=n,r=e.options,i=e.getLabels().length,s=r.reverse?e.max:e.min,o=fat(t,e,s),a=[];if(r.grid.circular){const l=e.getPointPositionForValue(0,s);return new Oie({x:l.x,y:l.y,radius:e.getDistanceFromCenterForValue(o)})}for(let l=0;l<i;++l)a.push(e.getPointPositionForValue(l,o));return a}function L3(n,e,t){const r=bat(e),{line:i,scale:s,axis:o}=e,a=i.options,l=a.fill,c=a.backgroundColor,{above:u=c,below:h=c}=l||{};r&&i.points.length&&(g$(n,t),Sat(n,{line:i,target:r,above:u,below:h,area:t,scale:s,axis:o}),y$(n))}function Sat(n,e){const{line:t,target:r,above:i,below:s,area:o,scale:a}=e,l=t._loop?"angle":e.axis;n.save(),l==="x"&&s!==i&&(b5(n,r,o.top),v5(n,{line:t,target:r,color:i,scale:a,property:l}),n.restore(),n.save(),b5(n,r,o.bottom)),v5(n,{line:t,target:r,color:s,scale:a,property:l}),n.restore()}function b5(n,e,t){const{segments:r,points:i}=e;let s=!0,o=!1;n.beginPath();for(const a of r){const{start:l,end:c}=a,u=i[l],h=i[M4(l,c,i)];s?(n.moveTo(u.x,u.y),s=!1):(n.lineTo(u.x,t),n.lineTo(u.x,u.y)),o=!!e.pathSegment(n,a,{move:o}),o?n.closePath():n.lineTo(h.x,t)}n.lineTo(e.first().x,t),n.closePath(),n.clip()}function v5(n,e){const{line:t,target:r,property:i,color:s,scale:o}=e,a=oat(t,r,i);for(const{source:l,target:c,start:u,end:h}of a){const{style:{backgroundColor:f=s}={}}=l,d=r!==!0;n.save(),n.fillStyle=f,Cat(n,o,d&&eF(i,u,h)),n.beginPath();const p=!!t.pathSegment(n,l);let m;if(d){p?n.closePath():w5(n,r,h,i);const g=!!r.pathSegment(n,c,{move:p,reverse:!0});m=p&&g,m||w5(n,r,u,i)}n.closePath(),n.fill(m?"evenodd":"nonzero"),n.restore()}}function Cat(n,e,t){const{top:r,bottom:i}=e.chart.chartArea,{property:s,start:o,end:a}=t||{};s==="x"&&(n.beginPath(),n.rect(o,r,a-o,i-r),n.clip())}function w5(n,e,t,r){const i=e.interpolate(t,r);i&&n.lineTo(i.x,i.y)}var kat={id:"filler",afterDatasetsUpdate(n,e,t){const r=(n.data.datasets||[]).length,i=[];let s,o,a,l;for(o=0;o<r;++o)s=n.getDatasetMeta(o),a=s.dataset,l=null,a&&a.options&&a instanceof Rd&&(l={visible:n.isDatasetVisible(o),index:o,fill:cat(a,o,r),chart:n,axis:s.controller.options.indexAxis,scale:s.vScale,line:a}),s.$filler=l,i.push(l);for(o=0;o<r;++o)l=i[o],!(!l||l.fill===!1)&&(l.fill=lat(i,o,t.propagate))},beforeDraw(n,e,t){const r=t.drawTime==="beforeDraw",i=n.getSortedVisibleDatasetMetas(),s=n.chartArea;for(let o=i.length-1;o>=0;--o){const a=i[o].$filler;a&&(a.line.updateControlPoints(s,a.axis),r&&a.fill&&L3(n.ctx,a,s))}},beforeDatasetsDraw(n,e,t){if(t.drawTime!=="beforeDatasetsDraw")return;const r=n.getSortedVisibleDatasetMetas();for(let i=r.length-1;i>=0;--i){const s=r[i].$filler;y5(s)&&L3(n.ctx,s,n.chartArea)}},beforeDatasetDraw(n,e,t){const r=e.meta.$filler;!y5(r)||t.drawTime!=="beforeDatasetDraw"||L3(n.ctx,r,n.chartArea)},defaults:{propagate:!0,drawTime:"beforeDatasetDraw"}};const x5=(n,e)=>{let{boxHeight:t=e,boxWidth:r=e}=n;return n.usePointStyle&&(t=Math.min(t,e),r=n.pointStyleWidth||Math.min(r,e)),{boxWidth:r,boxHeight:t,itemHeight:Math.max(e,t)}},Tat=(n,e)=>n!==null&&e!==null&&n.datasetIndex===e.datasetIndex&&n.index===e.index;class _5 extends Ac{constructor(e){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=e.chart,this.options=e.options,this.ctx=e.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(e,t,r){this.maxWidth=e,this.maxHeight=t,this._margins=r,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const e=this.options.labels||{};let t=si(e.generateLabels,[this.chart],this)||[];e.filter&&(t=t.filter(r=>e.filter(r,this.chart.data))),e.sort&&(t=t.sort((r,i)=>e.sort(r,i,this.chart.data))),this.options.reverse&&t.reverse(),this.legendItems=t}fit(){const{options:e,ctx:t}=this;if(!e.display){this.width=this.height=0;return}const r=e.labels,i=Hs(r.font),s=i.size,o=this._computeTitleHeight(),{boxWidth:a,itemHeight:l}=x5(r,s);let c,u;t.font=i.string,this.isHorizontal()?(c=this.maxWidth,u=this._fitRows(o,s,a,l)+10):(u=this.maxHeight,c=this._fitCols(o,i,a,l)+10),this.width=Math.min(c,e.maxWidth||this.maxWidth),this.height=Math.min(u,e.maxHeight||this.maxHeight)}_fitRows(e,t,r,i){const{ctx:s,maxWidth:o,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.lineWidths=[0],u=i+a;let h=e;s.textAlign="left",s.textBaseline="middle";let f=-1,d=-u;return this.legendItems.forEach((p,m)=>{const g=r+t/2+s.measureText(p.text).width;(m===0||c[c.length-1]+g+2*a>o)&&(h+=u,c[c.length-(m>0?0:1)]=0,d+=u,f++),l[m]={left:0,top:d,row:f,width:g,height:i},c[c.length-1]+=g+a}),h}_fitCols(e,t,r,i){const{ctx:s,maxHeight:o,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.columnSizes=[],u=o-e;let h=a,f=0,d=0,p=0,m=0;return this.legendItems.forEach((g,y)=>{const{itemWidth:b,itemHeight:_}=Eat(r,t,s,g,i);y>0&&d+_+2*a>u&&(h+=f+a,c.push({width:f,height:d}),p+=f+a,m++,f=d=0),l[y]={left:p,top:d,col:m,width:b,height:_},f=Math.max(f,b),d+=_+a}),h+=f,c.push({width:f,height:d}),h}adjustHitBoxes(){if(!this.options.display)return;const e=this._computeTitleHeight(),{legendHitBoxes:t,options:{align:r,labels:{padding:i},rtl:s}}=this,o=Rb(s,this.left,this.width);if(this.isHorizontal()){let a=0,l=Bo(r,this.left+i,this.right-this.lineWidths[a]);for(const c of t)a!==c.row&&(a=c.row,l=Bo(r,this.left+i,this.right-this.lineWidths[a])),c.top+=this.top+e+i,c.left=o.leftForLtr(o.x(l),c.width),l+=c.width+i}else{let a=0,l=Bo(r,this.top+e+i,this.bottom-this.columnSizes[a].height);for(const c of t)c.col!==a&&(a=c.col,l=Bo(r,this.top+e+i,this.bottom-this.columnSizes[a].height)),c.top=l,c.left+=this.left+i,c.left=o.leftForLtr(o.x(c.left),c.width),l+=c.height+i}}isHorizontal(){return this.options.position==="top"||this.options.position==="bottom"}draw(){if(this.options.display){const e=this.ctx;g$(e,this),this._draw(),y$(e)}}_draw(){const{options:e,columnSizes:t,lineWidths:r,ctx:i}=this,{align:s,labels:o}=e,a=as.color,l=Rb(e.rtl,this.left,this.width),c=Hs(o.font),{padding:u}=o,h=c.size,f=h/2;let d;this.drawTitle(),i.textAlign=l.textAlign("left"),i.textBaseline="middle",i.lineWidth=.5,i.font=c.string;const{boxWidth:p,boxHeight:m,itemHeight:g}=x5(o,h),y=function(C,k,A){if(isNaN(p)||p<=0||isNaN(m)||m<0)return;i.save();const M=Wn(A.lineWidth,1);if(i.fillStyle=Wn(A.fillStyle,a),i.lineCap=Wn(A.lineCap,"butt"),i.lineDashOffset=Wn(A.lineDashOffset,0),i.lineJoin=Wn(A.lineJoin,"miter"),i.lineWidth=M,i.strokeStyle=Wn(A.strokeStyle,a),i.setLineDash(Wn(A.lineDash,[])),o.usePointStyle){const E={radius:m*Math.SQRT2/2,pointStyle:A.pointStyle,rotation:A.rotation,borderWidth:M},N=l.xPlus(C,p/2),O=k+f;sie(i,E,N,O,o.pointStyleWidth&&p)}else{const E=k+Math.max((h-m)/2,0),N=l.leftForLtr(C,p),O=Gd(A.borderRadius);i.beginPath(),Object.values(O).some(R=>R!==0)?Hd(i,{x:N,y:E,w:p,h:m,radius:O}):i.rect(N,E,p,m),i.fill(),M!==0&&i.stroke()}i.restore()},b=function(C,k,A){gg(i,A.text,C,k+g/2,c,{strikethrough:A.hidden,textAlign:l.textAlign(A.textAlign)})},_=this.isHorizontal(),w=this._computeTitleHeight();_?d={x:Bo(s,this.left+u,this.right-r[0]),y:this.top+u+w,line:0}:d={x:this.left+u,y:Bo(s,this.top+w+u,this.bottom-t[0].height),line:0},pie(this.ctx,e.textDirection);const S=g+u;this.legendItems.forEach((C,k)=>{i.strokeStyle=C.fontColor,i.fillStyle=C.fontColor;const A=i.measureText(C.text).width,M=l.textAlign(C.textAlign||(C.textAlign=o.textAlign)),E=p+f+A;let N=d.x,O=d.y;l.setWidth(this.width),_?k>0&&N+E+u>this.right&&(O=d.y+=S,d.line++,N=d.x=Bo(s,this.left+u,this.right-r[d.line])):k>0&&O+S>this.bottom&&(N=d.x=N+t[d.line].width+u,d.line++,O=d.y=Bo(s,this.top+w+u,this.bottom-t[d.line].height));const R=l.x(N);if(y(R,O,C),N=lit(M,N+p+f,_?N+E:this.right,e.rtl),b(l.x(N),O,C),_)d.x+=E+u;else if(typeof C.text!="string"){const D=c.lineHeight;d.y+=Fie(C,D)}else d.y+=S}),mie(this.ctx,e.textDirection)}drawTitle(){const e=this.options,t=e.title,r=Hs(t.font),i=ea(t.padding);if(!t.display)return;const s=Rb(e.rtl,this.left,this.width),o=this.ctx,a=t.position,l=r.size/2,c=i.top+l;let u,h=this.left,f=this.width;if(this.isHorizontal())f=Math.max(...this.lineWidths),u=this.top+c,h=Bo(e.align,h,this.right-f);else{const p=this.columnSizes.reduce((m,g)=>Math.max(m,g.height),0);u=c+Bo(e.align,this.top,this.bottom-p-e.labels.padding-this._computeTitleHeight())}const d=Bo(a,h,h+f);o.textAlign=s.textAlign(S4(a)),o.textBaseline="middle",o.strokeStyle=t.color,o.fillStyle=t.color,o.font=r.string,gg(o,t.text,d,u,r)}_computeTitleHeight(){const e=this.options.title,t=Hs(e.font),r=ea(e.padding);return e.display?t.lineHeight+r.height:0}_getLegendItemAt(e,t){let r,i,s;if(Tf(e,this.left,this.right)&&Tf(t,this.top,this.bottom)){for(s=this.legendHitBoxes,r=0;r<s.length;++r)if(i=s[r],Tf(e,i.left,i.left+i.width)&&Tf(t,i.top,i.top+i.height))return this.legendItems[r]}return null}handleEvent(e){const t=this.options;if(!Mat(e.type,t))return;const r=this._getLegendItemAt(e.x,e.y);if(e.type==="mousemove"||e.type==="mouseout"){const i=this._hoveredItem,s=Tat(i,r);i&&!s&&si(t.onLeave,[e,i,this],this),this._hoveredItem=r,r&&!s&&si(t.onHover,[e,r,this],this)}else r&&si(t.onClick,[e,r,this],this)}}function Eat(n,e,t,r,i){const s=Iat(r,n,e,t),o=Aat(i,r,e.lineHeight);return{itemWidth:s,itemHeight:o}}function Iat(n,e,t,r){let i=n.text;return i&&typeof i!="string"&&(i=i.reduce((s,o)=>s.length>o.length?s:o)),e+t.size/2+r.measureText(i).width}function Aat(n,e,t){let r=n;return typeof e.text!="string"&&(r=Fie(e,t)),r}function Fie(n,e){const t=n.text?n.text.length+.5:0;return e*t}function Mat(n,e){return!!((n==="mousemove"||n==="mouseout")&&(e.onHover||e.onLeave)||e.onClick&&(n==="click"||n==="mouseup"))}var Nat={id:"legend",_element:_5,start(n,e,t){const r=n.legend=new _5({ctx:n.ctx,options:t,chart:n});gc.configure(n,r,t),gc.addBox(n,r)},stop(n){gc.removeBox(n,n.legend),delete n.legend},beforeUpdate(n,e,t){const r=n.legend;gc.configure(n,r,t),r.options=t},afterUpdate(n){const e=n.legend;e.buildLabels(),e.adjustHitBoxes()},afterEvent(n,e){e.replay||n.legend.handleEvent(e.event)},defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,onClick(n,e,t){const r=e.datasetIndex,i=t.chart;i.isDatasetVisible(r)?(i.hide(r),e.hidden=!0):(i.show(r),e.hidden=!1)},onHover:null,onLeave:null,labels:{color:n=>n.chart.options.color,boxWidth:40,padding:10,generateLabels(n){const e=n.data.datasets,{labels:{usePointStyle:t,pointStyle:r,textAlign:i,color:s,useBorderRadius:o,borderRadius:a}}=n.legend.options;return n._getSortedDatasetMetas().map(l=>{const c=l.controller.getStyle(t?0:void 0),u=ea(c.borderWidth);return{text:e[l.index].label,fillStyle:c.backgroundColor,fontColor:s,hidden:!l.visible,lineCap:c.borderCapStyle,lineDash:c.borderDash,lineDashOffset:c.borderDashOffset,lineJoin:c.borderJoinStyle,lineWidth:(u.width+u.height)/4,strokeStyle:c.borderColor,pointStyle:r||c.pointStyle,rotation:c.rotation,textAlign:i||c.textAlign,borderRadius:o&&(a||c.borderRadius),datasetIndex:l.index}},this)}},title:{color:n=>n.chart.options.color,display:!1,position:"center",text:""}},descriptors:{_scriptable:n=>!n.startsWith("on"),labels:{_scriptable:n=>!["generateLabels","filter","sort"].includes(n)}}};class Lie extends Ac{constructor(e){super(),this.chart=e.chart,this.options=e.options,this.ctx=e.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(e,t){const r=this.options;if(this.left=0,this.top=0,!r.display){this.width=this.height=this.right=this.bottom=0;return}this.width=this.right=e,this.height=this.bottom=t;const i=mi(r.text)?r.text.length:1;this._padding=ea(r.padding);const s=i*Hs(r.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=s:this.width=s}isHorizontal(){const e=this.options.position;return e==="top"||e==="bottom"}_drawArgs(e){const{top:t,left:r,bottom:i,right:s,options:o}=this,a=o.align;let l=0,c,u,h;return this.isHorizontal()?(u=Bo(a,r,s),h=t+e,c=s-r):(o.position==="left"?(u=r+e,h=Bo(a,i,t),l=Ti*-.5):(u=s-e,h=Bo(a,t,i),l=Ti*.5),c=i-t),{titleX:u,titleY:h,maxWidth:c,rotation:l}}draw(){const e=this.ctx,t=this.options;if(!t.display)return;const r=Hs(t.font),s=r.lineHeight/2+this._padding.top,{titleX:o,titleY:a,maxWidth:l,rotation:c}=this._drawArgs(s);gg(e,t.text,0,0,r,{color:t.color,maxWidth:l,rotation:c,textAlign:S4(t.align),textBaseline:"middle",translation:[o,a]})}}function $at(n,e){const t=new Lie({ctx:n.ctx,options:e,chart:n});gc.configure(n,t,e),gc.addBox(n,t),n.titleBlock=t}var zie={id:"title",_element:Lie,start(n,e,t){$at(n,t)},stop(n){const e=n.titleBlock;gc.removeBox(n,e),delete n.titleBlock},beforeUpdate(n,e,t){const r=n.titleBlock;gc.configure(n,r,t),r.options=t},defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const E1={average(n){if(!n.length)return!1;let e,t,r=0,i=0,s=0;for(e=0,t=n.length;e<t;++e){const o=n[e].element;if(o&&o.hasValue()){const a=o.tooltipPosition();r+=a.x,i+=a.y,++s}}return{x:r/s,y:i/s}},nearest(n,e){if(!n.length)return!1;let t=e.x,r=e.y,i=Number.POSITIVE_INFINITY,s,o,a;for(s=0,o=n.length;s<o;++s){const l=n[s].element;if(l&&l.hasValue()){const c=l.getCenterPoint(),u=XO(e,c);u<i&&(i=u,a=l)}}if(a){const l=a.tooltipPosition();t=l.x,r=l.y}return{x:t,y:r}}};function eh(n,e){return e&&(mi(e)?Array.prototype.push.apply(n,e):n.push(e)),n}function df(n){return(typeof n=="string"||n instanceof String)&&n.indexOf(`
`)>-1?n.split(`
`):n}function Rat(n,e){const{element:t,datasetIndex:r,index:i}=e,s=n.getDatasetMeta(r).controller,{label:o,value:a}=s.getLabelAndValue(i);return{chart:n,label:o,parsed:s.getParsed(i),raw:n.data.datasets[r].data[i],formattedValue:a,dataset:s.getDataset(),dataIndex:i,datasetIndex:r,element:t}}function S5(n,e){const t=n.chart.ctx,{body:r,footer:i,title:s}=n,{boxWidth:o,boxHeight:a}=e,l=Hs(e.bodyFont),c=Hs(e.titleFont),u=Hs(e.footerFont),h=s.length,f=i.length,d=r.length,p=ea(e.padding);let m=p.height,g=0,y=r.reduce((w,S)=>w+S.before.length+S.lines.length+S.after.length,0);if(y+=n.beforeBody.length+n.afterBody.length,h&&(m+=h*c.lineHeight+(h-1)*e.titleSpacing+e.titleMarginBottom),y){const w=e.displayColors?Math.max(a,l.lineHeight):l.lineHeight;m+=d*w+(y-d)*l.lineHeight+(y-1)*e.bodySpacing}f&&(m+=e.footerMarginTop+f*u.lineHeight+(f-1)*e.footerSpacing);let b=0;const _=function(w){g=Math.max(g,t.measureText(w).width+b)};return t.save(),t.font=c.string,Dr(n.title,_),t.font=l.string,Dr(n.beforeBody.concat(n.afterBody),_),b=e.displayColors?o+2+e.boxPadding:0,Dr(r,w=>{Dr(w.before,_),Dr(w.lines,_),Dr(w.after,_)}),b=0,t.font=u.string,Dr(n.footer,_),t.restore(),g+=p.width,{width:g,height:m}}function Pat(n,e){const{y:t,height:r}=e;return t<r/2?"top":t>n.height-r/2?"bottom":"center"}function Dat(n,e,t,r){const{x:i,width:s}=r,o=t.caretSize+t.caretPadding;if(n==="left"&&i+s+o>e.width||n==="right"&&i-s-o<0)return!0}function Oat(n,e,t,r){const{x:i,width:s}=t,{width:o,chartArea:{left:a,right:l}}=n;let c="center";return r==="center"?c=i<=(a+l)/2?"left":"right":i<=s/2?c="left":i>=o-s/2&&(c="right"),Dat(c,n,e,t)&&(c="center"),c}function C5(n,e,t){const r=t.yAlign||e.yAlign||Pat(n,t);return{xAlign:t.xAlign||e.xAlign||Oat(n,e,t,r),yAlign:r}}function Fat(n,e){let{x:t,width:r}=n;return e==="right"?t-=r:e==="center"&&(t-=r/2),t}function Lat(n,e,t){let{y:r,height:i}=n;return e==="top"?r+=t:e==="bottom"?r-=i+t:r-=i/2,r}function k5(n,e,t,r){const{caretSize:i,caretPadding:s,cornerRadius:o}=n,{xAlign:a,yAlign:l}=t,c=i+s,{topLeft:u,topRight:h,bottomLeft:f,bottomRight:d}=Gd(o);let p=Fat(e,a);const m=Lat(e,l,c);return l==="center"?a==="left"?p+=c:a==="right"&&(p-=c):a==="left"?p-=Math.max(u,f)+i:a==="right"&&(p+=Math.max(h,d)+i),{x:Yo(p,0,r.width-e.width),y:Yo(m,0,r.height-e.height)}}function wT(n,e,t){const r=ea(t.padding);return e==="center"?n.x+n.width/2:e==="right"?n.x+n.width-r.right:n.x+r.left}function T5(n){return eh([],df(n))}function zat(n,e,t){return Pp(n,{tooltip:e,tooltipItems:t,type:"tooltip"})}function E5(n,e){const t=e&&e.dataset&&e.dataset.tooltip&&e.dataset.tooltip.callbacks;return t?n.override(t):n}const Bie={beforeTitle:sf,title(n){if(n.length>0){const e=n[0],t=e.chart.data.labels,r=t?t.length:0;if(this&&this.options&&this.options.mode==="dataset")return e.dataset.label||"";if(e.label)return e.label;if(r>0&&e.dataIndex<r)return t[e.dataIndex]}return""},afterTitle:sf,beforeBody:sf,beforeLabel:sf,label(n){if(this&&this.options&&this.options.mode==="dataset")return n.label+": "+n.formattedValue||n.formattedValue;let e=n.dataset.label||"";e&&(e+=": ");const t=n.formattedValue;return Nr(t)||(e+=t),e},labelColor(n){const t=n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);return{borderColor:t.borderColor,backgroundColor:t.backgroundColor,borderWidth:t.borderWidth,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(n){const t=n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);return{pointStyle:t.pointStyle,rotation:t.rotation}},afterLabel:sf,afterBody:sf,beforeFooter:sf,footer:sf,afterFooter:sf};function La(n,e,t,r){const i=n[e].call(t,r);return typeof i>"u"?Bie[e].call(t,r):i}class tF extends Ac{constructor(e){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=e.chart,this.options=e.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(e){this.options=e,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const e=this._cachedAnimations;if(e)return e;const t=this.chart,r=this.options.setContext(this.getContext()),i=r.enabled&&t.options.animation&&r.animations,s=new vie(this.chart,i);return i._cacheable&&(this._cachedAnimations=Object.freeze(s)),s}getContext(){return this.$context||(this.$context=zat(this.chart.getContext(),this,this._tooltipItems))}getTitle(e,t){const{callbacks:r}=t,i=La(r,"beforeTitle",this,e),s=La(r,"title",this,e),o=La(r,"afterTitle",this,e);let a=[];return a=eh(a,df(i)),a=eh(a,df(s)),a=eh(a,df(o)),a}getBeforeBody(e,t){return T5(La(t.callbacks,"beforeBody",this,e))}getBody(e,t){const{callbacks:r}=t,i=[];return Dr(e,s=>{const o={before:[],lines:[],after:[]},a=E5(r,s);eh(o.before,df(La(a,"beforeLabel",this,s))),eh(o.lines,La(a,"label",this,s)),eh(o.after,df(La(a,"afterLabel",this,s))),i.push(o)}),i}getAfterBody(e,t){return T5(La(t.callbacks,"afterBody",this,e))}getFooter(e,t){const{callbacks:r}=t,i=La(r,"beforeFooter",this,e),s=La(r,"footer",this,e),o=La(r,"afterFooter",this,e);let a=[];return a=eh(a,df(i)),a=eh(a,df(s)),a=eh(a,df(o)),a}_createItems(e){const t=this._active,r=this.chart.data,i=[],s=[],o=[];let a=[],l,c;for(l=0,c=t.length;l<c;++l)a.push(Rat(this.chart,t[l]));return e.filter&&(a=a.filter((u,h,f)=>e.filter(u,h,f,r))),e.itemSort&&(a=a.sort((u,h)=>e.itemSort(u,h,r))),Dr(a,u=>{const h=E5(e.callbacks,u);i.push(La(h,"labelColor",this,u)),s.push(La(h,"labelPointStyle",this,u)),o.push(La(h,"labelTextColor",this,u))}),this.labelColors=i,this.labelPointStyles=s,this.labelTextColors=o,this.dataPoints=a,a}update(e,t){const r=this.options.setContext(this.getContext()),i=this._active;let s,o=[];if(!i.length)this.opacity!==0&&(s={opacity:0});else{const a=E1[r.position].call(this,i,this._eventPosition);o=this._createItems(r),this.title=this.getTitle(o,r),this.beforeBody=this.getBeforeBody(o,r),this.body=this.getBody(o,r),this.afterBody=this.getAfterBody(o,r),this.footer=this.getFooter(o,r);const l=this._size=S5(this,r),c=Object.assign({},a,l),u=C5(this.chart,r,c),h=k5(r,c,u,this.chart);this.xAlign=u.xAlign,this.yAlign=u.yAlign,s={opacity:1,x:h.x,y:h.y,width:l.width,height:l.height,caretX:a.x,caretY:a.y}}this._tooltipItems=o,this.$context=void 0,s&&this._resolveAnimations().update(this,s),e&&r.external&&r.external.call(this,{chart:this.chart,tooltip:this,replay:t})}drawCaret(e,t,r,i){const s=this.getCaretPosition(e,r,i);t.lineTo(s.x1,s.y1),t.lineTo(s.x2,s.y2),t.lineTo(s.x3,s.y3)}getCaretPosition(e,t,r){const{xAlign:i,yAlign:s}=this,{caretSize:o,cornerRadius:a}=r,{topLeft:l,topRight:c,bottomLeft:u,bottomRight:h}=Gd(a),{x:f,y:d}=e,{width:p,height:m}=t;let g,y,b,_,w,S;return s==="center"?(w=d+m/2,i==="left"?(g=f,y=g-o,_=w+o,S=w-o):(g=f+p,y=g+o,_=w-o,S=w+o),b=g):(i==="left"?y=f+Math.max(l,u)+o:i==="right"?y=f+p-Math.max(c,h)-o:y=this.caretX,s==="top"?(_=d,w=_-o,g=y-o,b=y+o):(_=d+m,w=_+o,g=y+o,b=y-o),S=_),{x1:g,x2:y,x3:b,y1:_,y2:w,y3:S}}drawTitle(e,t,r){const i=this.title,s=i.length;let o,a,l;if(s){const c=Rb(r.rtl,this.x,this.width);for(e.x=wT(this,r.titleAlign,r),t.textAlign=c.textAlign(r.titleAlign),t.textBaseline="middle",o=Hs(r.titleFont),a=r.titleSpacing,t.fillStyle=r.titleColor,t.font=o.string,l=0;l<s;++l)t.fillText(i[l],c.x(e.x),e.y+o.lineHeight/2),e.y+=o.lineHeight+a,l+1===s&&(e.y+=r.titleMarginBottom-a)}}_drawColorBox(e,t,r,i,s){const o=this.labelColors[r],a=this.labelPointStyles[r],{boxHeight:l,boxWidth:c,boxPadding:u}=s,h=Hs(s.bodyFont),f=wT(this,"left",s),d=i.x(f),p=l<h.lineHeight?(h.lineHeight-l)/2:0,m=t.y+p;if(s.usePointStyle){const g={radius:Math.min(c,l)/2,pointStyle:a.pointStyle,rotation:a.rotation,borderWidth:1},y=i.leftForLtr(d,c)+c/2,b=m+l/2;e.strokeStyle=s.multiKeyBackground,e.fillStyle=s.multiKeyBackground,YO(e,g,y,b),e.strokeStyle=o.borderColor,e.fillStyle=o.backgroundColor,YO(e,g,y,b)}else{e.lineWidth=rr(o.borderWidth)?Math.max(...Object.values(o.borderWidth)):o.borderWidth||1,e.strokeStyle=o.borderColor,e.setLineDash(o.borderDash||[]),e.lineDashOffset=o.borderDashOffset||0;const g=i.leftForLtr(d,c-u),y=i.leftForLtr(i.xPlus(d,1),c-u-2),b=Gd(o.borderRadius);Object.values(b).some(_=>_!==0)?(e.beginPath(),e.fillStyle=s.multiKeyBackground,Hd(e,{x:g,y:m,w:c,h:l,radius:b}),e.fill(),e.stroke(),e.fillStyle=o.backgroundColor,e.beginPath(),Hd(e,{x:y,y:m+1,w:c-2,h:l-2,radius:b}),e.fill()):(e.fillStyle=s.multiKeyBackground,e.fillRect(g,m,c,l),e.strokeRect(g,m,c,l),e.fillStyle=o.backgroundColor,e.fillRect(y,m+1,c-2,l-2))}e.fillStyle=this.labelTextColors[r]}drawBody(e,t,r){const{body:i}=this,{bodySpacing:s,bodyAlign:o,displayColors:a,boxHeight:l,boxWidth:c,boxPadding:u}=r,h=Hs(r.bodyFont);let f=h.lineHeight,d=0;const p=Rb(r.rtl,this.x,this.width),m=function(A){t.fillText(A,p.x(e.x+d),e.y+f/2),e.y+=f+s},g=p.textAlign(o);let y,b,_,w,S,C,k;for(t.textAlign=o,t.textBaseline="middle",t.font=h.string,e.x=wT(this,g,r),t.fillStyle=r.bodyColor,Dr(this.beforeBody,m),d=a&&g!=="right"?o==="center"?c/2+u:c+2+u:0,w=0,C=i.length;w<C;++w){for(y=i[w],b=this.labelTextColors[w],t.fillStyle=b,Dr(y.before,m),_=y.lines,a&&_.length&&(this._drawColorBox(t,e,w,p,r),f=Math.max(h.lineHeight,l)),S=0,k=_.length;S<k;++S)m(_[S]),f=h.lineHeight;Dr(y.after,m)}d=0,f=h.lineHeight,Dr(this.afterBody,m),e.y-=s}drawFooter(e,t,r){const i=this.footer,s=i.length;let o,a;if(s){const l=Rb(r.rtl,this.x,this.width);for(e.x=wT(this,r.footerAlign,r),e.y+=r.footerMarginTop,t.textAlign=l.textAlign(r.footerAlign),t.textBaseline="middle",o=Hs(r.footerFont),t.fillStyle=r.footerColor,t.font=o.string,a=0;a<s;++a)t.fillText(i[a],l.x(e.x),e.y+o.lineHeight/2),e.y+=o.lineHeight+r.footerSpacing}}drawBackground(e,t,r,i){const{xAlign:s,yAlign:o}=this,{x:a,y:l}=e,{width:c,height:u}=r,{topLeft:h,topRight:f,bottomLeft:d,bottomRight:p}=Gd(i.cornerRadius);t.fillStyle=i.backgroundColor,t.strokeStyle=i.borderColor,t.lineWidth=i.borderWidth,t.beginPath(),t.moveTo(a+h,l),o==="top"&&this.drawCaret(e,t,r,i),t.lineTo(a+c-f,l),t.quadraticCurveTo(a+c,l,a+c,l+f),o==="center"&&s==="right"&&this.drawCaret(e,t,r,i),t.lineTo(a+c,l+u-p),t.quadraticCurveTo(a+c,l+u,a+c-p,l+u),o==="bottom"&&this.drawCaret(e,t,r,i),t.lineTo(a+d,l+u),t.quadraticCurveTo(a,l+u,a,l+u-d),o==="center"&&s==="left"&&this.drawCaret(e,t,r,i),t.lineTo(a,l+h),t.quadraticCurveTo(a,l,a+h,l),t.closePath(),t.fill(),i.borderWidth>0&&t.stroke()}_updateAnimationTarget(e){const t=this.chart,r=this.$animations,i=r&&r.x,s=r&&r.y;if(i||s){const o=E1[e.position].call(this,this._active,this._eventPosition);if(!o)return;const a=this._size=S5(this,e),l=Object.assign({},o,this._size),c=C5(t,e,l),u=k5(e,l,c,t);(i._to!==u.x||s._to!==u.y)&&(this.xAlign=c.xAlign,this.yAlign=c.yAlign,this.width=a.width,this.height=a.height,this.caretX=o.x,this.caretY=o.y,this._resolveAnimations().update(this,u))}}_willRender(){return!!this.opacity}draw(e){const t=this.options.setContext(this.getContext());let r=this.opacity;if(!r)return;this._updateAnimationTarget(t);const i={width:this.width,height:this.height},s={x:this.x,y:this.y};r=Math.abs(r)<.001?0:r;const o=ea(t.padding),a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;t.enabled&&a&&(e.save(),e.globalAlpha=r,this.drawBackground(s,e,i,t),pie(e,t.textDirection),s.y+=o.top,this.drawTitle(s,e,t),this.drawBody(s,e,t),this.drawFooter(s,e,t),mie(e,t.textDirection),e.restore())}getActiveElements(){return this._active||[]}setActiveElements(e,t){const r=this._active,i=e.map(({datasetIndex:a,index:l})=>{const c=this.chart.getDatasetMeta(a);if(!c)throw new Error("Cannot find a dataset at index "+a);return{datasetIndex:a,element:c.data[l],index:l}}),s=!iA(r,i),o=this._positionChanged(i,t);(s||o)&&(this._active=i,this._eventPosition=t,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(e,t,r=!0){if(t&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const i=this.options,s=this._active||[],o=this._getActiveElements(e,s,t,r),a=this._positionChanged(o,e),l=t||!iA(o,s)||a;return l&&(this._active=o,(i.enabled||i.external)&&(this._eventPosition={x:e.x,y:e.y},this.update(!0,t))),l}_getActiveElements(e,t,r,i){const s=this.options;if(e.type==="mouseout")return[];if(!i)return t;const o=this.chart.getElementsAtEventForMode(e,s.mode,s,r);return s.reverse&&o.reverse(),o}_positionChanged(e,t){const{caretX:r,caretY:i,options:s}=this,o=E1[s.position].call(this,e,t);return o!==!1&&(r!==o.x||i!==o.y)}}Nt(tF,"positioners",E1);var Vie={id:"tooltip",_element:tF,positioners:E1,afterInit(n,e,t){t&&(n.tooltip=new tF({chart:n,options:t}))},beforeUpdate(n,e,t){n.tooltip&&n.tooltip.initialize(t)},reset(n,e,t){n.tooltip&&n.tooltip.initialize(t)},afterDraw(n){const e=n.tooltip;if(e&&e._willRender()){const t={tooltip:e};if(n.notifyPlugins("beforeTooltipDraw",{...t,cancelable:!0})===!1)return;e.draw(n.ctx),n.notifyPlugins("afterTooltipDraw",t)}},afterEvent(n,e){if(n.tooltip){const t=e.replay;n.tooltip.handleEvent(e.event,t,e.inChartArea)&&(e.changed=!0)}},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(n,e)=>e.bodyFont.size,boxWidth:(n,e)=>e.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:Bie},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:n=>n!=="filter"&&n!=="itemSort"&&n!=="external",_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};const Bat=(n,e,t,r)=>(typeof e=="string"?(t=n.push(e)-1,r.unshift({index:t,label:e})):isNaN(e)&&(t=null),t);function Vat(n,e,t,r){const i=n.indexOf(e);if(i===-1)return Bat(n,e,t,r);const s=n.lastIndexOf(e);return i!==s?t:i}const Uat=(n,e)=>n===null?null:Yo(Math.round(n),0,e);function I5(n){const e=this.getLabels();return n>=0&&n<e.length?e[n]:n}class fA extends Ky{constructor(e){super(e),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(e){const t=this._addedLabels;if(t.length){const r=this.getLabels();for(const{index:i,label:s}of t)r[i]===s&&r.splice(i,1);this._addedLabels=[]}super.init(e)}parse(e,t){if(Nr(e))return null;const r=this.getLabels();return t=isFinite(t)&&r[t]===e?t:Vat(r,e,Wn(t,e),this._addedLabels),Uat(t,r.length-1)}determineDataLimits(){const{minDefined:e,maxDefined:t}=this.getUserBounds();let{min:r,max:i}=this.getMinMax(!0);this.options.bounds==="ticks"&&(e||(r=0),t||(i=this.getLabels().length-1)),this.min=r,this.max=i}buildTicks(){const e=this.min,t=this.max,r=this.options.offset,i=[];let s=this.getLabels();s=e===0&&t===s.length-1?s:s.slice(e,t+1),this._valueRange=Math.max(s.length-(r?0:1),1),this._startValue=this.min-(r?.5:0);for(let o=e;o<=t;o++)i.push({value:o});return i}getLabelForValue(e){return I5.call(this,e)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(e){return typeof e!="number"&&(e=this.parse(e)),e===null?NaN:this.getPixelForDecimal((e-this._startValue)/this._valueRange)}getPixelForTick(e){const t=this.ticks;return e<0||e>t.length-1?null:this.getPixelForValue(t[e].value)}getValueForPixel(e){return Math.round(this._startValue+this.getDecimalForPixel(e)*this._valueRange)}getBasePixel(){return this.bottom}}Nt(fA,"id","category"),Nt(fA,"defaults",{ticks:{callback:I5}});function Wat(n,e){const t=[],{bounds:i,step:s,min:o,max:a,precision:l,count:c,maxTicks:u,maxDigits:h,includeBounds:f}=n,d=s||1,p=u-1,{min:m,max:g}=e,y=!Nr(o),b=!Nr(a),_=!Nr(c),w=(g-m)/(h+1);let S=E6((g-m)/p/d)*d,C,k,A,M;if(S<1e-14&&!y&&!b)return[{value:m},{value:g}];M=Math.ceil(g/S)-Math.floor(m/S),M>p&&(S=E6(M*S/p/d)*d),Nr(l)||(C=Math.pow(10,l),S=Math.ceil(S*C)/C),i==="ticks"?(k=Math.floor(m/S)*S,A=Math.ceil(g/S)*S):(k=m,A=g),y&&b&&s&&tit((a-o)/s,S/1e3)?(M=Math.round(Math.min((a-o)/S,u)),S=(a-o)/M,k=o,A=a):_?(k=y?o:k,A=b?a:A,M=c-1,S=(A-k)/M):(M=(A-k)/S,J1(M,Math.round(M),S/1e3)?M=Math.round(M):M=Math.ceil(M));const E=Math.max(I6(S),I6(k));C=Math.pow(10,Nr(l)?E:l),k=Math.round(k*C)/C,A=Math.round(A*C)/C;let N=0;for(y&&(f&&k!==o?(t.push({value:o}),k<o&&N++,J1(Math.round((k+N*S)*C)/C,o,A5(o,w,n))&&N++):k<o&&N++);N<M;++N)t.push({value:Math.round((k+N*S)*C)/C});return b&&f&&A!==a?t.length&&J1(t[t.length-1].value,a,A5(a,w,n))?t[t.length-1].value=a:t.push({value:a}):(!b||A===a)&&t.push({value:A}),t}function A5(n,e,{horizontal:t,minRotation:r}){const i=mu(r),s=(t?Math.sin(i):Math.cos(i))||.001,o=.75*e*(""+n).length;return Math.min(e/s,o)}class dA extends Ky{constructor(e){super(e),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(e,t){return Nr(e)||(typeof e=="number"||e instanceof Number)&&!isFinite(+e)?null:+e}handleTickRangeOptions(){const{beginAtZero:e}=this.options,{minDefined:t,maxDefined:r}=this.getUserBounds();let{min:i,max:s}=this;const o=l=>i=t?i:l,a=l=>s=r?s:l;if(e){const l=vh(i),c=vh(s);l<0&&c<0?a(0):l>0&&c>0&&o(0)}if(i===s){let l=s===0?1:Math.abs(s*.05);a(s+l),e||o(i-l)}this.min=i,this.max=s}getTickLimit(){const e=this.options.ticks;let{maxTicksLimit:t,stepSize:r}=e,i;return r?(i=Math.ceil(this.max/r)-Math.floor(this.min/r)+1,i>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${r} would result generating up to ${i} ticks. Limiting to 1000.`),i=1e3)):(i=this.computeTickLimit(),t=t||11),t&&(i=Math.min(t,i)),i}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const e=this.options,t=e.ticks;let r=this.getTickLimit();r=Math.max(2,r);const i={maxTicks:r,bounds:e.bounds,min:e.min,max:e.max,precision:t.precision,step:t.stepSize,count:t.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:t.minRotation||0,includeBounds:t.includeBounds!==!1},s=this._range||this,o=Wat(i,s);return e.bounds==="ticks"&&Kre(o,this,"value"),e.reverse?(o.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),o}configure(){const e=this.ticks;let t=this.min,r=this.max;if(super.configure(),this.options.offset&&e.length){const i=(r-t)/Math.max(e.length-1,1)/2;t-=i,r+=i}this._startValue=t,this._endValue=r,this._valueRange=r-t}getLabelForValue(e){return AC(e,this.chart.options.locale,this.options.ticks.format)}}class nF extends dA{determineDataLimits(){const{min:e,max:t}=this.getMinMax(!0);this.min=Yi(e)?e:0,this.max=Yi(t)?t:1,this.handleTickRangeOptions()}computeTickLimit(){const e=this.isHorizontal(),t=e?this.width:this.height,r=mu(this.options.ticks.minRotation),i=(e?Math.sin(r):Math.cos(r))||.001,s=this._resolveTickFontOptions(0);return Math.ceil(t/Math.min(40,s.lineHeight/i))}getPixelForValue(e){return e===null?NaN:this.getPixelForDecimal((e-this._startValue)/this._valueRange)}getValueForPixel(e){return this._startValue+this.getDecimalForPixel(e)*this._valueRange}}Nt(nF,"id","linear"),Nt(nF,"defaults",{ticks:{callback:m$.formatters.numeric}});const Q_=n=>Math.floor($d(n)),sm=(n,e)=>Math.pow(10,Q_(n)+e);function M5(n){return n/Math.pow(10,Q_(n))===1}function N5(n,e,t){const r=Math.pow(10,t),i=Math.floor(n/r);return Math.ceil(e/r)-i}function Hat(n,e){const t=e-n;let r=Q_(t);for(;N5(n,e,r)>10;)r++;for(;N5(n,e,r)<10;)r--;return Math.min(r,Q_(n))}function Gat(n,{min:e,max:t}){e=gl(n.min,e);const r=[],i=Q_(e);let s=Hat(e,t),o=s<0?Math.pow(10,Math.abs(s)):1;const a=Math.pow(10,s),l=i>s?Math.pow(10,i):0,c=Math.round((e-l)*o)/o,u=Math.floor((e-l)/a/10)*a*10;let h=Math.floor((c-u)/Math.pow(10,s)),f=gl(n.min,Math.round((l+u+h*Math.pow(10,s))*o)/o);for(;f<t;)r.push({value:f,major:M5(f),significand:h}),h>=10?h=h<15?15:20:h++,h>=20&&(s++,h=2,o=s>=0?1:o),f=Math.round((l+u+h*Math.pow(10,s))*o)/o;const d=gl(n.max,f);return r.push({value:d,major:M5(d),significand:h}),r}class rF extends Ky{constructor(e){super(e),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(e,t){const r=dA.prototype.parse.apply(this,[e,t]);if(r===0){this._zero=!0;return}return Yi(r)&&r>0?r:null}determineDataLimits(){const{min:e,max:t}=this.getMinMax(!0);this.min=Yi(e)?Math.max(0,e):null,this.max=Yi(t)?Math.max(0,t):null,this.options.beginAtZero&&(this._zero=!0),this._zero&&this.min!==this._suggestedMin&&!Yi(this._userMin)&&(this.min=e===sm(this.min,0)?sm(this.min,-1):sm(this.min,0)),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:e,maxDefined:t}=this.getUserBounds();let r=this.min,i=this.max;const s=a=>r=e?r:a,o=a=>i=t?i:a;r===i&&(r<=0?(s(1),o(10)):(s(sm(r,-1)),o(sm(i,1)))),r<=0&&s(sm(i,-1)),i<=0&&o(sm(r,1)),this.min=r,this.max=i}buildTicks(){const e=this.options,t={min:this._userMin,max:this._userMax},r=Gat(t,this);return e.bounds==="ticks"&&Kre(r,this,"value"),e.reverse?(r.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),r}getLabelForValue(e){return e===void 0?"0":AC(e,this.chart.options.locale,this.options.ticks.format)}configure(){const e=this.min;super.configure(),this._startValue=$d(e),this._valueRange=$d(this.max)-$d(e)}getPixelForValue(e){return(e===void 0||e===0)&&(e=this.min),e===null||isNaN(e)?NaN:this.getPixelForDecimal(e===this.min?0:($d(e)-this._startValue)/this._valueRange)}getValueForPixel(e){const t=this.getDecimalForPixel(e);return Math.pow(10,this._startValue+t*this._valueRange)}}Nt(rF,"id","logarithmic"),Nt(rF,"defaults",{ticks:{callback:m$.formatters.logarithmic,major:{enabled:!0}}});function iF(n){const e=n.ticks;if(e.display&&n.display){const t=ea(e.backdropPadding);return Wn(e.font&&e.font.size,as.font.size)+t.height}return 0}function jat(n,e,t){return t=mi(t)?t:[t],{w:bit(n,e.string,t),h:t.length*e.lineHeight}}function $5(n,e,t,r,i){return n===r||n===i?{start:e-t/2,end:e+t/2}:n<r||n>i?{start:e-t,end:e}:{start:e,end:e+t}}function qat(n){const e={l:n.left+n._padding.left,r:n.right-n._padding.right,t:n.top+n._padding.top,b:n.bottom-n._padding.bottom},t=Object.assign({},e),r=[],i=[],s=n._pointLabels.length,o=n.options.pointLabels,a=o.centerPointLabels?Ti/s:0;for(let l=0;l<s;l++){const c=o.setContext(n.getPointLabelContext(l));i[l]=c.padding;const u=n.getPointPosition(l,n.drawingArea+i[l],a),h=Hs(c.font),f=jat(n.ctx,h,n._pointLabels[l]);r[l]=f;const d=yl(n.getIndexAngle(l)+a),p=Math.round(x4(d)),m=$5(p,u.x,f.w,0,180),g=$5(p,u.y,f.h,90,270);Xat(t,e,d,m,g)}n.setCenterPoint(e.l-t.l,t.r-e.r,e.t-t.t,t.b-e.b),n._pointLabelItems=Kat(n,r,i)}function Xat(n,e,t,r,i){const s=Math.abs(Math.sin(t)),o=Math.abs(Math.cos(t));let a=0,l=0;r.start<e.l?(a=(e.l-r.start)/s,n.l=Math.min(n.l,e.l-a)):r.end>e.r&&(a=(r.end-e.r)/s,n.r=Math.max(n.r,e.r+a)),i.start<e.t?(l=(e.t-i.start)/o,n.t=Math.min(n.t,e.t-l)):i.end>e.b&&(l=(i.end-e.b)/o,n.b=Math.max(n.b,e.b+l))}function Kat(n,e,t){const r=[],i=n._pointLabels.length,s=n.options,o=iF(s)/2,a=n.drawingArea,l=s.pointLabels.centerPointLabels?Ti/i:0;for(let c=0;c<i;c++){const u=n.getPointPosition(c,a+o+t[c],l),h=Math.round(x4(yl(u.angle+Zi))),f=e[c],d=Jat(u.y,f.h,h),p=Yat(h),m=Zat(u.x,f.w,p);r.push({x:u.x,y:d,textAlign:p,left:m,top:d,right:m+f.w,bottom:d+f.h})}return r}function Yat(n){return n===0||n===180?"center":n<180?"left":"right"}function Zat(n,e,t){return t==="right"?n-=e:t==="center"&&(n-=e/2),n}function Jat(n,e,t){return t===90||t===270?n-=e/2:(t>270||t<90)&&(n-=e),n}function Qat(n,e){const{ctx:t,options:{pointLabels:r}}=n;for(let i=e-1;i>=0;i--){const s=r.setContext(n.getPointLabelContext(i)),o=Hs(s.font),{x:a,y:l,textAlign:c,left:u,top:h,right:f,bottom:d}=n._pointLabelItems[i],{backdropColor:p}=s;if(!Nr(p)){const m=Gd(s.borderRadius),g=ea(s.backdropPadding);t.fillStyle=p;const y=u-g.left,b=h-g.top,_=f-u+g.width,w=d-h+g.height;Object.values(m).some(S=>S!==0)?(t.beginPath(),Hd(t,{x:y,y:b,w:_,h:w,radius:m}),t.fill()):t.fillRect(y,b,_,w)}gg(t,n._pointLabels[i],a,l+o.lineHeight/2,o,{color:s.color,textAlign:c,textBaseline:"middle"})}}function Uie(n,e,t,r){const{ctx:i}=n;if(t)i.arc(n.xCenter,n.yCenter,e,0,yi);else{let s=n.getPointPosition(0,e);i.moveTo(s.x,s.y);for(let o=1;o<r;o++)s=n.getPointPosition(o,e),i.lineTo(s.x,s.y)}}function elt(n,e,t,r,i){const s=n.ctx,o=e.circular,{color:a,lineWidth:l}=e;!o&&!r||!a||!l||t<0||(s.save(),s.strokeStyle=a,s.lineWidth=l,s.setLineDash(i.dash),s.lineDashOffset=i.dashOffset,s.beginPath(),Uie(n,t,o,r),s.closePath(),s.stroke(),s.restore())}function tlt(n,e,t){return Pp(n,{label:t,index:e,type:"pointLabel"})}class I1 extends dA{constructor(e){super(e),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const e=this._padding=ea(iF(this.options)/2),t=this.width=this.maxWidth-e.width,r=this.height=this.maxHeight-e.height;this.xCenter=Math.floor(this.left+t/2+e.left),this.yCenter=Math.floor(this.top+r/2+e.top),this.drawingArea=Math.floor(Math.min(t,r)/2)}determineDataLimits(){const{min:e,max:t}=this.getMinMax(!1);this.min=Yi(e)&&!isNaN(e)?e:0,this.max=Yi(t)&&!isNaN(t)?t:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/iF(this.options))}generateTickLabels(e){dA.prototype.generateTickLabels.call(this,e),this._pointLabels=this.getLabels().map((t,r)=>{const i=si(this.options.pointLabels.callback,[t,r],this);return i||i===0?i:""}).filter((t,r)=>this.chart.getDataVisibility(r))}fit(){const e=this.options;e.display&&e.pointLabels.display?qat(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(e,t,r,i){this.xCenter+=Math.floor((e-t)/2),this.yCenter+=Math.floor((r-i)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(e,t,r,i))}getIndexAngle(e){const t=yi/(this._pointLabels.length||1),r=this.options.startAngle||0;return yl(e*t+mu(r))}getDistanceFromCenterForValue(e){if(Nr(e))return NaN;const t=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-e)*t:(e-this.min)*t}getValueForDistanceFromCenter(e){if(Nr(e))return NaN;const t=e/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-t:this.min+t}getPointLabelContext(e){const t=this._pointLabels||[];if(e>=0&&e<t.length){const r=t[e];return tlt(this.getContext(),e,r)}}getPointPosition(e,t,r=0){const i=this.getIndexAngle(e)-Zi+r;return{x:Math.cos(i)*t+this.xCenter,y:Math.sin(i)*t+this.yCenter,angle:i}}getPointPositionForValue(e,t){return this.getPointPosition(e,this.getDistanceFromCenterForValue(t))}getBasePosition(e){return this.getPointPositionForValue(e||0,this.getBaseValue())}getPointLabelPosition(e){const{left:t,top:r,right:i,bottom:s}=this._pointLabelItems[e];return{left:t,top:r,right:i,bottom:s}}drawBackground(){const{backgroundColor:e,grid:{circular:t}}=this.options;if(e){const r=this.ctx;r.save(),r.beginPath(),Uie(this,this.getDistanceFromCenterForValue(this._endValue),t,this._pointLabels.length),r.closePath(),r.fillStyle=e,r.fill(),r.restore()}}drawGrid(){const e=this.ctx,t=this.options,{angleLines:r,grid:i,border:s}=t,o=this._pointLabels.length;let a,l,c;if(t.pointLabels.display&&Qat(this,o),i.display&&this.ticks.forEach((u,h)=>{if(h!==0){l=this.getDistanceFromCenterForValue(u.value);const f=this.getContext(h),d=i.setContext(f),p=s.setContext(f);elt(this,d,l,o,p)}}),r.display){for(e.save(),a=o-1;a>=0;a--){const u=r.setContext(this.getPointLabelContext(a)),{color:h,lineWidth:f}=u;!f||!h||(e.lineWidth=f,e.strokeStyle=h,e.setLineDash(u.borderDash),e.lineDashOffset=u.borderDashOffset,l=this.getDistanceFromCenterForValue(t.ticks.reverse?this.min:this.max),c=this.getPointPosition(a,l),e.beginPath(),e.moveTo(this.xCenter,this.yCenter),e.lineTo(c.x,c.y),e.stroke())}e.restore()}}drawBorder(){}drawLabels(){const e=this.ctx,t=this.options,r=t.ticks;if(!r.display)return;const i=this.getIndexAngle(0);let s,o;e.save(),e.translate(this.xCenter,this.yCenter),e.rotate(i),e.textAlign="center",e.textBaseline="middle",this.ticks.forEach((a,l)=>{if(l===0&&!t.reverse)return;const c=r.setContext(this.getContext(l)),u=Hs(c.font);if(s=this.getDistanceFromCenterForValue(this.ticks[l].value),c.showLabelBackdrop){e.font=u.string,o=e.measureText(a.label).width,e.fillStyle=c.backdropColor;const h=ea(c.backdropPadding);e.fillRect(-o/2-h.left,-s-u.size/2-h.top,o+h.width,u.size+h.height)}gg(e,a.label,0,-s,u,{color:c.color})}),e.restore()}drawTitle(){}}Nt(I1,"id","radialLinear"),Nt(I1,"defaults",{display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:m$.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback(e){return e},padding:5,centerPointLabels:!1}}),Nt(I1,"defaultRoutes",{"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"}),Nt(I1,"descriptors",{angleLines:{_fallback:"grid"}});const v$={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},Ua=Object.keys(v$);function nlt(n,e){return n-e}function R5(n,e){if(Nr(e))return null;const t=n._adapter,{parser:r,round:i,isoWeekday:s}=n._parseOpts;let o=e;return typeof r=="function"&&(o=r(o)),Yi(o)||(o=typeof r=="string"?t.parse(o,r):t.parse(o)),o===null?null:(i&&(o=i==="week"&&(ov(s)||s===!0)?t.startOf(o,"isoWeek",s):t.startOf(o,i)),+o)}function P5(n,e,t,r){const i=Ua.length;for(let s=Ua.indexOf(n);s<i-1;++s){const o=v$[Ua[s]],a=o.steps?o.steps:Number.MAX_SAFE_INTEGER;if(o.common&&Math.ceil((t-e)/(a*o.size))<=r)return Ua[s]}return Ua[i-1]}function rlt(n,e,t,r,i){for(let s=Ua.length-1;s>=Ua.indexOf(t);s--){const o=Ua[s];if(v$[o].common&&n._adapter.diff(i,r,o)>=e-1)return o}return Ua[t?Ua.indexOf(t):0]}function ilt(n){for(let e=Ua.indexOf(n)+1,t=Ua.length;e<t;++e)if(v$[Ua[e]].common)return Ua[e]}function D5(n,e,t){if(!t)n[e]=!0;else if(t.length){const{lo:r,hi:i}=_4(t,e),s=t[r]>=e?t[r]:t[i];n[s]=!0}}function slt(n,e,t,r){const i=n._adapter,s=+i.startOf(e[0].value,r),o=e[e.length-1].value;let a,l;for(a=s;a<=o;a=+i.add(a,1,r))l=t[a],l>=0&&(e[l].major=!0);return e}function O5(n,e,t){const r=[],i={},s=e.length;let o,a;for(o=0;o<s;++o)a=e[o],i[a]=o,r.push({value:a,major:!1});return s===0||!t?r:slt(n,r,i,t)}class eS extends Ky{constructor(e){super(e),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(e,t={}){const r=e.time||(e.time={}),i=this._adapter=new _ie._date(e.adapters.date);i.init(t),Z1(r.displayFormats,i.formats()),this._parseOpts={parser:r.parser,round:r.round,isoWeekday:r.isoWeekday},super.init(e),this._normalized=t.normalized}parse(e,t){return e===void 0?null:R5(this,e)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const e=this.options,t=this._adapter,r=e.time.unit||"day";let{min:i,max:s,minDefined:o,maxDefined:a}=this.getUserBounds();function l(c){!o&&!isNaN(c.min)&&(i=Math.min(i,c.min)),!a&&!isNaN(c.max)&&(s=Math.max(s,c.max))}(!o||!a)&&(l(this._getLabelBounds()),(e.bounds!=="ticks"||e.ticks.source!=="labels")&&l(this.getMinMax(!1))),i=Yi(i)&&!isNaN(i)?i:+t.startOf(Date.now(),r),s=Yi(s)&&!isNaN(s)?s:+t.endOf(Date.now(),r)+1,this.min=Math.min(i,s-1),this.max=Math.max(i+1,s)}_getLabelBounds(){const e=this.getLabelTimestamps();let t=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;return e.length&&(t=e[0],r=e[e.length-1]),{min:t,max:r}}buildTicks(){const e=this.options,t=e.time,r=e.ticks,i=r.source==="labels"?this.getLabelTimestamps():this._generate();e.bounds==="ticks"&&i.length&&(this.min=this._userMin||i[0],this.max=this._userMax||i[i.length-1]);const s=this.min,o=this.max,a=sit(i,s,o);return this._unit=t.unit||(r.autoSkip?P5(t.minUnit,this.min,this.max,this._getLabelCapacity(s)):rlt(this,a.length,t.minUnit,this.min,this.max)),this._majorUnit=!r.major.enabled||this._unit==="year"?void 0:ilt(this._unit),this.initOffsets(i),e.reverse&&a.reverse(),O5(this,a,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map(e=>+e.value))}initOffsets(e=[]){let t=0,r=0,i,s;this.options.offset&&e.length&&(i=this.getDecimalForValue(e[0]),e.length===1?t=1-i:t=(this.getDecimalForValue(e[1])-i)/2,s=this.getDecimalForValue(e[e.length-1]),e.length===1?r=s:r=(s-this.getDecimalForValue(e[e.length-2]))/2);const o=e.length<3?.5:.25;t=Yo(t,0,o),r=Yo(r,0,o),this._offsets={start:t,end:r,factor:1/(t+1+r)}}_generate(){const e=this._adapter,t=this.min,r=this.max,i=this.options,s=i.time,o=s.unit||P5(s.minUnit,t,r,this._getLabelCapacity(t)),a=Wn(i.ticks.stepSize,1),l=o==="week"?s.isoWeekday:!1,c=ov(l)||l===!0,u={};let h=t,f,d;if(c&&(h=+e.startOf(h,"isoWeek",l)),h=+e.startOf(h,c?"day":o),e.diff(r,t,o)>1e5*a)throw new Error(t+" and "+r+" are too far apart with stepSize of "+a+" "+o);const p=i.ticks.source==="data"&&this.getDataTimestamps();for(f=h,d=0;f<r;f=+e.add(f,a,o),d++)D5(u,f,p);return(f===r||i.bounds==="ticks"||d===1)&&D5(u,f,p),Object.keys(u).sort((m,g)=>m-g).map(m=>+m)}getLabelForValue(e){const t=this._adapter,r=this.options.time;return r.tooltipFormat?t.format(e,r.tooltipFormat):t.format(e,r.displayFormats.datetime)}format(e,t){const i=this.options.time.displayFormats,s=this._unit,o=t||i[s];return this._adapter.format(e,o)}_tickFormatFunction(e,t,r,i){const s=this.options,o=s.ticks.callback;if(o)return si(o,[e,t,r],this);const a=s.time.displayFormats,l=this._unit,c=this._majorUnit,u=l&&a[l],h=c&&a[c],f=r[t],d=c&&h&&f&&f.major;return this._adapter.format(e,i||(d?h:u))}generateTickLabels(e){let t,r,i;for(t=0,r=e.length;t<r;++t)i=e[t],i.label=this._tickFormatFunction(i.value,t,e)}getDecimalForValue(e){return e===null?NaN:(e-this.min)/(this.max-this.min)}getPixelForValue(e){const t=this._offsets,r=this.getDecimalForValue(e);return this.getPixelForDecimal((t.start+r)*t.factor)}getValueForPixel(e){const t=this._offsets,r=this.getDecimalForPixel(e)/t.factor-t.end;return this.min+r*(this.max-this.min)}_getLabelSize(e){const t=this.options.ticks,r=this.ctx.measureText(e).width,i=mu(this.isHorizontal()?t.maxRotation:t.minRotation),s=Math.cos(i),o=Math.sin(i),a=this._resolveTickFontOptions(0).size;return{w:r*s+a*o,h:r*o+a*s}}_getLabelCapacity(e){const t=this.options.time,r=t.displayFormats,i=r[t.unit]||r.millisecond,s=this._tickFormatFunction(e,0,O5(this,[e],this._majorUnit),i),o=this._getLabelSize(s),a=Math.floor(this.isHorizontal()?this.width/o.w:this.height/o.h)-1;return a>0?a:1}getDataTimestamps(){let e=this._cache.data||[],t,r;if(e.length)return e;const i=this.getMatchingVisibleMetas();if(this._normalized&&i.length)return this._cache.data=i[0].controller.getAllParsedValues(this);for(t=0,r=i.length;t<r;++t)e=e.concat(i[t].controller.getAllParsedValues(this));return this._cache.data=this.normalize(e)}getLabelTimestamps(){const e=this._cache.labels||[];let t,r;if(e.length)return e;const i=this.getLabels();for(t=0,r=i.length;t<r;++t)e.push(R5(this,i[t]));return this._cache.labels=this._normalized?e:this.normalize(e)}normalize(e){return Jre(e.sort(nlt))}}Nt(eS,"id","time"),Nt(eS,"defaults",{bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",callback:!1,major:{enabled:!1}}});function xT(n,e,t){let r=0,i=n.length-1,s,o,a,l;t?(e>=n[r].pos&&e<=n[i].pos&&({lo:r,hi:i}=Lm(n,"pos",e)),{pos:s,time:a}=n[r],{pos:o,time:l}=n[i]):(e>=n[r].time&&e<=n[i].time&&({lo:r,hi:i}=Lm(n,"time",e)),{time:s,pos:a}=n[r],{time:o,pos:l}=n[i]);const c=o-s;return c?a+(l-a)*(e-s)/c:a}class sF extends eS{constructor(e){super(e),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const e=this._getTimestampsForTable(),t=this._table=this.buildLookupTable(e);this._minPos=xT(t,this.min),this._tableRange=xT(t,this.max)-this._minPos,super.initOffsets(e)}buildLookupTable(e){const{min:t,max:r}=this,i=[],s=[];let o,a,l,c,u;for(o=0,a=e.length;o<a;++o)c=e[o],c>=t&&c<=r&&i.push(c);if(i.length<2)return[{time:t,pos:0},{time:r,pos:1}];for(o=0,a=i.length;o<a;++o)u=i[o+1],l=i[o-1],c=i[o],Math.round((u+l)/2)!==c&&s.push({time:c,pos:o/(a-1)});return s}_getTimestampsForTable(){let e=this._cache.all||[];if(e.length)return e;const t=this.getDataTimestamps(),r=this.getLabelTimestamps();return t.length&&r.length?e=this.normalize(t.concat(r)):e=t.length?t:r,e=this._cache.all=e,e}getDecimalForValue(e){return(xT(this._table,e)-this._minPos)/this._tableRange}getValueForPixel(e){const t=this._offsets,r=this.getDecimalForPixel(e)/t.factor-t.end;return xT(this._table,r*this._tableRange+this._minPos,!0)}}Nt(sF,"id","timeseries"),Nt(sF,"defaults",eS.defaults);class Yy extends Error{}class olt extends Yy{constructor(e){super(`Invalid DateTime: ${e.toMessage()}`)}}class alt extends Yy{constructor(e){super(`Invalid Interval: ${e.toMessage()}`)}}class llt extends Yy{constructor(e){super(`Invalid Duration: ${e.toMessage()}`)}}class A1 extends Yy{}class Wie extends Yy{constructor(e){super(`Invalid unit ${e}`)}}class lc extends Yy{}class ad extends Yy{constructor(){super("Zone is an abstract class")}}const zt="numeric",Iu="short",Al="long",pA={year:zt,month:zt,day:zt},Hie={year:zt,month:Iu,day:zt},clt={year:zt,month:Iu,day:zt,weekday:Iu},Gie={year:zt,month:Al,day:zt},jie={year:zt,month:Al,day:zt,weekday:Al},qie={hour:zt,minute:zt},Xie={hour:zt,minute:zt,second:zt},Kie={hour:zt,minute:zt,second:zt,timeZoneName:Iu},Yie={hour:zt,minute:zt,second:zt,timeZoneName:Al},Zie={hour:zt,minute:zt,hourCycle:"h23"},Jie={hour:zt,minute:zt,second:zt,hourCycle:"h23"},Qie={hour:zt,minute:zt,second:zt,hourCycle:"h23",timeZoneName:Iu},ese={hour:zt,minute:zt,second:zt,hourCycle:"h23",timeZoneName:Al},tse={year:zt,month:zt,day:zt,hour:zt,minute:zt},nse={year:zt,month:zt,day:zt,hour:zt,minute:zt,second:zt},rse={year:zt,month:Iu,day:zt,hour:zt,minute:zt},ise={year:zt,month:Iu,day:zt,hour:zt,minute:zt,second:zt},ult={year:zt,month:Iu,day:zt,weekday:Iu,hour:zt,minute:zt},sse={year:zt,month:Al,day:zt,hour:zt,minute:zt,timeZoneName:Iu},ose={year:zt,month:Al,day:zt,hour:zt,minute:zt,second:zt,timeZoneName:Iu},ase={year:zt,month:Al,day:zt,weekday:Al,hour:zt,minute:zt,timeZoneName:Al},lse={year:zt,month:Al,day:zt,weekday:Al,hour:zt,minute:zt,second:zt,timeZoneName:Al};class NC{get type(){throw new ad}get name(){throw new ad}get ianaName(){return this.name}get isUniversal(){throw new ad}offsetName(e,t){throw new ad}formatOffset(e,t){throw new ad}offset(e){throw new ad}equals(e){throw new ad}get isValid(){throw new ad}}let z3=null;class w$ extends NC{static get instance(){return z3===null&&(z3=new w$),z3}get type(){return"system"}get name(){return new Intl.DateTimeFormat().resolvedOptions().timeZone}get isUniversal(){return!1}offsetName(e,{format:t,locale:r}){return use(e,t,r)}formatOffset(e,t){return n_(this.offset(e),t)}offset(e){return-new Date(e).getTimezoneOffset()}equals(e){return e.type==="system"}get isValid(){return!0}}let ZE={};function hlt(n){return ZE[n]||(ZE[n]=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:n,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",era:"short"})),ZE[n]}const flt={year:0,month:1,day:2,era:3,hour:4,minute:5,second:6};function dlt(n,e){const t=n.format(e).replace(/\u200E/g,""),r=/(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(t),[,i,s,o,a,l,c,u]=r;return[o,i,s,a,l,c,u]}function plt(n,e){const t=n.formatToParts(e),r=[];for(let i=0;i<t.length;i++){const{type:s,value:o}=t[i],a=flt[s];s==="era"?r[a]=o:dr(a)||(r[a]=parseInt(o,10))}return r}let _T={};class Df extends NC{static create(e){return _T[e]||(_T[e]=new Df(e)),_T[e]}static resetCache(){_T={},ZE={}}static isValidSpecifier(e){return this.isValidZone(e)}static isValidZone(e){if(!e)return!1;try{return new Intl.DateTimeFormat("en-US",{timeZone:e}).format(),!0}catch{return!1}}constructor(e){super(),this.zoneName=e,this.valid=Df.isValidZone(e)}get type(){return"iana"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(e,{format:t,locale:r}){return use(e,t,r,this.name)}formatOffset(e,t){return n_(this.offset(e),t)}offset(e){const t=new Date(e);if(isNaN(t))return NaN;const r=hlt(this.name);let[i,s,o,a,l,c,u]=r.formatToParts?plt(r,t):dlt(r,t);a==="BC"&&(i=-Math.abs(i)+1);const f=_$({year:i,month:s,day:o,hour:l===24?0:l,minute:c,second:u,millisecond:0});let d=+t;const p=d%1e3;return d-=p>=0?p:1e3+p,(f-d)/(60*1e3)}equals(e){return e.type==="iana"&&e.name===this.name}get isValid(){return this.valid}}let F5={};function mlt(n,e={}){const t=JSON.stringify([n,e]);let r=F5[t];return r||(r=new Intl.ListFormat(n,e),F5[t]=r),r}let oF={};function aF(n,e={}){const t=JSON.stringify([n,e]);let r=oF[t];return r||(r=new Intl.DateTimeFormat(n,e),oF[t]=r),r}let lF={};function glt(n,e={}){const t=JSON.stringify([n,e]);let r=lF[t];return r||(r=new Intl.NumberFormat(n,e),lF[t]=r),r}let cF={};function ylt(n,e={}){const{base:t,...r}=e,i=JSON.stringify([n,r]);let s=cF[i];return s||(s=new Intl.RelativeTimeFormat(n,e),cF[i]=s),s}let M1=null;function blt(){return M1||(M1=new Intl.DateTimeFormat().resolvedOptions().locale,M1)}function vlt(n){const e=n.indexOf("-x-");e!==-1&&(n=n.substring(0,e));const t=n.indexOf("-u-");if(t===-1)return[n];{let r,i;try{r=aF(n).resolvedOptions(),i=n}catch{const l=n.substring(0,t);r=aF(l).resolvedOptions(),i=l}const{numberingSystem:s,calendar:o}=r;return[i,s,o]}}function wlt(n,e,t){return(t||e)&&(n.includes("-u-")||(n+="-u"),t&&(n+=`-ca-${t}`),e&&(n+=`-nu-${e}`)),n}function xlt(n){const e=[];for(let t=1;t<=12;t++){const r=wn.utc(2009,t,1);e.push(n(r))}return e}function _lt(n){const e=[];for(let t=1;t<=7;t++){const r=wn.utc(2016,11,13+t);e.push(n(r))}return e}function ST(n,e,t,r){const i=n.listingMode();return i==="error"?null:i==="en"?t(e):r(e)}function Slt(n){return n.numberingSystem&&n.numberingSystem!=="latn"?!1:n.numberingSystem==="latn"||!n.locale||n.locale.startsWith("en")||new Intl.DateTimeFormat(n.intl).resolvedOptions().numberingSystem==="latn"}class Clt{constructor(e,t,r){this.padTo=r.padTo||0,this.floor=r.floor||!1;const{padTo:i,floor:s,...o}=r;if(!t||Object.keys(o).length>0){const a={useGrouping:!1,...r};r.padTo>0&&(a.minimumIntegerDigits=r.padTo),this.inf=glt(e,a)}}format(e){if(this.inf){const t=this.floor?Math.floor(e):e;return this.inf.format(t)}else{const t=this.floor?Math.floor(e):$4(e,3);return bs(t,this.padTo)}}}class klt{constructor(e,t,r){this.opts=r,this.originalZone=void 0;let i;if(this.opts.timeZone)this.dt=e;else if(e.zone.type==="fixed"){const o=-1*(e.offset/60),a=o>=0?`Etc/GMT+${o}`:`Etc/GMT${o}`;e.offset!==0&&Df.create(a).valid?(i=a,this.dt=e):(i="UTC",this.dt=e.offset===0?e:e.setZone("UTC").plus({minutes:e.offset}),this.originalZone=e.zone)}else e.zone.type==="system"?this.dt=e:e.zone.type==="iana"?(this.dt=e,i=e.zone.name):(i="UTC",this.dt=e.setZone("UTC").plus({minutes:e.offset}),this.originalZone=e.zone);const s={...this.opts};s.timeZone=s.timeZone||i,this.dtf=aF(t,s)}format(){return this.originalZone?this.formatToParts().map(({value:e})=>e).join(""):this.dtf.format(this.dt.toJSDate())}formatToParts(){const e=this.dtf.formatToParts(this.dt.toJSDate());return this.originalZone?e.map(t=>{if(t.type==="timeZoneName"){const r=this.originalZone.offsetName(this.dt.ts,{locale:this.dt.locale,format:this.opts.timeZoneName});return{...t,value:r}}else return t}):e}resolvedOptions(){return this.dtf.resolvedOptions()}}class Tlt{constructor(e,t,r){this.opts={style:"long",...r},!t&&cse()&&(this.rtf=ylt(e,r))}format(e,t){return this.rtf?this.rtf.format(e,t):Wlt(t,e,this.opts.numeric,this.opts.style!=="long")}formatToParts(e,t){return this.rtf?this.rtf.formatToParts(e,t):[]}}class fi{static fromOpts(e){return fi.create(e.locale,e.numberingSystem,e.outputCalendar,e.defaultToEN)}static create(e,t,r,i=!1){const s=e||gs.defaultLocale,o=s||(i?"en-US":blt()),a=t||gs.defaultNumberingSystem,l=r||gs.defaultOutputCalendar;return new fi(o,a,l,s)}static resetCache(){M1=null,oF={},lF={},cF={}}static fromObject({locale:e,numberingSystem:t,outputCalendar:r}={}){return fi.create(e,t,r)}constructor(e,t,r,i){const[s,o,a]=vlt(e);this.locale=s,this.numberingSystem=t||o||null,this.outputCalendar=r||a||null,this.intl=wlt(this.locale,this.numberingSystem,this.outputCalendar),this.weekdaysCache={format:{},standalone:{}},this.monthsCache={format:{},standalone:{}},this.meridiemCache=null,this.eraCache={},this.specifiedLocale=i,this.fastNumbersCached=null}get fastNumbers(){return this.fastNumbersCached==null&&(this.fastNumbersCached=Slt(this)),this.fastNumbersCached}listingMode(){const e=this.isEnglish(),t=(this.numberingSystem===null||this.numberingSystem==="latn")&&(this.outputCalendar===null||this.outputCalendar==="gregory");return e&&t?"en":"intl"}clone(e){return!e||Object.getOwnPropertyNames(e).length===0?this:fi.create(e.locale||this.specifiedLocale,e.numberingSystem||this.numberingSystem,e.outputCalendar||this.outputCalendar,e.defaultToEN||!1)}redefaultToEN(e={}){return this.clone({...e,defaultToEN:!0})}redefaultToSystem(e={}){return this.clone({...e,defaultToEN:!1})}months(e,t=!1){return ST(this,e,dse,()=>{const r=t?{month:e,day:"numeric"}:{month:e},i=t?"format":"standalone";return this.monthsCache[i][e]||(this.monthsCache[i][e]=xlt(s=>this.extract(s,r,"month"))),this.monthsCache[i][e]})}weekdays(e,t=!1){return ST(this,e,gse,()=>{const r=t?{weekday:e,year:"numeric",month:"long",day:"numeric"}:{weekday:e},i=t?"format":"standalone";return this.weekdaysCache[i][e]||(this.weekdaysCache[i][e]=_lt(s=>this.extract(s,r,"weekday"))),this.weekdaysCache[i][e]})}meridiems(){return ST(this,void 0,()=>yse,()=>{if(!this.meridiemCache){const e={hour:"numeric",hourCycle:"h12"};this.meridiemCache=[wn.utc(2016,11,13,9),wn.utc(2016,11,13,19)].map(t=>this.extract(t,e,"dayperiod"))}return this.meridiemCache})}eras(e){return ST(this,e,bse,()=>{const t={era:e};return this.eraCache[e]||(this.eraCache[e]=[wn.utc(-40,1,1),wn.utc(2017,1,1)].map(r=>this.extract(r,t,"era"))),this.eraCache[e]})}extract(e,t,r){const i=this.dtFormatter(e,t),s=i.formatToParts(),o=s.find(a=>a.type.toLowerCase()===r);return o?o.value:null}numberFormatter(e={}){return new Clt(this.intl,e.forceSimple||this.fastNumbers,e)}dtFormatter(e,t={}){return new klt(e,this.intl,t)}relFormatter(e={}){return new Tlt(this.intl,this.isEnglish(),e)}listFormatter(e={}){return mlt(this.intl,e)}isEnglish(){return this.locale==="en"||this.locale.toLowerCase()==="en-us"||new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")}equals(e){return this.locale===e.locale&&this.numberingSystem===e.numberingSystem&&this.outputCalendar===e.outputCalendar}}let B3=null;class ya extends NC{static get utcInstance(){return B3===null&&(B3=new ya(0)),B3}static instance(e){return e===0?ya.utcInstance:new ya(e)}static parseSpecifier(e){if(e){const t=e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);if(t)return new ya(S$(t[1],t[2]))}return null}constructor(e){super(),this.fixed=e}get type(){return"fixed"}get name(){return this.fixed===0?"UTC":`UTC${n_(this.fixed,"narrow")}`}get ianaName(){return this.fixed===0?"Etc/UTC":`Etc/GMT${n_(-this.fixed,"narrow")}`}offsetName(){return this.name}formatOffset(e,t){return n_(this.fixed,t)}get isUniversal(){return!0}offset(){return this.fixed}equals(e){return e.type==="fixed"&&e.fixed===this.fixed}get isValid(){return!0}}class Elt extends NC{constructor(e){super(),this.zoneName=e}get type(){return"invalid"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(){return null}formatOffset(){return""}offset(){return NaN}equals(){return!1}get isValid(){return!1}}function kd(n,e){if(dr(n)||n===null)return e;if(n instanceof NC)return n;if(Ilt(n)){const t=n.toLowerCase();return t==="default"?e:t==="local"||t==="system"?w$.instance:t==="utc"||t==="gmt"?ya.utcInstance:ya.parseSpecifier(t)||Df.create(n)}else return Xm(n)?ya.instance(n):typeof n=="object"&&"offset"in n&&typeof n.offset=="function"?n:new Elt(n)}let L5=()=>Date.now(),z5="system",B5=null,V5=null,U5=null,W5=60,H5;class gs{static get now(){return L5}static set now(e){L5=e}static set defaultZone(e){z5=e}static get defaultZone(){return kd(z5,w$.instance)}static get defaultLocale(){return B5}static set defaultLocale(e){B5=e}static get defaultNumberingSystem(){return V5}static set defaultNumberingSystem(e){V5=e}static get defaultOutputCalendar(){return U5}static set defaultOutputCalendar(e){U5=e}static get twoDigitCutoffYear(){return W5}static set twoDigitCutoffYear(e){W5=e%100}static get throwOnInvalid(){return H5}static set throwOnInvalid(e){H5=e}static resetCaches(){fi.resetCache(),Df.resetCache()}}function dr(n){return typeof n>"u"}function Xm(n){return typeof n=="number"}function x$(n){return typeof n=="number"&&n%1===0}function Ilt(n){return typeof n=="string"}function Alt(n){return Object.prototype.toString.call(n)==="[object Date]"}function cse(){try{return typeof Intl<"u"&&!!Intl.RelativeTimeFormat}catch{return!1}}function Mlt(n){return Array.isArray(n)?n:[n]}function G5(n,e,t){if(n.length!==0)return n.reduce((r,i)=>{const s=[e(i),i];return r&&t(r[0],s[0])===r[0]?r:s},null)[1]}function Nlt(n,e){return e.reduce((t,r)=>(t[r]=n[r],t),{})}function cv(n,e){return Object.prototype.hasOwnProperty.call(n,e)}function Ef(n,e,t){return x$(n)&&n>=e&&n<=t}function $lt(n,e){return n-e*Math.floor(n/e)}function bs(n,e=2){const t=n<0;let r;return t?r="-"+(""+-n).padStart(e,"0"):r=(""+n).padStart(e,"0"),r}function Sd(n){if(!(dr(n)||n===null||n===""))return parseInt(n,10)}function om(n){if(!(dr(n)||n===null||n===""))return parseFloat(n)}function N4(n){if(!(dr(n)||n===null||n==="")){const e=parseFloat("0."+n)*1e3;return Math.floor(e)}}function $4(n,e,t=!1){const r=10**e;return(t?Math.trunc:Math.round)(n*r)/r}function $C(n){return n%4===0&&(n%100!==0||n%400===0)}function t_(n){return $C(n)?366:365}function mA(n,e){const t=$lt(e-1,12)+1,r=n+(e-t)/12;return t===2?$C(r)?29:28:[31,null,31,30,31,30,31,31,30,31,30,31][t-1]}function _$(n){let e=Date.UTC(n.year,n.month-1,n.day,n.hour,n.minute,n.second,n.millisecond);return n.year<100&&n.year>=0&&(e=new Date(e),e.setUTCFullYear(n.year,n.month-1,n.day)),+e}function gA(n){const e=(n+Math.floor(n/4)-Math.floor(n/100)+Math.floor(n/400))%7,t=n-1,r=(t+Math.floor(t/4)-Math.floor(t/100)+Math.floor(t/400))%7;return e===4||r===3?53:52}function uF(n){return n>99?n:n>gs.twoDigitCutoffYear?1900+n:2e3+n}function use(n,e,t,r=null){const i=new Date(n),s={hourCycle:"h23",year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit"};r&&(s.timeZone=r);const o={timeZoneName:e,...s},a=new Intl.DateTimeFormat(t,o).formatToParts(i).find(l=>l.type.toLowerCase()==="timezonename");return a?a.value:null}function S$(n,e){let t=parseInt(n,10);Number.isNaN(t)&&(t=0);const r=parseInt(e,10)||0,i=t<0||Object.is(t,-0)?-r:r;return t*60+i}function hse(n){const e=Number(n);if(typeof n=="boolean"||n===""||Number.isNaN(e))throw new lc(`Invalid unit value ${n}`);return e}function yA(n,e){const t={};for(const r in n)if(cv(n,r)){const i=n[r];if(i==null)continue;t[e(r)]=hse(i)}return t}function n_(n,e){const t=Math.trunc(Math.abs(n/60)),r=Math.trunc(Math.abs(n%60)),i=n>=0?"+":"-";switch(e){case"short":return`${i}${bs(t,2)}:${bs(r,2)}`;case"narrow":return`${i}${t}${r>0?`:${r}`:""}`;case"techie":return`${i}${bs(t,2)}${bs(r,2)}`;default:throw new RangeError(`Value format ${e} is out of range for property format`)}}function C$(n){return Nlt(n,["hour","minute","second","millisecond"])}const Rlt=["January","February","March","April","May","June","July","August","September","October","November","December"],fse=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],Plt=["J","F","M","A","M","J","J","A","S","O","N","D"];function dse(n){switch(n){case"narrow":return[...Plt];case"short":return[...fse];case"long":return[...Rlt];case"numeric":return["1","2","3","4","5","6","7","8","9","10","11","12"];case"2-digit":return["01","02","03","04","05","06","07","08","09","10","11","12"];default:return null}}const pse=["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"],mse=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"],Dlt=["M","T","W","T","F","S","S"];function gse(n){switch(n){case"narrow":return[...Dlt];case"short":return[...mse];case"long":return[...pse];case"numeric":return["1","2","3","4","5","6","7"];default:return null}}const yse=["AM","PM"],Olt=["Before Christ","Anno Domini"],Flt=["BC","AD"],Llt=["B","A"];function bse(n){switch(n){case"narrow":return[...Llt];case"short":return[...Flt];case"long":return[...Olt];default:return null}}function zlt(n){return yse[n.hour<12?0:1]}function Blt(n,e){return gse(e)[n.weekday-1]}function Vlt(n,e){return dse(e)[n.month-1]}function Ult(n,e){return bse(e)[n.year<0?0:1]}function Wlt(n,e,t="always",r=!1){const i={years:["year","yr."],quarters:["quarter","qtr."],months:["month","mo."],weeks:["week","wk."],days:["day","day","days"],hours:["hour","hr."],minutes:["minute","min."],seconds:["second","sec."]},s=["hours","minutes","seconds"].indexOf(n)===-1;if(t==="auto"&&s){const h=n==="days";switch(e){case 1:return h?"tomorrow":`next ${i[n][0]}`;case-1:return h?"yesterday":`last ${i[n][0]}`;case 0:return h?"today":`this ${i[n][0]}`}}const o=Object.is(e,-0)||e<0,a=Math.abs(e),l=a===1,c=i[n],u=r?l?c[1]:c[2]||c[1]:l?i[n][0]:n;return o?`${a} ${u} ago`:`in ${a} ${u}`}function j5(n,e){let t="";for(const r of n)r.literal?t+=r.val:t+=e(r.val);return t}const Hlt={D:pA,DD:Hie,DDD:Gie,DDDD:jie,t:qie,tt:Xie,ttt:Kie,tttt:Yie,T:Zie,TT:Jie,TTT:Qie,TTTT:ese,f:tse,ff:rse,fff:sse,ffff:ase,F:nse,FF:ise,FFF:ose,FFFF:lse};class qo{static create(e,t={}){return new qo(e,t)}static parseFormat(e){let t=null,r="",i=!1;const s=[];for(let o=0;o<e.length;o++){const a=e.charAt(o);a==="'"?(r.length>0&&s.push({literal:i||/^\s+$/.test(r),val:r}),t=null,r="",i=!i):i||a===t?r+=a:(r.length>0&&s.push({literal:/^\s+$/.test(r),val:r}),r=a,t=a)}return r.length>0&&s.push({literal:i||/^\s+$/.test(r),val:r}),s}static macroTokenToFormatOpts(e){return Hlt[e]}constructor(e,t){this.opts=t,this.loc=e,this.systemLoc=null}formatWithSystemDefault(e,t){return this.systemLoc===null&&(this.systemLoc=this.loc.redefaultToSystem()),this.systemLoc.dtFormatter(e,{...this.opts,...t}).format()}dtFormatter(e,t={}){return this.loc.dtFormatter(e,{...this.opts,...t})}formatDateTime(e,t){return this.dtFormatter(e,t).format()}formatDateTimeParts(e,t){return this.dtFormatter(e,t).formatToParts()}formatInterval(e,t){return this.dtFormatter(e.start,t).dtf.formatRange(e.start.toJSDate(),e.end.toJSDate())}resolvedOptions(e,t){return this.dtFormatter(e,t).resolvedOptions()}num(e,t=0){if(this.opts.forceSimple)return bs(e,t);const r={...this.opts};return t>0&&(r.padTo=t),this.loc.numberFormatter(r).format(e)}formatDateTimeFromString(e,t){const r=this.loc.listingMode()==="en",i=this.loc.outputCalendar&&this.loc.outputCalendar!=="gregory",s=(d,p)=>this.loc.extract(e,d,p),o=d=>e.isOffsetFixed&&e.offset===0&&d.allowZ?"Z":e.isValid?e.zone.formatOffset(e.ts,d.format):"",a=()=>r?zlt(e):s({hour:"numeric",hourCycle:"h12"},"dayperiod"),l=(d,p)=>r?Vlt(e,d):s(p?{month:d}:{month:d,day:"numeric"},"month"),c=(d,p)=>r?Blt(e,d):s(p?{weekday:d}:{weekday:d,month:"long",day:"numeric"},"weekday"),u=d=>{const p=qo.macroTokenToFormatOpts(d);return p?this.formatWithSystemDefault(e,p):d},h=d=>r?Ult(e,d):s({era:d},"era"),f=d=>{switch(d){case"S":return this.num(e.millisecond);case"u":case"SSS":return this.num(e.millisecond,3);case"s":return this.num(e.second);case"ss":return this.num(e.second,2);case"uu":return this.num(Math.floor(e.millisecond/10),2);case"uuu":return this.num(Math.floor(e.millisecond/100));case"m":return this.num(e.minute);case"mm":return this.num(e.minute,2);case"h":return this.num(e.hour%12===0?12:e.hour%12);case"hh":return this.num(e.hour%12===0?12:e.hour%12,2);case"H":return this.num(e.hour);case"HH":return this.num(e.hour,2);case"Z":return o({format:"narrow",allowZ:this.opts.allowZ});case"ZZ":return o({format:"short",allowZ:this.opts.allowZ});case"ZZZ":return o({format:"techie",allowZ:this.opts.allowZ});case"ZZZZ":return e.zone.offsetName(e.ts,{format:"short",locale:this.loc.locale});case"ZZZZZ":return e.zone.offsetName(e.ts,{format:"long",locale:this.loc.locale});case"z":return e.zoneName;case"a":return a();case"d":return i?s({day:"numeric"},"day"):this.num(e.day);case"dd":return i?s({day:"2-digit"},"day"):this.num(e.day,2);case"c":return this.num(e.weekday);case"ccc":return c("short",!0);case"cccc":return c("long",!0);case"ccccc":return c("narrow",!0);case"E":return this.num(e.weekday);case"EEE":return c("short",!1);case"EEEE":return c("long",!1);case"EEEEE":return c("narrow",!1);case"L":return i?s({month:"numeric",day:"numeric"},"month"):this.num(e.month);case"LL":return i?s({month:"2-digit",day:"numeric"},"month"):this.num(e.month,2);case"LLL":return l("short",!0);case"LLLL":return l("long",!0);case"LLLLL":return l("narrow",!0);case"M":return i?s({month:"numeric"},"month"):this.num(e.month);case"MM":return i?s({month:"2-digit"},"month"):this.num(e.month,2);case"MMM":return l("short",!1);case"MMMM":return l("long",!1);case"MMMMM":return l("narrow",!1);case"y":return i?s({year:"numeric"},"year"):this.num(e.year);case"yy":return i?s({year:"2-digit"},"year"):this.num(e.year.toString().slice(-2),2);case"yyyy":return i?s({year:"numeric"},"year"):this.num(e.year,4);case"yyyyyy":return i?s({year:"numeric"},"year"):this.num(e.year,6);case"G":return h("short");case"GG":return h("long");case"GGGGG":return h("narrow");case"kk":return this.num(e.weekYear.toString().slice(-2),2);case"kkkk":return this.num(e.weekYear,4);case"W":return this.num(e.weekNumber);case"WW":return this.num(e.weekNumber,2);case"o":return this.num(e.ordinal);case"ooo":return this.num(e.ordinal,3);case"q":return this.num(e.quarter);case"qq":return this.num(e.quarter,2);case"X":return this.num(Math.floor(e.ts/1e3));case"x":return this.num(e.ts);default:return u(d)}};return j5(qo.parseFormat(t),f)}formatDurationFromString(e,t){const r=l=>{switch(l[0]){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":return"hour";case"d":return"day";case"w":return"week";case"M":return"month";case"y":return"year";default:return null}},i=l=>c=>{const u=r(c);return u?this.num(l.get(u),c.length):c},s=qo.parseFormat(t),o=s.reduce((l,{literal:c,val:u})=>c?l:l.concat(u),[]),a=e.shiftTo(...o.map(r).filter(l=>l));return j5(s,i(a))}}class gu{constructor(e,t){this.reason=e,this.explanation=t}toMessage(){return this.explanation?`${this.reason}: ${this.explanation}`:this.reason}}const vse=/[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;function Jw(...n){const e=n.reduce((t,r)=>t+r.source,"");return RegExp(`^${e}$`)}function Qw(...n){return e=>n.reduce(([t,r,i],s)=>{const[o,a,l]=s(e,i);return[{...t,...o},a||r,l]},[{},null,1]).slice(0,2)}function ex(n,...e){if(n==null)return[null,null];for(const[t,r]of e){const i=t.exec(n);if(i)return r(i)}return[null,null]}function wse(...n){return(e,t)=>{const r={};let i;for(i=0;i<n.length;i++)r[n[i]]=Sd(e[t+i]);return[r,null,t+i]}}const xse=/(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,Glt=`(?:${xse.source}?(?:\\[(${vse.source})\\])?)?`,R4=/(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/,_se=RegExp(`${R4.source}${Glt}`),P4=RegExp(`(?:T${_se.source})?`),jlt=/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/,qlt=/(\d{4})-?W(\d\d)(?:-?(\d))?/,Xlt=/(\d{4})-?(\d{3})/,Klt=wse("weekYear","weekNumber","weekDay"),Ylt=wse("year","ordinal"),Zlt=/(\d{4})-(\d\d)-(\d\d)/,Sse=RegExp(`${R4.source} ?(?:${xse.source}|(${vse.source}))?`),Jlt=RegExp(`(?: ${Sse.source})?`);function Pb(n,e,t){const r=n[e];return dr(r)?t:Sd(r)}function Qlt(n,e){return[{year:Pb(n,e),month:Pb(n,e+1,1),day:Pb(n,e+2,1)},null,e+3]}function tx(n,e){return[{hours:Pb(n,e,0),minutes:Pb(n,e+1,0),seconds:Pb(n,e+2,0),milliseconds:N4(n[e+3])},null,e+4]}function RC(n,e){const t=!n[e]&&!n[e+1],r=S$(n[e+1],n[e+2]),i=t?null:ya.instance(r);return[{},i,e+3]}function PC(n,e){const t=n[e]?Df.create(n[e]):null;return[{},t,e+1]}const ect=RegExp(`^T?${R4.source}$`),tct=/^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;function nct(n){const[e,t,r,i,s,o,a,l,c]=n,u=e[0]==="-",h=l&&l[0]==="-",f=(d,p=!1)=>d!==void 0&&(p||d&&u)?-d:d;return[{years:f(om(t)),months:f(om(r)),weeks:f(om(i)),days:f(om(s)),hours:f(om(o)),minutes:f(om(a)),seconds:f(om(l),l==="-0"),milliseconds:f(N4(c),h)}]}const rct={GMT:0,EDT:-4*60,EST:-5*60,CDT:-5*60,CST:-6*60,MDT:-6*60,MST:-7*60,PDT:-7*60,PST:-8*60};function D4(n,e,t,r,i,s,o){const a={year:e.length===2?uF(Sd(e)):Sd(e),month:fse.indexOf(t)+1,day:Sd(r),hour:Sd(i),minute:Sd(s)};return o&&(a.second=Sd(o)),n&&(a.weekday=n.length>3?pse.indexOf(n)+1:mse.indexOf(n)+1),a}const ict=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;function sct(n){const[,e,t,r,i,s,o,a,l,c,u,h]=n,f=D4(e,i,r,t,s,o,a);let d;return l?d=rct[l]:c?d=0:d=S$(u,h),[f,new ya(d)]}function oct(n){return n.replace(/\([^()]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").trim()}const act=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,lct=/^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,cct=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;function q5(n){const[,e,t,r,i,s,o,a]=n;return[D4(e,i,r,t,s,o,a),ya.utcInstance]}function uct(n){const[,e,t,r,i,s,o,a]=n;return[D4(e,a,t,r,i,s,o),ya.utcInstance]}const hct=Jw(jlt,P4),fct=Jw(qlt,P4),dct=Jw(Xlt,P4),pct=Jw(_se),Cse=Qw(Qlt,tx,RC,PC),mct=Qw(Klt,tx,RC,PC),gct=Qw(Ylt,tx,RC,PC),yct=Qw(tx,RC,PC);function bct(n){return ex(n,[hct,Cse],[fct,mct],[dct,gct],[pct,yct])}function vct(n){return ex(oct(n),[ict,sct])}function wct(n){return ex(n,[act,q5],[lct,q5],[cct,uct])}function xct(n){return ex(n,[tct,nct])}const _ct=Qw(tx);function Sct(n){return ex(n,[ect,_ct])}const Cct=Jw(Zlt,Jlt),kct=Jw(Sse),Tct=Qw(tx,RC,PC);function Ect(n){return ex(n,[Cct,Cse],[kct,Tct])}const X5="Invalid Duration",kse={weeks:{days:7,hours:7*24,minutes:7*24*60,seconds:7*24*60*60,milliseconds:7*24*60*60*1e3},days:{hours:24,minutes:24*60,seconds:24*60*60,milliseconds:24*60*60*1e3},hours:{minutes:60,seconds:60*60,milliseconds:60*60*1e3},minutes:{seconds:60,milliseconds:60*1e3},seconds:{milliseconds:1e3}},Ict={years:{quarters:4,months:12,weeks:52,days:365,hours:365*24,minutes:365*24*60,seconds:365*24*60*60,milliseconds:365*24*60*60*1e3},quarters:{months:3,weeks:13,days:91,hours:91*24,minutes:91*24*60,seconds:91*24*60*60,milliseconds:91*24*60*60*1e3},months:{weeks:4,days:30,hours:30*24,minutes:30*24*60,seconds:30*24*60*60,milliseconds:30*24*60*60*1e3},...kse},tc=146097/400,F0=146097/4800,Act={years:{quarters:4,months:12,weeks:tc/7,days:tc,hours:tc*24,minutes:tc*24*60,seconds:tc*24*60*60,milliseconds:tc*24*60*60*1e3},quarters:{months:3,weeks:tc/28,days:tc/4,hours:tc*24/4,minutes:tc*24*60/4,seconds:tc*24*60*60/4,milliseconds:tc*24*60*60*1e3/4},months:{weeks:F0/7,days:F0,hours:F0*24,minutes:F0*24*60,seconds:F0*24*60*60,milliseconds:F0*24*60*60*1e3},...kse},zm=["years","quarters","months","weeks","days","hours","minutes","seconds","milliseconds"],Mct=zm.slice(0).reverse();function ld(n,e,t=!1){const r={values:t?e.values:{...n.values,...e.values||{}},loc:n.loc.clone(e.loc),conversionAccuracy:e.conversionAccuracy||n.conversionAccuracy,matrix:e.matrix||n.matrix};return new Sr(r)}function Tse(n,e){let t=e.milliseconds??0;for(const r of Mct.slice(1))e[r]&&(t+=e[r]*n[r].milliseconds);return t}function K5(n,e){const t=Tse(n,e)<0?-1:1;zm.reduceRight((r,i)=>{if(dr(e[i]))return r;if(r){const s=e[r]*t,o=n[i][r],a=Math.floor(s/o);e[i]+=a*t,e[r]-=a*o*t}return i},null),zm.reduce((r,i)=>{if(dr(e[i]))return r;if(r){const s=e[r]%1;e[r]-=s,e[i]+=s*n[r][i]}return i},null)}function Nct(n){const e={};for(const[t,r]of Object.entries(n))r!==0&&(e[t]=r);return e}class Sr{constructor(e){const t=e.conversionAccuracy==="longterm"||!1;let r=t?Act:Ict;e.matrix&&(r=e.matrix),this.values=e.values,this.loc=e.loc||fi.create(),this.conversionAccuracy=t?"longterm":"casual",this.invalid=e.invalid||null,this.matrix=r,this.isLuxonDuration=!0}static fromMillis(e,t){return Sr.fromObject({milliseconds:e},t)}static fromObject(e,t={}){if(e==null||typeof e!="object")throw new lc(`Duration.fromObject: argument expected to be an object, got ${e===null?"null":typeof e}`);return new Sr({values:yA(e,Sr.normalizeUnit),loc:fi.fromObject(t),conversionAccuracy:t.conversionAccuracy,matrix:t.matrix})}static fromDurationLike(e){if(Xm(e))return Sr.fromMillis(e);if(Sr.isDuration(e))return e;if(typeof e=="object")return Sr.fromObject(e);throw new lc(`Unknown duration argument ${e} of type ${typeof e}`)}static fromISO(e,t){const[r]=xct(e);return r?Sr.fromObject(r,t):Sr.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static fromISOTime(e,t){const[r]=Sct(e);return r?Sr.fromObject(r,t):Sr.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static invalid(e,t=null){if(!e)throw new lc("need to specify a reason the Duration is invalid");const r=e instanceof gu?e:new gu(e,t);if(gs.throwOnInvalid)throw new llt(r);return new Sr({invalid:r})}static normalizeUnit(e){const t={year:"years",years:"years",quarter:"quarters",quarters:"quarters",month:"months",months:"months",week:"weeks",weeks:"weeks",day:"days",days:"days",hour:"hours",hours:"hours",minute:"minutes",minutes:"minutes",second:"seconds",seconds:"seconds",millisecond:"milliseconds",milliseconds:"milliseconds"}[e&&e.toLowerCase()];if(!t)throw new Wie(e);return t}static isDuration(e){return e&&e.isLuxonDuration||!1}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}toFormat(e,t={}){const r={...t,floor:t.round!==!1&&t.floor!==!1};return this.isValid?qo.create(this.loc,r).formatDurationFromString(this,e):X5}toHuman(e={}){if(!this.isValid)return X5;const t=zm.map(r=>{const i=this.values[r];return dr(i)?null:this.loc.numberFormatter({style:"unit",unitDisplay:"long",...e,unit:r.slice(0,-1)}).format(i)}).filter(r=>r);return this.loc.listFormatter({type:"conjunction",style:e.listStyle||"narrow",...e}).format(t)}toObject(){return this.isValid?{...this.values}:{}}toISO(){if(!this.isValid)return null;let e="P";return this.years!==0&&(e+=this.years+"Y"),(this.months!==0||this.quarters!==0)&&(e+=this.months+this.quarters*3+"M"),this.weeks!==0&&(e+=this.weeks+"W"),this.days!==0&&(e+=this.days+"D"),(this.hours!==0||this.minutes!==0||this.seconds!==0||this.milliseconds!==0)&&(e+="T"),this.hours!==0&&(e+=this.hours+"H"),this.minutes!==0&&(e+=this.minutes+"M"),(this.seconds!==0||this.milliseconds!==0)&&(e+=$4(this.seconds+this.milliseconds/1e3,3)+"S"),e==="P"&&(e+="T0S"),e}toISOTime(e={}){if(!this.isValid)return null;const t=this.toMillis();return t<0||t>=864e5?null:(e={suppressMilliseconds:!1,suppressSeconds:!1,includePrefix:!1,format:"extended",...e,includeOffset:!1},wn.fromMillis(t,{zone:"UTC"}).toISOTime(e))}toJSON(){return this.toISO()}toString(){return this.toISO()}toMillis(){return this.isValid?Tse(this.matrix,this.values):NaN}valueOf(){return this.toMillis()}plus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e),r={};for(const i of zm)(cv(t.values,i)||cv(this.values,i))&&(r[i]=t.get(i)+this.get(i));return ld(this,{values:r},!0)}minus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e);return this.plus(t.negate())}mapUnits(e){if(!this.isValid)return this;const t={};for(const r of Object.keys(this.values))t[r]=hse(e(this.values[r],r));return ld(this,{values:t},!0)}get(e){return this[Sr.normalizeUnit(e)]}set(e){if(!this.isValid)return this;const t={...this.values,...yA(e,Sr.normalizeUnit)};return ld(this,{values:t})}reconfigure({locale:e,numberingSystem:t,conversionAccuracy:r,matrix:i}={}){const o={loc:this.loc.clone({locale:e,numberingSystem:t}),matrix:i,conversionAccuracy:r};return ld(this,o)}as(e){return this.isValid?this.shiftTo(e).get(e):NaN}normalize(){if(!this.isValid)return this;const e=this.toObject();return K5(this.matrix,e),ld(this,{values:e},!0)}rescale(){if(!this.isValid)return this;const e=Nct(this.normalize().shiftToAll().toObject());return ld(this,{values:e},!0)}shiftTo(...e){if(!this.isValid)return this;if(e.length===0)return this;e=e.map(o=>Sr.normalizeUnit(o));const t={},r={},i=this.toObject();let s;for(const o of zm)if(e.indexOf(o)>=0){s=o;let a=0;for(const c in r)a+=this.matrix[c][o]*r[c],r[c]=0;Xm(i[o])&&(a+=i[o]);const l=Math.trunc(a);t[o]=l,r[o]=(a*1e3-l*1e3)/1e3}else Xm(i[o])&&(r[o]=i[o]);for(const o in r)r[o]!==0&&(t[s]+=o===s?r[o]:r[o]/this.matrix[s][o]);return K5(this.matrix,t),ld(this,{values:t},!0)}shiftToAll(){return this.isValid?this.shiftTo("years","months","weeks","days","hours","minutes","seconds","milliseconds"):this}negate(){if(!this.isValid)return this;const e={};for(const t of Object.keys(this.values))e[t]=this.values[t]===0?0:-this.values[t];return ld(this,{values:e},!0)}get years(){return this.isValid?this.values.years||0:NaN}get quarters(){return this.isValid?this.values.quarters||0:NaN}get months(){return this.isValid?this.values.months||0:NaN}get weeks(){return this.isValid?this.values.weeks||0:NaN}get days(){return this.isValid?this.values.days||0:NaN}get hours(){return this.isValid?this.values.hours||0:NaN}get minutes(){return this.isValid?this.values.minutes||0:NaN}get seconds(){return this.isValid?this.values.seconds||0:NaN}get milliseconds(){return this.isValid?this.values.milliseconds||0:NaN}get isValid(){return this.invalid===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}equals(e){if(!this.isValid||!e.isValid||!this.loc.equals(e.loc))return!1;function t(r,i){return r===void 0||r===0?i===void 0||i===0:r===i}for(const r of zm)if(!t(this.values[r],e.values[r]))return!1;return!0}}const L0="Invalid Interval";function $ct(n,e){return!n||!n.isValid?Gi.invalid("missing or invalid start"):!e||!e.isValid?Gi.invalid("missing or invalid end"):e<n?Gi.invalid("end before start",`The end of an interval must be after its start, but you had start=${n.toISO()} and end=${e.toISO()}`):null}class Gi{constructor(e){this.s=e.start,this.e=e.end,this.invalid=e.invalid||null,this.isLuxonInterval=!0}static invalid(e,t=null){if(!e)throw new lc("need to specify a reason the Interval is invalid");const r=e instanceof gu?e:new gu(e,t);if(gs.throwOnInvalid)throw new alt(r);return new Gi({invalid:r})}static fromDateTimes(e,t){const r=Yx(e),i=Yx(t),s=$ct(r,i);return s??new Gi({start:r,end:i})}static after(e,t){const r=Sr.fromDurationLike(t),i=Yx(e);return Gi.fromDateTimes(i,i.plus(r))}static before(e,t){const r=Sr.fromDurationLike(t),i=Yx(e);return Gi.fromDateTimes(i.minus(r),i)}static fromISO(e,t){const[r,i]=(e||"").split("/",2);if(r&&i){let s,o;try{s=wn.fromISO(r,t),o=s.isValid}catch{o=!1}let a,l;try{a=wn.fromISO(i,t),l=a.isValid}catch{l=!1}if(o&&l)return Gi.fromDateTimes(s,a);if(o){const c=Sr.fromISO(i,t);if(c.isValid)return Gi.after(s,c)}else if(l){const c=Sr.fromISO(r,t);if(c.isValid)return Gi.before(a,c)}}return Gi.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static isInterval(e){return e&&e.isLuxonInterval||!1}get start(){return this.isValid?this.s:null}get end(){return this.isValid?this.e:null}get isValid(){return this.invalidReason===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}length(e="milliseconds"){return this.isValid?this.toDuration(e).get(e):NaN}count(e="milliseconds"){if(!this.isValid)return NaN;const t=this.start.startOf(e),r=this.end.startOf(e);return Math.floor(r.diff(t,e).get(e))+(r.valueOf()!==this.end.valueOf())}hasSame(e){return this.isValid?this.isEmpty()||this.e.minus(1).hasSame(this.s,e):!1}isEmpty(){return this.s.valueOf()===this.e.valueOf()}isAfter(e){return this.isValid?this.s>e:!1}isBefore(e){return this.isValid?this.e<=e:!1}contains(e){return this.isValid?this.s<=e&&this.e>e:!1}set({start:e,end:t}={}){return this.isValid?Gi.fromDateTimes(e||this.s,t||this.e):this}splitAt(...e){if(!this.isValid)return[];const t=e.map(Yx).filter(o=>this.contains(o)).sort(),r=[];let{s:i}=this,s=0;for(;i<this.e;){const o=t[s]||this.e,a=+o>+this.e?this.e:o;r.push(Gi.fromDateTimes(i,a)),i=a,s+=1}return r}splitBy(e){const t=Sr.fromDurationLike(e);if(!this.isValid||!t.isValid||t.as("milliseconds")===0)return[];let{s:r}=this,i=1,s;const o=[];for(;r<this.e;){const a=this.start.plus(t.mapUnits(l=>l*i));s=+a>+this.e?this.e:a,o.push(Gi.fromDateTimes(r,s)),r=s,i+=1}return o}divideEqually(e){return this.isValid?this.splitBy(this.length()/e).slice(0,e):[]}overlaps(e){return this.e>e.s&&this.s<e.e}abutsStart(e){return this.isValid?+this.e==+e.s:!1}abutsEnd(e){return this.isValid?+e.e==+this.s:!1}engulfs(e){return this.isValid?this.s<=e.s&&this.e>=e.e:!1}equals(e){return!this.isValid||!e.isValid?!1:this.s.equals(e.s)&&this.e.equals(e.e)}intersection(e){if(!this.isValid)return this;const t=this.s>e.s?this.s:e.s,r=this.e<e.e?this.e:e.e;return t>=r?null:Gi.fromDateTimes(t,r)}union(e){if(!this.isValid)return this;const t=this.s<e.s?this.s:e.s,r=this.e>e.e?this.e:e.e;return Gi.fromDateTimes(t,r)}static merge(e){const[t,r]=e.sort((i,s)=>i.s-s.s).reduce(([i,s],o)=>s?s.overlaps(o)||s.abutsStart(o)?[i,s.union(o)]:[i.concat([s]),o]:[i,o],[[],null]);return r&&t.push(r),t}static xor(e){let t=null,r=0;const i=[],s=e.map(l=>[{time:l.s,type:"s"},{time:l.e,type:"e"}]),o=Array.prototype.concat(...s),a=o.sort((l,c)=>l.time-c.time);for(const l of a)r+=l.type==="s"?1:-1,r===1?t=l.time:(t&&+t!=+l.time&&i.push(Gi.fromDateTimes(t,l.time)),t=null);return Gi.merge(i)}difference(...e){return Gi.xor([this].concat(e)).map(t=>this.intersection(t)).filter(t=>t&&!t.isEmpty())}toString(){return this.isValid?`[${this.s.toISO()} – ${this.e.toISO()})`:L0}toLocaleString(e=pA,t={}){return this.isValid?qo.create(this.s.loc.clone(t),e).formatInterval(this):L0}toISO(e){return this.isValid?`${this.s.toISO(e)}/${this.e.toISO(e)}`:L0}toISODate(){return this.isValid?`${this.s.toISODate()}/${this.e.toISODate()}`:L0}toISOTime(e){return this.isValid?`${this.s.toISOTime(e)}/${this.e.toISOTime(e)}`:L0}toFormat(e,{separator:t=" – "}={}){return this.isValid?`${this.s.toFormat(e)}${t}${this.e.toFormat(e)}`:L0}toDuration(e,t){return this.isValid?this.e.diff(this.s,e,t):Sr.invalid(this.invalidReason)}mapEndpoints(e){return Gi.fromDateTimes(e(this.s),e(this.e))}}class CT{static hasDST(e=gs.defaultZone){const t=wn.now().setZone(e).set({month:12});return!e.isUniversal&&t.offset!==t.set({month:6}).offset}static isValidIANAZone(e){return Df.isValidZone(e)}static normalizeZone(e){return kd(e,gs.defaultZone)}static months(e="long",{locale:t=null,numberingSystem:r=null,locObj:i=null,outputCalendar:s="gregory"}={}){return(i||fi.create(t,r,s)).months(e)}static monthsFormat(e="long",{locale:t=null,numberingSystem:r=null,locObj:i=null,outputCalendar:s="gregory"}={}){return(i||fi.create(t,r,s)).months(e,!0)}static weekdays(e="long",{locale:t=null,numberingSystem:r=null,locObj:i=null}={}){return(i||fi.create(t,r,null)).weekdays(e)}static weekdaysFormat(e="long",{locale:t=null,numberingSystem:r=null,locObj:i=null}={}){return(i||fi.create(t,r,null)).weekdays(e,!0)}static meridiems({locale:e=null}={}){return fi.create(e).meridiems()}static eras(e="short",{locale:t=null}={}){return fi.create(t,null,"gregory").eras(e)}static features(){return{relative:cse()}}}function Y5(n,e){const t=i=>i.toUTC(0,{keepLocalTime:!0}).startOf("day").valueOf(),r=t(e)-t(n);return Math.floor(Sr.fromMillis(r).as("days"))}function Rct(n,e,t){const r=[["years",(l,c)=>c.year-l.year],["quarters",(l,c)=>c.quarter-l.quarter+(c.year-l.year)*4],["months",(l,c)=>c.month-l.month+(c.year-l.year)*12],["weeks",(l,c)=>{const u=Y5(l,c);return(u-u%7)/7}],["days",Y5]],i={},s=n;let o,a;for(const[l,c]of r)t.indexOf(l)>=0&&(o=l,i[l]=c(n,e),a=s.plus(i),a>e?(i[l]--,n=s.plus(i),n>e&&(a=n,i[l]--,n=s.plus(i))):n=a);return[n,i,a,o]}function Pct(n,e,t,r){let[i,s,o,a]=Rct(n,e,t);const l=e-i,c=t.filter(h=>["hours","minutes","seconds","milliseconds"].indexOf(h)>=0);c.length===0&&(o<e&&(o=i.plus({[a]:1})),o!==i&&(s[a]=(s[a]||0)+l/(o-i)));const u=Sr.fromObject(s,r);return c.length>0?Sr.fromMillis(l,r).shiftTo(...c).plus(u):u}const O4={arab:"[٠-٩]",arabext:"[۰-۹]",bali:"[᭐-᭙]",beng:"[০-৯]",deva:"[०-९]",fullwide:"[０-９]",gujr:"[૦-૯]",hanidec:"[〇|一|二|三|四|五|六|七|八|九]",khmr:"[០-៩]",knda:"[೦-೯]",laoo:"[໐-໙]",limb:"[᥆-᥏]",mlym:"[൦-൯]",mong:"[᠐-᠙]",mymr:"[၀-၉]",orya:"[୦-୯]",tamldec:"[௦-௯]",telu:"[౦-౯]",thai:"[๐-๙]",tibt:"[༠-༩]",latn:"\\d"},Z5={arab:[1632,1641],arabext:[1776,1785],bali:[6992,7001],beng:[2534,2543],deva:[2406,2415],fullwide:[65296,65303],gujr:[2790,2799],khmr:[6112,6121],knda:[3302,3311],laoo:[3792,3801],limb:[6470,6479],mlym:[3430,3439],mong:[6160,6169],mymr:[4160,4169],orya:[2918,2927],tamldec:[3046,3055],telu:[3174,3183],thai:[3664,3673],tibt:[3872,3881]},Dct=O4.hanidec.replace(/[\[|\]]/g,"").split("");function Oct(n){let e=parseInt(n,10);if(isNaN(e)){e="";for(let t=0;t<n.length;t++){const r=n.charCodeAt(t);if(n[t].search(O4.hanidec)!==-1)e+=Dct.indexOf(n[t]);else for(const i in Z5){const[s,o]=Z5[i];r>=s&&r<=o&&(e+=r-s)}}return parseInt(e,10)}else return e}function Zc({numberingSystem:n},e=""){return new RegExp(`${O4[n||"latn"]}${e}`)}const Fct="missing Intl.DateTimeFormat.formatToParts support";function Ir(n,e=t=>t){return{regex:n,deser:([t])=>e(Oct(t))}}const Lct=String.fromCharCode(160),Ese=`[ ${Lct}]`,Ise=new RegExp(Ese,"g");function zct(n){return n.replace(/\./g,"\\.?").replace(Ise,Ese)}function J5(n){return n.replace(/\./g,"").replace(Ise," ").toLowerCase()}function Jc(n,e){return n===null?null:{regex:RegExp(n.map(zct).join("|")),deser:([t])=>n.findIndex(r=>J5(t)===J5(r))+e}}function Q5(n,e){return{regex:n,deser:([,t,r])=>S$(t,r),groups:e}}function kT(n){return{regex:n,deser:([e])=>e}}function Bct(n){return n.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")}function Vct(n,e){const t=Zc(e),r=Zc(e,"{2}"),i=Zc(e,"{3}"),s=Zc(e,"{4}"),o=Zc(e,"{6}"),a=Zc(e,"{1,2}"),l=Zc(e,"{1,3}"),c=Zc(e,"{1,6}"),u=Zc(e,"{1,9}"),h=Zc(e,"{2,4}"),f=Zc(e,"{4,6}"),d=g=>({regex:RegExp(Bct(g.val)),deser:([y])=>y,literal:!0}),m=(g=>{if(n.literal)return d(g);switch(g.val){case"G":return Jc(e.eras("short"),0);case"GG":return Jc(e.eras("long"),0);case"y":return Ir(c);case"yy":return Ir(h,uF);case"yyyy":return Ir(s);case"yyyyy":return Ir(f);case"yyyyyy":return Ir(o);case"M":return Ir(a);case"MM":return Ir(r);case"MMM":return Jc(e.months("short",!0),1);case"MMMM":return Jc(e.months("long",!0),1);case"L":return Ir(a);case"LL":return Ir(r);case"LLL":return Jc(e.months("short",!1),1);case"LLLL":return Jc(e.months("long",!1),1);case"d":return Ir(a);case"dd":return Ir(r);case"o":return Ir(l);case"ooo":return Ir(i);case"HH":return Ir(r);case"H":return Ir(a);case"hh":return Ir(r);case"h":return Ir(a);case"mm":return Ir(r);case"m":return Ir(a);case"q":return Ir(a);case"qq":return Ir(r);case"s":return Ir(a);case"ss":return Ir(r);case"S":return Ir(l);case"SSS":return Ir(i);case"u":return kT(u);case"uu":return kT(a);case"uuu":return Ir(t);case"a":return Jc(e.meridiems(),0);case"kkkk":return Ir(s);case"kk":return Ir(h,uF);case"W":return Ir(a);case"WW":return Ir(r);case"E":case"c":return Ir(t);case"EEE":return Jc(e.weekdays("short",!1),1);case"EEEE":return Jc(e.weekdays("long",!1),1);case"ccc":return Jc(e.weekdays("short",!0),1);case"cccc":return Jc(e.weekdays("long",!0),1);case"Z":case"ZZ":return Q5(new RegExp(`([+-]${a.source})(?::(${r.source}))?`),2);case"ZZZ":return Q5(new RegExp(`([+-]${a.source})(${r.source})?`),2);case"z":return kT(/[a-z_+-/]{1,256}?/i);case" ":return kT(/[^\S\n\r]/);default:return d(g)}})(n)||{invalidReason:Fct};return m.token=n,m}const Uct={year:{"2-digit":"yy",numeric:"yyyyy"},month:{numeric:"M","2-digit":"MM",short:"MMM",long:"MMMM"},day:{numeric:"d","2-digit":"dd"},weekday:{short:"EEE",long:"EEEE"},dayperiod:"a",dayPeriod:"a",hour12:{numeric:"h","2-digit":"hh"},hour24:{numeric:"H","2-digit":"HH"},minute:{numeric:"m","2-digit":"mm"},second:{numeric:"s","2-digit":"ss"},timeZoneName:{long:"ZZZZZ",short:"ZZZ"}};function Wct(n,e,t){const{type:r,value:i}=n;if(r==="literal"){const l=/^\s+$/.test(i);return{literal:!l,val:l?" ":i}}const s=e[r];let o=r;r==="hour"&&(e.hour12!=null?o=e.hour12?"hour12":"hour24":e.hourCycle!=null?e.hourCycle==="h11"||e.hourCycle==="h12"?o="hour12":o="hour24":o=t.hour12?"hour12":"hour24");let a=Uct[o];if(typeof a=="object"&&(a=a[s]),a)return{literal:!1,val:a}}function Hct(n){return[`^${n.map(t=>t.regex).reduce((t,r)=>`${t}(${r.source})`,"")}$`,n]}function Gct(n,e,t){const r=n.match(e);if(r){const i={};let s=1;for(const o in t)if(cv(t,o)){const a=t[o],l=a.groups?a.groups+1:1;!a.literal&&a.token&&(i[a.token.val[0]]=a.deser(r.slice(s,s+l))),s+=l}return[r,i]}else return[r,{}]}function jct(n){const e=s=>{switch(s){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":case"H":return"hour";case"d":return"day";case"o":return"ordinal";case"L":case"M":return"month";case"y":return"year";case"E":case"c":return"weekday";case"W":return"weekNumber";case"k":return"weekYear";case"q":return"quarter";default:return null}};let t=null,r;return dr(n.z)||(t=Df.create(n.z)),dr(n.Z)||(t||(t=new ya(n.Z)),r=n.Z),dr(n.q)||(n.M=(n.q-1)*3+1),dr(n.h)||(n.h<12&&n.a===1?n.h+=12:n.h===12&&n.a===0&&(n.h=0)),n.G===0&&n.y&&(n.y=-n.y),dr(n.u)||(n.S=N4(n.u)),[Object.keys(n).reduce((s,o)=>{const a=e(o);return a&&(s[a]=n[o]),s},{}),t,r]}let V3=null;function qct(){return V3||(V3=wn.fromMillis(1555555555555)),V3}function Xct(n,e){if(n.literal)return n;const t=qo.macroTokenToFormatOpts(n.val),r=Nse(t,e);return r==null||r.includes(void 0)?n:r}function Ase(n,e){return Array.prototype.concat(...n.map(t=>Xct(t,e)))}function Mse(n,e,t){const r=Ase(qo.parseFormat(t),n),i=r.map(o=>Vct(o,n)),s=i.find(o=>o.invalidReason);if(s)return{input:e,tokens:r,invalidReason:s.invalidReason};{const[o,a]=Hct(i),l=RegExp(o,"i"),[c,u]=Gct(e,l,a),[h,f,d]=u?jct(u):[null,null,void 0];if(cv(u,"a")&&cv(u,"H"))throw new A1("Can't include meridiem when specifying 24-hour format");return{input:e,tokens:r,regex:l,rawMatches:c,matches:u,result:h,zone:f,specificOffset:d}}}function Kct(n,e,t){const{result:r,zone:i,specificOffset:s,invalidReason:o}=Mse(n,e,t);return[r,i,s,o]}function Nse(n,e){if(!n)return null;const r=qo.create(e,n).dtFormatter(qct()),i=r.formatToParts(),s=r.resolvedOptions();return i.map(o=>Wct(o,n,s))}const $se=[0,31,59,90,120,151,181,212,243,273,304,334],Rse=[0,31,60,91,121,152,182,213,244,274,305,335];function yc(n,e){return new gu("unit out of range",`you specified ${e} (of type ${typeof e}) as a ${n}, which is invalid`)}function Pse(n,e,t){const r=new Date(Date.UTC(n,e-1,t));n<100&&n>=0&&r.setUTCFullYear(r.getUTCFullYear()-1900);const i=r.getUTCDay();return i===0?7:i}function Dse(n,e,t){return t+($C(n)?Rse:$se)[e-1]}function Ose(n,e){const t=$C(n)?Rse:$se,r=t.findIndex(s=>s<e),i=e-t[r];return{month:r+1,day:i}}function hF(n){const{year:e,month:t,day:r}=n,i=Dse(e,t,r),s=Pse(e,t,r);let o=Math.floor((i-s+10)/7),a;return o<1?(a=e-1,o=gA(a)):o>gA(e)?(a=e+1,o=1):a=e,{weekYear:a,weekNumber:o,weekday:s,...C$(n)}}function ej(n){const{weekYear:e,weekNumber:t,weekday:r}=n,i=Pse(e,1,4),s=t_(e);let o=t*7+r-i-3,a;o<1?(a=e-1,o+=t_(a)):o>s?(a=e+1,o-=t_(e)):a=e;const{month:l,day:c}=Ose(a,o);return{year:a,month:l,day:c,...C$(n)}}function U3(n){const{year:e,month:t,day:r}=n,i=Dse(e,t,r);return{year:e,ordinal:i,...C$(n)}}function tj(n){const{year:e,ordinal:t}=n,{month:r,day:i}=Ose(e,t);return{year:e,month:r,day:i,...C$(n)}}function Yct(n){const e=x$(n.weekYear),t=Ef(n.weekNumber,1,gA(n.weekYear)),r=Ef(n.weekday,1,7);return e?t?r?!1:yc("weekday",n.weekday):yc("week",n.week):yc("weekYear",n.weekYear)}function Zct(n){const e=x$(n.year),t=Ef(n.ordinal,1,t_(n.year));return e?t?!1:yc("ordinal",n.ordinal):yc("year",n.year)}function Fse(n){const e=x$(n.year),t=Ef(n.month,1,12),r=Ef(n.day,1,mA(n.year,n.month));return e?t?r?!1:yc("day",n.day):yc("month",n.month):yc("year",n.year)}function Lse(n){const{hour:e,minute:t,second:r,millisecond:i}=n,s=Ef(e,0,23)||e===24&&t===0&&r===0&&i===0,o=Ef(t,0,59),a=Ef(r,0,59),l=Ef(i,0,999);return s?o?a?l?!1:yc("millisecond",i):yc("second",r):yc("minute",t):yc("hour",e)}const W3="Invalid DateTime",nj=864e13;function TT(n){return new gu("unsupported zone",`the zone "${n.name}" is not supported`)}function H3(n){return n.weekData===null&&(n.weekData=hF(n.c)),n.weekData}function am(n,e){const t={ts:n.ts,zone:n.zone,c:n.c,o:n.o,loc:n.loc,invalid:n.invalid};return new wn({...t,...e,old:t})}function zse(n,e,t){let r=n-e*60*1e3;const i=t.offset(r);if(e===i)return[r,e];r-=(i-e)*60*1e3;const s=t.offset(r);return i===s?[r,i]:[n-Math.min(i,s)*60*1e3,Math.max(i,s)]}function ET(n,e){n+=e*60*1e3;const t=new Date(n);return{year:t.getUTCFullYear(),month:t.getUTCMonth()+1,day:t.getUTCDate(),hour:t.getUTCHours(),minute:t.getUTCMinutes(),second:t.getUTCSeconds(),millisecond:t.getUTCMilliseconds()}}function JE(n,e,t){return zse(_$(n),e,t)}function rj(n,e){const t=n.o,r=n.c.year+Math.trunc(e.years),i=n.c.month+Math.trunc(e.months)+Math.trunc(e.quarters)*3,s={...n.c,year:r,month:i,day:Math.min(n.c.day,mA(r,i))+Math.trunc(e.days)+Math.trunc(e.weeks)*7},o=Sr.fromObject({years:e.years-Math.trunc(e.years),quarters:e.quarters-Math.trunc(e.quarters),months:e.months-Math.trunc(e.months),weeks:e.weeks-Math.trunc(e.weeks),days:e.days-Math.trunc(e.days),hours:e.hours,minutes:e.minutes,seconds:e.seconds,milliseconds:e.milliseconds}).as("milliseconds"),a=_$(s);let[l,c]=zse(a,t,n.zone);return o!==0&&(l+=o,c=n.zone.offset(l)),{ts:l,o:c}}function Kx(n,e,t,r,i,s){const{setZone:o,zone:a}=t;if(n&&Object.keys(n).length!==0||e){const l=e||a,c=wn.fromObject(n,{...t,zone:l,specificOffset:s});return o?c:c.setZone(a)}else return wn.invalid(new gu("unparsable",`the input "${i}" can't be parsed as ${r}`))}function IT(n,e,t=!0){return n.isValid?qo.create(fi.create("en-US"),{allowZ:t,forceSimple:!0}).formatDateTimeFromString(n,e):null}function G3(n,e){const t=n.c.year>9999||n.c.year<0;let r="";return t&&n.c.year>=0&&(r+="+"),r+=bs(n.c.year,t?6:4),e?(r+="-",r+=bs(n.c.month),r+="-",r+=bs(n.c.day)):(r+=bs(n.c.month),r+=bs(n.c.day)),r}function ij(n,e,t,r,i,s){let o=bs(n.c.hour);return e?(o+=":",o+=bs(n.c.minute),(n.c.millisecond!==0||n.c.second!==0||!t)&&(o+=":")):o+=bs(n.c.minute),(n.c.millisecond!==0||n.c.second!==0||!t)&&(o+=bs(n.c.second),(n.c.millisecond!==0||!r)&&(o+=".",o+=bs(n.c.millisecond,3))),i&&(n.isOffsetFixed&&n.offset===0&&!s?o+="Z":n.o<0?(o+="-",o+=bs(Math.trunc(-n.o/60)),o+=":",o+=bs(Math.trunc(-n.o%60))):(o+="+",o+=bs(Math.trunc(n.o/60)),o+=":",o+=bs(Math.trunc(n.o%60)))),s&&(o+="["+n.zone.ianaName+"]"),o}const Bse={month:1,day:1,hour:0,minute:0,second:0,millisecond:0},Jct={weekNumber:1,weekday:1,hour:0,minute:0,second:0,millisecond:0},Qct={ordinal:1,hour:0,minute:0,second:0,millisecond:0},Vse=["year","month","day","hour","minute","second","millisecond"],eut=["weekYear","weekNumber","weekday","hour","minute","second","millisecond"],tut=["year","ordinal","hour","minute","second","millisecond"];function sj(n){const e={year:"year",years:"year",month:"month",months:"month",day:"day",days:"day",hour:"hour",hours:"hour",minute:"minute",minutes:"minute",quarter:"quarter",quarters:"quarter",second:"second",seconds:"second",millisecond:"millisecond",milliseconds:"millisecond",weekday:"weekday",weekdays:"weekday",weeknumber:"weekNumber",weeksnumber:"weekNumber",weeknumbers:"weekNumber",weekyear:"weekYear",weekyears:"weekYear",ordinal:"ordinal"}[n.toLowerCase()];if(!e)throw new Wie(n);return e}function oj(n,e){const t=kd(e.zone,gs.defaultZone),r=fi.fromObject(e),i=gs.now();let s,o;if(dr(n.year))s=i;else{for(const c of Vse)dr(n[c])&&(n[c]=Bse[c]);const a=Fse(n)||Lse(n);if(a)return wn.invalid(a);const l=t.offset(i);[s,o]=JE(n,l,t)}return new wn({ts:s,zone:t,loc:r,o})}function aj(n,e,t){const r=dr(t.round)?!0:t.round,i=(o,a)=>(o=$4(o,r||t.calendary?0:2,!0),e.loc.clone(t).relFormatter(t).format(o,a)),s=o=>t.calendary?e.hasSame(n,o)?0:e.startOf(o).diff(n.startOf(o),o).get(o):e.diff(n,o).get(o);if(t.unit)return i(s(t.unit),t.unit);for(const o of t.units){const a=s(o);if(Math.abs(a)>=1)return i(a,o)}return i(n>e?-0:0,t.units[t.units.length-1])}function lj(n){let e={},t;return n.length>0&&typeof n[n.length-1]=="object"?(e=n[n.length-1],t=Array.from(n).slice(0,n.length-1)):t=Array.from(n),[e,t]}class wn{constructor(e){const t=e.zone||gs.defaultZone;let r=e.invalid||(Number.isNaN(e.ts)?new gu("invalid input"):null)||(t.isValid?null:TT(t));this.ts=dr(e.ts)?gs.now():e.ts;let i=null,s=null;if(!r)if(e.old&&e.old.ts===this.ts&&e.old.zone.equals(t))[i,s]=[e.old.c,e.old.o];else{const a=t.offset(this.ts);i=ET(this.ts,a),r=Number.isNaN(i.year)?new gu("invalid input"):null,i=r?null:i,s=r?null:a}this._zone=t,this.loc=e.loc||fi.create(),this.invalid=r,this.weekData=null,this.c=i,this.o=s,this.isLuxonDateTime=!0}static now(){return new wn({})}static local(){const[e,t]=lj(arguments),[r,i,s,o,a,l,c]=t;return oj({year:r,month:i,day:s,hour:o,minute:a,second:l,millisecond:c},e)}static utc(){const[e,t]=lj(arguments),[r,i,s,o,a,l,c]=t;return e.zone=ya.utcInstance,oj({year:r,month:i,day:s,hour:o,minute:a,second:l,millisecond:c},e)}static fromJSDate(e,t={}){const r=Alt(e)?e.valueOf():NaN;if(Number.isNaN(r))return wn.invalid("invalid input");const i=kd(t.zone,gs.defaultZone);return i.isValid?new wn({ts:r,zone:i,loc:fi.fromObject(t)}):wn.invalid(TT(i))}static fromMillis(e,t={}){if(Xm(e))return e<-nj||e>nj?wn.invalid("Timestamp out of range"):new wn({ts:e,zone:kd(t.zone,gs.defaultZone),loc:fi.fromObject(t)});throw new lc(`fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`)}static fromSeconds(e,t={}){if(Xm(e))return new wn({ts:e*1e3,zone:kd(t.zone,gs.defaultZone),loc:fi.fromObject(t)});throw new lc("fromSeconds requires a numerical input")}static fromObject(e,t={}){e=e||{};const r=kd(t.zone,gs.defaultZone);if(!r.isValid)return wn.invalid(TT(r));const i=gs.now(),s=dr(t.specificOffset)?r.offset(i):t.specificOffset,o=yA(e,sj),a=!dr(o.ordinal),l=!dr(o.year),c=!dr(o.month)||!dr(o.day),u=l||c,h=o.weekYear||o.weekNumber,f=fi.fromObject(t);if((u||a)&&h)throw new A1("Can't mix weekYear/weekNumber units with year/month/day or ordinals");if(c&&a)throw new A1("Can't mix ordinal dates with month/day");const d=h||o.weekday&&!u;let p,m,g=ET(i,s);d?(p=eut,m=Jct,g=hF(g)):a?(p=tut,m=Qct,g=U3(g)):(p=Vse,m=Bse);let y=!1;for(const A of p){const M=o[A];dr(M)?y?o[A]=m[A]:o[A]=g[A]:y=!0}const b=d?Yct(o):a?Zct(o):Fse(o),_=b||Lse(o);if(_)return wn.invalid(_);const w=d?ej(o):a?tj(o):o,[S,C]=JE(w,s,r),k=new wn({ts:S,zone:r,o:C,loc:f});return o.weekday&&u&&e.weekday!==k.weekday?wn.invalid("mismatched weekday",`you can't specify both a weekday of ${o.weekday} and a date of ${k.toISO()}`):k}static fromISO(e,t={}){const[r,i]=bct(e);return Kx(r,i,t,"ISO 8601",e)}static fromRFC2822(e,t={}){const[r,i]=vct(e);return Kx(r,i,t,"RFC 2822",e)}static fromHTTP(e,t={}){const[r,i]=wct(e);return Kx(r,i,t,"HTTP",t)}static fromFormat(e,t,r={}){if(dr(e)||dr(t))throw new lc("fromFormat requires an input string and a format");const{locale:i=null,numberingSystem:s=null}=r,o=fi.fromOpts({locale:i,numberingSystem:s,defaultToEN:!0}),[a,l,c,u]=Kct(o,e,t);return u?wn.invalid(u):Kx(a,l,r,`format ${t}`,e,c)}static fromString(e,t,r={}){return wn.fromFormat(e,t,r)}static fromSQL(e,t={}){const[r,i]=Ect(e);return Kx(r,i,t,"SQL",e)}static invalid(e,t=null){if(!e)throw new lc("need to specify a reason the DateTime is invalid");const r=e instanceof gu?e:new gu(e,t);if(gs.throwOnInvalid)throw new olt(r);return new wn({invalid:r})}static isDateTime(e){return e&&e.isLuxonDateTime||!1}static parseFormatForOpts(e,t={}){const r=Nse(e,fi.fromObject(t));return r?r.map(i=>i?i.val:null).join(""):null}static expandFormat(e,t={}){return Ase(qo.parseFormat(e),fi.fromObject(t)).map(i=>i.val).join("")}get(e){return this[e]}get isValid(){return this.invalid===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}get outputCalendar(){return this.isValid?this.loc.outputCalendar:null}get zone(){return this._zone}get zoneName(){return this.isValid?this.zone.name:null}get year(){return this.isValid?this.c.year:NaN}get quarter(){return this.isValid?Math.ceil(this.c.month/3):NaN}get month(){return this.isValid?this.c.month:NaN}get day(){return this.isValid?this.c.day:NaN}get hour(){return this.isValid?this.c.hour:NaN}get minute(){return this.isValid?this.c.minute:NaN}get second(){return this.isValid?this.c.second:NaN}get millisecond(){return this.isValid?this.c.millisecond:NaN}get weekYear(){return this.isValid?H3(this).weekYear:NaN}get weekNumber(){return this.isValid?H3(this).weekNumber:NaN}get weekday(){return this.isValid?H3(this).weekday:NaN}get ordinal(){return this.isValid?U3(this.c).ordinal:NaN}get monthShort(){return this.isValid?CT.months("short",{locObj:this.loc})[this.month-1]:null}get monthLong(){return this.isValid?CT.months("long",{locObj:this.loc})[this.month-1]:null}get weekdayShort(){return this.isValid?CT.weekdays("short",{locObj:this.loc})[this.weekday-1]:null}get weekdayLong(){return this.isValid?CT.weekdays("long",{locObj:this.loc})[this.weekday-1]:null}get offset(){return this.isValid?+this.o:NaN}get offsetNameShort(){return this.isValid?this.zone.offsetName(this.ts,{format:"short",locale:this.locale}):null}get offsetNameLong(){return this.isValid?this.zone.offsetName(this.ts,{format:"long",locale:this.locale}):null}get isOffsetFixed(){return this.isValid?this.zone.isUniversal:null}get isInDST(){return this.isOffsetFixed?!1:this.offset>this.set({month:1,day:1}).offset||this.offset>this.set({month:5}).offset}getPossibleOffsets(){if(!this.isValid||this.isOffsetFixed)return[this];const e=864e5,t=6e4,r=_$(this.c),i=this.zone.offset(r-e),s=this.zone.offset(r+e),o=this.zone.offset(r-i*t),a=this.zone.offset(r-s*t);if(o===a)return[this];const l=r-o*t,c=r-a*t,u=ET(l,o),h=ET(c,a);return u.hour===h.hour&&u.minute===h.minute&&u.second===h.second&&u.millisecond===h.millisecond?[am(this,{ts:l}),am(this,{ts:c})]:[this]}get isInLeapYear(){return $C(this.year)}get daysInMonth(){return mA(this.year,this.month)}get daysInYear(){return this.isValid?t_(this.year):NaN}get weeksInWeekYear(){return this.isValid?gA(this.weekYear):NaN}resolvedLocaleOptions(e={}){const{locale:t,numberingSystem:r,calendar:i}=qo.create(this.loc.clone(e),e).resolvedOptions(this);return{locale:t,numberingSystem:r,outputCalendar:i}}toUTC(e=0,t={}){return this.setZone(ya.instance(e),t)}toLocal(){return this.setZone(gs.defaultZone)}setZone(e,{keepLocalTime:t=!1,keepCalendarTime:r=!1}={}){if(e=kd(e,gs.defaultZone),e.equals(this.zone))return this;if(e.isValid){let i=this.ts;if(t||r){const s=e.offset(this.ts),o=this.toObject();[i]=JE(o,s,e)}return am(this,{ts:i,zone:e})}else return wn.invalid(TT(e))}reconfigure({locale:e,numberingSystem:t,outputCalendar:r}={}){const i=this.loc.clone({locale:e,numberingSystem:t,outputCalendar:r});return am(this,{loc:i})}setLocale(e){return this.reconfigure({locale:e})}set(e){if(!this.isValid)return this;const t=yA(e,sj),r=!dr(t.weekYear)||!dr(t.weekNumber)||!dr(t.weekday),i=!dr(t.ordinal),s=!dr(t.year),o=!dr(t.month)||!dr(t.day),a=s||o,l=t.weekYear||t.weekNumber;if((a||i)&&l)throw new A1("Can't mix weekYear/weekNumber units with year/month/day or ordinals");if(o&&i)throw new A1("Can't mix ordinal dates with month/day");let c;r?c=ej({...hF(this.c),...t}):dr(t.ordinal)?(c={...this.toObject(),...t},dr(t.day)&&(c.day=Math.min(mA(c.year,c.month),c.day))):c=tj({...U3(this.c),...t});const[u,h]=JE(c,this.o,this.zone);return am(this,{ts:u,o:h})}plus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e);return am(this,rj(this,t))}minus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e).negate();return am(this,rj(this,t))}startOf(e){if(!this.isValid)return this;const t={},r=Sr.normalizeUnit(e);switch(r){case"years":t.month=1;case"quarters":case"months":t.day=1;case"weeks":case"days":t.hour=0;case"hours":t.minute=0;case"minutes":t.second=0;case"seconds":t.millisecond=0;break}if(r==="weeks"&&(t.weekday=1),r==="quarters"){const i=Math.ceil(this.month/3);t.month=(i-1)*3+1}return this.set(t)}endOf(e){return this.isValid?this.plus({[e]:1}).startOf(e).minus(1):this}toFormat(e,t={}){return this.isValid?qo.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this,e):W3}toLocaleString(e=pA,t={}){return this.isValid?qo.create(this.loc.clone(t),e).formatDateTime(this):W3}toLocaleParts(e={}){return this.isValid?qo.create(this.loc.clone(e),e).formatDateTimeParts(this):[]}toISO({format:e="extended",suppressSeconds:t=!1,suppressMilliseconds:r=!1,includeOffset:i=!0,extendedZone:s=!1}={}){if(!this.isValid)return null;const o=e==="extended";let a=G3(this,o);return a+="T",a+=ij(this,o,t,r,i,s),a}toISODate({format:e="extended"}={}){return this.isValid?G3(this,e==="extended"):null}toISOWeekDate(){return IT(this,"kkkk-'W'WW-c")}toISOTime({suppressMilliseconds:e=!1,suppressSeconds:t=!1,includeOffset:r=!0,includePrefix:i=!1,extendedZone:s=!1,format:o="extended"}={}){return this.isValid?(i?"T":"")+ij(this,o==="extended",t,e,r,s):null}toRFC2822(){return IT(this,"EEE, dd LLL yyyy HH:mm:ss ZZZ",!1)}toHTTP(){return IT(this.toUTC(),"EEE, dd LLL yyyy HH:mm:ss 'GMT'")}toSQLDate(){return this.isValid?G3(this,!0):null}toSQLTime({includeOffset:e=!0,includeZone:t=!1,includeOffsetSpace:r=!0}={}){let i="HH:mm:ss.SSS";return(t||e)&&(r&&(i+=" "),t?i+="z":e&&(i+="ZZ")),IT(this,i,!0)}toSQL(e={}){return this.isValid?`${this.toSQLDate()} ${this.toSQLTime(e)}`:null}toString(){return this.isValid?this.toISO():W3}valueOf(){return this.toMillis()}toMillis(){return this.isValid?this.ts:NaN}toSeconds(){return this.isValid?this.ts/1e3:NaN}toUnixInteger(){return this.isValid?Math.floor(this.ts/1e3):NaN}toJSON(){return this.toISO()}toBSON(){return this.toJSDate()}toObject(e={}){if(!this.isValid)return{};const t={...this.c};return e.includeConfig&&(t.outputCalendar=this.outputCalendar,t.numberingSystem=this.loc.numberingSystem,t.locale=this.loc.locale),t}toJSDate(){return new Date(this.isValid?this.ts:NaN)}diff(e,t="milliseconds",r={}){if(!this.isValid||!e.isValid)return Sr.invalid("created by diffing an invalid DateTime");const i={locale:this.locale,numberingSystem:this.numberingSystem,...r},s=Mlt(t).map(Sr.normalizeUnit),o=e.valueOf()>this.valueOf(),a=o?this:e,l=o?e:this,c=Pct(a,l,s,i);return o?c.negate():c}diffNow(e="milliseconds",t={}){return this.diff(wn.now(),e,t)}until(e){return this.isValid?Gi.fromDateTimes(this,e):this}hasSame(e,t){if(!this.isValid)return!1;const r=e.valueOf(),i=this.setZone(e.zone,{keepLocalTime:!0});return i.startOf(t)<=r&&r<=i.endOf(t)}equals(e){return this.isValid&&e.isValid&&this.valueOf()===e.valueOf()&&this.zone.equals(e.zone)&&this.loc.equals(e.loc)}toRelative(e={}){if(!this.isValid)return null;const t=e.base||wn.fromObject({},{zone:this.zone}),r=e.padding?this<t?-e.padding:e.padding:0;let i=["years","months","days","hours","minutes","seconds"],s=e.unit;return Array.isArray(e.unit)&&(i=e.unit,s=void 0),aj(t,this.plus(r),{...e,numeric:"always",units:i,unit:s})}toRelativeCalendar(e={}){return this.isValid?aj(e.base||wn.fromObject({},{zone:this.zone}),this,{...e,numeric:"auto",units:["years","months","days"],calendary:!0}):null}static min(...e){if(!e.every(wn.isDateTime))throw new lc("min requires all arguments be DateTimes");return G5(e,t=>t.valueOf(),Math.min)}static max(...e){if(!e.every(wn.isDateTime))throw new lc("max requires all arguments be DateTimes");return G5(e,t=>t.valueOf(),Math.max)}static fromFormatExplain(e,t,r={}){const{locale:i=null,numberingSystem:s=null}=r,o=fi.fromOpts({locale:i,numberingSystem:s,defaultToEN:!0});return Mse(o,e,t)}static fromStringExplain(e,t,r={}){return wn.fromFormatExplain(e,t,r)}static get DATE_SHORT(){return pA}static get DATE_MED(){return Hie}static get DATE_MED_WITH_WEEKDAY(){return clt}static get DATE_FULL(){return Gie}static get DATE_HUGE(){return jie}static get TIME_SIMPLE(){return qie}static get TIME_WITH_SECONDS(){return Xie}static get TIME_WITH_SHORT_OFFSET(){return Kie}static get TIME_WITH_LONG_OFFSET(){return Yie}static get TIME_24_SIMPLE(){return Zie}static get TIME_24_WITH_SECONDS(){return Jie}static get TIME_24_WITH_SHORT_OFFSET(){return Qie}static get TIME_24_WITH_LONG_OFFSET(){return ese}static get DATETIME_SHORT(){return tse}static get DATETIME_SHORT_WITH_SECONDS(){return nse}static get DATETIME_MED(){return rse}static get DATETIME_MED_WITH_SECONDS(){return ise}static get DATETIME_MED_WITH_WEEKDAY(){return ult}static get DATETIME_FULL(){return sse}static get DATETIME_FULL_WITH_SECONDS(){return ose}static get DATETIME_HUGE(){return ase}static get DATETIME_HUGE_WITH_SECONDS(){return lse}}function Yx(n){if(wn.isDateTime(n))return n;if(n&&n.valueOf&&Xm(n.valueOf()))return wn.fromJSDate(n);if(n&&typeof n=="object")return wn.fromObject(n);throw new lc(`Unknown datetime argument: ${n}, of type ${typeof n}`)}/*!
 * chartjs-adapter-luxon v1.3.1
 * https://www.chartjs.org
 * (c) 2023 chartjs-adapter-luxon Contributors
 * Released under the MIT license
 */const nut={datetime:wn.DATETIME_MED_WITH_SECONDS,millisecond:"h:mm:ss.SSS a",second:wn.TIME_WITH_SECONDS,minute:wn.TIME_SIMPLE,hour:{hour:"numeric"},day:{day:"numeric",month:"short"},week:"DD",month:{month:"short",year:"numeric"},quarter:"'Q'q - yyyy",year:{year:"numeric"}};_ie._date.override({_id:"luxon",_create:function(n){return wn.fromMillis(n,this.options)},init(n){this.options.locale||(this.options.locale=n.locale)},formats:function(){return nut},parse:function(n,e){const t=this.options,r=typeof n;return n===null||r==="undefined"?null:(r==="number"?n=this._create(n):r==="string"?typeof e=="string"?n=wn.fromFormat(n,e,t):n=wn.fromISO(n,t):n instanceof Date?n=wn.fromJSDate(n,t):r==="object"&&!(n instanceof wn)&&(n=wn.fromObject(n,t)),n.isValid?n.valueOf():null)},format:function(n,e){const t=this._create(n);return typeof e=="string"?t.toFormat(e):t.toLocaleString(e)},add:function(n,e,t){const r={};return r[t]=e,this._create(n).plus(r).valueOf()},diff:function(n,e,t){return this._create(n).diff(this._create(e)).as(t).valueOf()},startOf:function(n,e,t){if(e==="isoWeek"){t=Math.trunc(Math.min(Math.max(0,t),6));const r=this._create(n);return r.minus({days:(r.weekday-t+7)%7}).startOf("day").valueOf()}return e?this._create(n).startOf(e).valueOf():n},endOf:function(n,e){return this._create(n).endOf(e).valueOf()}});var cj=Object.prototype.hasOwnProperty;function uj(n,e,t){for(t of n.keys())if(r_(t,e))return t}function r_(n,e){var t,r,i;if(n===e)return!0;if(n&&e&&(t=n.constructor)===e.constructor){if(t===Date)return n.getTime()===e.getTime();if(t===RegExp)return n.toString()===e.toString();if(t===Array){if((r=n.length)===e.length)for(;r--&&r_(n[r],e[r]););return r===-1}if(t===Set){if(n.size!==e.size)return!1;for(r of n)if(i=r,i&&typeof i=="object"&&(i=uj(e,i),!i)||!e.has(i))return!1;return!0}if(t===Map){if(n.size!==e.size)return!1;for(r of n)if(i=r[0],i&&typeof i=="object"&&(i=uj(e,i),!i)||!r_(r[1],e.get(i)))return!1;return!0}if(t===ArrayBuffer)n=new Uint8Array(n),e=new Uint8Array(e);else if(t===DataView){if((r=n.byteLength)===e.byteLength)for(;r--&&n.getInt8(r)===e.getInt8(r););return r===-1}if(ArrayBuffer.isView(n)){if((r=n.byteLength)===e.byteLength)for(;r--&&n[r]===e[r];);return r===-1}if(!t||typeof n=="object"){r=0;for(t in n)if(cj.call(n,t)&&++r&&!cj.call(e,t)||!(t in e)||!r_(n[t],e[t]))return!1;return Object.keys(e).length===r}}return n!==n&&e!==e}/*!
 * chartjs-chart-matrix v2.0.1
 * https://chartjs-chart-matrix.pages.dev/
 * (c) 2023 Jukka Kurkela
 * Released under the MIT license
 */var rut="2.0.1";class N1 extends xc{initialize(){this.enableOptionSharing=!0,super.initialize()}update(e){const t=this,r=t._cachedMeta;t.updateElements(r.data,0,r.data.length,e)}updateElements(e,t,r,i){const s=this,o=i==="reset",{xScale:a,yScale:l}=s._cachedMeta,c=s.resolveDataElementOptions(t,i),u=s.getSharedOptions(i,e[t],c);for(let h=t;h<t+r;h++){const f=!o&&s.getParsed(h),d=o?a.getBasePixel():a.getPixelForValue(f.x),p=o?l.getBasePixel():l.getPixelForValue(f.y),m=s.resolveDataElementOptions(h,i),{width:g,height:y,anchorX:b,anchorY:_}=m,w={x:iut(b,d,g),y:sut(_,p,y),width:g,height:y,options:m};s.updateElement(e[h],h,w,i)}s.updateSharedOptions(u,i)}draw(){const e=this,t=e.getMeta().data||[];let r,i;for(r=0,i=t.length;r<i;++r)t[r].draw(e._ctx)}}Nt(N1,"id","matrix"),Nt(N1,"version",rut),Nt(N1,"defaults",{dataElementType:"matrix",animations:{numbers:{type:"number",properties:["x","y","width","height"]}}}),Nt(N1,"overrides",{interaction:{mode:"nearest",intersect:!0},scales:{x:{type:"linear",offset:!0},y:{type:"linear",reverse:!0}}});function iut(n,e,t){return n==="left"||n==="start"?e:n==="right"||n==="end"?e-t:e-t/2}function sut(n,e,t){return n==="top"||n==="start"?e:n==="bottom"||n==="end"?e-t:e-t/2}function Use(n,e){const{x:t,y:r,width:i,height:s}=n.getProps(["x","y","width","height"],e);return{left:t,top:r,right:t+i,bottom:r+s}}function AT(n,e,t){return Math.max(Math.min(n,t),e)}function out(n,e,t){const r=n.options.borderWidth;let i,s,o,a;return rr(r)?(i=+r.top||0,s=+r.right||0,o=+r.bottom||0,a=+r.left||0):i=s=o=a=+r||0,{t:AT(i,0,t),r:AT(s,0,e),b:AT(o,0,t),l:AT(a,0,e)}}function aut(n){const e=Use(n),t=e.right-e.left,r=e.bottom-e.top,i=out(n,t/2,r/2);return{outer:{x:e.left,y:e.top,w:t,h:r},inner:{x:e.left+i.l,y:e.top+i.t,w:t-i.l-i.r,h:r-i.t-i.b}}}function j3(n,e,t,r){const i=e===null,s=t===null,o=!n||i&&s?!1:Use(n,r);return o&&(i||e>=o.left&&e<=o.right)&&(s||t>=o.top&&t<=o.bottom)}class fF extends Ac{constructor(e){super(),this.options=void 0,this.width=void 0,this.height=void 0,e&&Object.assign(this,e)}draw(e){const t=this.options,{inner:r,outer:i}=aut(this),s=Gd(t.borderRadius);e.save(),i.w!==r.w||i.h!==r.h?(e.beginPath(),Hd(e,{x:i.x,y:i.y,w:i.w,h:i.h,radius:s}),Hd(e,{x:r.x,y:r.y,w:r.w,h:r.h,radius:s}),e.fillStyle=t.backgroundColor,e.fill(),e.fillStyle=t.borderColor,e.fill("evenodd")):(e.beginPath(),Hd(e,{x:r.x,y:r.y,w:r.w,h:r.h,radius:s}),e.fillStyle=t.backgroundColor,e.fill()),e.restore()}inRange(e,t,r){return j3(this,e,t,r)}inXRange(e,t){return j3(this,e,null,t)}inYRange(e,t){return j3(this,null,e,t)}getCenterPoint(e){const{x:t,y:r,width:i,height:s}=this.getProps(["x","y","width","height"],e);return{x:t+i/2,y:r+s/2}}tooltipPosition(){return this.getCenterPoint()}getRange(e){return e==="x"?this.width/2:this.height/2}}Nt(fF,"id","matrix"),Nt(fF,"defaults",{backgroundColor:void 0,borderColor:void 0,borderWidth:void 0,borderRadius:0,anchorX:"center",anchorY:"center",width:20,height:20});var lut={exports:{}};/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */(function(n){(function(e,t,r,i){var s=["","webkit","Moz","MS","ms","o"],o=t.createElement("div"),a="function",l=Math.round,c=Math.abs,u=Date.now;function h(G,Y,de){return setTimeout(_(G,de),Y)}function f(G,Y,de){return Array.isArray(G)?(d(G,de[Y],de),!0):!1}function d(G,Y,de){var Re;if(G)if(G.forEach)G.forEach(Y,de);else if(G.length!==i)for(Re=0;Re<G.length;)Y.call(de,G[Re],Re,G),Re++;else for(Re in G)G.hasOwnProperty(Re)&&Y.call(de,G[Re],Re,G)}function p(G,Y,de){var Re="DEPRECATED METHOD: "+Y+`
`+de+` AT 
`;return function(){var lt=new Error("get-stack-trace"),Vt=lt&&lt.stack?lt.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",$n=e.console&&(e.console.warn||e.console.log);return $n&&$n.call(e.console,Re,Vt),G.apply(this,arguments)}}var m;typeof Object.assign!="function"?m=function(Y){if(Y===i||Y===null)throw new TypeError("Cannot convert undefined or null to object");for(var de=Object(Y),Re=1;Re<arguments.length;Re++){var lt=arguments[Re];if(lt!==i&&lt!==null)for(var Vt in lt)lt.hasOwnProperty(Vt)&&(de[Vt]=lt[Vt])}return de}:m=Object.assign;var g=p(function(Y,de,Re){for(var lt=Object.keys(de),Vt=0;Vt<lt.length;)(!Re||Re&&Y[lt[Vt]]===i)&&(Y[lt[Vt]]=de[lt[Vt]]),Vt++;return Y},"extend","Use `assign`."),y=p(function(Y,de){return g(Y,de,!0)},"merge","Use `assign`.");function b(G,Y,de){var Re=Y.prototype,lt;lt=G.prototype=Object.create(Re),lt.constructor=G,lt._super=Re,de&&m(lt,de)}function _(G,Y){return function(){return G.apply(Y,arguments)}}function w(G,Y){return typeof G==a?G.apply(Y&&Y[0]||i,Y):G}function S(G,Y){return G===i?Y:G}function C(G,Y,de){d(E(Y),function(Re){G.addEventListener(Re,de,!1)})}function k(G,Y,de){d(E(Y),function(Re){G.removeEventListener(Re,de,!1)})}function A(G,Y){for(;G;){if(G==Y)return!0;G=G.parentNode}return!1}function M(G,Y){return G.indexOf(Y)>-1}function E(G){return G.trim().split(/\s+/g)}function N(G,Y,de){if(G.indexOf&&!de)return G.indexOf(Y);for(var Re=0;Re<G.length;){if(de&&G[Re][de]==Y||!de&&G[Re]===Y)return Re;Re++}return-1}function O(G){return Array.prototype.slice.call(G,0)}function R(G,Y,de){for(var Re=[],lt=[],Vt=0;Vt<G.length;){var $n=Y?G[Vt][Y]:G[Vt];N(lt,$n)<0&&Re.push(G[Vt]),lt[Vt]=$n,Vt++}return de&&(Y?Re=Re.sort(function(Ui,ds){return Ui[Y]>ds[Y]}):Re=Re.sort()),Re}function D(G,Y){for(var de,Re,lt=Y[0].toUpperCase()+Y.slice(1),Vt=0;Vt<s.length;){if(de=s[Vt],Re=de?de+lt:Y,Re in G)return Re;Vt++}return i}var z=1;function B(){return z++}function X(G){var Y=G.ownerDocument||G;return Y.defaultView||Y.parentWindow||e}var H=/mobile|tablet|ip(ad|hone|od)|android/i,te="ontouchstart"in e,ge=D(e,"PointerEvent")!==i,ae=te&&H.test(navigator.userAgent),Ne="touch",Te="pen",De="mouse",be="kinect",Ke=25,Oe=1,ot=2,He=4,mt=8,ht=1,Ue=2,Be=4,Ve=8,ft=16,Ye=Ue|Be,ee=Ve|ft,J=Ye|ee,it=["x","y"],Ge=["clientX","clientY"];function ye(G,Y){var de=this;this.manager=G,this.callback=Y,this.element=G.element,this.target=G.options.inputTarget,this.domHandler=function(Re){w(G.options.enable,[G])&&de.handler(Re)},this.init()}ye.prototype={handler:function(){},init:function(){this.evEl&&C(this.element,this.evEl,this.domHandler),this.evTarget&&C(this.target,this.evTarget,this.domHandler),this.evWin&&C(X(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&k(this.element,this.evEl,this.domHandler),this.evTarget&&k(this.target,this.evTarget,this.domHandler),this.evWin&&k(X(this.element),this.evWin,this.domHandler)}};function Je(G){var Y,de=G.options.inputClass;return de?Y=de:ge?Y=Ps:ae?Y=wt:te?Y=En:Y=Wl,new Y(G,bt)}function bt(G,Y,de){var Re=de.pointers.length,lt=de.changedPointers.length,Vt=Y&Oe&&Re-lt===0,$n=Y&(He|mt)&&Re-lt===0;de.isFirst=!!Vt,de.isFinal=!!$n,Vt&&(G.session={}),de.eventType=Y,It(G,de),G.emit("hammer.input",de),G.recognize(de),G.session.prevInput=de}function It(G,Y){var de=G.session,Re=Y.pointers,lt=Re.length;de.firstInput||(de.firstInput=rt(Y)),lt>1&&!de.firstMultiple?de.firstMultiple=rt(Y):lt===1&&(de.firstMultiple=!1);var Vt=de.firstInput,$n=de.firstMultiple,Ri=$n?$n.center:Vt.center,Ui=Y.center=Et(Re);Y.timeStamp=u(),Y.deltaTime=Y.timeStamp-Vt.timeStamp,Y.angle=Cr(Ri,Ui),Y.distance=Mn(Ri,Ui),pt(de,Y),Y.offsetDirection=Ht(Y.deltaX,Y.deltaY);var ds=yt(Y.deltaTime,Y.deltaX,Y.deltaY);Y.overallVelocityX=ds.x,Y.overallVelocityY=ds.y,Y.overallVelocity=c(ds.x)>c(ds.y)?ds.x:ds.y,Y.scale=$n?Ai($n.pointers,Re):1,Y.rotation=$n?Bi($n.pointers,Re):0,Y.maxPointers=de.prevInput?Y.pointers.length>de.prevInput.maxPointers?Y.pointers.length:de.prevInput.maxPointers:Y.pointers.length,ce(de,Y);var Ma=G.element;A(Y.srcEvent.target,Ma)&&(Ma=Y.srcEvent.target),Y.target=Ma}function pt(G,Y){var de=Y.center,Re=G.offsetDelta||{},lt=G.prevDelta||{},Vt=G.prevInput||{};(Y.eventType===Oe||Vt.eventType===He)&&(lt=G.prevDelta={x:Vt.deltaX||0,y:Vt.deltaY||0},Re=G.offsetDelta={x:de.x,y:de.y}),Y.deltaX=lt.x+(de.x-Re.x),Y.deltaY=lt.y+(de.y-Re.y)}function ce(G,Y){var de=G.lastInterval||Y,Re=Y.timeStamp-de.timeStamp,lt,Vt,$n,Ri;if(Y.eventType!=mt&&(Re>Ke||de.velocity===i)){var Ui=Y.deltaX-de.deltaX,ds=Y.deltaY-de.deltaY,Ma=yt(Re,Ui,ds);Vt=Ma.x,$n=Ma.y,lt=c(Ma.x)>c(Ma.y)?Ma.x:Ma.y,Ri=Ht(Ui,ds),G.lastInterval=Y}else lt=de.velocity,Vt=de.velocityX,$n=de.velocityY,Ri=de.direction;Y.velocity=lt,Y.velocityX=Vt,Y.velocityY=$n,Y.direction=Ri}function rt(G){for(var Y=[],de=0;de<G.pointers.length;)Y[de]={clientX:l(G.pointers[de].clientX),clientY:l(G.pointers[de].clientY)},de++;return{timeStamp:u(),pointers:Y,center:Et(Y),deltaX:G.deltaX,deltaY:G.deltaY}}function Et(G){var Y=G.length;if(Y===1)return{x:l(G[0].clientX),y:l(G[0].clientY)};for(var de=0,Re=0,lt=0;lt<Y;)de+=G[lt].clientX,Re+=G[lt].clientY,lt++;return{x:l(de/Y),y:l(Re/Y)}}function yt(G,Y,de){return{x:Y/G||0,y:de/G||0}}function Ht(G,Y){return G===Y?ht:c(G)>=c(Y)?G<0?Ue:Be:Y<0?Ve:ft}function Mn(G,Y,de){de||(de=it);var Re=Y[de[0]]-G[de[0]],lt=Y[de[1]]-G[de[1]];return Math.sqrt(Re*Re+lt*lt)}function Cr(G,Y,de){de||(de=it);var Re=Y[de[0]]-G[de[0]],lt=Y[de[1]]-G[de[1]];return Math.atan2(lt,Re)*180/Math.PI}function Bi(G,Y){return Cr(Y[1],Y[0],Ge)+Cr(G[1],G[0],Ge)}function Ai(G,Y){return Mn(Y[0],Y[1],Ge)/Mn(G[0],G[1],Ge)}var Mi={mousedown:Oe,mousemove:ot,mouseup:He},zh="mousedown",Ul="mousemove mouseup";function Wl(){this.evEl=zh,this.evWin=Ul,this.pressed=!1,ye.apply(this,arguments)}b(Wl,ye,{handler:function(Y){var de=Mi[Y.type];de&Oe&&Y.button===0&&(this.pressed=!0),de&ot&&Y.which!==1&&(de=He),this.pressed&&(de&He&&(this.pressed=!1),this.callback(this.manager,de,{pointers:[Y],changedPointers:[Y],pointerType:De,srcEvent:Y}))}});var mo={pointerdown:Oe,pointermove:ot,pointerup:He,pointercancel:mt,pointerout:mt},Hl={2:Ne,3:Te,4:De,5:be},Bc="pointerdown",Vc="pointermove pointerup pointercancel";e.MSPointerEvent&&!e.PointerEvent&&(Bc="MSPointerDown",Vc="MSPointerMove MSPointerUp MSPointerCancel");function Ps(){this.evEl=Bc,this.evWin=Vc,ye.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}b(Ps,ye,{handler:function(Y){var de=this.store,Re=!1,lt=Y.type.toLowerCase().replace("ms",""),Vt=mo[lt],$n=Hl[Y.pointerType]||Y.pointerType,Ri=$n==Ne,Ui=N(de,Y.pointerId,"pointerId");Vt&Oe&&(Y.button===0||Ri)?Ui<0&&(de.push(Y),Ui=de.length-1):Vt&(He|mt)&&(Re=!0),!(Ui<0)&&(de[Ui]=Y,this.callback(this.manager,Vt,{pointers:de,changedPointers:[Y],pointerType:$n,srcEvent:Y}),Re&&de.splice(Ui,1))}});var Bh={touchstart:Oe,touchmove:ot,touchend:He,touchcancel:mt},rl="touchstart",Vh="touchstart touchmove touchend touchcancel";function re(){this.evTarget=rl,this.evWin=Vh,this.started=!1,ye.apply(this,arguments)}b(re,ye,{handler:function(Y){var de=Bh[Y.type];if(de===Oe&&(this.started=!0),!!this.started){var Re=We.call(this,Y,de);de&(He|mt)&&Re[0].length-Re[1].length===0&&(this.started=!1),this.callback(this.manager,de,{pointers:Re[0],changedPointers:Re[1],pointerType:Ne,srcEvent:Y})}}});function We(G,Y){var de=O(G.touches),Re=O(G.changedTouches);return Y&(He|mt)&&(de=R(de.concat(Re),"identifier",!0)),[de,Re]}var Fe={touchstart:Oe,touchmove:ot,touchend:He,touchcancel:mt},Qe="touchstart touchmove touchend touchcancel";function wt(){this.evTarget=Qe,this.targetIds={},ye.apply(this,arguments)}b(wt,ye,{handler:function(Y){var de=Fe[Y.type],Re=Bn.call(this,Y,de);Re&&this.callback(this.manager,de,{pointers:Re[0],changedPointers:Re[1],pointerType:Ne,srcEvent:Y})}});function Bn(G,Y){var de=O(G.touches),Re=this.targetIds;if(Y&(Oe|ot)&&de.length===1)return Re[de[0].identifier]=!0,[de,de];var lt,Vt,$n=O(G.changedTouches),Ri=[],Ui=this.target;if(Vt=de.filter(function(ds){return A(ds.target,Ui)}),Y===Oe)for(lt=0;lt<Vt.length;)Re[Vt[lt].identifier]=!0,lt++;for(lt=0;lt<$n.length;)Re[$n[lt].identifier]&&Ri.push($n[lt]),Y&(He|mt)&&delete Re[$n[lt].identifier],lt++;if(Ri.length)return[R(Vt.concat(Ri),"identifier",!0),Ri]}var sn=2500,Tn=25;function En(){ye.apply(this,arguments);var G=_(this.handler,this);this.touch=new wt(this.manager,G),this.mouse=new Wl(this.manager,G),this.primaryTouch=null,this.lastTouches=[]}b(En,ye,{handler:function(Y,de,Re){var lt=Re.pointerType==Ne,Vt=Re.pointerType==De;if(!(Vt&&Re.sourceCapabilities&&Re.sourceCapabilities.firesTouchEvents)){if(lt)Nn.call(this,de,Re);else if(Vt&&_n.call(this,Re))return;this.callback(Y,de,Re)}},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});function Nn(G,Y){G&Oe?(this.primaryTouch=Y.changedPointers[0].identifier,tr.call(this,Y)):G&(He|mt)&&tr.call(this,Y)}function tr(G){var Y=G.changedPointers[0];if(Y.identifier===this.primaryTouch){var de={x:Y.clientX,y:Y.clientY};this.lastTouches.push(de);var Re=this.lastTouches,lt=function(){var Vt=Re.indexOf(de);Vt>-1&&Re.splice(Vt,1)};setTimeout(lt,sn)}}function _n(G){for(var Y=G.srcEvent.clientX,de=G.srcEvent.clientY,Re=0;Re<this.lastTouches.length;Re++){var lt=this.lastTouches[Re],Vt=Math.abs(Y-lt.x),$n=Math.abs(de-lt.y);if(Vt<=Tn&&$n<=Tn)return!0}return!1}var hr=D(o.style,"touchAction"),Ds=hr!==i,xr="compute",Zs="auto",Ar="manipulation",Mo="none",ri="pan-x",go="pan-y",No=Uh();function Ni(G,Y){this.manager=G,this.set(Y)}Ni.prototype={set:function(G){G==xr&&(G=this.compute()),Ds&&this.manager.element.style&&No[G]&&(this.manager.element.style[hr]=G),this.actions=G.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var G=[];return d(this.manager.recognizers,function(Y){w(Y.options.enable,[Y])&&(G=G.concat(Y.getTouchAction()))}),yo(G.join(" "))},preventDefaults:function(G){var Y=G.srcEvent,de=G.offsetDirection;if(this.manager.session.prevented){Y.preventDefault();return}var Re=this.actions,lt=M(Re,Mo)&&!No[Mo],Vt=M(Re,go)&&!No[go],$n=M(Re,ri)&&!No[ri];if(lt){var Ri=G.pointers.length===1,Ui=G.distance<2,ds=G.deltaTime<250;if(Ri&&Ui&&ds)return}if(!($n&&Vt)&&(lt||Vt&&de&Ye||$n&&de&ee))return this.preventSrc(Y)},preventSrc:function(G){this.manager.session.prevented=!0,G.preventDefault()}};function yo(G){if(M(G,Mo))return Mo;var Y=M(G,ri),de=M(G,go);return Y&&de?Mo:Y||de?Y?ri:go:M(G,Ar)?Ar:Zs}function Uh(){if(!Ds)return!1;var G={},Y=e.CSS&&e.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach(function(de){G[de]=Y?e.CSS.supports("touch-action",de):!0}),G}var il=1,Js=2,Uc=4,Aa=8,$i=Aa,Wc=16,Qs=32;function Vi(G){this.options=m({},this.defaults,G||{}),this.id=B(),this.manager=null,this.options.enable=S(this.options.enable,!0),this.state=il,this.simultaneous={},this.requireFail=[]}Vi.prototype={defaults:{},set:function(G){return m(this.options,G),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(G){if(f(G,"recognizeWith",this))return this;var Y=this.simultaneous;return G=Hh(G,this),Y[G.id]||(Y[G.id]=G,G.recognizeWith(this)),this},dropRecognizeWith:function(G){return f(G,"dropRecognizeWith",this)?this:(G=Hh(G,this),delete this.simultaneous[G.id],this)},requireFailure:function(G){if(f(G,"requireFailure",this))return this;var Y=this.requireFail;return G=Hh(G,this),N(Y,G)===-1&&(Y.push(G),G.requireFailure(this)),this},dropRequireFailure:function(G){if(f(G,"dropRequireFailure",this))return this;G=Hh(G,this);var Y=N(this.requireFail,G);return Y>-1&&this.requireFail.splice(Y,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(G){return!!this.simultaneous[G.id]},emit:function(G){var Y=this,de=this.state;function Re(lt){Y.manager.emit(lt,G)}de<Aa&&Re(Y.options.event+Wh(de)),Re(Y.options.event),G.additionalEvent&&Re(G.additionalEvent),de>=Aa&&Re(Y.options.event+Wh(de))},tryEmit:function(G){if(this.canEmit())return this.emit(G);this.state=Qs},canEmit:function(){for(var G=0;G<this.requireFail.length;){if(!(this.requireFail[G].state&(Qs|il)))return!1;G++}return!0},recognize:function(G){var Y=m({},G);if(!w(this.options.enable,[this,Y])){this.reset(),this.state=Qs;return}this.state&($i|Wc|Qs)&&(this.state=il),this.state=this.process(Y),this.state&(Js|Uc|Aa|Wc)&&this.tryEmit(Y)},process:function(G){},getTouchAction:function(){},reset:function(){}};function Wh(G){return G&Wc?"cancel":G&Aa?"end":G&Uc?"move":G&Js?"start":""}function s0(G){return G==ft?"down":G==Ve?"up":G==Ue?"left":G==Be?"right":""}function Hh(G,Y){var de=Y.manager;return de?de.get(G):G}function eo(){Vi.apply(this,arguments)}b(eo,Vi,{defaults:{pointers:1},attrTest:function(G){var Y=this.options.pointers;return Y===0||G.pointers.length===Y},process:function(G){var Y=this.state,de=G.eventType,Re=Y&(Js|Uc),lt=this.attrTest(G);return Re&&(de&mt||!lt)?Y|Wc:Re||lt?de&He?Y|Aa:Y&Js?Y|Uc:Js:Qs}});function Gh(){eo.apply(this,arguments),this.pX=null,this.pY=null}b(Gh,eo,{defaults:{event:"pan",threshold:10,pointers:1,direction:J},getTouchAction:function(){var G=this.options.direction,Y=[];return G&Ye&&Y.push(go),G&ee&&Y.push(ri),Y},directionTest:function(G){var Y=this.options,de=!0,Re=G.distance,lt=G.direction,Vt=G.deltaX,$n=G.deltaY;return lt&Y.direction||(Y.direction&Ye?(lt=Vt===0?ht:Vt<0?Ue:Be,de=Vt!=this.pX,Re=Math.abs(G.deltaX)):(lt=$n===0?ht:$n<0?Ve:ft,de=$n!=this.pY,Re=Math.abs(G.deltaY))),G.direction=lt,de&&Re>Y.threshold&&lt&Y.direction},attrTest:function(G){return eo.prototype.attrTest.call(this,G)&&(this.state&Js||!(this.state&Js)&&this.directionTest(G))},emit:function(G){this.pX=G.deltaX,this.pY=G.deltaY;var Y=s0(G.direction);Y&&(G.additionalEvent=this.options.event+Y),this._super.emit.call(this,G)}});function Kf(){eo.apply(this,arguments)}b(Kf,eo,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[Mo]},attrTest:function(G){return this._super.attrTest.call(this,G)&&(Math.abs(G.scale-1)>this.options.threshold||this.state&Js)},emit:function(G){if(G.scale!==1){var Y=G.scale<1?"in":"out";G.additionalEvent=this.options.event+Y}this._super.emit.call(this,G)}});function ju(){Vi.apply(this,arguments),this._timer=null,this._input=null}b(ju,Vi,{defaults:{event:"press",pointers:1,time:251,threshold:9},getTouchAction:function(){return[Zs]},process:function(G){var Y=this.options,de=G.pointers.length===Y.pointers,Re=G.distance<Y.threshold,lt=G.deltaTime>Y.time;if(this._input=G,!Re||!de||G.eventType&(He|mt)&&!lt)this.reset();else if(G.eventType&Oe)this.reset(),this._timer=h(function(){this.state=$i,this.tryEmit()},Y.time,this);else if(G.eventType&He)return $i;return Qs},reset:function(){clearTimeout(this._timer)},emit:function(G){this.state===$i&&(G&&G.eventType&He?this.manager.emit(this.options.event+"up",G):(this._input.timeStamp=u(),this.manager.emit(this.options.event,this._input)))}});function Yf(){eo.apply(this,arguments)}b(Yf,eo,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[Mo]},attrTest:function(G){return this._super.attrTest.call(this,G)&&(Math.abs(G.rotation)>this.options.threshold||this.state&Js)}});function jh(){eo.apply(this,arguments)}b(jh,eo,{defaults:{event:"swipe",threshold:10,velocity:.3,direction:Ye|ee,pointers:1},getTouchAction:function(){return Gh.prototype.getTouchAction.call(this)},attrTest:function(G){var Y=this.options.direction,de;return Y&(Ye|ee)?de=G.overallVelocity:Y&Ye?de=G.overallVelocityX:Y&ee&&(de=G.overallVelocityY),this._super.attrTest.call(this,G)&&Y&G.offsetDirection&&G.distance>this.options.threshold&&G.maxPointers==this.options.pointers&&c(de)>this.options.velocity&&G.eventType&He},emit:function(G){var Y=s0(G.offsetDirection);Y&&this.manager.emit(this.options.event+Y,G),this.manager.emit(this.options.event,G)}});function Gl(){Vi.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}b(Gl,Vi,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},getTouchAction:function(){return[Ar]},process:function(G){var Y=this.options,de=G.pointers.length===Y.pointers,Re=G.distance<Y.threshold,lt=G.deltaTime<Y.time;if(this.reset(),G.eventType&Oe&&this.count===0)return this.failTimeout();if(Re&&lt&&de){if(G.eventType!=He)return this.failTimeout();var Vt=this.pTime?G.timeStamp-this.pTime<Y.interval:!0,$n=!this.pCenter||Mn(this.pCenter,G.center)<Y.posThreshold;this.pTime=G.timeStamp,this.pCenter=G.center,!$n||!Vt?this.count=1:this.count+=1,this._input=G;var Ri=this.count%Y.taps;if(Ri===0)return this.hasRequireFailures()?(this._timer=h(function(){this.state=$i,this.tryEmit()},Y.interval,this),Js):$i}return Qs},failTimeout:function(){return this._timer=h(function(){this.state=Qs},this.options.interval,this),Qs},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==$i&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}});function Zr(G,Y){return Y=Y||{},Y.recognizers=S(Y.recognizers,Zr.defaults.preset),new Hc(G,Y)}Zr.VERSION="2.0.7",Zr.defaults={domEvents:!1,touchAction:xr,enable:!0,inputTarget:null,inputClass:null,preset:[[Yf,{enable:!1}],[Kf,{enable:!1},["rotate"]],[jh,{direction:Ye}],[Gh,{direction:Ye},["swipe"]],[Gl],[Gl,{event:"doubletap",taps:2},["tap"]],[ju]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var o0=1,Zf=2;function Hc(G,Y){this.options=m({},Zr.defaults,Y||{}),this.options.inputTarget=this.options.inputTarget||G,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=G,this.input=Je(this),this.touchAction=new Ni(this,this.options.touchAction),qh(this,!0),d(this.options.recognizers,function(de){var Re=this.add(new de[0](de[1]));de[2]&&Re.recognizeWith(de[2]),de[3]&&Re.requireFailure(de[3])},this)}Hc.prototype={set:function(G){return m(this.options,G),G.touchAction&&this.touchAction.update(),G.inputTarget&&(this.input.destroy(),this.input.target=G.inputTarget,this.input.init()),this},stop:function(G){this.session.stopped=G?Zf:o0},recognize:function(G){var Y=this.session;if(!Y.stopped){this.touchAction.preventDefaults(G);var de,Re=this.recognizers,lt=Y.curRecognizer;(!lt||lt&&lt.state&$i)&&(lt=Y.curRecognizer=null);for(var Vt=0;Vt<Re.length;)de=Re[Vt],Y.stopped!==Zf&&(!lt||de==lt||de.canRecognizeWith(lt))?de.recognize(G):de.reset(),!lt&&de.state&(Js|Uc|Aa)&&(lt=Y.curRecognizer=de),Vt++}},get:function(G){if(G instanceof Vi)return G;for(var Y=this.recognizers,de=0;de<Y.length;de++)if(Y[de].options.event==G)return Y[de];return null},add:function(G){if(f(G,"add",this))return this;var Y=this.get(G.options.event);return Y&&this.remove(Y),this.recognizers.push(G),G.manager=this,this.touchAction.update(),G},remove:function(G){if(f(G,"remove",this))return this;if(G=this.get(G),G){var Y=this.recognizers,de=N(Y,G);de!==-1&&(Y.splice(de,1),this.touchAction.update())}return this},on:function(G,Y){if(G!==i&&Y!==i){var de=this.handlers;return d(E(G),function(Re){de[Re]=de[Re]||[],de[Re].push(Y)}),this}},off:function(G,Y){if(G!==i){var de=this.handlers;return d(E(G),function(Re){Y?de[Re]&&de[Re].splice(N(de[Re],Y),1):delete de[Re]}),this}},emit:function(G,Y){this.options.domEvents&&a0(G,Y);var de=this.handlers[G]&&this.handlers[G].slice();if(!(!de||!de.length)){Y.type=G,Y.preventDefault=function(){Y.srcEvent.preventDefault()};for(var Re=0;Re<de.length;)de[Re](Y),Re++}},destroy:function(){this.element&&qh(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}};function qh(G,Y){var de=G.element;if(de.style){var Re;d(G.options.cssProps,function(lt,Vt){Re=D(de.style,Vt),Y?(G.oldCssProps[Re]=de.style[Re],de.style[Re]=lt):de.style[Re]=G.oldCssProps[Re]||""}),Y||(G.oldCssProps={})}}function a0(G,Y){var de=t.createEvent("Event");de.initEvent(G,!0,!0),de.gesture=Y,Y.target.dispatchEvent(de)}m(Zr,{INPUT_START:Oe,INPUT_MOVE:ot,INPUT_END:He,INPUT_CANCEL:mt,STATE_POSSIBLE:il,STATE_BEGAN:Js,STATE_CHANGED:Uc,STATE_ENDED:Aa,STATE_RECOGNIZED:$i,STATE_CANCELLED:Wc,STATE_FAILED:Qs,DIRECTION_NONE:ht,DIRECTION_LEFT:Ue,DIRECTION_RIGHT:Be,DIRECTION_UP:Ve,DIRECTION_DOWN:ft,DIRECTION_HORIZONTAL:Ye,DIRECTION_VERTICAL:ee,DIRECTION_ALL:J,Manager:Hc,Input:ye,TouchAction:Ni,TouchInput:wt,MouseInput:Wl,PointerEventInput:Ps,TouchMouseInput:En,SingleTouchInput:re,Recognizer:Vi,AttrRecognizer:eo,Tap:Gl,Pan:Gh,Swipe:jh,Pinch:Kf,Rotate:Yf,Press:ju,on:C,off:k,each:d,merge:y,extend:g,assign:m,inherit:b,bindFn:_,prefixed:D});var l0=typeof e<"u"?e:typeof self<"u"?self:{};l0.Hammer=Zr,typeof i=="function"&&i.amd?i(function(){return Zr}):n.exports?n.exports=Zr:e[r]=Zr})(window,document,"Hammer")})(lut);var Wse={exports:{}};(function(n){(function(e){var t=e.URL||e.webkitURL;function r(c){return t?t.createObjectURL(c):!1}function i(c){return t?t.revokeObjectURL(c):!1}function s(c,u){c&&c.slice(0,5)==="blob:"&&!(u&&u.noRevoke)&&i(c)}function o(c,u,h,f){if(!e.FileReader)return!1;var d=new FileReader;d.onload=function(){u.call(d,this.result)},h&&(d.onabort=d.onerror=function(){h.call(d,this.error)});var p=d[f||"readAsDataURL"];if(p)return p.call(d,c),d}function a(c,u){return Object.prototype.toString.call(u)==="[object "+c+"]"}function l(c,u,h){function f(d,p){var m=document.createElement("img"),g;function y(_,w){if(d===p){d&&d(_,w);return}else if(_ instanceof Error){p(_);return}w=w||{},w.image=_,d(w)}function b(_,w){w&&e.console&&console.log(w),_&&a("Blob",_)?(c=_,g=r(c)):(g=c,h&&h.crossOrigin&&(m.crossOrigin=h.crossOrigin)),m.src=g}if(m.onerror=function(_){s(g,h),p&&p.call(m,_)},m.onload=function(){s(g,h);var _={originalWidth:m.naturalWidth||m.width,originalHeight:m.naturalHeight||m.height};try{l.transform(m,h,y,c,_)}catch(w){p&&p(w)}},typeof c=="string")return l.requiresMetaData(h)?l.fetchBlob(c,b,h):b(),m;if(a("Blob",c)||a("File",c))return g=r(c),g?(m.src=g,m):o(c,function(_){m.src=_},p)}return e.Promise&&typeof u!="function"?(h=u,new Promise(f)):f(u,u)}l.requiresMetaData=function(c){return c&&c.meta},l.fetchBlob=function(c,u){u()},l.transform=function(c,u,h,f,d){h(c,d)},l.global=e,l.readFile=o,l.isInstanceOf=a,l.createObjectURL=r,l.revokeObjectURL=i,n.exports?n.exports=l:e.loadImage=l})(typeof window<"u"&&window||gt)})(Wse);var Dp=Wse.exports,Hse={exports:{}};(function(n){(function(e){n.exports?e(Dp):e(window.loadImage)})(function(e){var t=e.transform;e.createCanvas=function(r,i,s){if(s&&e.global.OffscreenCanvas)return new OffscreenCanvas(r,i);var o=document.createElement("canvas");return o.width=r,o.height=i,o},e.transform=function(r,i,s,o,a){t.call(e,e.scale(r,i,a),i,s,o,a)},e.transformCoordinates=function(){},e.getTransformedOptions=function(r,i){var s=i.aspectRatio,o,a,l,c;if(!s)return i;o={};for(a in i)Object.prototype.hasOwnProperty.call(i,a)&&(o[a]=i[a]);return o.crop=!0,l=r.naturalWidth||r.width,c=r.naturalHeight||r.height,l/c>s?(o.maxWidth=c*s,o.maxHeight=c):(o.maxWidth=l,o.maxHeight=l/s),o},e.drawImage=function(r,i,s,o,a,l,c,u,h){var f=i.getContext("2d");return h.imageSmoothingEnabled===!1?(f.msImageSmoothingEnabled=!1,f.imageSmoothingEnabled=!1):h.imageSmoothingQuality&&(f.imageSmoothingQuality=h.imageSmoothingQuality),f.drawImage(r,s,o,a,l,0,0,c,u),f},e.requiresCanvas=function(r){return r.canvas||r.crop||!!r.aspectRatio},e.scale=function(r,i,s){i=i||{},s=s||{};var o=r.getContext||e.requiresCanvas(i)&&!!e.global.HTMLCanvasElement,a=r.naturalWidth||r.width,l=r.naturalHeight||r.height,c=a,u=l,h,f,d,p,m,g,y,b,_,w,S,C;function k(){var M=Math.max((d||c)/c,(p||u)/u);M>1&&(c*=M,u*=M)}function A(){var M=Math.min((h||c)/c,(f||u)/u);M<1&&(c*=M,u*=M)}if(o&&(i=e.getTransformedOptions(r,i,s),y=i.left||0,b=i.top||0,i.sourceWidth?(m=i.sourceWidth,i.right!==void 0&&i.left===void 0&&(y=a-m-i.right)):m=a-y-(i.right||0),i.sourceHeight?(g=i.sourceHeight,i.bottom!==void 0&&i.top===void 0&&(b=l-g-i.bottom)):g=l-b-(i.bottom||0),c=m,u=g),h=i.maxWidth,f=i.maxHeight,d=i.minWidth,p=i.minHeight,o&&h&&f&&i.crop?(c=h,u=f,S=m/g-h/f,S<0?(g=f*m/h,i.top===void 0&&i.bottom===void 0&&(b=(l-g)/2)):S>0&&(m=h*g/f,i.left===void 0&&i.right===void 0&&(y=(a-m)/2))):((i.contain||i.cover)&&(d=h=h||d,p=f=f||p),i.cover?(A(),k()):(k(),A())),o){if(_=i.pixelRatio,_>1&&!(r.style.width&&Math.floor(parseFloat(r.style.width,10))===Math.floor(a/_))&&(c*=_,u*=_),e.orientationCropBug&&!r.getContext&&(y||b||m!==a||g!==l)&&(S=r,r=e.createCanvas(a,l,!0),e.drawImage(S,r,0,0,a,l,a,l,i)),w=i.downsamplingRatio,w>0&&w<1&&c<m&&u<g)for(;m*w>c;)C=e.createCanvas(m*w,g*w,!0),e.drawImage(r,C,y,b,m,g,C.width,C.height,i),y=0,b=0,m=C.width,g=C.height,r=C;return C=e.createCanvas(c,u),e.transformCoordinates(C,i,s),_>1&&(C.style.width=C.width/_+"px"),e.drawImage(r,C,y,b,m,g,c,u,i).setTransform(1,0,0,1,0,0),C}return r.width=c,r.height=u,r}})})(Hse);var cut=Hse.exports,Gse={exports:{}};(function(n){(function(e){n.exports?e(Dp):e(window.loadImage)})(function(e){var t=e.global,r=e.transform,i=t.Blob&&(Blob.prototype.slice||Blob.prototype.webkitSlice||Blob.prototype.mozSlice),s=t.ArrayBuffer&&ArrayBuffer.prototype.slice||function(u,h){h=h||this.byteLength-u;var f=new Uint8Array(this,u,h),d=new Uint8Array(h);return d.set(f),d.buffer},o={jpeg:{65505:[],65517:[]}};function a(u,h,f,d){var p=this;function m(g,y){if(!(t.DataView&&i&&u&&u.size>=12&&u.type==="image/jpeg"))return g(d);var b=f.maxMetaDataSize||262144;e.readFile(i.call(u,0,b),function(_){var w=new DataView(_);if(w.getUint16(0)!==65496)return y(new Error("Invalid JPEG file: Missing JPEG marker."));for(var S=2,C=w.byteLength-4,k=S,A,M,E,N;S<C&&(A=w.getUint16(S),A>=65504&&A<=65519||A===65534);){if(M=w.getUint16(S+2)+2,S+M>w.byteLength){console.log("Invalid JPEG metadata: Invalid segment size.");break}if(E=o.jpeg[A],E&&!f.disableMetaDataParsers)for(N=0;N<E.length;N+=1)E[N].call(p,w,S,M,d,f);S+=M,k=S}!f.disableImageHead&&k>6&&(d.imageHead=s.call(_,0,k)),g(d)},y,"readAsArrayBuffer")||g(d)}return f=f||{},t.Promise&&typeof h!="function"?(f=h||{},d=f,new Promise(m)):(d=d||{},m(h,h))}function l(u,h,f){return!u||!h||!f?null:new Blob([f,i.call(u,h.byteLength)],{type:"image/jpeg"})}function c(u,h,f){var d={maxMetaDataSize:1024,disableMetaDataParsers:!0};if(!f&&t.Promise)return a(u,d).then(function(p){return l(u,p.imageHead,h)});a(u,function(p){f(l(u,p.imageHead,h))},d)}e.transform=function(u,h,f,d,p){e.requiresMetaData(h)?(p=p||{},a(d,function(m){m!==p&&(t.console&&console.log(m),m=p),r.call(e,u,h,f,d,m)},h,p)):r.apply(e,arguments)},e.blobSlice=i,e.bufferSlice=s,e.replaceHead=c,e.parseMetaData=a,e.metaDataParsers=o})})(Gse);var F4=Gse.exports,uut={exports:{}};(function(n){(function(e){n.exports?e(Dp):e(window.loadImage)})(function(e){var t=e.global;t.fetch&&t.Request&&t.Response&&t.Response.prototype.blob?e.fetchBlob=function(r,i,s){function o(a){return a.blob()}if(t.Promise&&typeof i!="function")return fetch(new Request(r,i)).then(o);fetch(new Request(r,s)).then(o).then(i).catch(function(a){i(null,a)})}:t.XMLHttpRequest&&new XMLHttpRequest().responseType===""&&(e.fetchBlob=function(r,i,s){function o(a,l){s=s||{};var c=new XMLHttpRequest;c.open(s.method||"GET",r),s.headers&&Object.keys(s.headers).forEach(function(u){c.setRequestHeader(u,s.headers[u])}),c.withCredentials=s.credentials==="include",c.responseType="blob",c.onload=function(){a(c.response)},c.onerror=c.onabort=c.ontimeout=function(u){a===l?l(null,u):l(u)},c.send(s.body)}return t.Promise&&typeof i!="function"?(s=i,new Promise(o)):o(i,i)})})})(uut);var jse={exports:{}};(function(n){(function(e){n.exports?e(Dp,F4):e(window.loadImage)})(function(e){function t(c){c&&(Object.defineProperty(this,"map",{value:this.ifds[c].map}),Object.defineProperty(this,"tags",{value:this.tags&&this.tags[c]||{}}))}t.prototype.map={Orientation:274,Thumbnail:"ifd1",Blob:513,Exif:34665,GPSInfo:34853,Interoperability:40965},t.prototype.ifds={ifd1:{name:"Thumbnail",map:t.prototype.map},34665:{name:"Exif",map:{}},34853:{name:"GPSInfo",map:{}},40965:{name:"Interoperability",map:{}}},t.prototype.get=function(c){return this[c]||this[this.map[c]]};function r(c,u,h){if(h){if(u+h>c.byteLength){console.log("Invalid Exif data: Invalid thumbnail data.");return}return new Blob([e.bufferSlice.call(c.buffer,u,u+h)],{type:"image/jpeg"})}}var i={1:{getValue:function(c,u){return c.getUint8(u)},size:1},2:{getValue:function(c,u){return String.fromCharCode(c.getUint8(u))},size:1,ascii:!0},3:{getValue:function(c,u,h){return c.getUint16(u,h)},size:2},4:{getValue:function(c,u,h){return c.getUint32(u,h)},size:4},5:{getValue:function(c,u,h){return c.getUint32(u,h)/c.getUint32(u+4,h)},size:8},9:{getValue:function(c,u,h){return c.getInt32(u,h)},size:4},10:{getValue:function(c,u,h){return c.getInt32(u,h)/c.getInt32(u+4,h)},size:8}};i[7]=i[1];function s(c,u,h,f,d,p){var m=i[f],g,y,b,_,w,S;if(!m){console.log("Invalid Exif data: Invalid tag type.");return}if(g=m.size*d,y=g>4?u+c.getUint32(h+8,p):h+8,y+g>c.byteLength){console.log("Invalid Exif data: Invalid data offset.");return}if(d===1)return m.getValue(c,y,p);for(b=[],_=0;_<d;_+=1)b[_]=m.getValue(c,y+_*m.size,p);if(m.ascii){for(w="",_=0;_<b.length&&(S=b[_],S!=="\0");_+=1)w+=S;return w}return b}function o(c,u,h){return(!c||c[h])&&(!u||u[h]!==!0)}function a(c,u,h,f,d,p,m,g){var y,b,_,w,S,C;if(h+6>c.byteLength){console.log("Invalid Exif data: Invalid directory offset.");return}if(y=c.getUint16(h,f),b=h+2+12*y,b+4>c.byteLength){console.log("Invalid Exif data: Invalid directory size.");return}for(_=0;_<y;_+=1)w=h+2+12*_,S=c.getUint16(w,f),o(m,g,S)&&(C=s(c,u,w,c.getUint16(w+2,f),c.getUint32(w+4,f),f),d[S]=C,p&&(p[S]=w));return c.getUint32(b,f)}function l(c,u,h,f,d,p,m){var g=c.exif[u];g&&(c.exif[u]=new t(u),c.exifOffsets&&(c.exifOffsets[u]=new t(u)),a(h,f,f+g,d,c.exif[u],c.exifOffsets&&c.exifOffsets[u],p&&p[u],m&&m[u]))}e.parseExifData=function(c,u,h,f,d){if(!d.disableExif){var p=d.includeExifTags,m=d.excludeExifTags||{34665:{37500:!0}},g=u+10,y,b,_;if(c.getUint32(u+4)===1165519206){if(g+8>c.byteLength){console.log("Invalid Exif data: Invalid segment size.");return}if(c.getUint16(u+8)!==0){console.log("Invalid Exif data: Missing byte alignment offset.");return}switch(c.getUint16(g)){case 18761:y=!0;break;case 19789:y=!1;break;default:console.log("Invalid Exif data: Invalid byte alignment marker.");return}if(c.getUint16(g+2,y)!==42){console.log("Invalid Exif data: Missing TIFF marker.");return}b=c.getUint32(g+4,y),f.exif=new t,d.disableExifOffsets||(f.exifOffsets=new t,f.exifTiffOffset=g,f.exifLittleEndian=y),b=a(c,g,g+b,y,f.exif,f.exifOffsets,p,m),b&&o(p,m,"ifd1")&&(f.exif.ifd1=b,f.exifOffsets&&(f.exifOffsets.ifd1=g+b)),Object.keys(f.exif.ifds).forEach(function(w){l(f,w,c,g,y,p,m)}),_=f.exif.ifd1,_&&_[513]&&(_[513]=r(c,g+_[513],_[514]))}}},e.metaDataParsers.jpeg[65505].push(e.parseExifData),e.exifWriters={274:function(c,u,h){var f=u.exifOffsets[274];if(!f)return c;var d=new DataView(c,f+8,2);return d.setUint16(0,h,u.exifLittleEndian),c}},e.writeExifData=function(c,u,h,f){return e.exifWriters[u.exif.map[h]](c,u,f)},e.ExifMap=t})})(jse);var hut=jse.exports,fut={exports:{}};(function(n){(function(e){n.exports?e(Dp,hut):e(window.loadImage)})(function(e){var t=e.ExifMap.prototype;t.tags={256:"ImageWidth",257:"ImageHeight",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",274:"Orientation",277:"SamplesPerPixel",284:"PlanarConfiguration",530:"YCbCrSubSampling",531:"YCbCrPositioning",282:"XResolution",283:"YResolution",296:"ResolutionUnit",273:"StripOffsets",278:"RowsPerStrip",279:"StripByteCounts",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",301:"TransferFunction",318:"WhitePoint",319:"PrimaryChromaticities",529:"YCbCrCoefficients",532:"ReferenceBlackWhite",306:"DateTime",270:"ImageDescription",271:"Make",272:"Model",305:"Software",315:"Artist",33432:"Copyright",34665:{36864:"ExifVersion",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",42240:"Gamma",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37500:"MakerNote",37510:"UserComment",40964:"RelatedSoundFile",36867:"DateTimeOriginal",36868:"DateTimeDigitized",36880:"OffsetTime",36881:"OffsetTimeOriginal",36882:"OffsetTimeDigitized",37520:"SubSecTime",37521:"SubSecTimeOriginal",37522:"SubSecTimeDigitized",33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"PhotographicSensitivity",34856:"OECF",34864:"SensitivityType",34865:"StandardOutputSensitivity",34866:"RecommendedExposureIndex",34867:"ISOSpeed",34868:"ISOSpeedLatitudeyyy",34869:"ISOSpeedLatitudezzz",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBias",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37396:"SubjectArea",37386:"FocalLength",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRatio",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",42016:"ImageUniqueID",42032:"CameraOwnerName",42033:"BodySerialNumber",42034:"LensSpecification",42035:"LensMake",42036:"LensModel",42037:"LensSerialNumber"},34853:{0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential",31:"GPSHPositioningError"},40965:{1:"InteroperabilityIndex"}},t.tags.ifd1=t.tags,t.stringValues={ExposureProgram:{0:"Undefined",1:"Manual",2:"Normal program",3:"Aperture priority",4:"Shutter priority",5:"Creative program",6:"Action program",7:"Portrait mode",8:"Landscape mode"},MeteringMode:{0:"Unknown",1:"Average",2:"CenterWeightedAverage",3:"Spot",4:"MultiSpot",5:"Pattern",6:"Partial",255:"Other"},LightSource:{0:"Unknown",1:"Daylight",2:"Fluorescent",3:"Tungsten (incandescent light)",4:"Flash",9:"Fine weather",10:"Cloudy weather",11:"Shade",12:"Daylight fluorescent (D 5700 - 7100K)",13:"Day white fluorescent (N 4600 - 5400K)",14:"Cool white fluorescent (W 3900 - 4500K)",15:"White fluorescent (WW 3200 - 3700K)",17:"Standard light A",18:"Standard light B",19:"Standard light C",20:"D55",21:"D65",22:"D75",23:"D50",24:"ISO studio tungsten",255:"Other"},Flash:{0:"Flash did not fire",1:"Flash fired",5:"Strobe return light not detected",7:"Strobe return light detected",9:"Flash fired, compulsory flash mode",13:"Flash fired, compulsory flash mode, return light not detected",15:"Flash fired, compulsory flash mode, return light detected",16:"Flash did not fire, compulsory flash mode",24:"Flash did not fire, auto mode",25:"Flash fired, auto mode",29:"Flash fired, auto mode, return light not detected",31:"Flash fired, auto mode, return light detected",32:"No flash function",65:"Flash fired, red-eye reduction mode",69:"Flash fired, red-eye reduction mode, return light not detected",71:"Flash fired, red-eye reduction mode, return light detected",73:"Flash fired, compulsory flash mode, red-eye reduction mode",77:"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",79:"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",89:"Flash fired, auto mode, red-eye reduction mode",93:"Flash fired, auto mode, return light not detected, red-eye reduction mode",95:"Flash fired, auto mode, return light detected, red-eye reduction mode"},SensingMethod:{1:"Undefined",2:"One-chip color area sensor",3:"Two-chip color area sensor",4:"Three-chip color area sensor",5:"Color sequential area sensor",7:"Trilinear sensor",8:"Color sequential linear sensor"},SceneCaptureType:{0:"Standard",1:"Landscape",2:"Portrait",3:"Night scene"},SceneType:{1:"Directly photographed"},CustomRendered:{0:"Normal process",1:"Custom process"},WhiteBalance:{0:"Auto white balance",1:"Manual white balance"},GainControl:{0:"None",1:"Low gain up",2:"High gain up",3:"Low gain down",4:"High gain down"},Contrast:{0:"Normal",1:"Soft",2:"Hard"},Saturation:{0:"Normal",1:"Low saturation",2:"High saturation"},Sharpness:{0:"Normal",1:"Soft",2:"Hard"},SubjectDistanceRange:{0:"Unknown",1:"Macro",2:"Close view",3:"Distant view"},FileSource:{3:"DSC"},ComponentsConfiguration:{0:"",1:"Y",2:"Cb",3:"Cr",4:"R",5:"G",6:"B"},Orientation:{1:"Original",2:"Horizontal flip",3:"Rotate 180° CCW",4:"Vertical flip",5:"Vertical flip + Rotate 90° CW",6:"Rotate 90° CW",7:"Horizontal flip + Rotate 90° CW",8:"Rotate 90° CCW"}},t.getText=function(r){var i=this.get(r);switch(r){case"LightSource":case"Flash":case"MeteringMode":case"ExposureProgram":case"SensingMethod":case"SceneCaptureType":case"SceneType":case"CustomRendered":case"WhiteBalance":case"GainControl":case"Contrast":case"Saturation":case"Sharpness":case"SubjectDistanceRange":case"FileSource":case"Orientation":return this.stringValues[r][i];case"ExifVersion":case"FlashpixVersion":return i?String.fromCharCode(i[0],i[1],i[2],i[3]):void 0;case"ComponentsConfiguration":return i?this.stringValues[r][i[0]]+this.stringValues[r][i[1]]+this.stringValues[r][i[2]]+this.stringValues[r][i[3]]:void 0;case"GPSVersionID":return i?i[0]+"."+i[1]+"."+i[2]+"."+i[3]:void 0}return String(i)},t.getAll=function(){var r={},i,s,o;for(i in this)Object.prototype.hasOwnProperty.call(this,i)&&(s=this[i],s&&s.getAll?r[this.ifds[i].name]=s.getAll():(o=this.tags[i],o&&(r[o]=this.getText(o))));return r},t.getName=function(r){var i=this.tags[r];return typeof i=="object"?this.ifds[r].name:i},function(){var r=t.tags,i,s,o;for(i in r)if(Object.prototype.hasOwnProperty.call(r,i))if(s=t.ifds[i],s){o=r[i];for(i in o)Object.prototype.hasOwnProperty.call(o,i)&&(s.map[o[i]]=Number(i))}else t.map[r[i]]=Number(i)}()})})(fut);var qse={exports:{}};(function(n){(function(e){n.exports?e(Dp,F4):e(window.loadImage)})(function(e){function t(){}t.prototype.map={ObjectName:5},t.prototype.types={0:"Uint16",200:"Uint16",201:"Uint16",202:"binary"},t.prototype.get=function(c){return this[c]||this[this.map[c]]};function r(c,u,h){for(var f="",d=u+h,p=u;p<d;p+=1)f+=String.fromCharCode(c.getUint8(p));return f}function i(c,u,h,f,d){return u.types[c]==="binary"?new Blob([h.buffer.slice(f,f+d)]):u.types[c]==="Uint16"?h.getUint16(f):r(h,f,d)}function s(c,u){return c===void 0?u:c instanceof Array?(c.push(u),c):[c,u]}function o(c,u,h,f,d,p){for(var m,g,y,b=u+h,_=u;_<b;)c.getUint8(_)===28&&c.getUint8(_+1)===2&&(y=c.getUint8(_+2),(!d||d[y])&&(!p||!p[y])&&(g=c.getInt16(_+3),m=i(y,f.iptc,c,_+5,g),f.iptc[y]=s(f.iptc[y],m),f.iptcOffsets&&(f.iptcOffsets[y]=_))),_+=1}function a(c,u){return c.getUint32(u)===943868237&&c.getUint16(u+4)===1028}function l(c,u){var h=c.getUint8(u+7);return h%2!==0&&(h+=1),h===0&&(h=4),h}e.parseIptcData=function(c,u,h,f,d){if(!d.disableIptc)for(var p=u+h;u+8<p;){if(a(c,u)){var m=l(c,u),g=u+8+m;if(g>p){console.log("Invalid IPTC data: Invalid segment offset.");break}var y=c.getUint16(u+6+m);if(u+y>p){console.log("Invalid IPTC data: Invalid segment size.");break}f.iptc=new t,d.disableIptcOffsets||(f.iptcOffsets=new t),o(c,g,y,f,d.includeIptcTags,d.excludeIptcTags||{202:!0});return}u+=1}},e.metaDataParsers.jpeg[65517].push(e.parseIptcData),e.IptcMap=t})})(qse);var dut=qse.exports,put={exports:{}};(function(n){(function(e){n.exports?e(Dp,dut):e(window.loadImage)})(function(e){var t=e.IptcMap.prototype;t.tags={0:"ApplicationRecordVersion",3:"ObjectTypeReference",4:"ObjectAttributeReference",5:"ObjectName",7:"EditStatus",8:"EditorialUpdate",10:"Urgency",12:"SubjectReference",15:"Category",20:"SupplementalCategories",22:"FixtureIdentifier",25:"Keywords",26:"ContentLocationCode",27:"ContentLocationName",30:"ReleaseDate",35:"ReleaseTime",37:"ExpirationDate",38:"ExpirationTime",40:"SpecialInstructions",42:"ActionAdvised",45:"ReferenceService",47:"ReferenceDate",50:"ReferenceNumber",55:"DateCreated",60:"TimeCreated",62:"DigitalCreationDate",63:"DigitalCreationTime",65:"OriginatingProgram",70:"ProgramVersion",75:"ObjectCycle",80:"Byline",85:"BylineTitle",90:"City",92:"Sublocation",95:"State",100:"CountryCode",101:"Country",103:"OriginalTransmissionReference",105:"Headline",110:"Credit",115:"Source",116:"CopyrightNotice",118:"Contact",120:"Caption",121:"LocalCaption",122:"Writer",125:"RasterizedCaption",130:"ImageType",131:"ImageOrientation",135:"LanguageIdentifier",150:"AudioType",151:"AudioSamplingRate",152:"AudioSamplingResolution",153:"AudioDuration",154:"AudioOutcue",184:"JobID",185:"MasterDocumentID",186:"ShortDocumentID",187:"UniqueDocumentID",188:"OwnerID",200:"ObjectPreviewFileFormat",201:"ObjectPreviewFileVersion",202:"ObjectPreviewData",221:"Prefs",225:"ClassifyState",228:"SimilarityIndex",230:"DocumentNotes",231:"DocumentHistory",232:"ExifCameraInfo",255:"CatalogSets"},t.stringValues={10:{0:"0 (reserved)",1:"1 (most urgent)",2:"2",3:"3",4:"4",5:"5 (normal urgency)",6:"6",7:"7",8:"8 (least urgent)",9:"9 (user-defined priority)"},75:{a:"Morning",b:"Both Morning and Evening",p:"Evening"},131:{L:"Landscape",P:"Portrait",S:"Square"}},t.getText=function(r){var i=this.get(r),s=this.map[r],o=this.stringValues[s];return o?o[i]:String(i)},t.getAll=function(){var r={},i,s;for(i in this)Object.prototype.hasOwnProperty.call(this,i)&&(s=this.tags[i],s&&(r[s]=this.getText(s)));return r},t.getName=function(r){return this.tags[r]},function(){var r=t.tags,i=t.map||{},s;for(s in r)Object.prototype.hasOwnProperty.call(r,s)&&(i[r[s]]=Number(s))}()})})(put);var mut={exports:{}};(function(n){(function(e){n.exports?e(Dp,cut,F4):e(window.loadImage)})(function(e){var t=e.transform,r=e.requiresCanvas,i=e.requiresMetaData,s=e.transformCoordinates,o=e.getTransformedOptions;(function(u){if(u.global.document){var h="data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAIAAwMBEQACEQEDEQH/xABRAAEAAAAAAAAAAAAAAAAAAAAKEAEBAQADAQEAAAAAAAAAAAAGBQQDCAkCBwEBAAAAAAAAAAAAAAAAAAAAABEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AG8T9NfSMEVMhQvoP3fFiRZ+MTHDifa/95OFSZU5OzRzxkyejv8ciEfhSceSXGjS8eSdLnZc2HDm4M3BxcXwH/9k=",f=document.createElement("img");f.onload=function(){if(u.orientation=f.width===2&&f.height===3,u.orientation){var d=u.createCanvas(1,1,!0),p=d.getContext("2d");p.drawImage(f,1,1,1,1,0,0,1,1),u.orientationCropBug=p.getImageData(0,0,1,1).data.toString()!=="255,255,255,255"}},f.src=h}})(e);function a(u,h){var f=u&&u.orientation;return f===!0&&!e.orientation||f===1&&e.orientation||(!h||e.orientation)&&f>1&&f<9}function l(u,h){return u!==h&&(u===1&&h>1&&h<9||u>1&&u<9)}function c(u,h){if(h>1&&h<9)switch(u){case 2:case 4:return h>4;case 5:case 7:return h%2===0;case 6:case 8:return h===2||h===4||h===5||h===7}return!1}e.requiresCanvas=function(u){return a(u)||r.call(e,u)},e.requiresMetaData=function(u){return a(u,!0)||i.call(e,u)},e.transform=function(u,h,f,d,p){t.call(e,u,h,function(m,g){if(g){var y=e.orientation&&g.exif&&g.exif.get("Orientation");if(y>4&&y<9){var b=g.originalWidth,_=g.originalHeight;g.originalWidth=_,g.originalHeight=b}}f(m,g)},d,p)},e.getTransformedOptions=function(u,h,f){var d=o.call(e,u,h),p=f.exif&&f.exif.get("Orientation"),m=d.orientation,g=e.orientation&&p;if(m===!0&&(m=p),!l(m,g))return d;var y=d.top,b=d.right,_=d.bottom,w=d.left,S={};for(var C in d)Object.prototype.hasOwnProperty.call(d,C)&&(S[C]=d[C]);if(S.orientation=m,(m>4&&!(g>4)||m<5&&g>4)&&(S.maxWidth=d.maxHeight,S.maxHeight=d.maxWidth,S.minWidth=d.minHeight,S.minHeight=d.minWidth,S.sourceWidth=d.sourceHeight,S.sourceHeight=d.sourceWidth),g>1){switch(g){case 2:b=d.left,w=d.right;break;case 3:y=d.bottom,b=d.left,_=d.top,w=d.right;break;case 4:y=d.bottom,_=d.top;break;case 5:y=d.left,b=d.bottom,_=d.right,w=d.top;break;case 6:y=d.left,b=d.top,_=d.right,w=d.bottom;break;case 7:y=d.right,b=d.top,_=d.left,w=d.bottom;break;case 8:y=d.right,b=d.bottom,_=d.left,w=d.top;break}if(c(m,g)){var k=y,A=b;y=_,b=w,_=k,w=A}}switch(S.top=y,S.right=b,S.bottom=_,S.left=w,m){case 2:S.right=w,S.left=b;break;case 3:S.top=_,S.right=w,S.bottom=y,S.left=b;break;case 4:S.top=_,S.bottom=y;break;case 5:S.top=w,S.right=_,S.bottom=b,S.left=y;break;case 6:S.top=b,S.right=_,S.bottom=w,S.left=y;break;case 7:S.top=b,S.right=y,S.bottom=w,S.left=_;break;case 8:S.top=w,S.right=y,S.bottom=b,S.left=_;break}return S},e.transformCoordinates=function(u,h,f){s.call(e,u,h,f);var d=h.orientation,p=e.orientation&&f.exif&&f.exif.get("Orientation");if(l(d,p)){var m=u.getContext("2d"),g=u.width,y=u.height,b=g,_=y;switch((d>4&&!(p>4)||d<5&&p>4)&&(u.width=y,u.height=g),d>4&&(b=y,_=g),p){case 2:m.translate(b,0),m.scale(-1,1);break;case 3:m.translate(b,_),m.rotate(Math.PI);break;case 4:m.translate(0,_),m.scale(1,-1);break;case 5:m.rotate(-.5*Math.PI),m.scale(-1,1);break;case 6:m.rotate(-.5*Math.PI),m.translate(-b,0);break;case 7:m.rotate(-.5*Math.PI),m.translate(-b,_),m.scale(1,-1);break;case 8:m.rotate(.5*Math.PI),m.translate(0,-_);break}switch(c(d,p)&&(m.translate(b,_),m.rotate(Math.PI)),d){case 2:m.translate(g,0),m.scale(-1,1);break;case 3:m.translate(g,y),m.rotate(Math.PI);break;case 4:m.translate(0,y),m.scale(1,-1);break;case 5:m.rotate(.5*Math.PI),m.scale(1,-1);break;case 6:m.rotate(.5*Math.PI),m.translate(0,-y);break;case 7:m.rotate(.5*Math.PI),m.translate(g,-y),m.scale(-1,1);break;case 8:m.rotate(-.5*Math.PI),m.translate(-g,0);break}}}})})(mut);function k$(n,e){let t=0;for(let r=0;r<n.length;r++)t+=(n[r]-e[r])*(n[r]-e[r]);return t}const q3={distanceFunction:k$};function gut(n,e,t=q3){const r=t.distanceFunction||q3.distanceFunction,i=t.similarityFunction||q3.similarityFunction;let s=-1;if(typeof i=="function"){let o=Number.MIN_VALUE;for(let a=0;a<n.length;a++){const l=i(e,n[a]);l>o&&(o=l,s=a)}}else if(typeof r=="function"){let o=Number.MAX_VALUE;for(let a=0;a<n.length;a++){const l=r(e,n[a]);l<o&&(o=l,s=a)}}else throw new Error("A similarity or distance function it's required");return s}function yut(n,e){for(var t=new Array(n.length),r=0;r<n.length;++r)for(var i=r;i<n.length;++i){t[r]||(t[r]=new Array(n.length)),t[i]||(t[i]=new Array(n.length));const s=e(n[r],n[i]);t[r][i]=s,t[i][r]=s}return t}function Xse(n,e,t,r){for(var i=0;i<n.length;i++)t[i]=gut(e,n[i],{distanceFunction:r});return t}function but(n,e,t,r){const i=e[0].length;for(var s=new Array(r),o=new Array(r),a=0;a<r;a++){s[a]=new Array(i),o[a]=0;for(var l=0;l<i;l++)s[a][l]=0}for(var c=0;c<e.length;c++){o[t[c]]++;for(var u=0;u<i;u++)s[t[c]][u]+=e[c][u]}for(var h=0;h<r;h++)for(var f=0;f<i;f++)o[h]?s[h][f]/=o[h]:s[h][f]=n[h][f];return s}function vut(n,e,t,r){for(var i=0;i<n.length;i++)if(t(n[i],e[i])>r)return!1;return!0}const hj=8,wut=1/16777216,xut=15,_ut=18,Sut=11;function Cut(n,e){n>>>=0,e>>>=0;const t=n&65535;return((n-t)*e>>>0)+t*e>>>0}class kut{constructor(e=Date.now()){this.state=new Uint32Array(4),this.init(e),this.random=this.getFloat.bind(this)}getUint32(){return this.nextState(),this.state[3]+this.state[2]>>>0}getFloat(){return(this.getUint32()>>>8)*wut}init(e){if(!Number.isInteger(e))throw new TypeError("seed must be an integer");this.state[0]=e,this.state[1]=0,this.state[2]=0,this.state[3]=0;for(let t=1;t<hj;t++)this.state[t&3]^=t+Cut(1812433253,this.state[t-1&3]^this.state[t-1&3]>>>30>>>0)>>>0;this.periodCertification();for(let t=0;t<hj;t++)this.nextState()}periodCertification(){this.state[0]===0&&this.state[1]===0&&this.state[2]===0&&this.state[3]===0&&(this.state[0]=88,this.state[1]=83,this.state[2]=65,this.state[3]=68)}nextState(){let e=this.state[0];e^=e<<xut,e^=e>>>_ut,e^=this.state[3]<<Sut,this.state[0]=this.state[1],this.state[1]=this.state[2],this.state[2]=this.state[3],this.state[3]=e}}const Tut=1e-8;function fj(n,e={},t=Math.random){const{size:r=1,replace:i=!1,probabilities:s}=e;let o,a;if(typeof n=="number"?o=Eut(n):o=n.slice(),s){if(!i)throw new Error("choice with probabilities and no replacement is not implemented");if(s.length!==o.length)throw new Error("the length of probabilities option should be equal to the number of choices");a=[s[0]];for(let c=1;c<s.length;c++)a[c]=a[c-1]+s[c];if(Math.abs(1-a[a.length-1])>Tut)throw new Error(`probabilities should sum to 1, but instead sums to ${a[a.length-1]}`)}if(i===!1&&r>o.length)throw new Error("size option is too large");const l=[];for(let c=0;c<r;c++){const u=Iut(o.length,t,a);l.push(o[u]),i||o.splice(u,1)}return l}function Eut(n){const e=[];for(let t=0;t<n;t++)e.push(t);return e}function Iut(n,e,t){const r=e();if(t){let i=0;for(;r>t[i];)i++;return i}else return Math.floor(r*n)}class L4{constructor(e=Math.random){if(typeof e=="number"){const t=new kut(e);this.randomGenerator=t.random}else this.randomGenerator=e}choice(e,t){return typeof e=="number"?fj(e,t,this.randomGenerator):fj(e,t,this.randomGenerator)}random(){return this.randomGenerator()}randInt(e,t){return t===void 0&&(t=e,e=0),e+Math.floor(this.randomGenerator()*(t-e))}randomSample(e){const t=[];for(let r=0;r<e;r++)t.push(this.random());return t}}const Aut=Object.prototype.toString;function vl(n){const e=Aut.call(n);return e.endsWith("Array]")&&!e.includes("Big")}function Mut(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!vl(n))throw new TypeError("input must be an array");if(n.length===0)throw new TypeError("input must not be empty");var t=e.fromIndex,r=t===void 0?0:t,i=e.toIndex,s=i===void 0?n.length:i;if(r<0||r>=n.length||!Number.isInteger(r))throw new Error("fromIndex must be a positive integer smaller than length");if(s<=r||s>n.length||!Number.isInteger(s))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var o=n[r],a=r+1;a<s;a++)n[a]>o&&(o=n[a]);return o}function Nut(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!vl(n))throw new TypeError("input must be an array");if(n.length===0)throw new TypeError("input must not be empty");var t=e.fromIndex,r=t===void 0?0:t,i=e.toIndex,s=i===void 0?n.length:i;if(r<0||r>=n.length||!Number.isInteger(r))throw new Error("fromIndex must be a positive integer smaller than length");if(s<=r||s>n.length||!Number.isInteger(s))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var o=n[r],a=r+1;a<s;a++)n[a]<o&&(o=n[a]);return o}function dj(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(vl(n)){if(n.length===0)throw new TypeError("input must not be empty")}else throw new TypeError("input must be an array");var t;if(e.output!==void 0){if(!vl(e.output))throw new TypeError("output option must be an array if specified");t=e.output}else t=new Array(n.length);var r=Nut(n),i=Mut(n);if(r===i)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var s=e.min,o=s===void 0?e.autoMinMax?r:0:s,a=e.max,l=a===void 0?e.autoMinMax?i:1:a;if(o>=l)throw new RangeError("min option must be smaller than max option");for(var c=(l-o)/(i-r),u=0;u<n.length;u++)t[u]=(n[u]-r)*c+o;return t}const MT=" ".repeat(2),Kse=" ".repeat(4);function $ut(){return Yse(this)}function Yse(n,e={}){const{maxRows:t=15,maxColumns:r=10,maxNumSize:i=8,padMinus:s="auto"}=e;return`${n.constructor.name} {
${MT}[
${Kse}${Rut(n,t,r,i,s)}
${MT}]
${MT}rows: ${n.rows}
${MT}columns: ${n.columns}
}`}function Rut(n,e,t,r,i){const{rows:s,columns:o}=n,a=Math.min(s,e),l=Math.min(o,t),c=[];if(i==="auto"){i=!1;e:for(let u=0;u<a;u++)for(let h=0;h<l;h++)if(n.get(u,h)<0){i=!0;break e}}for(let u=0;u<a;u++){let h=[];for(let f=0;f<l;f++)h.push(Put(n.get(u,f),r,i));c.push(`${h.join(" ")}`)}return l!==o&&(c[c.length-1]+=` ... ${o-t} more columns`),a!==s&&c.push(`... ${s-e} more rows`),c.join(`
${Kse}`)}function Put(n,e,t){return(n>=0&&t?` ${pj(n,e-1)}`:pj(n,e)).padEnd(e)}function pj(n,e){let t=n.toString();if(t.length<=e)return t;let r=n.toFixed(e);if(r.length>e&&(r=n.toFixed(Math.max(0,e-(r.length-e)))),r.length<=e&&!r.startsWith("0.000")&&!r.startsWith("-0.000"))return r;let i=n.toExponential(e);return i.length>e&&(i=n.toExponential(Math.max(0,e-(i.length-e)))),i.slice(0)}function Dut(n,e){n.prototype.add=function(r){return typeof r=="number"?this.addS(r):this.addM(r)},n.prototype.addS=function(r){for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)+r);return this},n.prototype.addM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)+r.get(i,s));return this},n.add=function(r,i){return new e(r).add(i)},n.prototype.sub=function(r){return typeof r=="number"?this.subS(r):this.subM(r)},n.prototype.subS=function(r){for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)-r);return this},n.prototype.subM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)-r.get(i,s));return this},n.sub=function(r,i){return new e(r).sub(i)},n.prototype.subtract=n.prototype.sub,n.prototype.subtractS=n.prototype.subS,n.prototype.subtractM=n.prototype.subM,n.subtract=n.sub,n.prototype.mul=function(r){return typeof r=="number"?this.mulS(r):this.mulM(r)},n.prototype.mulS=function(r){for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)*r);return this},n.prototype.mulM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)*r.get(i,s));return this},n.mul=function(r,i){return new e(r).mul(i)},n.prototype.multiply=n.prototype.mul,n.prototype.multiplyS=n.prototype.mulS,n.prototype.multiplyM=n.prototype.mulM,n.multiply=n.mul,n.prototype.div=function(r){return typeof r=="number"?this.divS(r):this.divM(r)},n.prototype.divS=function(r){for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)/r);return this},n.prototype.divM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)/r.get(i,s));return this},n.div=function(r,i){return new e(r).div(i)},n.prototype.divide=n.prototype.div,n.prototype.divideS=n.prototype.divS,n.prototype.divideM=n.prototype.divM,n.divide=n.div,n.prototype.mod=function(r){return typeof r=="number"?this.modS(r):this.modM(r)},n.prototype.modS=function(r){for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)%r);return this},n.prototype.modM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)%r.get(i,s));return this},n.mod=function(r,i){return new e(r).mod(i)},n.prototype.modulus=n.prototype.mod,n.prototype.modulusS=n.prototype.modS,n.prototype.modulusM=n.prototype.modM,n.modulus=n.mod,n.prototype.and=function(r){return typeof r=="number"?this.andS(r):this.andM(r)},n.prototype.andS=function(r){for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)&r);return this},n.prototype.andM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)&r.get(i,s));return this},n.and=function(r,i){return new e(r).and(i)},n.prototype.or=function(r){return typeof r=="number"?this.orS(r):this.orM(r)},n.prototype.orS=function(r){for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)|r);return this},n.prototype.orM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)|r.get(i,s));return this},n.or=function(r,i){return new e(r).or(i)},n.prototype.xor=function(r){return typeof r=="number"?this.xorS(r):this.xorM(r)},n.prototype.xorS=function(r){for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)^r);return this},n.prototype.xorM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)^r.get(i,s));return this},n.xor=function(r,i){return new e(r).xor(i)},n.prototype.leftShift=function(r){return typeof r=="number"?this.leftShiftS(r):this.leftShiftM(r)},n.prototype.leftShiftS=function(r){for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)<<r);return this},n.prototype.leftShiftM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)<<r.get(i,s));return this},n.leftShift=function(r,i){return new e(r).leftShift(i)},n.prototype.signPropagatingRightShift=function(r){return typeof r=="number"?this.signPropagatingRightShiftS(r):this.signPropagatingRightShiftM(r)},n.prototype.signPropagatingRightShiftS=function(r){for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)>>r);return this},n.prototype.signPropagatingRightShiftM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)>>r.get(i,s));return this},n.signPropagatingRightShift=function(r,i){return new e(r).signPropagatingRightShift(i)},n.prototype.rightShift=function(r){return typeof r=="number"?this.rightShiftS(r):this.rightShiftM(r)},n.prototype.rightShiftS=function(r){for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)>>>r);return this},n.prototype.rightShiftM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,this.get(i,s)>>>r.get(i,s));return this},n.rightShift=function(r,i){return new e(r).rightShift(i)},n.prototype.zeroFillRightShift=n.prototype.rightShift,n.prototype.zeroFillRightShiftS=n.prototype.rightShiftS,n.prototype.zeroFillRightShiftM=n.prototype.rightShiftM,n.zeroFillRightShift=n.rightShift,n.prototype.not=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,~this.get(r,i));return this},n.not=function(r){return new e(r).not()},n.prototype.abs=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.abs(this.get(r,i)));return this},n.abs=function(r){return new e(r).abs()},n.prototype.acos=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.acos(this.get(r,i)));return this},n.acos=function(r){return new e(r).acos()},n.prototype.acosh=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.acosh(this.get(r,i)));return this},n.acosh=function(r){return new e(r).acosh()},n.prototype.asin=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.asin(this.get(r,i)));return this},n.asin=function(r){return new e(r).asin()},n.prototype.asinh=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.asinh(this.get(r,i)));return this},n.asinh=function(r){return new e(r).asinh()},n.prototype.atan=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.atan(this.get(r,i)));return this},n.atan=function(r){return new e(r).atan()},n.prototype.atanh=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.atanh(this.get(r,i)));return this},n.atanh=function(r){return new e(r).atanh()},n.prototype.cbrt=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.cbrt(this.get(r,i)));return this},n.cbrt=function(r){return new e(r).cbrt()},n.prototype.ceil=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.ceil(this.get(r,i)));return this},n.ceil=function(r){return new e(r).ceil()},n.prototype.clz32=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.clz32(this.get(r,i)));return this},n.clz32=function(r){return new e(r).clz32()},n.prototype.cos=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.cos(this.get(r,i)));return this},n.cos=function(r){return new e(r).cos()},n.prototype.cosh=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.cosh(this.get(r,i)));return this},n.cosh=function(r){return new e(r).cosh()},n.prototype.exp=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.exp(this.get(r,i)));return this},n.exp=function(r){return new e(r).exp()},n.prototype.expm1=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.expm1(this.get(r,i)));return this},n.expm1=function(r){return new e(r).expm1()},n.prototype.floor=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.floor(this.get(r,i)));return this},n.floor=function(r){return new e(r).floor()},n.prototype.fround=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.fround(this.get(r,i)));return this},n.fround=function(r){return new e(r).fround()},n.prototype.log=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.log(this.get(r,i)));return this},n.log=function(r){return new e(r).log()},n.prototype.log1p=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.log1p(this.get(r,i)));return this},n.log1p=function(r){return new e(r).log1p()},n.prototype.log10=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.log10(this.get(r,i)));return this},n.log10=function(r){return new e(r).log10()},n.prototype.log2=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.log2(this.get(r,i)));return this},n.log2=function(r){return new e(r).log2()},n.prototype.round=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.round(this.get(r,i)));return this},n.round=function(r){return new e(r).round()},n.prototype.sign=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.sign(this.get(r,i)));return this},n.sign=function(r){return new e(r).sign()},n.prototype.sin=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.sin(this.get(r,i)));return this},n.sin=function(r){return new e(r).sin()},n.prototype.sinh=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.sinh(this.get(r,i)));return this},n.sinh=function(r){return new e(r).sinh()},n.prototype.sqrt=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.sqrt(this.get(r,i)));return this},n.sqrt=function(r){return new e(r).sqrt()},n.prototype.tan=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.tan(this.get(r,i)));return this},n.tan=function(r){return new e(r).tan()},n.prototype.tanh=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.tanh(this.get(r,i)));return this},n.tanh=function(r){return new e(r).tanh()},n.prototype.trunc=function(){for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.set(r,i,Math.trunc(this.get(r,i)));return this},n.trunc=function(r){return new e(r).trunc()},n.pow=function(r,i){return new e(r).pow(i)},n.prototype.pow=function(r){return typeof r=="number"?this.powS(r):this.powM(r)},n.prototype.powS=function(r){for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,Math.pow(this.get(i,s),r));return this},n.prototype.powM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let i=0;i<this.rows;i++)for(let s=0;s<this.columns;s++)this.set(i,s,Math.pow(this.get(i,s),r.get(i,s)));return this}}function su(n,e,t){let r=t?n.rows:n.rows-1;if(e<0||e>r)throw new RangeError("Row index out of range")}function ou(n,e,t){let r=t?n.columns:n.columns-1;if(e<0||e>r)throw new RangeError("Column index out of range")}function db(n,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==n.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function pb(n,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==n.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function Out(n,e){if(!vl(e))throw new TypeError("row indices must be an array");for(let t=0;t<e.length;t++)if(e[t]<0||e[t]>=n.rows)throw new RangeError("row indices are out of range")}function Fut(n,e){if(!vl(e))throw new TypeError("column indices must be an array");for(let t=0;t<e.length;t++)if(e[t]<0||e[t]>=n.columns)throw new RangeError("column indices are out of range")}function mj(n,e,t,r,i){if(arguments.length!==5)throw new RangeError("expected 4 arguments");if(NT("startRow",e),NT("endRow",t),NT("startColumn",r),NT("endColumn",i),e>t||r>i||e<0||e>=n.rows||t<0||t>=n.rows||r<0||r>=n.columns||i<0||i>=n.columns)throw new RangeError("Submatrix indices are out of range")}function T$(n,e=0){let t=[];for(let r=0;r<n;r++)t.push(e);return t}function NT(n,e){if(typeof e!="number")throw new TypeError(`${n} must be a number`)}function z0(n){if(n.isEmpty())throw new Error("Empty matrix has no elements to index")}function Lut(n){let e=T$(n.rows);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[t]+=n.get(t,r);return e}function zut(n){let e=T$(n.columns);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[r]+=n.get(t,r);return e}function But(n){let e=0;for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)e+=n.get(t,r);return e}function Vut(n){let e=T$(n.rows,1);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[t]*=n.get(t,r);return e}function Uut(n){let e=T$(n.columns,1);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[r]*=n.get(t,r);return e}function Wut(n){let e=1;for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)e*=n.get(t,r);return e}function Hut(n,e,t){const r=n.rows,i=n.columns,s=[];for(let o=0;o<r;o++){let a=0,l=0,c=0;for(let u=0;u<i;u++)c=n.get(o,u)-t[o],a+=c,l+=c*c;e?s.push((l-a*a/i)/(i-1)):s.push((l-a*a/i)/i)}return s}function Gut(n,e,t){const r=n.rows,i=n.columns,s=[];for(let o=0;o<i;o++){let a=0,l=0,c=0;for(let u=0;u<r;u++)c=n.get(u,o)-t[o],a+=c,l+=c*c;e?s.push((l-a*a/r)/(r-1)):s.push((l-a*a/r)/r)}return s}function jut(n,e,t){const r=n.rows,i=n.columns,s=r*i;let o=0,a=0,l=0;for(let c=0;c<r;c++)for(let u=0;u<i;u++)l=n.get(c,u)-t,o+=l,a+=l*l;return e?(a-o*o/s)/(s-1):(a-o*o/s)/s}function qut(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)-e[t])}function Xut(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)-e[r])}function Kut(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)-e)}function Yut(n){const e=[];for(let t=0;t<n.rows;t++){let r=0;for(let i=0;i<n.columns;i++)r+=Math.pow(n.get(t,i),2)/(n.columns-1);e.push(Math.sqrt(r))}return e}function Zut(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)/e[t])}function Jut(n){const e=[];for(let t=0;t<n.columns;t++){let r=0;for(let i=0;i<n.rows;i++)r+=Math.pow(n.get(i,t),2)/(n.rows-1);e.push(Math.sqrt(r))}return e}function Qut(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)/e[r])}function eht(n){const e=n.size-1;let t=0;for(let r=0;r<n.columns;r++)for(let i=0;i<n.rows;i++)t+=Math.pow(n.get(i,r),2)/e;return Math.sqrt(t)}function tht(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)/e)}class Qn{static from1DArray(e,t,r){if(e*t!==r.length)throw new RangeError("data length does not match given dimensions");let s=new en(e,t);for(let o=0;o<e;o++)for(let a=0;a<t;a++)s.set(o,a,r[o*t+a]);return s}static rowVector(e){let t=new en(1,e.length);for(let r=0;r<e.length;r++)t.set(0,r,e[r]);return t}static columnVector(e){let t=new en(e.length,1);for(let r=0;r<e.length;r++)t.set(r,0,e[r]);return t}static zeros(e,t){return new en(e,t)}static ones(e,t){return new en(e,t).fill(1)}static rand(e,t,r={}){if(typeof r!="object")throw new TypeError("options must be an object");const{random:i=Math.random}=r;let s=new en(e,t);for(let o=0;o<e;o++)for(let a=0;a<t;a++)s.set(o,a,i());return s}static randInt(e,t,r={}){if(typeof r!="object")throw new TypeError("options must be an object");const{min:i=0,max:s=1e3,random:o=Math.random}=r;if(!Number.isInteger(i))throw new TypeError("min must be an integer");if(!Number.isInteger(s))throw new TypeError("max must be an integer");if(i>=s)throw new RangeError("min must be smaller than max");let a=s-i,l=new en(e,t);for(let c=0;c<e;c++)for(let u=0;u<t;u++){let h=i+Math.round(o()*a);l.set(c,u,h)}return l}static eye(e,t,r){t===void 0&&(t=e),r===void 0&&(r=1);let i=Math.min(e,t),s=this.zeros(e,t);for(let o=0;o<i;o++)s.set(o,o,r);return s}static diag(e,t,r){let i=e.length;t===void 0&&(t=i),r===void 0&&(r=t);let s=Math.min(i,t,r),o=this.zeros(t,r);for(let a=0;a<s;a++)o.set(a,a,e[a]);return o}static min(e,t){e=this.checkMatrix(e),t=this.checkMatrix(t);let r=e.rows,i=e.columns,s=new en(r,i);for(let o=0;o<r;o++)for(let a=0;a<i;a++)s.set(o,a,Math.min(e.get(o,a),t.get(o,a)));return s}static max(e,t){e=this.checkMatrix(e),t=this.checkMatrix(t);let r=e.rows,i=e.columns,s=new this(r,i);for(let o=0;o<r;o++)for(let a=0;a<i;a++)s.set(o,a,Math.max(e.get(o,a),t.get(o,a)));return s}static checkMatrix(e){return Qn.isMatrix(e)?e:new en(e)}static isMatrix(e){return e!=null&&e.klass==="Matrix"}get size(){return this.rows*this.columns}apply(e){if(typeof e!="function")throw new TypeError("callback must be a function");for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.call(this,t,r);return this}to1DArray(){let e=[];for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}to2DArray(){let e=[];for(let t=0;t<this.rows;t++){e.push([]);for(let r=0;r<this.columns;r++)e[t].push(this.get(t,r))}return e}toJSON(){return this.to2DArray()}isRowVector(){return this.rows===1}isColumnVector(){return this.columns===1}isVector(){return this.rows===1||this.columns===1}isSquare(){return this.rows===this.columns}isEmpty(){return this.rows===0||this.columns===0}isSymmetric(){if(this.isSquare()){for(let e=0;e<this.rows;e++)for(let t=0;t<=e;t++)if(this.get(e,t)!==this.get(t,e))return!1;return!0}return!1}isEchelonForm(){let e=0,t=0,r=-1,i=!0,s=!1;for(;e<this.rows&&i;){for(t=0,s=!1;t<this.columns&&s===!1;)this.get(e,t)===0?t++:this.get(e,t)===1&&t>r?(s=!0,r=t):(i=!1,s=!0);e++}return i}isReducedEchelonForm(){let e=0,t=0,r=-1,i=!0,s=!1;for(;e<this.rows&&i;){for(t=0,s=!1;t<this.columns&&s===!1;)this.get(e,t)===0?t++:this.get(e,t)===1&&t>r?(s=!0,r=t):(i=!1,s=!0);for(let o=t+1;o<this.rows;o++)this.get(e,o)!==0&&(i=!1);e++}return i}echelonForm(){let e=this.clone(),t=0,r=0;for(;t<e.rows&&r<e.columns;){let i=t;for(let s=t;s<e.rows;s++)e.get(s,r)>e.get(i,r)&&(i=s);if(e.get(i,r)===0)r++;else{e.swapRows(t,i);let s=e.get(t,r);for(let o=r;o<e.columns;o++)e.set(t,o,e.get(t,o)/s);for(let o=t+1;o<e.rows;o++){let a=e.get(o,r)/e.get(t,r);e.set(o,r,0);for(let l=r+1;l<e.columns;l++)e.set(o,l,e.get(o,l)-e.get(t,l)*a)}t++,r++}}return e}reducedEchelonForm(){let e=this.echelonForm(),t=e.columns,r=e.rows,i=r-1;for(;i>=0;)if(e.maxRow(i)===0)i--;else{let s=0,o=!1;for(;s<r&&o===!1;)e.get(i,s)===1?o=!0:s++;for(let a=0;a<i;a++){let l=e.get(a,s);for(let c=s;c<t;c++){let u=e.get(a,c)-l*e.get(i,c);e.set(a,c,u)}}i--}return e}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{rows:t=1,columns:r=1}=e;if(!Number.isInteger(t)||t<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let i=new en(this.rows*t,this.columns*r);for(let s=0;s<t;s++)for(let o=0;o<r;o++)i.setSubMatrix(this,this.rows*s,this.columns*o);return i}fill(e){for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,e);return this}neg(){return this.mulS(-1)}getRow(e){su(this,e);let t=[];for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}getRowVector(e){return en.rowVector(this.getRow(e))}setRow(e,t){su(this,e),t=db(this,t);for(let r=0;r<this.columns;r++)this.set(e,r,t[r]);return this}swapRows(e,t){su(this,e),su(this,t);for(let r=0;r<this.columns;r++){let i=this.get(e,r);this.set(e,r,this.get(t,r)),this.set(t,r,i)}return this}getColumn(e){ou(this,e);let t=[];for(let r=0;r<this.rows;r++)t.push(this.get(r,e));return t}getColumnVector(e){return en.columnVector(this.getColumn(e))}setColumn(e,t){ou(this,e),t=pb(this,t);for(let r=0;r<this.rows;r++)this.set(r,e,t[r]);return this}swapColumns(e,t){ou(this,e),ou(this,t);for(let r=0;r<this.rows;r++){let i=this.get(r,e);this.set(r,e,this.get(r,t)),this.set(r,t,i)}return this}addRowVector(e){e=db(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)+e[r]);return this}subRowVector(e){e=db(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)-e[r]);return this}mulRowVector(e){e=db(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e[r]);return this}divRowVector(e){e=db(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)/e[r]);return this}addColumnVector(e){e=pb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)+e[t]);return this}subColumnVector(e){e=pb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)-e[t]);return this}mulColumnVector(e){e=pb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e[t]);return this}divColumnVector(e){e=pb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)/e[t]);return this}mulRow(e,t){su(this,e);for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this}mulColumn(e,t){ou(this,e);for(let r=0;r<this.rows;r++)this.set(r,e,this.get(r,e)*t);return this}max(e){if(this.isEmpty())return NaN;switch(e){case"row":{const t=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.get(r,i)>t[r]&&(t[r]=this.get(r,i));return t}case"column":{const t=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.get(r,i)>t[i]&&(t[i]=this.get(r,i));return t}case void 0:{let t=this.get(0,0);for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.get(r,i)>t&&(t=this.get(r,i));return t}default:throw new Error(`invalid option: ${e}`)}}maxIndex(){z0(this);let e=this.get(0,0),t=[0,0];for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.get(r,i)>e&&(e=this.get(r,i),t[0]=r,t[1]=i);return t}min(e){if(this.isEmpty())return NaN;switch(e){case"row":{const t=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.get(r,i)<t[r]&&(t[r]=this.get(r,i));return t}case"column":{const t=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.get(r,i)<t[i]&&(t[i]=this.get(r,i));return t}case void 0:{let t=this.get(0,0);for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.get(r,i)<t&&(t=this.get(r,i));return t}default:throw new Error(`invalid option: ${e}`)}}minIndex(){z0(this);let e=this.get(0,0),t=[0,0];for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.get(r,i)<e&&(e=this.get(r,i),t[0]=r,t[1]=i);return t}maxRow(e){if(su(this,e),this.isEmpty())return NaN;let t=this.get(e,0);for(let r=1;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}maxRowIndex(e){su(this,e),z0(this);let t=this.get(e,0),r=[e,0];for(let i=1;i<this.columns;i++)this.get(e,i)>t&&(t=this.get(e,i),r[1]=i);return r}minRow(e){if(su(this,e),this.isEmpty())return NaN;let t=this.get(e,0);for(let r=1;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}minRowIndex(e){su(this,e),z0(this);let t=this.get(e,0),r=[e,0];for(let i=1;i<this.columns;i++)this.get(e,i)<t&&(t=this.get(e,i),r[1]=i);return r}maxColumn(e){if(ou(this,e),this.isEmpty())return NaN;let t=this.get(0,e);for(let r=1;r<this.rows;r++)this.get(r,e)>t&&(t=this.get(r,e));return t}maxColumnIndex(e){ou(this,e),z0(this);let t=this.get(0,e),r=[0,e];for(let i=1;i<this.rows;i++)this.get(i,e)>t&&(t=this.get(i,e),r[0]=i);return r}minColumn(e){if(ou(this,e),this.isEmpty())return NaN;let t=this.get(0,e);for(let r=1;r<this.rows;r++)this.get(r,e)<t&&(t=this.get(r,e));return t}minColumnIndex(e){ou(this,e),z0(this);let t=this.get(0,e),r=[0,e];for(let i=1;i<this.rows;i++)this.get(i,e)<t&&(t=this.get(i,e),r[0]=i);return r}diag(){let e=Math.min(this.rows,this.columns),t=[];for(let r=0;r<e;r++)t.push(this.get(r,r));return t}norm(e="frobenius"){switch(e){case"max":return this.max();case"frobenius":return Math.sqrt(this.dot(this));default:throw new RangeError(`unknown norm type: ${e}`)}}cumulativeSum(){let e=0;for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e+=this.get(t,r),this.set(t,r,e);return this}dot(e){Qn.isMatrix(e)&&(e=e.to1DArray());let t=this.to1DArray();if(t.length!==e.length)throw new RangeError("vectors do not have the same size");let r=0;for(let i=0;i<t.length;i++)r+=t[i]*e[i];return r}mmul(e){e=en.checkMatrix(e);let t=this.rows,r=this.columns,i=e.columns,s=new en(t,i),o=new Float64Array(r);for(let a=0;a<i;a++){for(let l=0;l<r;l++)o[l]=e.get(l,a);for(let l=0;l<t;l++){let c=0;for(let u=0;u<r;u++)c+=this.get(l,u)*o[u];s.set(l,a,c)}}return s}strassen2x2(e){e=en.checkMatrix(e);let t=new en(2,2);const r=this.get(0,0),i=e.get(0,0),s=this.get(0,1),o=e.get(0,1),a=this.get(1,0),l=e.get(1,0),c=this.get(1,1),u=e.get(1,1),h=(r+c)*(i+u),f=(a+c)*i,d=r*(o-u),p=c*(l-i),m=(r+s)*u,g=(a-r)*(i+o),y=(s-c)*(l+u),b=h+p-m+y,_=d+m,w=f+p,S=h-f+d+g;return t.set(0,0,b),t.set(0,1,_),t.set(1,0,w),t.set(1,1,S),t}strassen3x3(e){e=en.checkMatrix(e);let t=new en(3,3);const r=this.get(0,0),i=this.get(0,1),s=this.get(0,2),o=this.get(1,0),a=this.get(1,1),l=this.get(1,2),c=this.get(2,0),u=this.get(2,1),h=this.get(2,2),f=e.get(0,0),d=e.get(0,1),p=e.get(0,2),m=e.get(1,0),g=e.get(1,1),y=e.get(1,2),b=e.get(2,0),_=e.get(2,1),w=e.get(2,2),S=(r+i+s-o-a-u-h)*g,C=(r-o)*(-d+g),k=a*(-f+d+m-g-y-b+w),A=(-r+o+a)*(f-d+g),M=(o+a)*(-f+d),E=r*f,N=(-r+c+u)*(f-p+y),O=(-r+c)*(p-y),R=(c+u)*(-f+p),D=(r+i+s-a-l-c-u)*y,z=u*(-f+p+m-g-y-b+_),B=(-s+u+h)*(g+b-_),X=(s-h)*(g-_),H=s*b,te=(u+h)*(-b+_),ge=(-s+a+l)*(y+b-w),ae=(s-l)*(y-w),Ne=(a+l)*(-b+w),Te=i*m,De=l*_,be=o*p,Ke=c*d,Oe=h*w,ot=E+H+Te,He=S+A+M+E+B+H+te,mt=E+N+R+D+H+ge+Ne,ht=C+k+A+E+H+ge+ae,Ue=C+A+M+E+De,Be=H+ge+ae+Ne+be,Ve=E+N+O+z+B+X+H,ft=B+X+H+te+Ke,Ye=E+N+O+R+Oe;return t.set(0,0,ot),t.set(0,1,He),t.set(0,2,mt),t.set(1,0,ht),t.set(1,1,Ue),t.set(1,2,Be),t.set(2,0,Ve),t.set(2,1,ft),t.set(2,2,Ye),t}mmulStrassen(e){e=en.checkMatrix(e);let t=this.clone(),r=t.rows,i=t.columns,s=e.rows,o=e.columns;i!==s&&console.warn(`Multiplying ${r} x ${i} and ${s} x ${o} matrix: dimensions do not match.`);function a(h,f,d){let p=h.rows,m=h.columns;if(p===f&&m===d)return h;{let g=Qn.zeros(f,d);return g=g.setSubMatrix(h,0,0),g}}let l=Math.max(r,s),c=Math.max(i,o);t=a(t,l,c),e=a(e,l,c);function u(h,f,d,p){if(d<=512||p<=512)return h.mmul(f);d%2===1&&p%2===1?(h=a(h,d+1,p+1),f=a(f,d+1,p+1)):d%2===1?(h=a(h,d+1,p),f=a(f,d+1,p)):p%2===1&&(h=a(h,d,p+1),f=a(f,d,p+1));let m=parseInt(h.rows/2,10),g=parseInt(h.columns/2,10),y=h.subMatrix(0,m-1,0,g-1),b=f.subMatrix(0,m-1,0,g-1),_=h.subMatrix(0,m-1,g,h.columns-1),w=f.subMatrix(0,m-1,g,f.columns-1),S=h.subMatrix(m,h.rows-1,0,g-1),C=f.subMatrix(m,f.rows-1,0,g-1),k=h.subMatrix(m,h.rows-1,g,h.columns-1),A=f.subMatrix(m,f.rows-1,g,f.columns-1),M=u(Qn.add(y,k),Qn.add(b,A),m,g),E=u(Qn.add(S,k),b,m,g),N=u(y,Qn.sub(w,A),m,g),O=u(k,Qn.sub(C,b),m,g),R=u(Qn.add(y,_),A,m,g),D=u(Qn.sub(S,y),Qn.add(b,w),m,g),z=u(Qn.sub(_,k),Qn.add(C,A),m,g),B=Qn.add(M,O);B.sub(R),B.add(z);let X=Qn.add(N,R),H=Qn.add(E,O),te=Qn.sub(M,E);te.add(N),te.add(D);let ge=Qn.zeros(2*B.rows,2*B.columns);return ge=ge.setSubMatrix(B,0,0),ge=ge.setSubMatrix(X,B.rows,0),ge=ge.setSubMatrix(H,0,B.columns),ge=ge.setSubMatrix(te,B.rows,B.columns),ge.subMatrix(0,d-1,0,p-1)}return u(t,e,l,c)}scaleRows(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{min:t=0,max:r=1}=e;if(!Number.isFinite(t))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(t>=r)throw new RangeError("min must be smaller than max");let i=new en(this.rows,this.columns);for(let s=0;s<this.rows;s++){const o=this.getRow(s);o.length>0&&dj(o,{min:t,max:r,output:o}),i.setRow(s,o)}return i}scaleColumns(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{min:t=0,max:r=1}=e;if(!Number.isFinite(t))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(t>=r)throw new RangeError("min must be smaller than max");let i=new en(this.rows,this.columns);for(let s=0;s<this.columns;s++){const o=this.getColumn(s);o.length&&dj(o,{min:t,max:r,output:o}),i.setColumn(s,o)}return i}flipRows(){const e=Math.ceil(this.columns/2);for(let t=0;t<this.rows;t++)for(let r=0;r<e;r++){let i=this.get(t,r),s=this.get(t,this.columns-1-r);this.set(t,r,s),this.set(t,this.columns-1-r,i)}return this}flipColumns(){const e=Math.ceil(this.rows/2);for(let t=0;t<this.columns;t++)for(let r=0;r<e;r++){let i=this.get(r,t),s=this.get(this.rows-1-r,t);this.set(r,t,s),this.set(this.rows-1-r,t,i)}return this}kroneckerProduct(e){e=en.checkMatrix(e);let t=this.rows,r=this.columns,i=e.rows,s=e.columns,o=new en(t*i,r*s);for(let a=0;a<t;a++)for(let l=0;l<r;l++)for(let c=0;c<i;c++)for(let u=0;u<s;u++)o.set(i*a+c,s*l+u,this.get(a,l)*e.get(c,u));return o}kroneckerSum(e){if(e=en.checkMatrix(e),!this.isSquare()||!e.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let t=this.rows,r=e.rows,i=this.kroneckerProduct(en.eye(r,r)),s=en.eye(t,t).kroneckerProduct(e);return i.add(s)}transpose(){let e=new en(this.columns,this.rows);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.set(r,t,this.get(t,r));return e}sortRows(e=gj){for(let t=0;t<this.rows;t++)this.setRow(t,this.getRow(t).sort(e));return this}sortColumns(e=gj){for(let t=0;t<this.columns;t++)this.setColumn(t,this.getColumn(t).sort(e));return this}subMatrix(e,t,r,i){mj(this,e,t,r,i);let s=new en(t-e+1,i-r+1);for(let o=e;o<=t;o++)for(let a=r;a<=i;a++)s.set(o-e,a-r,this.get(o,a));return s}subMatrixRow(e,t,r){if(t===void 0&&(t=0),r===void 0&&(r=this.columns-1),t>r||t<0||t>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let i=new en(e.length,r-t+1);for(let s=0;s<e.length;s++)for(let o=t;o<=r;o++){if(e[s]<0||e[s]>=this.rows)throw new RangeError(`Row index out of range: ${e[s]}`);i.set(s,o-t,this.get(e[s],o))}return i}subMatrixColumn(e,t,r){if(t===void 0&&(t=0),r===void 0&&(r=this.rows-1),t>r||t<0||t>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let i=new en(r-t+1,e.length);for(let s=0;s<e.length;s++)for(let o=t;o<=r;o++){if(e[s]<0||e[s]>=this.columns)throw new RangeError(`Column index out of range: ${e[s]}`);i.set(o-t,s,this.get(o,e[s]))}return i}setSubMatrix(e,t,r){if(e=en.checkMatrix(e),e.isEmpty())return this;let i=t+e.rows-1,s=r+e.columns-1;mj(this,t,i,r,s);for(let o=0;o<e.rows;o++)for(let a=0;a<e.columns;a++)this.set(t+o,r+a,e.get(o,a));return this}selection(e,t){Out(this,e),Fut(this,t);let r=new en(e.length,t.length);for(let i=0;i<e.length;i++){let s=e[i];for(let o=0;o<t.length;o++){let a=t[o];r.set(i,o,this.get(s,a))}}return r}trace(){let e=Math.min(this.rows,this.columns),t=0;for(let r=0;r<e;r++)t+=this.get(r,r);return t}clone(){let e=new en(this.rows,this.columns);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.set(t,r,this.get(t,r));return e}sum(e){switch(e){case"row":return Lut(this);case"column":return zut(this);case void 0:return But(this);default:throw new Error(`invalid option: ${e}`)}}product(e){switch(e){case"row":return Vut(this);case"column":return Uut(this);case void 0:return Wut(this);default:throw new Error(`invalid option: ${e}`)}}mean(e){const t=this.sum(e);switch(e){case"row":{for(let r=0;r<this.rows;r++)t[r]/=this.columns;return t}case"column":{for(let r=0;r<this.columns;r++)t[r]/=this.rows;return t}case void 0:return t/this.size;default:throw new Error(`invalid option: ${e}`)}}variance(e,t={}){if(typeof e=="object"&&(t=e,e=void 0),typeof t!="object")throw new TypeError("options must be an object");const{unbiased:r=!0,mean:i=this.mean(e)}=t;if(typeof r!="boolean")throw new TypeError("unbiased must be a boolean");switch(e){case"row":{if(!vl(i))throw new TypeError("mean must be an array");return Hut(this,r,i)}case"column":{if(!vl(i))throw new TypeError("mean must be an array");return Gut(this,r,i)}case void 0:{if(typeof i!="number")throw new TypeError("mean must be a number");return jut(this,r,i)}default:throw new Error(`invalid option: ${e}`)}}standardDeviation(e,t){typeof e=="object"&&(t=e,e=void 0);const r=this.variance(e,t);if(e===void 0)return Math.sqrt(r);for(let i=0;i<r.length;i++)r[i]=Math.sqrt(r[i]);return r}center(e,t={}){if(typeof e=="object"&&(t=e,e=void 0),typeof t!="object")throw new TypeError("options must be an object");const{center:r=this.mean(e)}=t;switch(e){case"row":{if(!vl(r))throw new TypeError("center must be an array");return qut(this,r),this}case"column":{if(!vl(r))throw new TypeError("center must be an array");return Xut(this,r),this}case void 0:{if(typeof r!="number")throw new TypeError("center must be a number");return Kut(this,r),this}default:throw new Error(`invalid option: ${e}`)}}scale(e,t={}){if(typeof e=="object"&&(t=e,e=void 0),typeof t!="object")throw new TypeError("options must be an object");let r=t.scale;switch(e){case"row":{if(r===void 0)r=Yut(this);else if(!vl(r))throw new TypeError("scale must be an array");return Zut(this,r),this}case"column":{if(r===void 0)r=Jut(this);else if(!vl(r))throw new TypeError("scale must be an array");return Qut(this,r),this}case void 0:{if(r===void 0)r=eht(this);else if(typeof r!="number")throw new TypeError("scale must be a number");return tht(this,r),this}default:throw new Error(`invalid option: ${e}`)}}toString(e){return Yse(this,e)}}Qn.prototype.klass="Matrix";typeof Symbol<"u"&&(Qn.prototype[Symbol.for("nodejs.util.inspect.custom")]=$ut);function gj(n,e){return n-e}function nht(n){return n.every(e=>typeof e=="number")}Qn.random=Qn.rand;Qn.randomInt=Qn.randInt;Qn.diagonal=Qn.diag;Qn.prototype.diagonal=Qn.prototype.diag;Qn.identity=Qn.eye;Qn.prototype.negate=Qn.prototype.neg;Qn.prototype.tensorProduct=Qn.prototype.kroneckerProduct;class en extends Qn{constructor(e,t){if(super(),en.isMatrix(e))return e.clone();if(Number.isInteger(e)&&e>=0)if(this.data=[],Number.isInteger(t)&&t>=0)for(let r=0;r<e;r++)this.data.push(new Float64Array(t));else throw new TypeError("nColumns must be a positive integer");else if(vl(e)){const r=e;if(e=r.length,t=e?r[0].length:0,typeof t!="number")throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let i=0;i<e;i++){if(r[i].length!==t)throw new RangeError("Inconsistent array dimensions");if(!nht(r[i]))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(r[i]))}}else throw new TypeError("First argument must be a positive number or an array");this.rows=e,this.columns=t}set(e,t,r){return this.data[e][t]=r,this}get(e,t){return this.data[e][t]}removeRow(e){return su(this,e),this.data.splice(e,1),this.rows-=1,this}addRow(e,t){return t===void 0&&(t=e,e=this.rows),su(this,e,!0),t=Float64Array.from(db(this,t)),this.data.splice(e,0,t),this.rows+=1,this}removeColumn(e){ou(this,e);for(let t=0;t<this.rows;t++){const r=new Float64Array(this.columns-1);for(let i=0;i<e;i++)r[i]=this.data[t][i];for(let i=e+1;i<this.columns;i++)r[i-1]=this.data[t][i];this.data[t]=r}return this.columns-=1,this}addColumn(e,t){typeof t>"u"&&(t=e,e=this.columns),ou(this,e,!0),t=pb(this,t);for(let r=0;r<this.rows;r++){const i=new Float64Array(this.columns+1);let s=0;for(;s<e;s++)i[s]=this.data[r][s];for(i[s++]=t[r];s<this.columns+1;s++)i[s]=this.data[r][s-1];this.data[r]=i}return this.columns+=1,this}}Dut(Qn,en);class uv extends Qn{constructor(e){super(),this.data=e,this.rows=e.length,this.columns=e[0].length}set(e,t,r){return this.data[e][t]=r,this}get(e,t){return this.data[e][t]}}class rht{constructor(e){e=uv.checkMatrix(e);let t=e.clone(),r=t.rows,i=t.columns,s=new Float64Array(r),o=1,a,l,c,u,h,f,d,p,m;for(a=0;a<r;a++)s[a]=a;for(p=new Float64Array(r),l=0;l<i;l++){for(a=0;a<r;a++)p[a]=t.get(a,l);for(a=0;a<r;a++){for(m=Math.min(a,l),h=0,c=0;c<m;c++)h+=t.get(a,c)*p[c];p[a]-=h,t.set(a,l,p[a])}for(u=l,a=l+1;a<r;a++)Math.abs(p[a])>Math.abs(p[u])&&(u=a);if(u!==l){for(c=0;c<i;c++)f=t.get(u,c),t.set(u,c,t.get(l,c)),t.set(l,c,f);d=s[u],s[u]=s[l],s[l]=d,o=-o}if(l<r&&t.get(l,l)!==0)for(a=l+1;a<r;a++)t.set(a,l,t.get(a,l)/t.get(l,l))}this.LU=t,this.pivotVector=s,this.pivotSign=o}isSingular(){let e=this.LU,t=e.columns;for(let r=0;r<t;r++)if(e.get(r,r)===0)return!0;return!1}solve(e){e=en.checkMatrix(e);let t=this.LU;if(t.rows!==e.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let i=e.columns,s=e.subMatrixRow(this.pivotVector,0,i-1),o=t.columns,a,l,c;for(c=0;c<o;c++)for(a=c+1;a<o;a++)for(l=0;l<i;l++)s.set(a,l,s.get(a,l)-s.get(c,l)*t.get(a,c));for(c=o-1;c>=0;c--){for(l=0;l<i;l++)s.set(c,l,s.get(c,l)/t.get(c,c));for(a=0;a<c;a++)for(l=0;l<i;l++)s.set(a,l,s.get(a,l)-s.get(c,l)*t.get(a,c))}return s}get determinant(){let e=this.LU;if(!e.isSquare())throw new Error("Matrix must be square");let t=this.pivotSign,r=e.columns;for(let i=0;i<r;i++)t*=e.get(i,i);return t}get lowerTriangularMatrix(){let e=this.LU,t=e.rows,r=e.columns,i=new en(t,r);for(let s=0;s<t;s++)for(let o=0;o<r;o++)s>o?i.set(s,o,e.get(s,o)):s===o?i.set(s,o,1):i.set(s,o,0);return i}get upperTriangularMatrix(){let e=this.LU,t=e.rows,r=e.columns,i=new en(t,r);for(let s=0;s<t;s++)for(let o=0;o<r;o++)s<=o?i.set(s,o,e.get(s,o)):i.set(s,o,0);return i}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function xm(n,e){let t=0;return Math.abs(n)>Math.abs(e)?(t=e/n,Math.abs(n)*Math.sqrt(1+t*t)):e!==0?(t=n/e,Math.abs(e)*Math.sqrt(1+t*t)):0}class iht{constructor(e){e=uv.checkMatrix(e);let t=e.clone(),r=e.rows,i=e.columns,s=new Float64Array(i),o,a,l,c;for(l=0;l<i;l++){let u=0;for(o=l;o<r;o++)u=xm(u,t.get(o,l));if(u!==0){for(t.get(l,l)<0&&(u=-u),o=l;o<r;o++)t.set(o,l,t.get(o,l)/u);for(t.set(l,l,t.get(l,l)+1),a=l+1;a<i;a++){for(c=0,o=l;o<r;o++)c+=t.get(o,l)*t.get(o,a);for(c=-c/t.get(l,l),o=l;o<r;o++)t.set(o,a,t.get(o,a)+c*t.get(o,l))}}s[l]=-u}this.QR=t,this.Rdiag=s}solve(e){e=en.checkMatrix(e);let t=this.QR,r=t.rows;if(e.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let i=e.columns,s=e.clone(),o=t.columns,a,l,c,u;for(c=0;c<o;c++)for(l=0;l<i;l++){for(u=0,a=c;a<r;a++)u+=t.get(a,c)*s.get(a,l);for(u=-u/t.get(c,c),a=c;a<r;a++)s.set(a,l,s.get(a,l)+u*t.get(a,c))}for(c=o-1;c>=0;c--){for(l=0;l<i;l++)s.set(c,l,s.get(c,l)/this.Rdiag[c]);for(a=0;a<c;a++)for(l=0;l<i;l++)s.set(a,l,s.get(a,l)-s.get(c,l)*t.get(a,c))}return s.subMatrix(0,o-1,0,i-1)}isFullRank(){let e=this.QR.columns;for(let t=0;t<e;t++)if(this.Rdiag[t]===0)return!1;return!0}get upperTriangularMatrix(){let e=this.QR,t=e.columns,r=new en(t,t),i,s;for(i=0;i<t;i++)for(s=0;s<t;s++)i<s?r.set(i,s,e.get(i,s)):i===s?r.set(i,s,this.Rdiag[i]):r.set(i,s,0);return r}get orthogonalMatrix(){let e=this.QR,t=e.rows,r=e.columns,i=new en(t,r),s,o,a,l;for(a=r-1;a>=0;a--){for(s=0;s<t;s++)i.set(s,a,0);for(i.set(a,a,1),o=a;o<r;o++)if(e.get(a,a)!==0){for(l=0,s=a;s<t;s++)l+=e.get(s,a)*i.get(s,o);for(l=-l/e.get(a,a),s=a;s<t;s++)i.set(s,o,i.get(s,o)+l*e.get(s,a))}}return i}}class Zse{constructor(e,t={}){if(e=uv.checkMatrix(e),e.isEmpty())throw new Error("Matrix must be non-empty");let r=e.rows,i=e.columns;const{computeLeftSingularVectors:s=!0,computeRightSingularVectors:o=!0,autoTranspose:a=!1}=t;let l=!!s,c=!!o,u=!1,h;if(r<i)if(!a)h=e.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else{h=e.transpose(),r=h.rows,i=h.columns,u=!0;let E=l;l=c,c=E}else h=e.clone();let f=Math.min(r,i),d=Math.min(r+1,i),p=new Float64Array(d),m=new en(r,f),g=new en(i,i),y=new Float64Array(i),b=new Float64Array(r),_=new Float64Array(d);for(let E=0;E<d;E++)_[E]=E;let w=Math.min(r-1,i),S=Math.max(0,Math.min(i-2,r)),C=Math.max(w,S);for(let E=0;E<C;E++){if(E<w){p[E]=0;for(let N=E;N<r;N++)p[E]=xm(p[E],h.get(N,E));if(p[E]!==0){h.get(E,E)<0&&(p[E]=-p[E]);for(let N=E;N<r;N++)h.set(N,E,h.get(N,E)/p[E]);h.set(E,E,h.get(E,E)+1)}p[E]=-p[E]}for(let N=E+1;N<i;N++){if(E<w&&p[E]!==0){let O=0;for(let R=E;R<r;R++)O+=h.get(R,E)*h.get(R,N);O=-O/h.get(E,E);for(let R=E;R<r;R++)h.set(R,N,h.get(R,N)+O*h.get(R,E))}y[N]=h.get(E,N)}if(l&&E<w)for(let N=E;N<r;N++)m.set(N,E,h.get(N,E));if(E<S){y[E]=0;for(let N=E+1;N<i;N++)y[E]=xm(y[E],y[N]);if(y[E]!==0){y[E+1]<0&&(y[E]=0-y[E]);for(let N=E+1;N<i;N++)y[N]/=y[E];y[E+1]+=1}if(y[E]=-y[E],E+1<r&&y[E]!==0){for(let N=E+1;N<r;N++)b[N]=0;for(let N=E+1;N<r;N++)for(let O=E+1;O<i;O++)b[N]+=y[O]*h.get(N,O);for(let N=E+1;N<i;N++){let O=-y[N]/y[E+1];for(let R=E+1;R<r;R++)h.set(R,N,h.get(R,N)+O*b[R])}}if(c)for(let N=E+1;N<i;N++)g.set(N,E,y[N])}}let k=Math.min(i,r+1);if(w<i&&(p[w]=h.get(w,w)),r<k&&(p[k-1]=0),S+1<k&&(y[S]=h.get(S,k-1)),y[k-1]=0,l){for(let E=w;E<f;E++){for(let N=0;N<r;N++)m.set(N,E,0);m.set(E,E,1)}for(let E=w-1;E>=0;E--)if(p[E]!==0){for(let N=E+1;N<f;N++){let O=0;for(let R=E;R<r;R++)O+=m.get(R,E)*m.get(R,N);O=-O/m.get(E,E);for(let R=E;R<r;R++)m.set(R,N,m.get(R,N)+O*m.get(R,E))}for(let N=E;N<r;N++)m.set(N,E,-m.get(N,E));m.set(E,E,1+m.get(E,E));for(let N=0;N<E-1;N++)m.set(N,E,0)}else{for(let N=0;N<r;N++)m.set(N,E,0);m.set(E,E,1)}}if(c)for(let E=i-1;E>=0;E--){if(E<S&&y[E]!==0)for(let N=E+1;N<i;N++){let O=0;for(let R=E+1;R<i;R++)O+=g.get(R,E)*g.get(R,N);O=-O/g.get(E+1,E);for(let R=E+1;R<i;R++)g.set(R,N,g.get(R,N)+O*g.get(R,E))}for(let N=0;N<i;N++)g.set(N,E,0);g.set(E,E,1)}let A=k-1,M=Number.EPSILON;for(;k>0;){let E,N;for(E=k-2;E>=-1&&E!==-1;E--){const O=Number.MIN_VALUE+M*Math.abs(p[E]+Math.abs(p[E+1]));if(Math.abs(y[E])<=O||Number.isNaN(y[E])){y[E]=0;break}}if(E===k-2)N=4;else{let O;for(O=k-1;O>=E&&O!==E;O--){let R=(O!==k?Math.abs(y[O]):0)+(O!==E+1?Math.abs(y[O-1]):0);if(Math.abs(p[O])<=M*R){p[O]=0;break}}O===E?N=3:O===k-1?N=1:(N=2,E=O)}switch(E++,N){case 1:{let O=y[k-2];y[k-2]=0;for(let R=k-2;R>=E;R--){let D=xm(p[R],O),z=p[R]/D,B=O/D;if(p[R]=D,R!==E&&(O=-B*y[R-1],y[R-1]=z*y[R-1]),c)for(let X=0;X<i;X++)D=z*g.get(X,R)+B*g.get(X,k-1),g.set(X,k-1,-B*g.get(X,R)+z*g.get(X,k-1)),g.set(X,R,D)}break}case 2:{let O=y[E-1];y[E-1]=0;for(let R=E;R<k;R++){let D=xm(p[R],O),z=p[R]/D,B=O/D;if(p[R]=D,O=-B*y[R],y[R]=z*y[R],l)for(let X=0;X<r;X++)D=z*m.get(X,R)+B*m.get(X,E-1),m.set(X,E-1,-B*m.get(X,R)+z*m.get(X,E-1)),m.set(X,R,D)}break}case 3:{const O=Math.max(Math.abs(p[k-1]),Math.abs(p[k-2]),Math.abs(y[k-2]),Math.abs(p[E]),Math.abs(y[E])),R=p[k-1]/O,D=p[k-2]/O,z=y[k-2]/O,B=p[E]/O,X=y[E]/O,H=((D+R)*(D-R)+z*z)/2,te=R*z*(R*z);let ge=0;(H!==0||te!==0)&&(H<0?ge=0-Math.sqrt(H*H+te):ge=Math.sqrt(H*H+te),ge=te/(H+ge));let ae=(B+R)*(B-R)+ge,Ne=B*X;for(let Te=E;Te<k-1;Te++){let De=xm(ae,Ne);De===0&&(De=Number.MIN_VALUE);let be=ae/De,Ke=Ne/De;if(Te!==E&&(y[Te-1]=De),ae=be*p[Te]+Ke*y[Te],y[Te]=be*y[Te]-Ke*p[Te],Ne=Ke*p[Te+1],p[Te+1]=be*p[Te+1],c)for(let Oe=0;Oe<i;Oe++)De=be*g.get(Oe,Te)+Ke*g.get(Oe,Te+1),g.set(Oe,Te+1,-Ke*g.get(Oe,Te)+be*g.get(Oe,Te+1)),g.set(Oe,Te,De);if(De=xm(ae,Ne),De===0&&(De=Number.MIN_VALUE),be=ae/De,Ke=Ne/De,p[Te]=De,ae=be*y[Te]+Ke*p[Te+1],p[Te+1]=-Ke*y[Te]+be*p[Te+1],Ne=Ke*y[Te+1],y[Te+1]=be*y[Te+1],l&&Te<r-1)for(let Oe=0;Oe<r;Oe++)De=be*m.get(Oe,Te)+Ke*m.get(Oe,Te+1),m.set(Oe,Te+1,-Ke*m.get(Oe,Te)+be*m.get(Oe,Te+1)),m.set(Oe,Te,De)}y[k-2]=ae;break}case 4:{if(p[E]<=0&&(p[E]=p[E]<0?-p[E]:0,c))for(let O=0;O<=A;O++)g.set(O,E,-g.get(O,E));for(;E<A&&!(p[E]>=p[E+1]);){let O=p[E];if(p[E]=p[E+1],p[E+1]=O,c&&E<i-1)for(let R=0;R<i;R++)O=g.get(R,E+1),g.set(R,E+1,g.get(R,E)),g.set(R,E,O);if(l&&E<r-1)for(let R=0;R<r;R++)O=m.get(R,E+1),m.set(R,E+1,m.get(R,E)),m.set(R,E,O);E++}k--;break}}}if(u){let E=g;g=m,m=E}this.m=r,this.n=i,this.s=p,this.U=m,this.V=g}solve(e){let t=e,r=this.threshold,i=this.s.length,s=en.zeros(i,i);for(let f=0;f<i;f++)Math.abs(this.s[f])<=r?s.set(f,f,0):s.set(f,f,1/this.s[f]);let o=this.U,a=this.rightSingularVectors,l=a.mmul(s),c=a.rows,u=o.rows,h=en.zeros(c,u);for(let f=0;f<c;f++)for(let d=0;d<u;d++){let p=0;for(let m=0;m<i;m++)p+=l.get(f,m)*o.get(d,m);h.set(f,d,p)}return h.mmul(t)}solveForDiagonal(e){return this.solve(en.diag(e))}inverse(){let e=this.V,t=this.threshold,r=e.rows,i=e.columns,s=new en(r,this.s.length);for(let u=0;u<r;u++)for(let h=0;h<i;h++)Math.abs(this.s[h])>t&&s.set(u,h,e.get(u,h)/this.s[h]);let o=this.U,a=o.rows,l=o.columns,c=new en(r,a);for(let u=0;u<r;u++)for(let h=0;h<a;h++){let f=0;for(let d=0;d<l;d++)f+=s.get(u,d)*o.get(h,d);c.set(u,h,f)}return c}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let e=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,t=0,r=this.s;for(let i=0,s=r.length;i<s;i++)r[i]>e&&t++;return t}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return en.diag(this.s)}}function sht(n,e=!1){return n=uv.checkMatrix(n),e?new Zse(n).inverse():oht(n,en.eye(n.rows))}function oht(n,e,t=!1){return n=uv.checkMatrix(n),e=uv.checkMatrix(e),t?new Zse(n).solve(e):n.isSquare()?new rht(n).solve(e):new iht(n).solve(e)}function aht(n,e,t){return new L4(t).choice(n,{size:e})}function lht(n,e,t,r){const i=new L4(r);var s=new Array(e);if(s[0]=Math.floor(i.random()*n.length),e>1){for(var o={dist:-1,index:-1},a=0;a<n.length;++a)t[s[0]][a]>o.dist&&(o.dist=t[s[0]][a],o.index=a);if(s[1]=o.index,e>2)for(var l=2;l<e;++l){for(var c={dist:-1,index:-1},u=0;u<n.length;++u){for(var h={dist:Number.MAX_VALUE,index:-1},f=0;f<l;++f)t[f][u]<h.dist&&s.indexOf(u)===-1&&(h={dist:t[f][u],index:u});h.dist!==Number.MAX_VALUE&&h.dist>c.dist&&(c=Object.assign({},h))}s[l]=c.index}}return s.map(d=>n[d])}function cht(n,e,t={}){n=new en(n);const r=n.rows,i=new L4(t.seed),s=[],o=t.localTrials||2+Math.floor(Math.log(e)),a=i.randInt(r);s.push(n.getRow(a));let l=new en(1,n.rows);for(let f=0;f<n.rows;f++)l.set(0,f,k$(n.getRow(f),s[0]));let c=[yj(l.getRow(0))];const u=1/c[0][r-1];let h=en.mul(l,u);for(let f=1;f<e;f++){const d=i.choice(r,{replace:!0,size:o,probabilities:h[0]}),p=n.selection(d,hht(n.columns)),m=uht(p,n);let g,y,b;for(let _=0;_<o;_++){const w=en.min(l,[m.getRow(_)]),S=w.sum();(g===void 0||S<y)&&(g=d[_],y=S,b=w)}s[f]=n.getRow(g),l=b,c=[yj(l.getRow(0))],h=en.mul(l,1/c[0][r-1])}return s}function uht(n,e){const t=new en(n.rows,e.rows);for(let r=0;r<n.rows;r++)for(let i=0;i<e.rows;i++)t.set(r,i,k$(n.getRow(r),e.getRow(i)));return t}function hht(n){let e=[];for(let t=0;t<n;t++)e.push(t);return e}function yj(n){let e=[n[0]];for(let t=1;t<n.length;t++)e[t]=e[t-1]+n[t];return e}const $T=Symbol("distance");class z4{constructor(e,t,r,i,s){this.clusters=e,this.centroids=t,this.converged=r,this.iterations=i,this[$T]=s}nearest(e){const t=new Array(e.length),r=this.centroids.map(function(i){return i.centroid});return Xse(e,r,t,this[$T])}computeInformation(e){for(var t=this.centroids.map(function(s){return{centroid:s,error:0,size:0}}),r=0;r<e.length;r++)t[this.clusters[r]].error+=this[$T](e[r],this.centroids[this.clusters[r]]),t[this.clusters[r]].size++;for(var i=0;i<this.centroids.length;i++)t[i].size?t[i].error/=t[i].size:t[i].error=null;return new z4(this.clusters,t,this.converged,this.iterations,this[$T])}}const fht={maxIterations:100,tolerance:1e-6,withIterations:!1,initialization:"kmeans++",distanceFunction:k$};function Jse(n,e,t,r,i,s){t=Xse(e,n,t,i.distanceFunction);var o=but(n,e,t,r),a=vut(o,n,i.distanceFunction,i.tolerance);return new z4(t,o,a,s,i.distanceFunction)}function*dht(n,e,t,r,i){for(var s=!1,o=0,a;!s&&o<i.maxIterations;)a=Jse(n,e,t,r,i,++o),yield a.computeInformation(e),s=a.converged,n=a.centroids}function pht(n,e,t){if(t=Object.assign({},fht,t),e<=0||e>n.length||!Number.isInteger(e))throw new Error("K should be a positive integer smaller than the number of points");var r;if(Array.isArray(t.initialization)){if(t.initialization.length!==e)throw new Error("The initial centers should have the same length as K");r=t.initialization}else switch(t.initialization){case"kmeans++":r=cht(n,e,t);break;case"random":r=aht(n,e,t.seed);break;case"mostDistant":r=lht(n,e,yut(n,t.distanceFunction),t.seed);break;default:throw new Error(`Unknown initialization method: "${t.initialization}"`)}t.maxIterations===0&&(t.maxIterations=Number.MAX_VALUE);var i=new Array(n.length);if(t.withIterations)return dht(r,n,i,e,t);for(var s=!1,o=0,a;!s&&o<t.maxIterations;)a=Jse(r,n,i,e,t,++o),s=a.converged,r=a.centroids;return a.computeInformation(n)}/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    *//*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function mht(n,e,t,r){function i(s){return s instanceof t?s:new t(function(o){o(s)})}return new(t||(t=Promise))(function(s,o){function a(u){try{c(r.next(u))}catch(h){o(h)}}function l(u){try{c(r.throw(u))}catch(h){o(h)}}function c(u){u.done?s(u.value):i(u.value).then(a,l)}c((r=r.apply(n,e||[])).next())})}function ght(n,e){var t={label:0,sent:function(){if(s[0]&1)throw s[1];return s[1]},trys:[],ops:[]},r,i,s,o;return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(c){return function(u){return l([c,u])}}function l(c){if(r)throw new TypeError("Generator is already executing.");for(;t;)try{if(r=1,i&&(s=c[0]&2?i.return:c[0]?i.throw||((s=i.return)&&s.call(i),0):i.next)&&!(s=s.call(i,c[1])).done)return s;switch(i=0,s&&(c=[c[0]&2,s.value]),c[0]){case 0:case 1:s=c;break;case 4:return t.label++,{value:c[1],done:!1};case 5:t.label++,i=c[1],c=[0];continue;case 7:c=t.ops.pop(),t.trys.pop();continue;default:if(s=t.trys,!(s=s.length>0&&s[s.length-1])&&(c[0]===6||c[0]===2)){t=0;continue}if(c[0]===3&&(!s||c[1]>s[0]&&c[1]<s[3])){t.label=c[1];break}if(c[0]===6&&t.label<s[1]){t.label=s[1],s=c;break}if(s&&t.label<s[2]){t.label=s[2],t.ops.push(c);break}s[2]&&t.ops.pop(),t.trys.pop();continue}c=e.call(n,t)}catch(u){c=[6,u],i=0}finally{r=s=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yht(n,e){return n==null&&e==null?null:n==null?e.clone():e===null?n.clone():li([n,e],0)}function bht(n,e){for(var t=[],r=0;r<n.length;r++)t.push({value:n[r],index:r});t.sort(function(o,a){return a.value-o.value});for(var i=new Float32Array(e),s=new Int32Array(e),r=0;r<e;r++)i[r]=t[r].value,s[r]=t[r].index;return{values:i,indices:s}}var vht=function(){function n(){this.classDatasetMatrices={},this.classExampleCount={},this.labelToClassId={},this.nextClassId=0}return n.prototype.addExample=function(e,t){var r=this;if(this.exampleShape==null&&(this.exampleShape=e.shape),!Rn(this.exampleShape,e.shape))throw new Error("Example shape provided, ".concat(e.shape," does not match ")+"previously provided example shapes ".concat(this.exampleShape,"."));this.clearTrainDatasetMatrix(),t in this.labelToClassId||(this.labelToClassId[t]=this.nextClassId++),Se(function(){var i=r.normalizeVectorToUnitLength(ve(e,[e.size])),s=i.shape[0];if(r.classDatasetMatrices[t]==null)r.classDatasetMatrices[t]=ve(i,[1,s]);else{var o=li([ve(r.classDatasetMatrices[t],[r.classExampleCount[t],s]),ve(i,[1,s])],0);r.classDatasetMatrices[t].dispose(),r.classDatasetMatrices[t]=o}qi(r.classDatasetMatrices[t]),r.classExampleCount[t]==null&&(r.classExampleCount[t]=0),r.classExampleCount[t]++})},n.prototype.similarities=function(e){var t=this;return Se(function(){var r=t.normalizeVectorToUnitLength(ve(e,[e.size])),i=r.shape[0];if(t.trainDatasetMatrix==null){var s=null;for(var o in t.classDatasetMatrices)s=yht(s,t.classDatasetMatrices[o]);t.trainDatasetMatrix=s}if(t.trainDatasetMatrix==null)return console.warn("Cannot predict without providing training examples."),null;qi(t.trainDatasetMatrix);var a=t.getNumExamples();return ve(Gn(ve(t.trainDatasetMatrix,[a,i]),ve(r,[i,1])),[a])})},n.prototype.predictClass=function(e,t){return t===void 0&&(t=3),mht(this,void 0,void 0,function(){var r,i,s,o,a=this;return ght(this,function(l){switch(l.label){case 0:if(t<1)throw new Error("Please provide a positive integer k value to predictClass.");if(this.getNumExamples()===0)throw new Error("You have not added any examples to the KNN classifier. Please add examples before calling predictClass.");return r=Se(function(){return St(a.similarities(e),"float32")}),i=Math.min(t,this.getNumExamples()),o=bht,[4,r.data()];case 1:return s=o.apply(void 0,[l.sent(),i]).indices,r.dispose(),[2,this.calculateTopClass(s,i)]}})})},n.prototype.clearClass=function(e){if(this.classDatasetMatrices[e]==null)throw new Error("Cannot clear invalid class ".concat(e));this.classDatasetMatrices[e].dispose(),delete this.classDatasetMatrices[e],delete this.classExampleCount[e],this.clearTrainDatasetMatrix()},n.prototype.clearAllClasses=function(){for(var e in this.classDatasetMatrices)this.clearClass(e)},n.prototype.getClassExampleCount=function(){return this.classExampleCount},n.prototype.getClassifierDataset=function(){return this.classDatasetMatrices},n.prototype.getNumClasses=function(){return Object.keys(this.classExampleCount).length},n.prototype.setClassifierDataset=function(e){this.clearTrainDatasetMatrix(),this.classDatasetMatrices=e;for(var t in e)this.classExampleCount[t]=e[t].shape[0]},n.prototype.calculateTopClass=function(e,t){var r,i={};if(e==null)return{classIndex:this.labelToClassId[r],label:r,confidences:i};var s={},o=0;for(var a in this.classDatasetMatrices)o+=this.classExampleCount[a],s[a]=o;var l={};for(var a in this.classDatasetMatrices)l[a]=0;for(var c=0;c<e.length;c++){var u=e[c];for(var a in this.classDatasetMatrices)if(u<s[a]){l[a]++;break}}var h=0;for(var a in this.classDatasetMatrices){var f=l[a]/t;f>h&&(h=f,r=a),i[a]=f}return{classIndex:this.labelToClassId[r],label:r,confidences:i}},n.prototype.clearTrainDatasetMatrix=function(){this.trainDatasetMatrix!=null&&(this.trainDatasetMatrix.dispose(),this.trainDatasetMatrix=null)},n.prototype.normalizeVectorToUnitLength=function(e){return Se(function(){var t=Ew(e);return Lt(e,t)})},n.prototype.getNumExamples=function(){var e=0;for(var t in this.classDatasetMatrices)e+=this.classExampleCount[t];return e},n.prototype.dispose=function(){this.clearTrainDatasetMatrix();for(var e in this.classDatasetMatrices)this.classDatasetMatrices[e].dispose()},n}();/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */function bA(n,e,t,r){return new(t||(t=Promise))(function(i,s){function o(c){try{l(r.next(c))}catch(u){s(u)}}function a(c){try{l(r.throw(c))}catch(u){s(u)}}function l(c){var u;c.done?i(c.value):(u=c.value,u instanceof t?u:new t(function(h){h(u)})).then(o,a)}l((r=r.apply(n,e||[])).next())})}function vA(n,e){var t,r,i,s,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function a(l){return function(c){return function(u){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,r&&(i=2&u[0]?r.return:u[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,u[1])).done)return i;switch(r=0,i&&(u=[2&u[0],i.value]),u[0]){case 0:case 1:i=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,r=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(!(i=(i=o.trys).length>0&&i[i.length-1])&&(u[0]===6||u[0]===2)){o=0;continue}if(u[0]===3&&(!i||u[1]>i[0]&&u[1]<i[3])){o.label=u[1];break}if(u[0]===6&&o.label<i[1]){o.label=i[1],i=u;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(u);break}i[2]&&o.ops.pop(),o.trys.pop();continue}u=e.call(n,o)}catch(h){u=[6,h],r=0}finally{t=i=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([l,c])}}}var wht={0:"tench, Tinca tinca",1:"goldfish, Carassius auratus",2:"great white shark, white shark, man-eater, man-eating shark, Carcharodon carcharias",3:"tiger shark, Galeocerdo cuvieri",4:"hammerhead, hammerhead shark",5:"electric ray, crampfish, numbfish, torpedo",6:"stingray",7:"cock",8:"hen",9:"ostrich, Struthio camelus",10:"brambling, Fringilla montifringilla",11:"goldfinch, Carduelis carduelis",12:"house finch, linnet, Carpodacus mexicanus",13:"junco, snowbird",14:"indigo bunting, indigo finch, indigo bird, Passerina cyanea",15:"robin, American robin, Turdus migratorius",16:"bulbul",17:"jay",18:"magpie",19:"chickadee",20:"water ouzel, dipper",21:"kite",22:"bald eagle, American eagle, Haliaeetus leucocephalus",23:"vulture",24:"great grey owl, great gray owl, Strix nebulosa",25:"European fire salamander, Salamandra salamandra",26:"common newt, Triturus vulgaris",27:"eft",28:"spotted salamander, Ambystoma maculatum",29:"axolotl, mud puppy, Ambystoma mexicanum",30:"bullfrog, Rana catesbeiana",31:"tree frog, tree-frog",32:"tailed frog, bell toad, ribbed toad, tailed toad, Ascaphus trui",33:"loggerhead, loggerhead turtle, Caretta caretta",34:"leatherback turtle, leatherback, leathery turtle, Dermochelys coriacea",35:"mud turtle",36:"terrapin",37:"box turtle, box tortoise",38:"banded gecko",39:"common iguana, iguana, Iguana iguana",40:"American chameleon, anole, Anolis carolinensis",41:"whiptail, whiptail lizard",42:"agama",43:"frilled lizard, Chlamydosaurus kingi",44:"alligator lizard",45:"Gila monster, Heloderma suspectum",46:"green lizard, Lacerta viridis",47:"African chameleon, Chamaeleo chamaeleon",48:"Komodo dragon, Komodo lizard, dragon lizard, giant lizard, Varanus komodoensis",49:"African crocodile, Nile crocodile, Crocodylus niloticus",50:"American alligator, Alligator mississipiensis",51:"triceratops",52:"thunder snake, worm snake, Carphophis amoenus",53:"ringneck snake, ring-necked snake, ring snake",54:"hognose snake, puff adder, sand viper",55:"green snake, grass snake",56:"king snake, kingsnake",57:"garter snake, grass snake",58:"water snake",59:"vine snake",60:"night snake, Hypsiglena torquata",61:"boa constrictor, Constrictor constrictor",62:"rock python, rock snake, Python sebae",63:"Indian cobra, Naja naja",64:"green mamba",65:"sea snake",66:"horned viper, cerastes, sand viper, horned asp, Cerastes cornutus",67:"diamondback, diamondback rattlesnake, Crotalus adamanteus",68:"sidewinder, horned rattlesnake, Crotalus cerastes",69:"trilobite",70:"harvestman, daddy longlegs, Phalangium opilio",71:"scorpion",72:"black and gold garden spider, Argiope aurantia",73:"barn spider, Araneus cavaticus",74:"garden spider, Aranea diademata",75:"black widow, Latrodectus mactans",76:"tarantula",77:"wolf spider, hunting spider",78:"tick",79:"centipede",80:"black grouse",81:"ptarmigan",82:"ruffed grouse, partridge, Bonasa umbellus",83:"prairie chicken, prairie grouse, prairie fowl",84:"peacock",85:"quail",86:"partridge",87:"African grey, African gray, Psittacus erithacus",88:"macaw",89:"sulphur-crested cockatoo, Kakatoe galerita, Cacatua galerita",90:"lorikeet",91:"coucal",92:"bee eater",93:"hornbill",94:"hummingbird",95:"jacamar",96:"toucan",97:"drake",98:"red-breasted merganser, Mergus serrator",99:"goose",100:"black swan, Cygnus atratus",101:"tusker",102:"echidna, spiny anteater, anteater",103:"platypus, duckbill, duckbilled platypus, duck-billed platypus, Ornithorhynchus anatinus",104:"wallaby, brush kangaroo",105:"koala, koala bear, kangaroo bear, native bear, Phascolarctos cinereus",106:"wombat",107:"jelly fish",108:"sea anemone, anemone",109:"brain coral",110:"flatworm, platyhelminth",111:"nematode, nematode worm, roundworm",112:"conch",113:"snail",114:"slug",115:"sea slug, nudibranch",116:"chiton, coat-of-mail shell, sea cradle, polyplacophore",117:"chambered nautilus, pearly nautilus, nautilus",118:"Dungeness crab, Cancer magister",119:"rock crab, Cancer irroratus",120:"fiddler crab",121:"king crab, Alaska crab, Alaskan king crab, Alaska king crab, Paralithodes camtschatica",122:"American lobster, Northern lobster, Maine lobster, Homarus americanus",123:"spiny lobster, langouste, rock lobster, crawfish, crayfish, sea crawfish",124:"crayfish, crawfish, crawdad, crawdaddy",125:"hermit crab",126:"isopod",127:"white stork, Ciconia ciconia",128:"black stork, Ciconia nigra",129:"spoonbill",130:"flamingo",131:"little blue heron, Egretta caerulea",132:"American egret, great white heron, Egretta albus",133:"bittern",134:"crane",135:"limpkin, Aramus pictus",136:"European gallinule, Porphyrio porphyrio",137:"American coot, marsh hen, mud hen, water hen, Fulica americana",138:"bustard",139:"ruddy turnstone, Arenaria interpres",140:"red-backed sandpiper, dunlin, Erolia alpina",141:"redshank, Tringa totanus",142:"dowitcher",143:"oystercatcher, oyster catcher",144:"pelican",145:"king penguin, Aptenodytes patagonica",146:"albatross, mollymawk",147:"grey whale, gray whale, devilfish, Eschrichtius gibbosus, Eschrichtius robustus",148:"killer whale, killer, orca, grampus, sea wolf, Orcinus orca",149:"dugong, Dugong dugon",150:"sea lion",151:"Chihuahua",152:"Japanese spaniel",153:"Maltese dog, Maltese terrier, Maltese",154:"Pekinese, Pekingese, Peke",155:"Shih-Tzu",156:"Blenheim spaniel",157:"papillon",158:"toy terrier",159:"Rhodesian ridgeback",160:"Afghan hound, Afghan",161:"basset, basset hound",162:"beagle",163:"bloodhound, sleuthhound",164:"bluetick",165:"black-and-tan coonhound",166:"Walker hound, Walker foxhound",167:"English foxhound",168:"redbone",169:"borzoi, Russian wolfhound",170:"Irish wolfhound",171:"Italian greyhound",172:"whippet",173:"Ibizan hound, Ibizan Podenco",174:"Norwegian elkhound, elkhound",175:"otterhound, otter hound",176:"Saluki, gazelle hound",177:"Scottish deerhound, deerhound",178:"Weimaraner",179:"Staffordshire bullterrier, Staffordshire bull terrier",180:"American Staffordshire terrier, Staffordshire terrier, American pit bull terrier, pit bull terrier",181:"Bedlington terrier",182:"Border terrier",183:"Kerry blue terrier",184:"Irish terrier",185:"Norfolk terrier",186:"Norwich terrier",187:"Yorkshire terrier",188:"wire-haired fox terrier",189:"Lakeland terrier",190:"Sealyham terrier, Sealyham",191:"Airedale, Airedale terrier",192:"cairn, cairn terrier",193:"Australian terrier",194:"Dandie Dinmont, Dandie Dinmont terrier",195:"Boston bull, Boston terrier",196:"miniature schnauzer",197:"giant schnauzer",198:"standard schnauzer",199:"Scotch terrier, Scottish terrier, Scottie",200:"Tibetan terrier, chrysanthemum dog",201:"silky terrier, Sydney silky",202:"soft-coated wheaten terrier",203:"West Highland white terrier",204:"Lhasa, Lhasa apso",205:"flat-coated retriever",206:"curly-coated retriever",207:"golden retriever",208:"Labrador retriever",209:"Chesapeake Bay retriever",210:"German short-haired pointer",211:"vizsla, Hungarian pointer",212:"English setter",213:"Irish setter, red setter",214:"Gordon setter",215:"Brittany spaniel",216:"clumber, clumber spaniel",217:"English springer, English springer spaniel",218:"Welsh springer spaniel",219:"cocker spaniel, English cocker spaniel, cocker",220:"Sussex spaniel",221:"Irish water spaniel",222:"kuvasz",223:"schipperke",224:"groenendael",225:"malinois",226:"briard",227:"kelpie",228:"komondor",229:"Old English sheepdog, bobtail",230:"Shetland sheepdog, Shetland sheep dog, Shetland",231:"collie",232:"Border collie",233:"Bouvier des Flandres, Bouviers des Flandres",234:"Rottweiler",235:"German shepherd, German shepherd dog, German police dog, alsatian",236:"Doberman, Doberman pinscher",237:"miniature pinscher",238:"Greater Swiss Mountain dog",239:"Bernese mountain dog",240:"Appenzeller",241:"EntleBucher",242:"boxer",243:"bull mastiff",244:"Tibetan mastiff",245:"French bulldog",246:"Great Dane",247:"Saint Bernard, St Bernard",248:"Eskimo dog, husky",249:"malamute, malemute, Alaskan malamute",250:"Siberian husky",251:"dalmatian, coach dog, carriage dog",252:"affenpinscher, monkey pinscher, monkey dog",253:"basenji",254:"pug, pug-dog",255:"Leonberg",256:"Newfoundland, Newfoundland dog",257:"Great Pyrenees",258:"Samoyed, Samoyede",259:"Pomeranian",260:"chow, chow chow",261:"keeshond",262:"Brabancon griffon",263:"Pembroke, Pembroke Welsh corgi",264:"Cardigan, Cardigan Welsh corgi",265:"toy poodle",266:"miniature poodle",267:"standard poodle",268:"Mexican hairless",269:"timber wolf, grey wolf, gray wolf, Canis lupus",270:"white wolf, Arctic wolf, Canis lupus tundrarum",271:"red wolf, maned wolf, Canis rufus, Canis niger",272:"coyote, prairie wolf, brush wolf, Canis latrans",273:"dingo, warrigal, warragal, Canis dingo",274:"dhole, Cuon alpinus",275:"African hunting dog, hyena dog, Cape hunting dog, Lycaon pictus",276:"hyena, hyaena",277:"red fox, Vulpes vulpes",278:"kit fox, Vulpes macrotis",279:"Arctic fox, white fox, Alopex lagopus",280:"grey fox, gray fox, Urocyon cinereoargenteus",281:"tabby, tabby cat",282:"tiger cat",283:"Persian cat",284:"Siamese cat, Siamese",285:"Egyptian cat",286:"cougar, puma, catamount, mountain lion, painter, panther, Felis concolor",287:"lynx, catamount",288:"leopard, Panthera pardus",289:"snow leopard, ounce, Panthera uncia",290:"jaguar, panther, Panthera onca, Felis onca",291:"lion, king of beasts, Panthera leo",292:"tiger, Panthera tigris",293:"cheetah, chetah, Acinonyx jubatus",294:"brown bear, bruin, Ursus arctos",295:"American black bear, black bear, Ursus americanus, Euarctos americanus",296:"ice bear, polar bear, Ursus Maritimus, Thalarctos maritimus",297:"sloth bear, Melursus ursinus, Ursus ursinus",298:"mongoose",299:"meerkat, mierkat",300:"tiger beetle",301:"ladybug, ladybeetle, lady beetle, ladybird, ladybird beetle",302:"ground beetle, carabid beetle",303:"long-horned beetle, longicorn, longicorn beetle",304:"leaf beetle, chrysomelid",305:"dung beetle",306:"rhinoceros beetle",307:"weevil",308:"fly",309:"bee",310:"ant, emmet, pismire",311:"grasshopper, hopper",312:"cricket",313:"walking stick, walkingstick, stick insect",314:"cockroach, roach",315:"mantis, mantid",316:"cicada, cicala",317:"leafhopper",318:"lacewing, lacewing fly",319:"dragonfly, darning needle, devil's darning needle, sewing needle, snake feeder, snake doctor, mosquito hawk, skeeter hawk",320:"damselfly",321:"admiral",322:"ringlet, ringlet butterfly",323:"monarch, monarch butterfly, milkweed butterfly, Danaus plexippus",324:"cabbage butterfly",325:"sulphur butterfly, sulfur butterfly",326:"lycaenid, lycaenid butterfly",327:"starfish, sea star",328:"sea urchin",329:"sea cucumber, holothurian",330:"wood rabbit, cottontail, cottontail rabbit",331:"hare",332:"Angora, Angora rabbit",333:"hamster",334:"porcupine, hedgehog",335:"fox squirrel, eastern fox squirrel, Sciurus niger",336:"marmot",337:"beaver",338:"guinea pig, Cavia cobaya",339:"sorrel",340:"zebra",341:"hog, pig, grunter, squealer, Sus scrofa",342:"wild boar, boar, Sus scrofa",343:"warthog",344:"hippopotamus, hippo, river horse, Hippopotamus amphibius",345:"ox",346:"water buffalo, water ox, Asiatic buffalo, Bubalus bubalis",347:"bison",348:"ram, tup",349:"bighorn, bighorn sheep, cimarron, Rocky Mountain bighorn, Rocky Mountain sheep, Ovis canadensis",350:"ibex, Capra ibex",351:"hartebeest",352:"impala, Aepyceros melampus",353:"gazelle",354:"Arabian camel, dromedary, Camelus dromedarius",355:"llama",356:"weasel",357:"mink",358:"polecat, fitch, foulmart, foumart, Mustela putorius",359:"black-footed ferret, ferret, Mustela nigripes",360:"otter",361:"skunk, polecat, wood pussy",362:"badger",363:"armadillo",364:"three-toed sloth, ai, Bradypus tridactylus",365:"orangutan, orang, orangutang, Pongo pygmaeus",366:"gorilla, Gorilla gorilla",367:"chimpanzee, chimp, Pan troglodytes",368:"gibbon, Hylobates lar",369:"siamang, Hylobates syndactylus, Symphalangus syndactylus",370:"guenon, guenon monkey",371:"patas, hussar monkey, Erythrocebus patas",372:"baboon",373:"macaque",374:"langur",375:"colobus, colobus monkey",376:"proboscis monkey, Nasalis larvatus",377:"marmoset",378:"capuchin, ringtail, Cebus capucinus",379:"howler monkey, howler",380:"titi, titi monkey",381:"spider monkey, Ateles geoffroyi",382:"squirrel monkey, Saimiri sciureus",383:"Madagascar cat, ring-tailed lemur, Lemur catta",384:"indri, indris, Indri indri, Indri brevicaudatus",385:"Indian elephant, Elephas maximus",386:"African elephant, Loxodonta africana",387:"lesser panda, red panda, panda, bear cat, cat bear, Ailurus fulgens",388:"giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca",389:"barracouta, snoek",390:"eel",391:"coho, cohoe, coho salmon, blue jack, silver salmon, Oncorhynchus kisutch",392:"rock beauty, Holocanthus tricolor",393:"anemone fish",394:"sturgeon",395:"gar, garfish, garpike, billfish, Lepisosteus osseus",396:"lionfish",397:"puffer, pufferfish, blowfish, globefish",398:"abacus",399:"abaya",400:"academic gown, academic robe, judge's robe",401:"accordion, piano accordion, squeeze box",402:"acoustic guitar",403:"aircraft carrier, carrier, flattop, attack aircraft carrier",404:"airliner",405:"airship, dirigible",406:"altar",407:"ambulance",408:"amphibian, amphibious vehicle",409:"analog clock",410:"apiary, bee house",411:"apron",412:"ashcan, trash can, garbage can, wastebin, ash bin, ash-bin, ashbin, dustbin, trash barrel, trash bin",413:"assault rifle, assault gun",414:"backpack, back pack, knapsack, packsack, rucksack, haversack",415:"bakery, bakeshop, bakehouse",416:"balance beam, beam",417:"balloon",418:"ballpoint, ballpoint pen, ballpen, Biro",419:"Band Aid",420:"banjo",421:"bannister, banister, balustrade, balusters, handrail",422:"barbell",423:"barber chair",424:"barbershop",425:"barn",426:"barometer",427:"barrel, cask",428:"barrow, garden cart, lawn cart, wheelbarrow",429:"baseball",430:"basketball",431:"bassinet",432:"bassoon",433:"bathing cap, swimming cap",434:"bath towel",435:"bathtub, bathing tub, bath, tub",436:"beach wagon, station wagon, wagon, estate car, beach waggon, station waggon, waggon",437:"beacon, lighthouse, beacon light, pharos",438:"beaker",439:"bearskin, busby, shako",440:"beer bottle",441:"beer glass",442:"bell cote, bell cot",443:"bib",444:"bicycle-built-for-two, tandem bicycle, tandem",445:"bikini, two-piece",446:"binder, ring-binder",447:"binoculars, field glasses, opera glasses",448:"birdhouse",449:"boathouse",450:"bobsled, bobsleigh, bob",451:"bolo tie, bolo, bola tie, bola",452:"bonnet, poke bonnet",453:"bookcase",454:"bookshop, bookstore, bookstall",455:"bottlecap",456:"bow",457:"bow tie, bow-tie, bowtie",458:"brass, memorial tablet, plaque",459:"brassiere, bra, bandeau",460:"breakwater, groin, groyne, mole, bulwark, seawall, jetty",461:"breastplate, aegis, egis",462:"broom",463:"bucket, pail",464:"buckle",465:"bulletproof vest",466:"bullet train, bullet",467:"butcher shop, meat market",468:"cab, hack, taxi, taxicab",469:"caldron, cauldron",470:"candle, taper, wax light",471:"cannon",472:"canoe",473:"can opener, tin opener",474:"cardigan",475:"car mirror",476:"carousel, carrousel, merry-go-round, roundabout, whirligig",477:"carpenter's kit, tool kit",478:"carton",479:"car wheel",480:"cash machine, cash dispenser, automated teller machine, automatic teller machine, automated teller, automatic teller, ATM",481:"cassette",482:"cassette player",483:"castle",484:"catamaran",485:"CD player",486:"cello, violoncello",487:"cellular telephone, cellular phone, cellphone, cell, mobile phone",488:"chain",489:"chainlink fence",490:"chain mail, ring mail, mail, chain armor, chain armour, ring armor, ring armour",491:"chain saw, chainsaw",492:"chest",493:"chiffonier, commode",494:"chime, bell, gong",495:"china cabinet, china closet",496:"Christmas stocking",497:"church, church building",498:"cinema, movie theater, movie theatre, movie house, picture palace",499:"cleaver, meat cleaver, chopper",500:"cliff dwelling",501:"cloak",502:"clog, geta, patten, sabot",503:"cocktail shaker",504:"coffee mug",505:"coffeepot",506:"coil, spiral, volute, whorl, helix",507:"combination lock",508:"computer keyboard, keypad",509:"confectionery, confectionary, candy store",510:"container ship, containership, container vessel",511:"convertible",512:"corkscrew, bottle screw",513:"cornet, horn, trumpet, trump",514:"cowboy boot",515:"cowboy hat, ten-gallon hat",516:"cradle",517:"crane",518:"crash helmet",519:"crate",520:"crib, cot",521:"Crock Pot",522:"croquet ball",523:"crutch",524:"cuirass",525:"dam, dike, dyke",526:"desk",527:"desktop computer",528:"dial telephone, dial phone",529:"diaper, nappy, napkin",530:"digital clock",531:"digital watch",532:"dining table, board",533:"dishrag, dishcloth",534:"dishwasher, dish washer, dishwashing machine",535:"disk brake, disc brake",536:"dock, dockage, docking facility",537:"dogsled, dog sled, dog sleigh",538:"dome",539:"doormat, welcome mat",540:"drilling platform, offshore rig",541:"drum, membranophone, tympan",542:"drumstick",543:"dumbbell",544:"Dutch oven",545:"electric fan, blower",546:"electric guitar",547:"electric locomotive",548:"entertainment center",549:"envelope",550:"espresso maker",551:"face powder",552:"feather boa, boa",553:"file, file cabinet, filing cabinet",554:"fireboat",555:"fire engine, fire truck",556:"fire screen, fireguard",557:"flagpole, flagstaff",558:"flute, transverse flute",559:"folding chair",560:"football helmet",561:"forklift",562:"fountain",563:"fountain pen",564:"four-poster",565:"freight car",566:"French horn, horn",567:"frying pan, frypan, skillet",568:"fur coat",569:"garbage truck, dustcart",570:"gasmask, respirator, gas helmet",571:"gas pump, gasoline pump, petrol pump, island dispenser",572:"goblet",573:"go-kart",574:"golf ball",575:"golfcart, golf cart",576:"gondola",577:"gong, tam-tam",578:"gown",579:"grand piano, grand",580:"greenhouse, nursery, glasshouse",581:"grille, radiator grille",582:"grocery store, grocery, food market, market",583:"guillotine",584:"hair slide",585:"hair spray",586:"half track",587:"hammer",588:"hamper",589:"hand blower, blow dryer, blow drier, hair dryer, hair drier",590:"hand-held computer, hand-held microcomputer",591:"handkerchief, hankie, hanky, hankey",592:"hard disc, hard disk, fixed disk",593:"harmonica, mouth organ, harp, mouth harp",594:"harp",595:"harvester, reaper",596:"hatchet",597:"holster",598:"home theater, home theatre",599:"honeycomb",600:"hook, claw",601:"hoopskirt, crinoline",602:"horizontal bar, high bar",603:"horse cart, horse-cart",604:"hourglass",605:"iPod",606:"iron, smoothing iron",607:"jack-o'-lantern",608:"jean, blue jean, denim",609:"jeep, landrover",610:"jersey, T-shirt, tee shirt",611:"jigsaw puzzle",612:"jinrikisha, ricksha, rickshaw",613:"joystick",614:"kimono",615:"knee pad",616:"knot",617:"lab coat, laboratory coat",618:"ladle",619:"lampshade, lamp shade",620:"laptop, laptop computer",621:"lawn mower, mower",622:"lens cap, lens cover",623:"letter opener, paper knife, paperknife",624:"library",625:"lifeboat",626:"lighter, light, igniter, ignitor",627:"limousine, limo",628:"liner, ocean liner",629:"lipstick, lip rouge",630:"Loafer",631:"lotion",632:"loudspeaker, speaker, speaker unit, loudspeaker system, speaker system",633:"loupe, jeweler's loupe",634:"lumbermill, sawmill",635:"magnetic compass",636:"mailbag, postbag",637:"mailbox, letter box",638:"maillot",639:"maillot, tank suit",640:"manhole cover",641:"maraca",642:"marimba, xylophone",643:"mask",644:"matchstick",645:"maypole",646:"maze, labyrinth",647:"measuring cup",648:"medicine chest, medicine cabinet",649:"megalith, megalithic structure",650:"microphone, mike",651:"microwave, microwave oven",652:"military uniform",653:"milk can",654:"minibus",655:"miniskirt, mini",656:"minivan",657:"missile",658:"mitten",659:"mixing bowl",660:"mobile home, manufactured home",661:"Model T",662:"modem",663:"monastery",664:"monitor",665:"moped",666:"mortar",667:"mortarboard",668:"mosque",669:"mosquito net",670:"motor scooter, scooter",671:"mountain bike, all-terrain bike, off-roader",672:"mountain tent",673:"mouse, computer mouse",674:"mousetrap",675:"moving van",676:"muzzle",677:"nail",678:"neck brace",679:"necklace",680:"nipple",681:"notebook, notebook computer",682:"obelisk",683:"oboe, hautboy, hautbois",684:"ocarina, sweet potato",685:"odometer, hodometer, mileometer, milometer",686:"oil filter",687:"organ, pipe organ",688:"oscilloscope, scope, cathode-ray oscilloscope, CRO",689:"overskirt",690:"oxcart",691:"oxygen mask",692:"packet",693:"paddle, boat paddle",694:"paddlewheel, paddle wheel",695:"padlock",696:"paintbrush",697:"pajama, pyjama, pj's, jammies",698:"palace",699:"panpipe, pandean pipe, syrinx",700:"paper towel",701:"parachute, chute",702:"parallel bars, bars",703:"park bench",704:"parking meter",705:"passenger car, coach, carriage",706:"patio, terrace",707:"pay-phone, pay-station",708:"pedestal, plinth, footstall",709:"pencil box, pencil case",710:"pencil sharpener",711:"perfume, essence",712:"Petri dish",713:"photocopier",714:"pick, plectrum, plectron",715:"pickelhaube",716:"picket fence, paling",717:"pickup, pickup truck",718:"pier",719:"piggy bank, penny bank",720:"pill bottle",721:"pillow",722:"ping-pong ball",723:"pinwheel",724:"pirate, pirate ship",725:"pitcher, ewer",726:"plane, carpenter's plane, woodworking plane",727:"planetarium",728:"plastic bag",729:"plate rack",730:"plow, plough",731:"plunger, plumber's helper",732:"Polaroid camera, Polaroid Land camera",733:"pole",734:"police van, police wagon, paddy wagon, patrol wagon, wagon, black Maria",735:"poncho",736:"pool table, billiard table, snooker table",737:"pop bottle, soda bottle",738:"pot, flowerpot",739:"potter's wheel",740:"power drill",741:"prayer rug, prayer mat",742:"printer",743:"prison, prison house",744:"projectile, missile",745:"projector",746:"puck, hockey puck",747:"punching bag, punch bag, punching ball, punchball",748:"purse",749:"quill, quill pen",750:"quilt, comforter, comfort, puff",751:"racer, race car, racing car",752:"racket, racquet",753:"radiator",754:"radio, wireless",755:"radio telescope, radio reflector",756:"rain barrel",757:"recreational vehicle, RV, R.V.",758:"reel",759:"reflex camera",760:"refrigerator, icebox",761:"remote control, remote",762:"restaurant, eating house, eating place, eatery",763:"revolver, six-gun, six-shooter",764:"rifle",765:"rocking chair, rocker",766:"rotisserie",767:"rubber eraser, rubber, pencil eraser",768:"rugby ball",769:"rule, ruler",770:"running shoe",771:"safe",772:"safety pin",773:"saltshaker, salt shaker",774:"sandal",775:"sarong",776:"sax, saxophone",777:"scabbard",778:"scale, weighing machine",779:"school bus",780:"schooner",781:"scoreboard",782:"screen, CRT screen",783:"screw",784:"screwdriver",785:"seat belt, seatbelt",786:"sewing machine",787:"shield, buckler",788:"shoe shop, shoe-shop, shoe store",789:"shoji",790:"shopping basket",791:"shopping cart",792:"shovel",793:"shower cap",794:"shower curtain",795:"ski",796:"ski mask",797:"sleeping bag",798:"slide rule, slipstick",799:"sliding door",800:"slot, one-armed bandit",801:"snorkel",802:"snowmobile",803:"snowplow, snowplough",804:"soap dispenser",805:"soccer ball",806:"sock",807:"solar dish, solar collector, solar furnace",808:"sombrero",809:"soup bowl",810:"space bar",811:"space heater",812:"space shuttle",813:"spatula",814:"speedboat",815:"spider web, spider's web",816:"spindle",817:"sports car, sport car",818:"spotlight, spot",819:"stage",820:"steam locomotive",821:"steel arch bridge",822:"steel drum",823:"stethoscope",824:"stole",825:"stone wall",826:"stopwatch, stop watch",827:"stove",828:"strainer",829:"streetcar, tram, tramcar, trolley, trolley car",830:"stretcher",831:"studio couch, day bed",832:"stupa, tope",833:"submarine, pigboat, sub, U-boat",834:"suit, suit of clothes",835:"sundial",836:"sunglass",837:"sunglasses, dark glasses, shades",838:"sunscreen, sunblock, sun blocker",839:"suspension bridge",840:"swab, swob, mop",841:"sweatshirt",842:"swimming trunks, bathing trunks",843:"swing",844:"switch, electric switch, electrical switch",845:"syringe",846:"table lamp",847:"tank, army tank, armored combat vehicle, armoured combat vehicle",848:"tape player",849:"teapot",850:"teddy, teddy bear",851:"television, television system",852:"tennis ball",853:"thatch, thatched roof",854:"theater curtain, theatre curtain",855:"thimble",856:"thresher, thrasher, threshing machine",857:"throne",858:"tile roof",859:"toaster",860:"tobacco shop, tobacconist shop, tobacconist",861:"toilet seat",862:"torch",863:"totem pole",864:"tow truck, tow car, wrecker",865:"toyshop",866:"tractor",867:"trailer truck, tractor trailer, trucking rig, rig, articulated lorry, semi",868:"tray",869:"trench coat",870:"tricycle, trike, velocipede",871:"trimaran",872:"tripod",873:"triumphal arch",874:"trolleybus, trolley coach, trackless trolley",875:"trombone",876:"tub, vat",877:"turnstile",878:"typewriter keyboard",879:"umbrella",880:"unicycle, monocycle",881:"upright, upright piano",882:"vacuum, vacuum cleaner",883:"vase",884:"vault",885:"velvet",886:"vending machine",887:"vestment",888:"viaduct",889:"violin, fiddle",890:"volleyball",891:"waffle iron",892:"wall clock",893:"wallet, billfold, notecase, pocketbook",894:"wardrobe, closet, press",895:"warplane, military plane",896:"washbasin, handbasin, washbowl, lavabo, wash-hand basin",897:"washer, automatic washer, washing machine",898:"water bottle",899:"water jug",900:"water tower",901:"whiskey jug",902:"whistle",903:"wig",904:"window screen",905:"window shade",906:"Windsor tie",907:"wine bottle",908:"wing",909:"wok",910:"wooden spoon",911:"wool, woolen, woollen",912:"worm fence, snake fence, snake-rail fence, Virginia fence",913:"wreck",914:"yawl",915:"yurt",916:"web site, website, internet site, site",917:"comic book",918:"crossword puzzle, crossword",919:"street sign",920:"traffic light, traffic signal, stoplight",921:"book jacket, dust cover, dust jacket, dust wrapper",922:"menu",923:"plate",924:"guacamole",925:"consomme",926:"hot pot, hotpot",927:"trifle",928:"ice cream, icecream",929:"ice lolly, lolly, lollipop, popsicle",930:"French loaf",931:"bagel, beigel",932:"pretzel",933:"cheeseburger",934:"hotdog, hot dog, red hot",935:"mashed potato",936:"head cabbage",937:"broccoli",938:"cauliflower",939:"zucchini, courgette",940:"spaghetti squash",941:"acorn squash",942:"butternut squash",943:"cucumber, cuke",944:"artichoke, globe artichoke",945:"bell pepper",946:"cardoon",947:"mushroom",948:"Granny Smith",949:"strawberry",950:"orange",951:"lemon",952:"fig",953:"pineapple, ananas",954:"banana",955:"jackfruit, jak, jack",956:"custard apple",957:"pomegranate",958:"hay",959:"carbonara",960:"chocolate sauce, chocolate syrup",961:"dough",962:"meat loaf, meatloaf",963:"pizza, pizza pie",964:"potpie",965:"burrito",966:"red wine",967:"espresso",968:"cup",969:"eggnog",970:"alp",971:"bubble",972:"cliff, drop, drop-off",973:"coral reef",974:"geyser",975:"lakeside, lakeshore",976:"promontory, headland, head, foreland",977:"sandbar, sand bar",978:"seashore, coast, seacoast, sea-coast",979:"valley, vale",980:"volcano",981:"ballplayer, baseball player",982:"groom, bridegroom",983:"scuba diver",984:"rapeseed",985:"daisy",986:"yellow lady's slipper, yellow lady-slipper, Cypripedium calceolus, Cypripedium parviflorum",987:"corn",988:"acorn",989:"hip, rose hip, rosehip",990:"buckeye, horse chestnut, conker",991:"coral fungus",992:"agaric",993:"gyromitra",994:"stinkhorn, carrion fungus",995:"earthstar",996:"hen-of-the-woods, hen of the woods, Polyporus frondosus, Grifola frondosa",997:"bolete",998:"ear, spike, capitulum",999:"toilet tissue, toilet paper, bathroom tissue"},cd=224,xht={"1.00":"module_apply_default/MobilenetV1/Logits/global_pool","2.00":"module_apply_default/MobilenetV2/Logits/AvgPool"},mb={"1.00":{.25:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_025_224/classification/1",inputRange:[0,1]},"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_050_224/classification/1",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_075_224/classification/1",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_100_224/classification/1",inputRange:[0,1]}},"2.00":{"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_050_224/classification/2",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_075_224/classification/2",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/classification/2",inputRange:[0,1]}}};function bj(n){return n===void 0&&(n={version:1,alpha:1}),bA(this,void 0,void 0,function(){var e,t,r,i,s,o,a;return vA(this,function(l){switch(l.label){case 0:if(YY==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");if(e=n.version.toFixed(2),t=n.alpha?n.alpha.toFixed(2):"",r=-1,i=1,n.modelUrl==null){if(!(e in mb))throw new Error("Invalid version of MobileNet. Valid versions are: "+Object.keys(mb));if(!(t in mb[e]))throw new Error("MobileNet constructed with invalid alpha "+n.alpha+". Valid multipliers for this version are: "+Object.keys(mb[e])+".");o=mb[e][t].inputRange,r=o[0],i=o[1]}return n.inputRange!=null&&(a=n.inputRange,r=a[0],i=a[1]),[4,(s=new _ht(e,t,n.modelUrl,r,i)).load()];case 1:return l.sent(),[2,s]}})})}var _ht=function(){function n(e,t,r,i,s){i===void 0&&(i=-1),s===void 0&&(s=1),this.version=e,this.alpha=t,this.modelUrl=r,this.inputMin=i,this.inputMax=s,this.normalizationConstant=(s-i)/255}return n.prototype.load=function(){return bA(this,void 0,void 0,function(){var e,t,r,i,s=this;return vA(this,function(o){switch(o.label){case 0:return this.modelUrl?(e=this,[4,Pl(this.modelUrl)]):[3,2];case 1:return e.model=o.sent(),[3,4];case 2:return t=mb[this.version][this.alpha].url,r=this,[4,Pl(t,{fromTFHub:!0})];case 3:r.model=o.sent(),o.label=4;case 4:return[4,(i=Se(function(){return s.model.predict(pi([1,cd,cd,3]))})).data()];case 5:return o.sent(),i.dispose(),[2]}})})},n.prototype.infer=function(e,t){var r=this;return t===void 0&&(t=!1),Se(function(){e instanceof jn||(e=iC(e));var i=Xe(fe(St(e,"float32"),r.normalizationConstant),r.inputMin),s=i;(e.shape[0]!==cd||e.shape[1]!==cd)&&(s=Ss.resizeBilinear(i,[cd,cd],!0));var o,a=ve(s,[-1,cd,cd,3]);if(t){var l=xht[r.version],c=r.model.execute(a,l);o=br(c,[1,2])}else{var u=r.model.predict(a);o=pn(u,[0,1],[-1,1e3])}return o})},n.prototype.classify=function(e,t){return t===void 0&&(t=3),bA(this,void 0,void 0,function(){var r,i;return vA(this,function(s){switch(s.label){case 0:return[4,Sht(r=this.infer(e),t)];case 1:return i=s.sent(),r.dispose(),[2,i]}})})},n}();function Sht(n,e){return bA(this,void 0,void 0,function(){var t,r,i,s,o,a,l;return vA(this,function(c){switch(c.label){case 0:return[4,(t=eC(n)).data()];case 1:for(r=c.sent(),t.dispose(),i=[],l=0;l<r.length;l++)i.push({value:r[l],index:l});for(i.sort(function(u,h){return h.value-u.value}),s=new Float32Array(e),o=new Int32Array(e),l=0;l<e;l++)s[l]=i[l].value,o[l]=i[l].index;for(a=[],l=0;l<o.length;l++)a.push({className:wht[o[l]],probability:s[l]});return[2,a]}})})}var Cht={};(function(){var n;function e(T){var $=0;return function(){return $<T.length?{done:!1,value:T[$++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(T,$,L){return T==Array.prototype||T==Object.prototype||(T[$]=L.value),T};function r(T){T=[typeof globalThis=="object"&&globalThis,T,typeof window=="object"&&window,typeof self=="object"&&self,typeof gt=="object"&&gt];for(var $=0;$<T.length;++$){var L=T[$];if(L&&L.Math==Math)return L}throw Error("Cannot find global object")}var i=r(this);function s(T,$){if($)e:{var L=i;T=T.split(".");for(var W=0;W<T.length-1;W++){var ne=T[W];if(!(ne in L))break e;L=L[ne]}T=T[T.length-1],W=L[T],$=$(W),$!=W&&$!=null&&t(L,T,{configurable:!0,writable:!0,value:$})}}s("Symbol",function(T){function $(oe){if(this instanceof $)throw new TypeError("Symbol is not a constructor");return new L(W+(oe||"")+"_"+ne++,oe)}function L(oe,se){this.h=oe,t(this,"description",{configurable:!0,writable:!0,value:se})}if(T)return T;L.prototype.toString=function(){return this.h};var W="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",ne=0;return $}),s("Symbol.iterator",function(T){if(T)return T;T=Symbol("Symbol.iterator");for(var $="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),L=0;L<$.length;L++){var W=i[$[L]];typeof W=="function"&&typeof W.prototype[T]!="function"&&t(W.prototype,T,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return T});function o(T){return T={next:T},T[Symbol.iterator]=function(){return this},T}function a(T){var $=typeof Symbol<"u"&&Symbol.iterator&&T[Symbol.iterator];return $?$.call(T):{next:e(T)}}function l(T){if(!(T instanceof Array)){T=a(T);for(var $,L=[];!($=T.next()).done;)L.push($.value);T=L}return T}var c=typeof Object.assign=="function"?Object.assign:function(T,$){for(var L=1;L<arguments.length;L++){var W=arguments[L];if(W)for(var ne in W)Object.prototype.hasOwnProperty.call(W,ne)&&(T[ne]=W[ne])}return T};s("Object.assign",function(T){return T||c});var u=typeof Object.create=="function"?Object.create:function(T){function $(){}return $.prototype=T,new $},h;if(typeof Object.setPrototypeOf=="function")h=Object.setPrototypeOf;else{var f;e:{var d={a:!0},p={};try{p.__proto__=d,f=p.a;break e}catch{}f=!1}h=f?function(T,$){if(T.__proto__=$,T.__proto__!==$)throw new TypeError(T+" is not extensible");return T}:null}var m=h;function g(T,$){if(T.prototype=u($.prototype),T.prototype.constructor=T,m)m(T,$);else for(var L in $)if(L!="prototype")if(Object.defineProperties){var W=Object.getOwnPropertyDescriptor($,L);W&&Object.defineProperty(T,L,W)}else T[L]=$[L];T.za=$.prototype}function y(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function b(T){if(T.m)throw new TypeError("Generator is already running");T.m=!0}y.prototype.u=function(T){this.i=T};function _(T,$){T.l={ma:$,na:!0},T.h=T.s||T.v}y.prototype.return=function(T){this.l={return:T},this.h=this.v};function w(T,$,L){return T.h=L,{value:$}}function S(T){this.h=new y,this.i=T}function C(T,$){b(T.h);var L=T.h.j;return L?k(T,"return"in L?L.return:function(W){return{value:W,done:!0}},$,T.h.return):(T.h.return($),A(T))}function k(T,$,L,W){try{var ne=$.call(T.h.j,L);if(!(ne instanceof Object))throw new TypeError("Iterator result "+ne+" is not an object");if(!ne.done)return T.h.m=!1,ne;var oe=ne.value}catch(se){return T.h.j=null,_(T.h,se),A(T)}return T.h.j=null,W.call(T.h,oe),A(T)}function A(T){for(;T.h.h;)try{var $=T.i(T.h);if($)return T.h.m=!1,{value:$.value,done:!1}}catch(L){T.h.i=void 0,_(T.h,L)}if(T.h.m=!1,T.h.l){if($=T.h.l,T.h.l=null,$.na)throw $.ma;return{value:$.return,done:!0}}return{value:void 0,done:!0}}function M(T){this.next=function($){return b(T.h),T.h.j?$=k(T,T.h.j.next,$,T.h.u):(T.h.u($),$=A(T)),$},this.throw=function($){return b(T.h),T.h.j?$=k(T,T.h.j.throw,$,T.h.u):(_(T.h,$),$=A(T)),$},this.return=function($){return C(T,$)},this[Symbol.iterator]=function(){return this}}function E(T){function $(W){return T.next(W)}function L(W){return T.throw(W)}return new Promise(function(W,ne){function oe(se){se.done?W(se.value):Promise.resolve(se.value).then($,L).then(oe,ne)}oe(T.next())})}function N(T){return E(new M(new S(T)))}s("Promise",function(T){function $(se){this.i=0,this.j=void 0,this.h=[],this.u=!1;var Ce=this.l();try{se(Ce.resolve,Ce.reject)}catch(Pe){Ce.reject(Pe)}}function L(){this.h=null}function W(se){return se instanceof $?se:new $(function(Ce){Ce(se)})}if(T)return T;L.prototype.i=function(se){if(this.h==null){this.h=[];var Ce=this;this.j(function(){Ce.m()})}this.h.push(se)};var ne=i.setTimeout;L.prototype.j=function(se){ne(se,0)},L.prototype.m=function(){for(;this.h&&this.h.length;){var se=this.h;this.h=[];for(var Ce=0;Ce<se.length;++Ce){var Pe=se[Ce];se[Ce]=null;try{Pe()}catch(dt){this.l(dt)}}}this.h=null},L.prototype.l=function(se){this.j(function(){throw se})},$.prototype.l=function(){function se(dt){return function(At){Pe||(Pe=!0,dt.call(Ce,At))}}var Ce=this,Pe=!1;return{resolve:se(this.I),reject:se(this.m)}},$.prototype.I=function(se){if(se===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(se instanceof $)this.L(se);else{e:switch(typeof se){case"object":var Ce=se!=null;break e;case"function":Ce=!0;break e;default:Ce=!1}Ce?this.F(se):this.s(se)}},$.prototype.F=function(se){var Ce=void 0;try{Ce=se.then}catch(Pe){this.m(Pe);return}typeof Ce=="function"?this.M(Ce,se):this.s(se)},$.prototype.m=function(se){this.v(2,se)},$.prototype.s=function(se){this.v(1,se)},$.prototype.v=function(se,Ce){if(this.i!=0)throw Error("Cannot settle("+se+", "+Ce+"): Promise already settled in state"+this.i);this.i=se,this.j=Ce,this.i===2&&this.K(),this.H()},$.prototype.K=function(){var se=this;ne(function(){if(se.D()){var Ce=i.console;typeof Ce<"u"&&Ce.error(se.j)}},1)},$.prototype.D=function(){if(this.u)return!1;var se=i.CustomEvent,Ce=i.Event,Pe=i.dispatchEvent;return typeof Pe>"u"?!0:(typeof se=="function"?se=new se("unhandledrejection",{cancelable:!0}):typeof Ce=="function"?se=new Ce("unhandledrejection",{cancelable:!0}):(se=i.document.createEvent("CustomEvent"),se.initCustomEvent("unhandledrejection",!1,!0,se)),se.promise=this,se.reason=this.j,Pe(se))},$.prototype.H=function(){if(this.h!=null){for(var se=0;se<this.h.length;++se)oe.i(this.h[se]);this.h=null}};var oe=new L;return $.prototype.L=function(se){var Ce=this.l();se.T(Ce.resolve,Ce.reject)},$.prototype.M=function(se,Ce){var Pe=this.l();try{se.call(Ce,Pe.resolve,Pe.reject)}catch(dt){Pe.reject(dt)}},$.prototype.then=function(se,Ce){function Pe(Ut,Rt){return typeof Ut=="function"?function(an){try{dt(Ut(an))}catch(Vn){At(Vn)}}:Rt}var dt,At,fn=new $(function(Ut,Rt){dt=Ut,At=Rt});return this.T(Pe(se,dt),Pe(Ce,At)),fn},$.prototype.catch=function(se){return this.then(void 0,se)},$.prototype.T=function(se,Ce){function Pe(){switch(dt.i){case 1:se(dt.j);break;case 2:Ce(dt.j);break;default:throw Error("Unexpected state: "+dt.i)}}var dt=this;this.h==null?oe.i(Pe):this.h.push(Pe),this.u=!0},$.resolve=W,$.reject=function(se){return new $(function(Ce,Pe){Pe(se)})},$.race=function(se){return new $(function(Ce,Pe){for(var dt=a(se),At=dt.next();!At.done;At=dt.next())W(At.value).T(Ce,Pe)})},$.all=function(se){var Ce=a(se),Pe=Ce.next();return Pe.done?W([]):new $(function(dt,At){function fn(an){return function(Vn){Ut[an]=Vn,Rt--,Rt==0&&dt(Ut)}}var Ut=[],Rt=0;do Ut.push(void 0),Rt++,W(Pe.value).T(fn(Ut.length-1),At),Pe=Ce.next();while(!Pe.done)})},$});function O(T,$){T instanceof String&&(T+="");var L=0,W=!1,ne={next:function(){if(!W&&L<T.length){var oe=L++;return{value:$(oe,T[oe]),done:!1}}return W=!0,{done:!0,value:void 0}}};return ne[Symbol.iterator]=function(){return ne},ne}s("Array.prototype.keys",function(T){return T||function(){return O(this,function($){return $})}}),s("Array.prototype.fill",function(T){return T||function($,L,W){var ne=this.length||0;for(0>L&&(L=Math.max(0,ne+L)),(W==null||W>ne)&&(W=ne),W=Number(W),0>W&&(W=Math.max(0,ne+W)),L=Number(L||0);L<W;L++)this[L]=$;return this}});function R(T){return T||Array.prototype.fill}s("Int8Array.prototype.fill",R),s("Uint8Array.prototype.fill",R),s("Uint8ClampedArray.prototype.fill",R),s("Int16Array.prototype.fill",R),s("Uint16Array.prototype.fill",R),s("Int32Array.prototype.fill",R),s("Uint32Array.prototype.fill",R),s("Float32Array.prototype.fill",R),s("Float64Array.prototype.fill",R),s("Object.is",function(T){return T||function($,L){return $===L?$!==0||1/$===1/L:$!==$&&L!==L}}),s("Array.prototype.includes",function(T){return T||function($,L){var W=this;W instanceof String&&(W=String(W));var ne=W.length;for(L=L||0,0>L&&(L=Math.max(L+ne,0));L<ne;L++){var oe=W[L];if(oe===$||Object.is(oe,$))return!0}return!1}}),s("String.prototype.includes",function(T){return T||function($,L){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if($ instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf($,L||0)!==-1}});var D=this||self;function z(T,$){T=T.split(".");var L=D;T[0]in L||typeof L.execScript>"u"||L.execScript("var "+T[0]);for(var W;T.length&&(W=T.shift());)T.length||$===void 0?L[W]&&L[W]!==Object.prototype[W]?L=L[W]:L=L[W]={}:L[W]=$}function B(T){var $;e:{if(($=D.navigator)&&($=$.userAgent))break e;$=""}return $.indexOf(T)!=-1}var X=Array.prototype.map?function(T,$){return Array.prototype.map.call(T,$,void 0)}:function(T,$){for(var L=T.length,W=Array(L),ne=typeof T=="string"?T.split(""):T,oe=0;oe<L;oe++)oe in ne&&(W[oe]=$.call(void 0,ne[oe],oe,T));return W},H={},te=null;function ge(T){var $=T.length,L=3*$/4;L%3?L=Math.floor(L):"=.".indexOf(T[$-1])!=-1&&(L="=.".indexOf(T[$-2])!=-1?L-2:L-1);var W=new Uint8Array(L),ne=0;return ae(T,function(oe){W[ne++]=oe}),ne!==L?W.subarray(0,ne):W}function ae(T,$){function L(Pe){for(;W<T.length;){var dt=T.charAt(W++),At=te[dt];if(At!=null)return At;if(!/^[\s\xa0]*$/.test(dt))throw Error("Unknown base64 encoding at char: "+dt)}return Pe}Ne();for(var W=0;;){var ne=L(-1),oe=L(0),se=L(64),Ce=L(64);if(Ce===64&&ne===-1)break;$(ne<<2|oe>>4),se!=64&&($(oe<<4&240|se>>2),Ce!=64&&$(se<<6&192|Ce))}}function Ne(){if(!te){te={};for(var T="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),$=["+/=","+/","-_=","-_.","-_"],L=0;5>L;L++){var W=T.concat($[L].split(""));H[L]=W;for(var ne=0;ne<W.length;ne++){var oe=W[ne];te[oe]===void 0&&(te[oe]=ne)}}}}var Te=typeof Uint8Array<"u",De=!(B("Trident")||B("MSIE"))&&typeof D.btoa=="function";function be(T){if(!De){var $;$===void 0&&($=0),Ne(),$=H[$];for(var L=Array(Math.floor(T.length/3)),W=$[64]||"",ne=0,oe=0;ne<T.length-2;ne+=3){var se=T[ne],Ce=T[ne+1],Pe=T[ne+2],dt=$[se>>2];se=$[(se&3)<<4|Ce>>4],Ce=$[(Ce&15)<<2|Pe>>6],Pe=$[Pe&63],L[oe++]=dt+se+Ce+Pe}switch(dt=0,Pe=W,T.length-ne){case 2:dt=T[ne+1],Pe=$[(dt&15)<<2]||W;case 1:T=T[ne],L[oe]=$[T>>2]+$[(T&3)<<4|dt>>4]+Pe+W}return L.join("")}for($="";10240<T.length;)$+=String.fromCharCode.apply(null,T.subarray(0,10240)),T=T.subarray(10240);return $+=String.fromCharCode.apply(null,T),btoa($)}var Ke=RegExp("[-_.]","g");function Oe(T){switch(T){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function ot(T){if(!De)return ge(T);Ke.test(T)&&(T=T.replace(Ke,Oe)),T=atob(T);for(var $=new Uint8Array(T.length),L=0;L<T.length;L++)$[L]=T.charCodeAt(L);return $}var He;function mt(){return He||(He=new Uint8Array(0))}var ht={},Ue=typeof Uint8Array.prototype.slice=="function",Be=0,Ve=0;function ft(T){var $=0>T;T=Math.abs(T);var L=T>>>0;T=Math.floor((T-L)/4294967296),$&&(L=a(ee(L,T)),$=L.next().value,T=L.next().value,L=$),Be=L>>>0,Ve=T>>>0}var Ye=typeof BigInt=="function";function ee(T,$){return $=~$,T?T=~T+1:$+=1,[T,$]}function J(T,$){this.i=T>>>0,this.h=$>>>0}function it(T){if(!T)return Ge||(Ge=new J(0,0));if(!/^-?\d+$/.test(T))return null;if(16>T.length)ft(Number(T));else if(Ye)T=BigInt(T),Be=Number(T&BigInt(4294967295))>>>0,Ve=Number(T>>BigInt(32)&BigInt(4294967295));else{var $=+(T[0]==="-");Ve=Be=0;for(var L=T.length,W=$,ne=(L-$)%6+$;ne<=L;W=ne,ne+=6)W=Number(T.slice(W,ne)),Ve*=1e6,Be=1e6*Be+W,4294967296<=Be&&(Ve+=Be/4294967296|0,Be%=4294967296);$&&($=a(ee(Be,Ve)),T=$.next().value,$=$.next().value,Be=T,Ve=$)}return new J(Be,Ve)}var Ge;function ye(T,$){return Error("Invalid wire type: "+T+" (at position "+$+")")}function Je(){return Error("Failed to read varint, encoding is invalid.")}function bt(T,$){return Error("Tried to read past the end of the data "+$+" > "+T)}function It(){throw Error("Invalid UTF8")}function pt(T,$){return $=String.fromCharCode.apply(null,$),T==null?$:T+$}var ce=void 0,rt,Et=typeof TextDecoder<"u",yt,Ht=typeof TextEncoder<"u",Mn;function Cr(T){if(T!==ht)throw Error("illegal external caller")}function Bi(T,$){if(Cr($),this.V=T,T!=null&&T.length===0)throw Error("ByteString should be constructed with non-empty values")}function Ai(){return Mn||(Mn=new Bi(null,ht))}function Mi(T){Cr(ht);var $=T.V;return $=$==null||Te&&$!=null&&$ instanceof Uint8Array?$:typeof $=="string"?ot($):null,$==null?$:T.V=$}function zh(T){if(typeof T=="string")return{buffer:ot(T),C:!1};if(Array.isArray(T))return{buffer:new Uint8Array(T),C:!1};if(T.constructor===Uint8Array)return{buffer:T,C:!1};if(T.constructor===ArrayBuffer)return{buffer:new Uint8Array(T),C:!1};if(T.constructor===Bi)return{buffer:Mi(T)||mt(),C:!0};if(T instanceof Uint8Array)return{buffer:new Uint8Array(T.buffer,T.byteOffset,T.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function Ul(T,$){this.i=null,this.m=!1,this.h=this.j=this.l=0,Wl(this,T,$)}function Wl(T,$,L){L=L===void 0?{}:L,T.S=L.S===void 0?!1:L.S,$&&($=zh($),T.i=$.buffer,T.m=$.C,T.l=0,T.j=T.i.length,T.h=T.l)}Ul.prototype.reset=function(){this.h=this.l};function mo(T,$){if(T.h=$,$>T.j)throw bt(T.j,$)}function Hl(T){var $=T.i,L=T.h,W=$[L++],ne=W&127;if(W&128&&(W=$[L++],ne|=(W&127)<<7,W&128&&(W=$[L++],ne|=(W&127)<<14,W&128&&(W=$[L++],ne|=(W&127)<<21,W&128&&(W=$[L++],ne|=W<<28,W&128&&$[L++]&128&&$[L++]&128&&$[L++]&128&&$[L++]&128&&$[L++]&128)))))throw Je();return mo(T,L),ne}function Bc(T,$){if(0>$)throw Error("Tried to read a negative byte length: "+$);var L=T.h,W=L+$;if(W>T.j)throw bt($,T.j-L);return T.h=W,L}var Vc=[];function Ps(){this.h=[]}Ps.prototype.length=function(){return this.h.length},Ps.prototype.end=function(){var T=this.h;return this.h=[],T};function Bh(T,$,L){for(;0<L||127<$;)T.h.push($&127|128),$=($>>>7|L<<25)>>>0,L>>>=7;T.h.push($)}function rl(T,$){for(;127<$;)T.h.push($&127|128),$>>>=7;T.h.push($)}function Vh(T,$){if(Vc.length){var L=Vc.pop();Wl(L,T,$),T=L}else T=new Ul(T,$);this.h=T,this.j=this.h.h,this.i=this.l=-1,this.setOptions($)}Vh.prototype.setOptions=function(T){T=T===void 0?{}:T,this.ca=T.ca===void 0?!1:T.ca},Vh.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function re(T){var $=T.h;if($.h==$.j)return!1;T.j=T.h.h;var L=Hl(T.h)>>>0;if($=L>>>3,L&=7,!(0<=L&&5>=L))throw ye(L,T.j);if(1>$)throw Error("Invalid field number: "+$+" (at position "+T.j+")");return T.l=$,T.i=L,!0}function We(T){switch(T.i){case 0:if(T.i!=0)We(T);else e:{T=T.h;for(var $=T.h,L=$+10,W=T.i;$<L;)if(!(W[$++]&128)){mo(T,$);break e}throw Je()}break;case 1:T=T.h,mo(T,T.h+8);break;case 2:T.i!=2?We(T):($=Hl(T.h)>>>0,T=T.h,mo(T,T.h+$));break;case 5:T=T.h,mo(T,T.h+4);break;case 3:$=T.l;do{if(!re(T))throw Error("Unmatched start-group tag: stream EOF");if(T.i==4){if(T.l!=$)throw Error("Unmatched end-group tag");break}We(T)}while(1);break;default:throw ye(T.i,T.j)}}var Fe=[];function Qe(){this.j=[],this.i=0,this.h=new Ps}function wt(T,$){$.length!==0&&(T.j.push($),T.i+=$.length)}function Bn(T,$){if($=$.R){wt(T,T.h.end());for(var L=0;L<$.length;L++)wt(T,Mi($[L])||mt())}}var sn=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Tn(T,$){return sn?T[sn]|=$:T.A!==void 0?T.A|=$:(Object.defineProperties(T,{A:{value:$,configurable:!0,writable:!0,enumerable:!1}}),$)}function En(T,$){sn?T[sn]&&(T[sn]&=~$):T.A!==void 0&&(T.A&=~$)}function Nn(T){var $;return sn?$=T[sn]:$=T.A,$??0}function tr(T,$){sn?T[sn]=$:T.A!==void 0?T.A=$:Object.defineProperties(T,{A:{value:$,configurable:!0,writable:!0,enumerable:!1}})}function _n(T){return Tn(T,1),T}function hr(T,$){tr($,(T|0)&-51)}function Ds(T,$){tr($,(T|18)&-41)}var xr={};function Zs(T){return T!==null&&typeof T=="object"&&!Array.isArray(T)&&T.constructor===Object}var Ar,Mo=[];tr(Mo,23),Ar=Object.freeze(Mo);function ri(T){if(Nn(T.o)&2)throw Error("Cannot mutate an immutable Message")}function go(T){var $=T.length;($=$?T[$-1]:void 0)&&Zs($)?$.g=1:($={},T.push(($.g=1,$)))}function No(T){var $=T.i+T.G;return T.B||(T.B=T.o[$]={})}function Ni(T,$){return $===-1?null:$>=T.i?T.B?T.B[$]:void 0:T.o[$+T.G]}function yo(T,$,L,W){ri(T),Uh(T,$,L,W)}function Uh(T,$,L,W){T.j&&(T.j=void 0),$>=T.i||W?No(T)[$]=L:(T.o[$+T.G]=L,(T=T.B)&&$ in T&&delete T[$])}function il(T,$,L,W){var ne=Ni(T,$);Array.isArray(ne)||(ne=Ar);var oe=Nn(ne);if(oe&1||_n(ne),W)oe&2||Tn(ne,2),L&1||Object.freeze(ne);else{W=!(L&2);var se=oe&2;L&1||!se?W&&oe&16&&!se&&En(ne,16):(ne=_n(Array.prototype.slice.call(ne)),Uh(T,$,ne))}return ne}function Js(T,$){var L=Ni(T,$),W=L==null?L:typeof L=="number"||L==="NaN"||L==="Infinity"||L==="-Infinity"?Number(L):void 0;return W!=null&&W!==L&&Uh(T,$,W),W}function Uc(T,$,L,W,ne){T.h||(T.h={});var oe=T.h[L],se=il(T,L,3,ne);if(!oe){var Ce=se;oe=[];var Pe=!!(Nn(T.o)&16);se=!!(Nn(Ce)&2);var dt=Ce;!ne&&se&&(Ce=Array.prototype.slice.call(Ce));for(var At=se,fn=0;fn<Ce.length;fn++){var Ut=Ce[fn],Rt=$,an=!1;if(an=an===void 0?!1:an,Ut=Array.isArray(Ut)?new Rt(Ut):an?new Rt:void 0,Ut!==void 0){Rt=Ut.o;var Vn=an=Nn(Rt);se&&(Vn|=2),Pe&&(Vn|=16),Vn!=an&&tr(Rt,Vn),Rt=Vn,At=At||!!(2&Rt),oe.push(Ut)}}return T.h[L]=oe,Pe=Nn(Ce),$=Pe|33,$=At?$&-9:$|8,Pe!=$&&(At=Ce,Object.isFrozen(At)&&(At=Array.prototype.slice.call(At)),tr(At,$),Ce=At),dt!==Ce&&Uh(T,L,Ce),(ne||W&&se)&&Tn(oe,2),W&&Object.freeze(oe),oe}return ne||(ne=Object.isFrozen(oe),W&&!ne?Object.freeze(oe):!W&&ne&&(oe=Array.prototype.slice.call(oe),T.h[L]=oe)),oe}function Aa(T,$,L){var W=!!(Nn(T.o)&2);if($=Uc(T,$,L,W,W),T=il(T,L,3,W),!(W||Nn(T)&8)){for(W=0;W<$.length;W++){if(L=$[W],Nn(L.o)&2){var ne=Gl(L,!1);ne.j=L}else ne=L;L!==ne&&($[W]=ne,T[W]=ne.o)}Tn(T,8)}return $}function $i(T,$,L){if(L!=null&&typeof L!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof L+": "+L);yo(T,$,L)}function Wc(T,$,L,W,ne){ri(T);var oe=Uc(T,L,$,!1,!1);return L=W??new L,T=il(T,$,2,!1),ne!=null?(oe.splice(ne,0,L),T.splice(ne,0,L.o)):(oe.push(L),T.push(L.o)),L.C()&&En(T,8),L}function Qs(T,$){return T??$}function Vi(T,$,L){return L=L===void 0?0:L,Qs(Js(T,$),L)}var Wh;function s0(T){switch(typeof T){case"number":return isFinite(T)?T:String(T);case"object":if(T)if(Array.isArray(T)){if(Nn(T)&128)return T=Array.prototype.slice.call(T),go(T),T}else{if(Te&&T!=null&&T instanceof Uint8Array)return be(T);if(T instanceof Bi){var $=T.V;return $==null?"":typeof $=="string"?$:T.V=be($)}}}return T}function Hh(T,$,L,W){if(T!=null){if(Array.isArray(T))T=eo(T,$,L,W!==void 0);else if(Zs(T)){var ne={},oe;for(oe in T)ne[oe]=Hh(T[oe],$,L,W);T=ne}else T=$(T,W);return T}}function eo(T,$,L,W){var ne=Nn(T);W=W?!!(ne&16):void 0,T=Array.prototype.slice.call(T);for(var oe=0;oe<T.length;oe++)T[oe]=Hh(T[oe],$,L,W);return L(ne,T),T}function Gh(T){return T.ja===xr?T.toJSON():s0(T)}function Kf(T,$){T&128&&go($)}function ju(T,$,L){if(L=L===void 0?Ds:L,T!=null){if(Te&&T instanceof Uint8Array)return T.length?new Bi(new Uint8Array(T),ht):Ai();if(Array.isArray(T)){var W=Nn(T);return W&2?T:$&&!(W&32)&&(W&16||W===0)?(tr(T,W|2),T):(T=eo(T,ju,W&4?Ds:L,!0),$=Nn(T),$&4&&$&2&&Object.freeze(T),T)}return T.ja===xr?jh(T):T}}function Yf(T,$,L,W,ne,oe,se){if(T=T.h&&T.h[L]){if(W=Nn(T),W&2?W=T:(oe=X(T,jh),Ds(W,oe),Object.freeze(oe),W=oe),ri($),se=W==null?Ar:_n([]),W!=null){for(oe=!!W.length,T=0;T<W.length;T++){var Ce=W[T];oe=oe&&!(Nn(Ce.o)&2),se[T]=Ce.o}oe=(oe?8:0)|1,T=Nn(se),(T&oe)!==oe&&(Object.isFrozen(se)&&(se=Array.prototype.slice.call(se)),tr(se,T|oe)),$.h||($.h={}),$.h[L]=W}else $.h&&($.h[L]=void 0);Uh($,L,se,ne)}else yo($,L,ju(W,oe,se),ne)}function jh(T){return Nn(T.o)&2||(T=Gl(T,!0),Tn(T.o,2)),T}function Gl(T,$){var L=T.o,W=[];Tn(W,16);var ne=T.constructor.h;if(ne&&W.push(ne),ne=T.B,ne){W.length=L.length,W.fill(void 0,W.length,L.length);var oe={};W[W.length-1]=oe}Nn(L)&128&&go(W),$=$||T.C()?Ds:hr,oe=T.constructor,Wh=W,W=new oe(W),Wh=void 0,T.R&&(W.R=T.R.slice()),oe=!!(Nn(L)&16);for(var se=ne?L.length-1:L.length,Ce=0;Ce<se;Ce++)Yf(T,W,Ce-T.G,L[Ce],!1,oe,$);if(ne)for(var Pe in ne)Yf(T,W,+Pe,ne[Pe],!0,oe,$);return W}function Zr(T,$,L){T==null&&(T=Wh),Wh=void 0;var W=this.constructor.i||0,ne=0<W,oe=this.constructor.h,se=!1;if(T==null){T=oe?[oe]:[];var Ce=48,Pe=!0;ne&&(W=0,Ce|=128),tr(T,Ce)}else{if(!Array.isArray(T)||oe&&oe!==T[0])throw Error();var dt=Ce=Tn(T,0);if((Pe=(16&dt)!==0)&&((se=(32&dt)!==0)||(dt|=32)),ne){if(128&dt)W=0;else if(0<T.length){var At=T[T.length-1];if(Zs(At)&&"g"in At){W=0,dt|=128,delete At.g;var fn=!0,Ut;for(Ut in At){fn=!1;break}fn&&T.pop()}}}else if(128&dt)throw Error();Ce!==dt&&tr(T,dt)}this.G=(oe?0:-1)-W,this.h=void 0,this.o=T;e:{if(oe=this.o.length,W=oe-1,oe&&(oe=this.o[W],Zs(oe))){this.B=oe,this.i=W-this.G;break e}$!==void 0&&-1<$?(this.i=Math.max($,W+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!ne&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(L){$=Pe&&!se&&!0,ne=this.i;var Rt;for(Pe=0;Pe<L.length;Pe++)se=L[Pe],se<ne?(se+=this.G,(W=T[se])?o0(W,$):T[se]=Ar):(Rt||(Rt=No(this)),(W=Rt[se])?o0(W,$):Rt[se]=Ar)}}Zr.prototype.toJSON=function(){return eo(this.o,Gh,Kf)},Zr.prototype.C=function(){return!!(Nn(this.o)&2)};function o0(T,$){if(Array.isArray(T)){var L=Nn(T),W=1;!$||L&2||(W|=16),(L&W)!==W&&tr(T,L|W)}}Zr.prototype.ja=xr,Zr.prototype.toString=function(){return this.o.toString()};function Zf(T,$,L){if(L){var W={},ne;for(ne in L){var oe=L[ne],se=oe.ra;se||(W.J=oe.xa||oe.oa.W,oe.ia?(W.aa=lt(oe.ia),se=function(Ce){return function(Pe,dt,At){return Ce.J(Pe,dt,At,Ce.aa)}}(W)):oe.ka?(W.Z=Vt(oe.da.P,oe.ka),se=function(Ce){return function(Pe,dt,At){return Ce.J(Pe,dt,At,Ce.Z)}}(W)):se=W.J,oe.ra=se),se($,T,oe.da),W={J:W.J,aa:W.aa,Z:W.Z}}}Bn($,T)}var Hc=Symbol();function qh(T,$,L){return T[Hc]||(T[Hc]=function(W,ne){return $(W,ne,L)})}function a0(T){var $=T[Hc];if(!$){var L=mx(T);$=function(W,ne){return c0(W,ne,L)},T[Hc]=$}return $}function l0(T){var $=T.ia;if($)return a0($);if($=T.wa)return qh(T.da.P,$,T.ka)}function G(T){var $=l0(T),L=T.da,W=T.oa.U;return $?function(ne,oe){return W(ne,oe,L,$)}:function(ne,oe){return W(ne,oe,L)}}function Y(T,$){var L=T[$];return typeof L=="function"&&L.length===0&&(L=L(),T[$]=L),Array.isArray(L)&&(Vp in L||$n in L||0<L.length&&typeof L[0]=="function")?L:void 0}function de(T,$,L,W,ne,oe){$.P=T[0];var se=1;if(T.length>se&&typeof T[se]!="number"){var Ce=T[se++];L($,Ce)}for(;se<T.length;){L=T[se++];for(var Pe=se+1;Pe<T.length&&typeof T[Pe]!="number";)Pe++;switch(Ce=T[se++],Pe-=se,Pe){case 0:W($,L,Ce);break;case 1:(Pe=Y(T,se))?(se++,ne($,L,Ce,Pe)):W($,L,Ce,T[se++]);break;case 2:Pe=se++,Pe=Y(T,Pe),ne($,L,Ce,Pe,T[se++]);break;case 3:oe($,L,Ce,T[se++],T[se++],T[se++]);break;case 4:oe($,L,Ce,T[se++],T[se++],T[se++],T[se++]);break;default:throw Error("unexpected number of binary field arguments: "+Pe)}}return $}var Re=Symbol();function lt(T){var $=T[Re];if(!$){var L=px(T);$=function(W,ne){return ZC(W,ne,L)},T[Re]=$}return $}function Vt(T,$){var L=T[Re];return L||(L=function(W,ne){return Zf(W,ne,$)},T[Re]=L),L}var $n=Symbol();function Ri(T,$){T.push($)}function Ui(T,$,L){T.push($,L.W)}function ds(T,$,L,W){var ne=lt(W),oe=px(W).P,se=L.W;T.push($,function(Ce,Pe,dt){return se(Ce,Pe,dt,oe,ne)})}function Ma(T,$,L,W,ne,oe){var se=Vt(W,oe),Ce=L.W;T.push($,function(Pe,dt,At){return Ce(Pe,dt,At,W,se)})}function px(T){var $=T[$n];return $||($=de(T,T[$n]=[],Ri,Ui,ds,Ma),Vp in T&&$n in T&&(T.length=0),$)}var Vp=Symbol();function YC(T,$){T[0]=$}function j$(T,$,L,W){var ne=L.U;T[$]=W?function(oe,se,Ce){return ne(oe,se,Ce,W)}:ne}function q$(T,$,L,W,ne){var oe=L.U,se=a0(W),Ce=mx(W).P;T[$]=function(Pe,dt,At){return oe(Pe,dt,At,Ce,se,ne)}}function X$(T,$,L,W,ne,oe,se){var Ce=L.U,Pe=qh(W,ne,oe);T[$]=function(dt,At,fn){return Ce(dt,At,fn,W,Pe,se)}}function mx(T){var $=T[Vp];return $||($=de(T,T[Vp]={},YC,j$,q$,X$),Vp in T&&$n in T&&(T.length=0),$)}function c0(T,$,L){for(;re($)&&$.i!=4;){var W=$.l,ne=L[W];if(!ne){var oe=L[0];oe&&(oe=oe[W])&&(ne=L[W]=G(oe))}if(!ne||!ne($,T,W)){ne=$,W=T,oe=ne.j,We(ne);var se=ne;if(!se.ca){if(ne=se.h.h-oe,se.h.h=oe,se=se.h,ne==0)ne=Ai();else{if(oe=Bc(se,ne),se.S&&se.m)ne=se.i.subarray(oe,oe+ne);else{se=se.i;var Ce=oe;ne=oe+ne,ne=Ce===ne?mt():Ue?se.slice(Ce,ne):new Uint8Array(se.subarray(Ce,ne))}ne=ne.length==0?Ai():new Bi(ne,ht)}(oe=W.R)?oe.push(ne):W.R=[ne]}}}return T}function ZC(T,$,L){for(var W=L.length,ne=W%2==1,oe=ne?1:0;oe<W;oe+=2)(0,L[oe+1])($,T,L[oe]);Zf(T,$,ne?L[0]:void 0)}function Up(T,$){return{U:T,W:$}}var sl=Up(function(T,$,L){if(T.i!==5)return!1;T=T.h;var W=T.i,ne=T.h,oe=W[ne],se=W[ne+1],Ce=W[ne+2];return W=W[ne+3],mo(T,T.h+4),se=(oe<<0|se<<8|Ce<<16|W<<24)>>>0,T=2*(se>>31)+1,oe=se>>>23&255,se&=8388607,yo($,L,oe==255?se?NaN:1/0*T:oe==0?T*Math.pow(2,-149)*se:T*Math.pow(2,oe-150)*(se+Math.pow(2,23))),!0},function(T,$,L){if($=Js($,L),$!=null){rl(T.h,8*L+5),T=T.h;var W=+$;W===0?0<1/W?Be=Ve=0:(Ve=0,Be=2147483648):isNaN(W)?(Ve=0,Be=2147483647):(W=(L=0>W?-2147483648:0)?-W:W,34028234663852886e22<W?(Ve=0,Be=(L|2139095040)>>>0):11754943508222875e-54>W?(W=Math.round(W/Math.pow(2,-149)),Ve=0,Be=(L|W)>>>0):($=Math.floor(Math.log(W)/Math.LN2),W*=Math.pow(2,-$),W=Math.round(8388608*W),16777216<=W&&++$,Ve=0,Be=(L|$+127<<23|W&8388607)>>>0)),L=Be,T.h.push(L>>>0&255),T.h.push(L>>>8&255),T.h.push(L>>>16&255),T.h.push(L>>>24&255)}}),K$=Up(function(T,$,L){if(T.i!==0)return!1;var W=T.h,ne=0,oe=T=0,se=W.i,Ce=W.h;do{var Pe=se[Ce++];ne|=(Pe&127)<<oe,oe+=7}while(32>oe&&Pe&128);for(32<oe&&(T|=(Pe&127)>>4),oe=3;32>oe&&Pe&128;oe+=7)Pe=se[Ce++],T|=(Pe&127)<<oe;if(mo(W,Ce),128>Pe)W=ne>>>0,Pe=T>>>0,(T=Pe&2147483648)&&(W=~W+1>>>0,Pe=~Pe>>>0,W==0&&(Pe=Pe+1>>>0)),W=4294967296*Pe+(W>>>0);else throw Je();return yo($,L,T?-W:W),!0},function(T,$,L){$=Ni($,L),$!=null&&(typeof $=="string"&&it($),$!=null&&(rl(T.h,8*L),typeof $=="number"?(T=T.h,ft($),Bh(T,Be,Ve)):(L=it($),Bh(T.h,L.i,L.h))))}),Y$=Up(function(T,$,L){return T.i!==0?!1:(yo($,L,Hl(T.h)),!0)},function(T,$,L){if($=Ni($,L),$!=null&&$!=null)if(rl(T.h,8*L),T=T.h,L=$,0<=L)rl(T,L);else{for($=0;9>$;$++)T.h.push(L&127|128),L>>=7;T.h.push(1)}}),Br=Up(function(T,$,L){if(T.i!==2)return!1;var W=Hl(T.h)>>>0;T=T.h;var ne=Bc(T,W);if(T=T.i,Et){var oe=T,se;(se=rt)||(se=rt=new TextDecoder("utf-8",{fatal:!0})),T=ne+W,oe=ne===0&&T===oe.length?oe:oe.subarray(ne,T);try{var Ce=se.decode(oe)}catch(fn){if(ce===void 0){try{se.decode(new Uint8Array([128]))}catch{}try{se.decode(new Uint8Array([97])),ce=!0}catch{ce=!1}}throw!ce&&(rt=void 0),fn}}else{Ce=ne,W=Ce+W,ne=[];for(var Pe=null,dt,At;Ce<W;)dt=T[Ce++],128>dt?ne.push(dt):224>dt?Ce>=W?It():(At=T[Ce++],194>dt||(At&192)!==128?(Ce--,It()):ne.push((dt&31)<<6|At&63)):240>dt?Ce>=W-1?It():(At=T[Ce++],(At&192)!==128||dt===224&&160>At||dt===237&&160<=At||((oe=T[Ce++])&192)!==128?(Ce--,It()):ne.push((dt&15)<<12|(At&63)<<6|oe&63)):244>=dt?Ce>=W-2?It():(At=T[Ce++],(At&192)!==128||(dt<<28)+(At-144)>>30||((oe=T[Ce++])&192)!==128||((se=T[Ce++])&192)!==128?(Ce--,It()):(dt=(dt&7)<<18|(At&63)<<12|(oe&63)<<6|se&63,dt-=65536,ne.push((dt>>10&1023)+55296,(dt&1023)+56320))):It(),8192<=ne.length&&(Pe=pt(Pe,ne),ne.length=0);Ce=pt(Pe,ne)}return yo($,L,Ce),!0},function(T,$,L){if($=Ni($,L),$!=null){var W=!1;if(W=W===void 0?!1:W,Ht){if(W&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test($))throw Error("Found an unpaired surrogate");$=(yt||(yt=new TextEncoder)).encode($)}else{for(var ne=0,oe=new Uint8Array(3*$.length),se=0;se<$.length;se++){var Ce=$.charCodeAt(se);if(128>Ce)oe[ne++]=Ce;else{if(2048>Ce)oe[ne++]=Ce>>6|192;else{if(55296<=Ce&&57343>=Ce){if(56319>=Ce&&se<$.length){var Pe=$.charCodeAt(++se);if(56320<=Pe&&57343>=Pe){Ce=1024*(Ce-55296)+Pe-56320+65536,oe[ne++]=Ce>>18|240,oe[ne++]=Ce>>12&63|128,oe[ne++]=Ce>>6&63|128,oe[ne++]=Ce&63|128;continue}else se--}if(W)throw Error("Found an unpaired surrogate");Ce=65533}oe[ne++]=Ce>>12|224,oe[ne++]=Ce>>6&63|128}oe[ne++]=Ce&63|128}}$=ne===oe.length?oe:oe.subarray(0,ne)}rl(T.h,8*L+2),rl(T.h,$.length),wt(T,T.h.end()),wt(T,$)}}),Rr=Up(function(T,$,L,W,ne){if(T.i!==2)return!1;$=Wc($,L,W),L=T.h.j,W=Hl(T.h)>>>0;var oe=T.h.h+W,se=oe-L;if(0>=se&&(T.h.j=oe,ne($,T,void 0,void 0,void 0),se=oe-T.h.h),se)throw Error("Message parsing ended unexpectedly. Expected to read "+(W+" bytes, instead read "+(W-se)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return T.h.h=oe,T.h.j=L,!0},function(T,$,L,W,ne){if($=Aa($,W,L),$!=null)for(W=0;W<$.length;W++){var oe=T;rl(oe.h,8*L+2);var se=oe.h.end();wt(oe,se),se.push(oe.i),oe=se,ne($[W],T),se=T;var Ce=oe.pop();for(Ce=se.i+se.h.length()-Ce;127<Ce;)oe.push(Ce&127|128),Ce>>>=7,se.i++;oe.push(Ce),se.i++}});function gx(T){return function($,L){e:{if(Fe.length){var W=Fe.pop();W.setOptions(L),Wl(W.h,$,L),$=W}else $=new Vh($,L);try{var ne=mx(T),oe=c0(new ne.P,$,ne);break e}finally{ne=$.h,ne.i=null,ne.m=!1,ne.l=0,ne.j=0,ne.h=0,ne.S=!1,$.l=-1,$.i=-1,100>Fe.length&&Fe.push($)}oe=void 0}return oe}}function yx(T){return function(){var $=new Qe;ZC(this,$,px(T)),wt($,$.h.end());for(var L=new Uint8Array($.i),W=$.j,ne=W.length,oe=0,se=0;se<ne;se++){var Ce=W[se];L.set(Ce,oe),oe+=Ce.length}return $.j=[L],L}}function Jf(T){Zr.call(this,T)}g(Jf,Zr);var JC=[Jf,1,Y$,2,sl,3,Br,4,Br];Jf.prototype.l=yx(JC);function bx(T){Zr.call(this,T,-1,Z$)}g(bx,Zr),bx.prototype.addClassification=function(T,$){return Wc(this,1,Jf,T,$),this};var Z$=[1],QC=gx([bx,1,Rr,JC]);function Wp(T){Zr.call(this,T)}g(Wp,Zr);var ps=[Wp,1,sl,2,sl,3,sl,4,sl,5,sl];Wp.prototype.l=yx(ps);function u0(T){Zr.call(this,T,-1,Xh)}g(u0,Zr);var Xh=[1],ek=gx([u0,1,Rr,ps]);function Qf(T){Zr.call(this,T)}g(Qf,Zr);var oa=[Qf,1,sl,2,sl,3,sl,4,sl,5,sl,6,K$],tk=gx(oa);Qf.prototype.l=yx(oa);function vx(T,$,L){if(L=T.createShader(L===0?T.VERTEX_SHADER:T.FRAGMENT_SHADER),T.shaderSource(L,$),T.compileShader(L),!T.getShaderParameter(L,T.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+T.getShaderInfoLog(L));return L}function nk(T){return Aa(T,Jf,1).map(function($){var L=Ni($,1);return{index:L??0,qa:Vi($,2),label:Ni($,3)!=null?Qs(Ni($,3),""):void 0,displayName:Ni($,4)!=null?Qs(Ni($,4),""):void 0}})}function rk(T){return{x:Vi(T,1),y:Vi(T,2),z:Vi(T,3),visibility:Js(T,4)!=null?Vi(T,4):void 0}}function h0(T){return Aa(ek(T),Wp,1).map(rk)}function f0(T,$){this.i=T,this.h=$,this.m=0}function $o(T,$,L){return J$(T,$),typeof T.h.canvas.transferToImageBitmap=="function"?Promise.resolve(T.h.canvas.transferToImageBitmap()):L?Promise.resolve(T.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(T.h.canvas):(T.j===void 0&&(T.j=document.createElement("canvas")),new Promise(function(W){T.j.height=T.h.canvas.height,T.j.width=T.h.canvas.width,T.j.getContext("2d",{}).drawImage(T.h.canvas,0,0,T.h.canvas.width,T.h.canvas.height),W(T.j)}))}function J$(T,$){var L=T.h;if(T.s===void 0){var W=vx(L,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),ne=vx(L,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),oe=L.createProgram();if(L.attachShader(oe,W),L.attachShader(oe,ne),L.linkProgram(oe),!L.getProgramParameter(oe,L.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+L.getProgramInfoLog(oe));W=T.s=oe,L.useProgram(W),ne=L.getUniformLocation(W,"sampler0"),T.l={O:L.getAttribLocation(W,"aVertex"),N:L.getAttribLocation(W,"aTex"),ya:ne},T.v=L.createBuffer(),L.bindBuffer(L.ARRAY_BUFFER,T.v),L.enableVertexAttribArray(T.l.O),L.vertexAttribPointer(T.l.O,2,L.FLOAT,!1,0,0),L.bufferData(L.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),L.STATIC_DRAW),L.bindBuffer(L.ARRAY_BUFFER,null),T.u=L.createBuffer(),L.bindBuffer(L.ARRAY_BUFFER,T.u),L.enableVertexAttribArray(T.l.N),L.vertexAttribPointer(T.l.N,2,L.FLOAT,!1,0,0),L.bufferData(L.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),L.STATIC_DRAW),L.bindBuffer(L.ARRAY_BUFFER,null),L.uniform1i(ne,0)}W=T.l,L.useProgram(T.s),L.canvas.width=$.width,L.canvas.height=$.height,L.viewport(0,0,$.width,$.height),L.activeTexture(L.TEXTURE0),T.i.bindTexture2d($.glName),L.enableVertexAttribArray(W.O),L.bindBuffer(L.ARRAY_BUFFER,T.v),L.vertexAttribPointer(W.O,2,L.FLOAT,!1,0,0),L.enableVertexAttribArray(W.N),L.bindBuffer(L.ARRAY_BUFFER,T.u),L.vertexAttribPointer(W.N,2,L.FLOAT,!1,0,0),L.bindFramebuffer(L.DRAW_FRAMEBUFFER?L.DRAW_FRAMEBUFFER:L.FRAMEBUFFER,null),L.clearColor(0,0,0,0),L.clear(L.COLOR_BUFFER_BIT),L.colorMask(!0,!0,!0,!0),L.drawArrays(L.TRIANGLE_FAN,0,4),L.disableVertexAttribArray(W.O),L.disableVertexAttribArray(W.N),L.bindBuffer(L.ARRAY_BUFFER,null),T.i.bindTexture2d(0)}function Na(T){this.h=T}var Q$=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function ik(T,$){return $+T}function Gc(T,$){window[T]=$}function d0(T){var $=document.createElement("script");return $.setAttribute("src",T),$.setAttribute("crossorigin","anonymous"),new Promise(function(L){$.addEventListener("load",function(){L()},!1),$.addEventListener("error",function(){L()},!1),document.body.appendChild($)})}function wx(){return N(function(T){switch(T.h){case 1:return T.s=2,w(T,WebAssembly.instantiate(Q$),4);case 4:T.h=3,T.s=0;break;case 2:return T.s=0,T.l=null,T.return(!1);case 3:return T.return(!0)}})}function Vr(T){if(this.h=T,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=T&&T.locateFile||ik,typeof window=="object")var $=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")$=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=$,T.options){$=a(Object.keys(T.options));for(var L=$.next();!L.done;L=$.next()){L=L.value;var W=T.options[L].default;W!==void 0&&(this.l[L]=typeof W=="function"?W():W)}}}n=Vr.prototype,n.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function qu(T){var $,L,W,ne,oe,se,Ce,Pe,dt,At,fn;return N(function(Ut){switch(Ut.h){case 1:return T.ga?($=T.h.files===void 0?[]:typeof T.h.files=="function"?T.h.files(T.l):T.h.files,w(Ut,wx(),2)):Ut.return();case 2:if(L=Ut.i,typeof window=="object")return Gc("createMediapipeSolutionsWasm",{locateFile:T.locateFile}),Gc("createMediapipeSolutionsPackedAssets",{locateFile:T.locateFile}),se=$.filter(function(Rt){return Rt.data!==void 0}),Ce=$.filter(function(Rt){return Rt.data===void 0}),Pe=Promise.all(se.map(function(Rt){var an=ed(T,Rt.url);if(Rt.path!==void 0){var Vn=Rt.path;an=an.then(function(Ur){return T.overrideFile(Vn,Ur),Promise.resolve(Ur)})}return an})),dt=Promise.all(Ce.map(function(Rt){return Rt.simd===void 0||Rt.simd&&L||!Rt.simd&&!L?d0(T.locateFile(Rt.url,T.ha)):Promise.resolve()})).then(function(){var Rt,an,Vn;return N(function(Ur){if(Ur.h==1)return Rt=window.createMediapipeSolutionsWasm,an=window.createMediapipeSolutionsPackedAssets,Vn=T,w(Ur,Rt(an),2);Vn.i=Ur.i,Ur.h=0})}),At=function(){return N(function(Rt){return T.h.graph&&T.h.graph.url?Rt=w(Rt,ed(T,T.h.graph.url),0):(Rt.h=0,Rt=void 0),Rt})}(),w(Ut,Promise.all([dt,Pe,At]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return W=$.filter(function(Rt){return Rt.simd===void 0||Rt.simd&&L||!Rt.simd&&!L}).map(function(Rt){return T.locateFile(Rt.url,T.ha)}),importScripts.apply(null,l(W)),ne=T,w(Ut,createMediapipeSolutionsWasm(Module),6);case 6:ne.i=Ut.i,T.m=new OffscreenCanvas(1,1),T.i.canvas=T.m,oe=T.i.GL.createContext(T.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),T.i.GL.makeContextCurrent(oe),Ut.h=4;break;case 7:if(T.m=document.createElement("canvas"),fn=T.m.getContext("webgl2",{}),!fn&&(fn=T.m.getContext("webgl",{}),!fn))return alert("Failed to create WebGL canvas context when passing video frame."),Ut.return();T.K=fn,T.i.canvas=T.m,T.i.createContext(T.m,!0,!0,{});case 4:T.j=new T.i.SolutionWasm,T.ga=!1,Ut.h=0}})}function xx(T){var $,L,W,ne,oe,se,Ce,Pe;return N(function(dt){if(dt.h==1){if(T.h.graph&&T.h.graph.url&&T.fa===T.h.graph.url)return dt.return();if(T.u=!0,!T.h.graph||!T.h.graph.url){dt.h=2;return}return T.fa=T.h.graph.url,w(dt,ed(T,T.h.graph.url),3)}for(dt.h!=2&&($=dt.i,T.j.loadGraph($)),L=a(Object.keys(T.D)),W=L.next();!W.done;W=L.next())ne=W.value,T.j.overrideFile(ne,T.D[ne]);if(T.D={},T.h.listeners)for(oe=a(T.h.listeners),se=oe.next();!se.done;se=oe.next())Ce=se.value,rR(T,Ce);Pe=T.l,T.l={},T.setOptions(Pe),dt.h=0})}n.reset=function(){var T=this;return N(function($){T.j&&(T.j.reset(),T.s={},T.v={}),$.h=0})},n.setOptions=function(T,$){var L=this;if($=$||this.h.options){for(var W=[],ne=[],oe={},se=a(Object.keys(T)),Ce=se.next();!Ce.done;oe={X:oe.X,Y:oe.Y},Ce=se.next())if(Ce=Ce.value,!(Ce in this.l&&this.l[Ce]===T[Ce])){this.l[Ce]=T[Ce];var Pe=$[Ce];Pe!==void 0&&(Pe.onChange&&(oe.X=Pe.onChange,oe.Y=T[Ce],W.push(function(dt){return function(){var At;return N(function(fn){if(fn.h==1)return w(fn,dt.X(dt.Y),2);At=fn.i,At===!0&&(L.u=!0),fn.h=0})}}(oe))),Pe.graphOptionXref&&(Ce=Object.assign({},{calculatorName:"",calculatorIndex:0},Pe.graphOptionXref,{valueNumber:Pe.type===1?T[Ce]:0,valueBoolean:Pe.type===0?T[Ce]:!1,valueString:Pe.type===2?T[Ce]:""}),ne.push(Ce)))}(W.length!==0||ne.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(ne),this.F=(this.F===void 0?[]:this.F).concat(W))}};function eR(T){var $,L,W,ne,oe,se,Ce;return N(function(Pe){switch(Pe.h){case 1:if(!T.u)return Pe.return();if(!T.F){Pe.h=2;break}$=a(T.F),L=$.next();case 3:if(L.done){Pe.h=5;break}return W=L.value,w(Pe,W(),4);case 4:L=$.next(),Pe.h=3;break;case 5:T.F=void 0;case 2:if(T.H){for(ne=new T.i.GraphOptionChangeRequestList,oe=a(T.H),se=oe.next();!se.done;se=oe.next())Ce=se.value,ne.push_back(Ce);T.j.changeOptions(ne),ne.delete(),T.H=void 0}T.u=!1,Pe.h=0}})}n.initialize=function(){var T=this;return N(function($){return $.h==1?w($,qu(T),2):$.h!=3?w($,xx(T),3):w($,eR(T),0)})};function ed(T,$){var L,W;return N(function(ne){return $ in T.L?ne.return(T.L[$]):(L=T.locateFile($,""),W=fetch(L).then(function(oe){return oe.arrayBuffer()}),T.L[$]=W,ne.return(W))})}n.overrideFile=function(T,$){this.j?this.j.overrideFile(T,$):this.D[T]=$},n.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},n.send=function(T,$){var L=this,W,ne,oe,se,Ce,Pe,dt,At,fn;return N(function(Ut){switch(Ut.h){case 1:return L.h.inputs?(W=1e3*($??performance.now()),w(Ut,L.I,2)):Ut.return();case 2:return w(Ut,L.initialize(),3);case 3:for(ne=new L.i.PacketDataList,oe=a(Object.keys(T)),se=oe.next();!se.done;se=oe.next())if(Ce=se.value,Pe=L.h.inputs[Ce]){e:{var Rt=T[Ce];switch(Pe.type){case"video":var an=L.s[Pe.stream];if(an||(an=new f0(L.i,L.K),L.s[Pe.stream]=an),an.m===0&&(an.m=an.i.createTexture()),typeof HTMLVideoElement<"u"&&Rt instanceof HTMLVideoElement)var Vn=Rt.videoWidth,Ur=Rt.videoHeight;else typeof HTMLImageElement<"u"&&Rt instanceof HTMLImageElement?(Vn=Rt.naturalWidth,Ur=Rt.naturalHeight):(Vn=Rt.width,Ur=Rt.height);Ur={glName:an.m,width:Vn,height:Ur},Vn=an.h,Vn.canvas.width=Ur.width,Vn.canvas.height=Ur.height,Vn.activeTexture(Vn.TEXTURE0),an.i.bindTexture2d(an.m),Vn.texImage2D(Vn.TEXTURE_2D,0,Vn.RGBA,Vn.RGBA,Vn.UNSIGNED_BYTE,Rt),an.i.bindTexture2d(0),an=Ur;break e;case"detections":for(an=L.s[Pe.stream],an||(an=new Na(L.i),L.s[Pe.stream]=an),an.data||(an.data=new an.h.DetectionListData),an.data.reset(Rt.length),Ur=0;Ur<Rt.length;++Ur){Vn=Rt[Ur];var Wr=an.data,Os=Wr.setBoundingBox,$a=Ur,Ro=Vn.la,yr=new Qf;if($i(yr,1,Ro.sa),$i(yr,2,Ro.ta),$i(yr,3,Ro.height),$i(yr,4,Ro.width),$i(yr,5,Ro.rotation),yo(yr,6,Ro.pa),Ro=yr.l(),Os.call(Wr,$a,Ro),Vn.ea)for(Wr=0;Wr<Vn.ea.length;++Wr){yr=Vn.ea[Wr],Os=an.data,$a=Os.addNormalizedLandmark,Ro=Ur,yr=Object.assign({},yr,{visibility:yr.visibility?yr.visibility:0});var xi=new Wp;$i(xi,1,yr.x),$i(xi,2,yr.y),$i(xi,3,yr.z),yr.visibility&&$i(xi,4,yr.visibility),yr=xi.l(),$a.call(Os,Ro,yr)}if(Vn.ba)for(Wr=0;Wr<Vn.ba.length;++Wr)Os=an.data,$a=Os.addClassification,Ro=Ur,yr=Vn.ba[Wr],xi=new Jf,$i(xi,2,yr.qa),yr.index&&yo(xi,1,yr.index),yr.label&&yo(xi,3,yr.label),yr.displayName&&yo(xi,4,yr.displayName),yr=xi.l(),$a.call(Os,Ro,yr)}an=an.data;break e;default:an={}}}switch(dt=an,At=Pe.stream,Pe.type){case"video":ne.pushTexture2d(Object.assign({},dt,{stream:At,timestamp:W}));break;case"detections":fn=dt,fn.stream=At,fn.timestamp=W,ne.pushDetectionList(fn);break;default:throw Error("Unknown input config type: '"+Pe.type+"'")}}return L.j.send(ne),w(Ut,L.I,4);case 4:ne.delete(),Ut.h=0}})};function tR(T,$,L){var W,ne,oe,se,Ce,Pe,dt,At,fn,Ut,Rt,an,Vn,Ur;return N(function(Wr){switch(Wr.h){case 1:if(!L)return Wr.return($);for(W={},ne=0,oe=a(Object.keys(L)),se=oe.next();!se.done;se=oe.next())Ce=se.value,Pe=L[Ce],typeof Pe!="string"&&Pe.type==="texture"&&$[Pe.stream]!==void 0&&++ne;1<ne&&(T.M=!1),dt=a(Object.keys(L)),se=dt.next();case 2:if(se.done){Wr.h=4;break}if(At=se.value,fn=L[At],typeof fn=="string")return Vn=W,Ur=At,w(Wr,nR(T,At,$[fn]),14);if(Ut=$[fn.stream],fn.type==="detection_list"){if(Ut){for(var Os=Ut.getRectList(),$a=Ut.getLandmarksList(),Ro=Ut.getClassificationsList(),yr=[],xi=0;xi<Os.size();++xi){var Xu=tk(Os.get(xi)),iR=Vi(Xu,1),Sx=Vi(Xu,2),sk=Vi(Xu,3),Ku=Vi(Xu,4),p0=Vi(Xu,5,0),m0=void 0;m0=m0===void 0?0:m0,Xu={la:{sa:iR,ta:Sx,height:sk,width:Ku,rotation:p0,pa:Qs(Ni(Xu,6),m0)},ea:h0($a.get(xi)),ba:nk(QC(Ro.get(xi)))},yr.push(Xu)}Os=yr}else Os=[];W[At]=Os,Wr.h=7;break}if(fn.type==="proto_list"){if(Ut){for(Os=Array(Ut.size()),$a=0;$a<Ut.size();$a++)Os[$a]=Ut.get($a);Ut.delete()}else Os=[];W[At]=Os,Wr.h=7;break}if(Ut===void 0){Wr.h=3;break}if(fn.type==="float_list"){W[At]=Ut,Wr.h=7;break}if(fn.type==="proto"){W[At]=Ut,Wr.h=7;break}if(fn.type!=="texture")throw Error("Unknown output config type: '"+fn.type+"'");return Rt=T.v[At],Rt||(Rt=new f0(T.i,T.K),T.v[At]=Rt),w(Wr,$o(Rt,Ut,T.M),13);case 13:an=Wr.i,W[At]=an;case 7:fn.transform&&W[At]&&(W[At]=fn.transform(W[At])),Wr.h=3;break;case 14:Vn[Ur]=Wr.i;case 3:se=dt.next(),Wr.h=2;break;case 4:return Wr.return(W)}})}function nR(T,$,L){var W;return N(function(ne){return typeof L=="number"||L instanceof Uint8Array||L instanceof T.i.Uint8BlobList?ne.return(L):L instanceof T.i.Texture2dDataOut?(W=T.v[$],W||(W=new f0(T.i,T.K),T.v[$]=W),ne.return($o(W,L,T.M))):ne.return(void 0)})}function rR(T,$){for(var L=$.name||"$",W=[].concat(l($.wants)),ne=new T.i.StringList,oe=a($.wants),se=oe.next();!se.done;se=oe.next())ne.push_back(se.value);oe=T.i.PacketListener.implement({onResults:function(Ce){for(var Pe={},dt=0;dt<$.wants.length;++dt)Pe[W[dt]]=Ce.get(dt);var At=T.listeners[L];At&&(T.I=tR(T,Pe,$.outs).then(function(fn){fn=At(fn);for(var Ut=0;Ut<$.wants.length;++Ut){var Rt=Pe[W[Ut]];typeof Rt=="object"&&Rt.hasOwnProperty&&Rt.hasOwnProperty("delete")&&Rt.delete()}fn&&(T.I=fn)}))}}),T.j.attachMultiListener(ne,oe),ne.delete()}n.onResults=function(T,$){this.listeners[$||"$"]=T},z("Solution",Vr),z("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function _x(T){switch(T===void 0&&(T=0),T){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function Hp(T){var $=this;T=T||{},this.h=new Vr({locateFile:T.locateFile,files:function(L){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:_x(L.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:h0},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:h0},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(L){var W,ne,oe;return N(function(se){return se.h==1?(W=_x(L),ne="third_party/mediapipe/modules/pose_landmark/"+W,w(se,ed($.h,W),2)):(oe=se.i,$.h.overrideFile(ne,oe),se.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=Hp.prototype,n.reset=function(){this.h.reset()},n.close=function(){return this.h.close(),Promise.resolve()},n.onResults=function(T){this.h.onResults(T)},n.initialize=function(){var T=this;return N(function($){return w($,T.h.initialize(),0)})},n.send=function(T,$){var L=this;return N(function(W){return w(W,L.h.send(T,$),0)})},n.setOptions=function(T){this.h.setOptions(T)},z("Pose",Hp),z("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),z("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),z("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),z("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),z("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),z("VERSION","0.5.1675469404")}).call(gt);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var Qse=function(n,e){return(Qse=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(t[i]=r[i])})(n,e)};function eoe(n,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function t(){this.constructor=n}Qse(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var qr=function(){return(qr=Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++)for(var i in e=arguments[t])Object.prototype.hasOwnProperty.call(e,i)&&(n[i]=e[i]);return n}).apply(this,arguments)};function lr(n,e,t,r){return new(t||(t=Promise))(function(i,s){function o(c){try{l(r.next(c))}catch(u){s(u)}}function a(c){try{l(r.throw(c))}catch(u){s(u)}}function l(c){var u;c.done?i(c.value):(u=c.value,u instanceof t?u:new t(function(h){h(u)})).then(o,a)}l((r=r.apply(n,e||[])).next())})}function cr(n,e){var t,r,i,s,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function a(l){return function(c){return function(u){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,r&&(i=2&u[0]?r.return:u[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,u[1])).done)return i;switch(r=0,i&&(u=[2&u[0],i.value]),u[0]){case 0:case 1:i=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,r=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(i=o.trys,!((i=i.length>0&&i[i.length-1])||u[0]!==6&&u[0]!==2)){o=0;continue}if(u[0]===3&&(!i||u[1]>i[0]&&u[1]<i[3])){o.label=u[1];break}if(u[0]===6&&o.label<i[1]){o.label=i[1],i=u;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(u);break}i[2]&&o.ops.pop(),o.trys.pop();continue}u=e.call(n,o)}catch(h){u=[6,h],r=0}finally{t=i=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([l,c])}}}function Bm(n,e,t){if(t||arguments.length===2)for(var r,i=0,s=e.length;i<s;i++)!r&&i in e||(r||(r=Array.prototype.slice.call(e,0,i)),r[i]=e[i]);return n.concat(r||Array.prototype.slice.call(e))}var Th=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],tS=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],kht={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},Tht={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},Eht=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],Iht=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function wA(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function toe(n){return lr(this,void 0,void 0,function(){var e,t;return cr(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),n instanceof jn?[4,rC(n,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=wA(n.width),e.height=wA(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),r.label=3;case 3:return[2,e]}})})}function noe(n){return lr(this,void 0,void 0,function(){var e,t,r,i,s,o;return cr(this,function(a){switch(a.label){case 0:return n instanceof jn?(e=n.shape.slice(0,2),t=e[0],r=e[1],i=ImageData.bind,[4,rC(n)]):[3,2];case 1:return[2,new(i.apply(ImageData,[void 0,a.sent(),r,t]))];case 2:return s=document.createElement("canvas"),o=s.getContext("2d"),s.width=wA(n.width),s.height=wA(n.height),o.drawImage(n,0,0),[2,o.getImageData(0,0,s.width,s.height)]}})})}function Aht(n){return lr(this,void 0,void 0,function(){var e,t;return cr(this,function(r){switch(r.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,toe(n)]:[3,2];case 1:return t=r.sent(),[3,3];case 2:t=n,r.label=3;case 3:return e=t,[2,iC(e,4)]}})})}function roe(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(n));if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got ".concat(n))}var Zx={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},Mht=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return lr(this,void 0,void 0,function(){return cr(this,function(e){return[2,this.mask]})})},n.prototype.toImageData=function(){return lr(this,void 0,void 0,function(){return cr(this,function(e){return[2,noe(this.mask)]})})},n.prototype.toTensor=function(){return lr(this,void 0,void 0,function(){return cr(this,function(e){return[2,Aht(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function Nht(n){return roe(n),"person"}var $ht=function(){function n(e){var t,r=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new Cht.Pose({locateFile:function(i,s){if(e.solutionPath){var o=e.solutionPath.replace(/\/+$/,"");return"".concat(o,"/").concat(i)}return"".concat(s,"/").concat(i)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(i){if(r.height=i.image.height,r.width=i.image.width,i.poseLandmarks==null)r.poses=[];else{var s=r.translateOutput(i.poseLandmarks,i.poseWorldLandmarks);i.segmentationMask&&(s.segmentation={maskValueToLabel:Nht,mask:new Mht(i.segmentationMask)}),r.poses=[s]}})}return n.prototype.translateOutput=function(e,t){var r=this,i={keypoints:e.map(function(s,o){return{x:s.x*r.width,y:s.y*r.height,z:s.z,score:s.visibility,name:tS[o]}})};return t!=null&&(i.keypoints3D=t.map(function(s,o){return{x:s.x,y:s.y,z:s.z,score:s.visibility,name:tS[o]}})),i},n.prototype.estimatePoses=function(e,t,r){return lr(this,void 0,void 0,function(){var i,s;return cr(this,function(o){switch(o.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof jn?(s=ImageData.bind,[4,rC(e)]):[3,2];case 1:return i=new(s.apply(ImageData,[void 0,o.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:i=e,o.label=3;case 3:return e=i,[4,this.poseSolution.send({image:e},r)];case 4:return o.sent(),[2,this.poses]}})})},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n}();function Rht(n){return lr(this,void 0,void 0,function(){var e,t;return cr(this,function(r){switch(r.label){case 0:return e=function(i){if(i==null)return qr({},Zx);var s=qr({},i);return s.runtime="mediapipe",s.enableSegmentation==null&&(s.enableSegmentation=Zx.enableSegmentation),s.enableSmoothing==null&&(s.enableSmoothing=Zx.enableSmoothing),s.smoothSegmentation==null&&(s.smoothSegmentation=Zx.smoothSegmentation),s.modelType==null&&(s.modelType=Zx.modelType),s}(n),[4,(t=new $ht(e)).initialize()];case 1:return r.sent(),[2,t]}})})}function hv(n){return n instanceof jn?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function ioe(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function B4(n){return n instanceof jn?n:iC(n)}function soe(n,e,t){return dF(t,"inputResolution"),[1/t.width*n[0][0]*e.width,1/t.height*n[0][1]*e.width,n[0][3]*e.width,1/t.width*n[1][0]*e.height,1/t.height*n[1][1]*e.height,n[1][3]*e.height,0,0]}function dF(n,e){U(n.width!==0,function(){return"".concat(e," width cannot be 0.")}),U(n.height!==0,function(){return"".concat(e," height cannot be 0.")})}function X3(n,e,t){var r=t.rotationVectorStartKeypointIndex,i=t.rotationVectorEndKeypointIndex,s=n.locationData,o=s.relativeKeypoints[r].x*e.width,a=s.relativeKeypoints[r].y*e.height,l=s.relativeKeypoints[i].x*e.width,c=s.relativeKeypoints[i].y*e.height,u=2*Math.sqrt((l-o)*(l-o)+(c-a)*(c-a)),h=function(f,d,p){var m,g=f.locationData,y=p.rotationVectorStartKeypointIndex,b=p.rotationVectorEndKeypointIndex;m=p.rotationVectorTargetAngle?p.rotationVectorTargetAngle:Math.PI*p.rotationVectorTargetAngleDegree/180;var _=g.relativeKeypoints[y].x*d.width,w=g.relativeKeypoints[y].y*d.height,S=g.relativeKeypoints[b].x*d.width,C=g.relativeKeypoints[b].y*d.height;return ioe(m-Math.atan2(-(C-w),S-_))}(n,e,t);return{xCenter:o/e.width,yCenter:a/e.height,width:u/e.width,height:u/e.height,rotation:h}}function ooe(n){if(n.length!==16)throw new Error("Array length must be 16 but got ".concat(n.length));return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function K3(n,e,t,r,i,s,o){return n[e][i]*(n[t][s]*n[r][o]-n[t][o]*n[r][s])}function Oo(n,e,t){var r=(e+1)%4,i=(e+2)%4,s=(e+3)%4,o=(t+1)%4,a=(t+2)%4,l=(t+3)%4;return K3(n,r,i,s,o,a,l)+K3(n,i,s,r,o,a,l)+K3(n,s,r,i,o,a,l)}function vj(n,e,t){t===void 0&&(t={ignoreRotation:!1});for(var r=[],i=0,s=n;i<s.length;i++){var o=s[i],a=o.x-.5,l=o.y-.5,c=t.ignoreRotation?0:e.rotation,u=Math.cos(c)*a-Math.sin(c)*l,h=Math.sin(c)*a+Math.cos(c)*l;u=u*e.width+e.xCenter,h=h*e.height+e.yCenter;var f=o.z*e.width,d=qr({},o);d.x=u,d.y=h,d.z=f,r.push(d)}return r}function aoe(n,e){var t=function(r,i,s,o){var a=i-r,l=o-s;if(a===0)throw new Error("Original min and max are both ".concat(r,", range cannot be 0."));var c=l/a;return{scale:c,offset:s-r*c}}(0,255,e[0],e[1]);return Se(function(){return Xe(fe(n,t.scale),t.offset)})}function pF(n,e,t){var r,i,s,o,a,l,c,u,h,f,d,p,m,g,y=e.outputTensorSize,b=e.keepAspectRatio,_=e.borderMode,w=e.outputTensorFloatRange,S=hv(n),C=function(M,E){return E?{xCenter:E.xCenter*M.width,yCenter:E.yCenter*M.height,width:E.width*M.width,height:E.height*M.height,rotation:E.rotation}:{xCenter:.5*M.width,yCenter:.5*M.height,width:M.width,height:M.height,rotation:0}}(S,t),k=function(M,E,N){if(N===void 0&&(N=!1),!N)return{top:0,left:0,right:0,bottom:0};var O=E.height,R=E.width;dF(E,"targetSize"),dF(M,"roi");var D,z,B=O/R,X=M.height/M.width,H=0,te=0;return B>X?(D=M.width,z=M.width*B,te=(1-X/B)/2):(D=M.height/B,z=M.height,H=(1-B/X)/2),M.width=D,M.height=z,{top:te,left:H,right:H,bottom:te}}(C,y,b),A=(r=C,i=S.width,s=S.height,o=!1,a=r.width,l=r.height,c=o?-1:1,u=Math.cos(r.rotation),h=Math.sin(r.rotation),f=r.xCenter,d=r.yCenter,p=1/i,m=1/s,(g=new Array(16))[0]=a*u*c*p,g[1]=-l*h*p,g[2]=0,g[3]=(-.5*a*u*c+.5*l*h+f)*p,g[4]=a*h*c*m,g[5]=l*u*m,g[6]=0,g[7]=(-.5*l*u-.5*a*h*c+d)*m,g[8]=0,g[9]=0,g[10]=a*p,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,ooe(g));return{imageTensor:Se(function(){var M=B4(n),E=ja(soe(A,S,y),[1,8]),N=_==="zero"?"constant":"nearest",O=Ss.transform(ss(St(M,"float32")),E,"bilinear",N,0,[y.height,y.width]);return w!=null?aoe(O,w):O}),padding:k,transformationMatrix:A}}function wj(n,e,t,r){return r===1?.5*(n+e):n+(e-n)*t/(r-1)}function Pht(n){return Se(function(){var e=function(i){return Se(function(){return[pn(i,[0,0,0],[1,-1,1]),pn(i,[0,0,1],[1,-1,-1])]})}(n),t=e[0],r=e[1];return{boxes:br(r),logits:br(t)}})}function loe(n){return n!=null&&n.currentTime!=null}function xj(n){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,i=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,o=0;o<n.length;++o){var a=n[o];t=Math.min(t,a.x),r=Math.max(r,a.x),i=Math.min(i,a.y),s=Math.max(s,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:i,xMax:r,yMax:s,width:r-t,height:s-i},e}function Dht(n,e,t,r){return lr(this,void 0,void 0,function(){var i,s,o,a,l;return cr(this,function(c){switch(c.label){case 0:return n.sort(function(u,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,u.score)}),i=ja(n.map(function(u){return[u.locationData.relativeBoundingBox.yMin,u.locationData.relativeBoundingBox.xMin,u.locationData.relativeBoundingBox.yMax,u.locationData.relativeBoundingBox.xMax]})),s=Xi(n.map(function(u){return u.score[0]})),[4,Ss.nonMaxSuppressionAsync(i,s,e,t)];case 1:return[4,(o=c.sent()).array()];case 2:return a=c.sent(),l=n.filter(function(u,h){return a.indexOf(h)>-1}),nn([i,s,o]),[2,l]}})})}function coe(n,e){return n.map(function(t){var r=qr(qr({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(r.z=t.z*e.width),r})}function Oht(n,e,t){return lr(this,void 0,void 0,function(){var r,i,s,o,a,l,c,u,h,f,d,p,m,g,y,b,_,w,S,C,k,A,M,E;return cr(this,function(N){switch(N.label){case 0:if(r=br(e,[0]),i=r.shape,s=i[0],o=i[1],a=i[2],n.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(n.length,", heatmap length: ").concat(a));return l=[],[4,r.buffer()];case 1:for(c=N.sent(),u=0;u<n.length;u++)if(h=n[u],f=qr({},h),l.push(f),d=Math.trunc(f.x*o),p=Math.trunc(f.y*s),!(d<0||d>=o||p<0||d>=s)){for(m=Math.trunc((t.kernelSize-1)/2),g=Math.max(0,d-m),y=Math.min(o,d+m+1),b=Math.max(0,p-m),_=Math.min(s,p+m+1),w=0,S=0,C=0,k=0,A=b;A<_;++A)for(M=g;M<y;++M)E=c.get(A,M,u),w+=E,k=Math.max(k,E),S+=M*E,C+=A*E;k>=t.minConfidenceToRefine&&w>0&&(f.x=S/o/w,f.y=C/s/w)}return r.dispose(),[2,l]}})})}function _j(n,e){var t=e.left,r=e.top,i=e.left+e.right,s=e.top+e.bottom;return n.map(function(o){return qr(qr({},o),{x:(o.x-t)/(1-i),y:(o.y-r)/(1-s),z:o.z/(1-i)})})}function Fht(n,e,t){return v_()==="webgl"?function(r,i,s){var o=s.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:r.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(o,`);

      setOutput(outputValue);
    }
`)},l=rg();return Se(function(){var c=l.compileAndRun(a,[r,i]);return wo().makeTensorFromDataId(c.dataId,c.shape,c.dtype)})}(n,e,t):Se(function(){var r=Dt(e,.5),i=Or(r),s=Dt(1,rp(1,fe(i,Xe(5.68842,fe(i,Xe(-.748699,fe(i,Xe(-57.8051,fe(i,Xe(291.309,fe(i,-624.717)))))))))));return Xe(e,fe(Dt(n,e),fe(s,t.combineWithPreviousRatio)))})}function Lht(n,e,t){return lr(this,void 0,void 0,function(){var r,i,s,o,a;return cr(this,function(l){switch(l.label){case 0:return r=n[0],i=n[1],s=function(c,u,h){return Se(function(){var f,d,p,m;h.reverseOutputOrder?(d=br(pn(c,[0,h.boxCoordOffset+0],[-1,1])),f=br(pn(c,[0,h.boxCoordOffset+1],[-1,1])),m=br(pn(c,[0,h.boxCoordOffset+2],[-1,1])),p=br(pn(c,[0,h.boxCoordOffset+3],[-1,1]))):(f=br(pn(c,[0,h.boxCoordOffset+0],[-1,1])),d=br(pn(c,[0,h.boxCoordOffset+1],[-1,1])),p=br(pn(c,[0,h.boxCoordOffset+2],[-1,1])),m=br(pn(c,[0,h.boxCoordOffset+3],[-1,1]))),d=Xe(fe(Lt(d,h.xScale),u.w),u.x),f=Xe(fe(Lt(f,h.yScale),u.h),u.y),h.applyExponentialOnBoxSize?(p=fe(Jo(Lt(p,h.hScale)),u.h),m=fe(Jo(Lt(m,h.wScale)),u.w)):(p=fe(Lt(p,h.hScale),u.h),m=fe(Lt(m,h.wScale),u.h));var g=Dt(f,Lt(p,2)),y=Dt(d,Lt(m,2)),b=Xe(f,Lt(p,2)),_=Xe(d,Lt(m,2)),w=li([ve(g,[h.numBoxes,1]),ve(y,[h.numBoxes,1]),ve(b,[h.numBoxes,1]),ve(_,[h.numBoxes,1])],1);if(h.numKeypoints)for(var S=0;S<h.numKeypoints;++S){var C=h.keypointCoordOffset+S*h.numValuesPerKeypoint,k=void 0,A=void 0;h.reverseOutputOrder?(k=br(pn(c,[0,C],[-1,1])),A=br(pn(c,[0,C+1],[-1,1]))):(A=br(pn(c,[0,C],[-1,1])),k=br(pn(c,[0,C+1],[-1,1])));var M=Xe(fe(Lt(k,h.xScale),u.w),u.x),E=Xe(fe(Lt(A,h.yScale),u.h),u.y);w=li([w,ve(M,[h.numBoxes,1]),ve(E,[h.numBoxes,1])],1)}return w})}(i,e,t),o=Se(function(){var c=r;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(c=_a(r,-t.scoreClippingThresh,t.scoreClippingThresh)),c=Il(c)):c}),[4,zht(s,o,t)];case 1:return a=l.sent(),nn([s,o]),[2,a]}})})}function zht(n,e,t){return lr(this,void 0,void 0,function(){var r,i,s,o,a,l,c,u,h,f,d,p;return cr(this,function(m){switch(m.label){case 0:return r=[],[4,n.data()];case 1:return i=m.sent(),[4,e.data()];case 2:for(s=m.sent(),o=0;o<t.numBoxes;++o)if(!(t.minScoreThresh!=null&&s[o]<t.minScoreThresh||(a=o*t.numCoords,l=Bht(i[a+0],i[a+1],i[a+2],i[a+3],s[o],t.flipVertically,o),(c=l.locationData.relativeBoundingBox).width<0||c.height<0))){if(t.numKeypoints>0)for((u=l.locationData).relativeKeypoints=[],h=t.numKeypoints*t.numValuesPerKeypoint,f=0;f<h;f+=t.numValuesPerKeypoint)d=a+t.keypointCoordOffset+f,p={x:i[d+0],y:t.flipVertically?1-i[d+1]:i[d+1]},u.relativeKeypoints.push(p);r.push(l)}return[2,r]}})})}function Bht(n,e,t,r,i,s,o){return{score:[i],ind:o,locationData:{relativeBoundingBox:{xMin:e,yMin:s?1-t:n,xMax:r,yMax:s?1-n:t,width:r-e,height:t-n}}}}function Vht(n,e){return n==="none"?e:function(t){return 1/(1+Math.exp(-t))}(e)}function Sj(n,e,t,r){return lr(this,void 0,void 0,function(){var i,s,o,a,l,c,u,h;return cr(this,function(f){switch(f.label){case 0:return t=t||e.flipHorizontally||!1,r=r||e.flipVertically||!1,i=n.size,s=i/e.numLandmarks,[4,n.data()];case 1:for(o=f.sent(),a=[],l=0;l<e.numLandmarks;++l)c=l*s,(h={x:0,y:0}).x=t?e.inputImageWidth-o[c]:o[c],s>1&&(h.y=r?e.inputImageHeight-o[c+1]:o[c+1]),s>2&&(h.z=o[c+2]),s>3&&(h.score=Vht(e.visibilityActivation,o[c+3])),a.push(h);for(u=0;u<a.length;++u)(h=a[u]).x=h.x/e.inputImageWidth,h.y=h.y/e.inputImageHeight,h.z=h.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function Cj(n,e,t){var r=n.width,i=n.height,s=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(s=function(u,h){return h.rotation!=null?u+=h.rotation:h.rotationDegree!=null&&(u+=Math.PI*h.rotationDegree/180),ioe(u)}(s,t)),s===0)n.xCenter=n.xCenter+r*t.shiftX,n.yCenter=n.yCenter+i*t.shiftY;else{var o=(e.width*r*t.shiftX*Math.cos(s)-e.height*i*t.shiftY*Math.sin(s))/e.width,a=(e.width*r*t.shiftX*Math.sin(s)+e.height*i*t.shiftY*Math.cos(s))/e.height;n.xCenter=n.xCenter+o,n.yCenter=n.yCenter+a}if(t.squareLong){var l=Math.max(r*e.width,i*e.height);r=l/e.width,i=l/e.height}else if(t.squareShort){var c=Math.min(r*e.width,i*e.height);r=c/e.width,i=c/e.height}return n.width=r*t.scaleX,n.height=i*t.scaleY,n}function Uht(n,e){return n.map(function(t){var r=qr(qr({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),r})}var Dd=function(){function n(e){this.alpha=e,this.initialized=!1}return n.prototype.apply=function(e,t){var r;return this.initialized?r=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(r=e,this.initialized=!0),this.rawValue=e,this.storedValue=r,r},n.prototype.applyWithAlpha=function(e,t,r){return this.alpha=t,this.apply(e,r)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n}(),Y3=function(){function n(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new Dd(this.getAlpha(this.minCutOff)),this.dx=new Dd(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(e,t,r){if(e==null)return e;var i=Math.trunc(t);if(this.lastTimestamp>=i)return e;this.lastTimestamp!==0&&i!==0&&(this.frequency=1/(1e-6*(i-this.lastTimestamp))),this.lastTimestamp=i;var s=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*r*this.frequency:0,o=this.dx.applyWithAlpha(s,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(o),l=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(o):null;return this.x.applyWithAlpha(e,this.getAlpha(a),l)},n.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},n}(),mF=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var i=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var s=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return Bm([],e,!0);s=1/r}return e.map(function(o,a){var l=qr(qr({},o),{x:i.xFilters[a].apply(o.x,t,s),y:i.yFilters[a].apply(o.y,t,s)});return o.z!=null&&(l.z=i.zFilters[a].apply(o.z,t,s)),l})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new Y3(t.config)}),this.yFilters=e.map(function(r){return new Y3(t.config)}),this.zFilters=e.map(function(r){return new Y3(t.config)}))},n}(),Z3=function(){function n(e){this.config=e,this.window=[],this.lowPassFilter=new Dd(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(e,t,r){if(e==null)return e;var i,s=Math.trunc(t);if(this.lastTimestamp>=s)return e;if(this.lastTimestamp===-1)i=1;else{for(var o=e*r-this.lastValue*this.lastValueScale,a=s-this.lastTimestamp,l=o,c=a,u=(1+this.window.length)*(1e6/30),h=0,f=this.window;h<f.length;h++){var d=f[h];if(c+d.duration>u)break;l+=d.distance,c+=d.duration}var p=l/(1e-6*c);i=1-1/(1+this.config.velocityScale*Math.abs(p)),this.window.unshift({distance:o,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=r,this.lastTimestamp=s,this.lowPassFilter.applyWithAlpha(e,i)},n}(),Wht=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var i=this;if(e==null)return this.reset(),null;var s=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return Bm([],e,!0);s=1/r}return this.initializeFiltersIfEmpty(e),e.map(function(o,a){var l=qr(qr({},o),{x:i.xFilters[a].apply(o.x,t,s),y:i.yFilters[a].apply(o.y,t,s)});return o.z!=null&&(l.z=i.zFilters[a].apply(o.z,t,s)),l})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new Z3(t.config)}),this.yFilters=e.map(function(r){return new Z3(t.config)}),this.zFilters=e.map(function(r){return new Z3(t.config)}))},n}(),J3=function(){function n(e){if(e.velocityFilter!=null)this.keypointsFilter=new Wht(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new mF(e.oneEuroFilter)}}return n.prototype.apply=function(e,t,r,i,s){if(i===void 0&&(i=!1),e==null)return this.keypointsFilter.reset(),null;var o=s!=null?function(c,u){return(c.width*u.width+c.height*u.height)/2}(s,r):1,a=i?coe(e,r):e,l=this.keypointsFilter.apply(a,t,o);return i?Uht(l,r):l},n}(),kj=function(){function n(e){this.alpha=e.alpha}return n.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(a){return new Dd(t.alpha)}));for(var r=[],i=0;i<e.length;++i){var s=e[i],o=qr({},s);o.score=this.visibilityFilters[i].apply(s.score),r.push(o)}return r},n}(),Hht={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},B0={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},Ght={maxPoses:1,flipHorizontal:!1},jht={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},qht=.3,Tj={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},Xht={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},Kht={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},Yht={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Zht={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Jht={kernelSize:7,minConfidenceToRefine:.5},Ej={alpha:.1},Qht={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},eft={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},tft={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},nft={activation:"none"},rft={combineWithPreviousRatio:.7},ift=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return lr(this,void 0,void 0,function(){return cr(this,function(e){return[2,toe(this.mask)]})})},n.prototype.toImageData=function(){return lr(this,void 0,void 0,function(){return cr(this,function(e){return[2,noe(this.mask)]})})},n.prototype.toTensor=function(){return lr(this,void 0,void 0,function(){return cr(this,function(e){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function sft(n){return roe(n),"person"}var oft=function(){function n(e,t,r,i,s,o){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=r,this.enableSegmentation=i,this.smoothSegmentation=s,this.modelType=o,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(h){h.reduceBoxesInLowestLayer==null&&(h.reduceBoxesInLowestLayer=!1),h.interpolatedScaleAspectRatio==null&&(h.interpolatedScaleAspectRatio=1),h.fixedAnchorSize==null&&(h.fixedAnchorSize=!1);for(var f=[],d=0;d<h.numLayers;){for(var p=[],m=[],g=[],y=[],b=d;b<h.strides.length&&h.strides[b]===h.strides[d];){var _=wj(h.minScale,h.maxScale,b,h.strides.length);if(b===0&&h.reduceBoxesInLowestLayer)g.push(1),g.push(2),g.push(.5),y.push(.1),y.push(_),y.push(_);else{for(var w=0;w<h.aspectRatios.length;++w)g.push(h.aspectRatios[w]),y.push(_);if(h.interpolatedScaleAspectRatio>0){var S=b===h.strides.length-1?1:wj(h.minScale,h.maxScale,b+1,h.strides.length);y.push(Math.sqrt(_*S)),g.push(h.interpolatedScaleAspectRatio)}}b++}for(var C=0;C<g.length;++C){var k=Math.sqrt(g[C]);p.push(y[C]/k),m.push(y[C]*k)}var A=0,M=0;if(h.featureMapHeight.length>0)A=h.featureMapHeight[d],M=h.featureMapWidth[d];else{var E=h.strides[d];A=Math.ceil(h.inputSizeHeight/E),M=Math.ceil(h.inputSizeWidth/E)}for(var N=0;N<A;++N)for(var O=0;O<M;++O)for(var R=0;R<p.length;++R){var D={xCenter:(O+h.anchorOffsetX)/M,yCenter:(N+h.anchorOffsetY)/A,width:0,height:0};h.fixedAnchorSize?(D.width=1,D.height=1):(D.width=m[R],D.height=p[R]),f.push(D)}d=b}return f}(Hht);var a=Xi(this.anchors.map(function(h){return h.width})),l=Xi(this.anchors.map(function(h){return h.height})),c=Xi(this.anchors.map(function(h){return h.xCenter})),u=Xi(this.anchors.map(function(h){return h.yCenter}));this.anchorTensor={x:c,y:u,w:a,h:l},this.prevFilteredSegmentationMask=this.enableSegmentation?ja([],[0,0]):null}return n.prototype.estimatePoses=function(e,t,r){return lr(this,void 0,void 0,function(){var i,s,o,a,l,c,u,h,f,d,p,m,g,y,b,_,w,S,C,k,A,M,E;return cr(this,function(N){switch(N.label){case 0:return i=function(O){var R;if((R=O==null?Ght:qr({},O)).maxPoses==null&&(R.maxPoses=1),R.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(R.maxPoses,". Should be > 0."));if(R.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return R}(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=i.maxPoses,this.timestamp=r!=null?1e3*r:loe(e)?1e6*e.currentTime:null,s=hv(e),o=Se(function(){return St(B4(e),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(o)]);case 1:if((l=N.sent()).length===0)return this.reset(),o.dispose(),[2,[]];c=l[0],a=this.poseDetectionToRoi(c,s),N.label=2;case 2:return[4,this.poseLandmarksByRoi(a,o)];case 3:return u=N.sent(),o.dispose(),u==null?(this.reset(),[2,[]]):(h=u.landmarks,f=u.auxiliaryLandmarks,d=u.poseScore,p=u.worldLandmarks,m=u.segmentationMask,g=this.poseLandmarkFiltering(h,f,p,s),y=g.actualLandmarksFiltered,b=g.auxiliaryLandmarksFiltered,_=g.actualWorldLandmarksFiltered,w=this.poseLandmarksToRoi(b,s),this.regionOfInterest=w,S=this.smoothSegmentation&&m!=null?this.poseSegmentationFiltering(m):m,(C=y!=null?coe(y,s):null)!=null&&C.forEach(function(O,R){O.name=tS[R]}),(k=_)!=null&&k.forEach(function(O,R){O.name=tS[R]}),A={score:d,keypoints:C,keypoints3D:k},S!==null&&(M=Se(function(){var O=ss(S,2),R=_u(O,[[0,0],[0,0],[0,1]]);return iz(R,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||nn(S),E={maskValueToLabel:sft,mask:new ift(M)},A.segmentation=E),[2,[A]])}})})},n.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=Fht(t,e,rft),nn(e)),nn(t),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),nn([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(nn(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=ja([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(e){return lr(this,void 0,void 0,function(){var t,r,i,s,o,a,l,c,u,h;return cr(this,function(f){switch(f.label){case 0:return t=pF(e,Xht),r=t.imageTensor,i=t.padding,s=this.detectorModel.predict(r),o=Pht(s),a=o.boxes,[4,Lht([l=o.logits,a],this.anchorTensor,jht)];case 1:return(c=f.sent()).length===0?(nn([r,s,l,a]),[2,c]):[4,Dht(c,this.maxPoses,qht)];case 2:return u=f.sent(),h=function(d,p){d===void 0&&(d=[]);for(var m=p.left,g=p.top,y=p.left+p.right,b=p.top+p.bottom,_=0;_<d.length;_++){var w=d[_],S=w.locationData.relativeBoundingBox,C=(S.xMin-m)/(1-y),k=(S.yMin-g)/(1-b),A=S.width/(1-y),M=S.height/(1-b);S.xMin=C,S.yMin=k,S.width=A,S.height=M,S.xMax=C+A,S.yMax=k+M;var E=w.locationData.relativeKeypoints;E&&E.forEach(function(N){var O=(N.x-m)/(1-y),R=(N.y-g)/(1-b);N.x=O,N.y=R})}return d}(u,i),nn([r,s,l,a]),[2,h]}})})},n.prototype.poseDetectionToRoi=function(e,t){return Cj(X3(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,Tj)},n.prototype.poseLandmarksByRoi=function(e,t){return lr(this,void 0,void 0,function(){var r,i,s,o,a,l,c,u,h,f,d,p,m,g;return cr(this,function(y){switch(y.label){case 0:if(r=hv(t),i=pF(t,Kht,e),s=i.imageTensor,o=i.padding,a=i.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return l=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&l.push("activation_segmentation"),c=this.landmarkModel.execute(s,l),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return(u=y.sent())==null?(nn(c),nn(s),[2,null]):(h=u.landmarks,f=u.auxiliaryLandmarks,d=u.poseScore,p=u.worldLandmarks,m=u.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(r,e,o,a,h,f,p,m)]);case 2:return g=y.sent(),nn(c),nn(s),[2,qr({poseScore:d},g)]}})})},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,r,i,s,o,a,l){return lr(this,void 0,void 0,function(){var c,u,h,f,d,p;return cr(this,function(m){return c=_j(s,r),u=_j(o,r),h=vj(c,t),f=vj(u,t),d=function(g,y){for(var b=[],_=0,w=g;_<w.length;_++){var S=w[_],C=S.x,k=S.y,A=y.rotation,M=Math.cos(A)*C-Math.sin(A)*k,E=Math.sin(A)*C+Math.cos(A)*k,N=qr({},S);N.x=M,N.y=E,b.push(N)}return b}(a,t),p=null,this.enableSegmentation&&(p=Se(function(){var g=l.shape,y=g[0],b=g[1],_=function(C){var k=ooe(new Array(16).fill(0));k[0][0]=Oo(C,0,0),k[1][0]=-Oo(C,0,1),k[2][0]=Oo(C,0,2),k[3][0]=-Oo(C,0,3),k[0][2]=Oo(C,2,0),k[1][2]=-Oo(C,2,1),k[2][2]=Oo(C,2,2),k[3][2]=-Oo(C,2,3),k[0][1]=-Oo(C,1,0),k[1][1]=Oo(C,1,1),k[2][1]=-Oo(C,1,2),k[3][1]=Oo(C,1,3),k[0][3]=-Oo(C,3,0),k[1][3]=Oo(C,3,1),k[2][3]=-Oo(C,3,2),k[3][3]=Oo(C,3,3);for(var A=C[0][0]*k[0][0]+C[1][0]*k[0][1]+C[2][0]*k[0][2]+C[3][0]*k[0][3],M=0;M<k.length;M++)for(var E=0;E<k.length;E++)k[M][E]/=A;return k}(i),w=ja(soe(_,{width:b,height:y},e),[1,8]),S=[1,y,b,1];return br(Ss.transform(ve(l,S),w,"bilinear","constant",0,[e.height,e.width]),[0,3])}),nn(l)),[2,{landmarks:h,auxiliaryLandmarks:f,worldLandmarks:d,segmentationMask:p}]})})},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return lr(this,void 0,void 0,function(){var t,r,i,s,o,a,l,c,u,h,f,d,p;return cr(this,function(m){switch(m.label){case 0:return t=e[0],r=e[1],i=e[2],s=e[3],o=this.enableSegmentation?e[4]:null,[4,r.data()];case 1:return(a=m.sent()[0])<.5?[2,null]:[4,Sj(t,Yht)];case 2:return[4,Oht(m.sent(),i,Jht)];case 3:return l=m.sent(),c=l.slice(0,33),u=l.slice(33,35),[4,Sj(s,Zht)];case 4:return h=m.sent(),f=h.slice(0,33),d=function(g,y,b){b===void 0&&(b=!0);for(var _=[],w=0;w<g.length;w++){var S=qr({},y[w]);b&&(S.score=g[w].score),_.push(S)}return _}(c,f,!0),p=this.enableSegmentation?function(g,y,b){return Se(function(){var _=br(g,[0]),w=_.shape[2];if(w===1){var S=_;switch(y.activation){case"none":break;case"sigmoid":S=Il(S);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(y.activation,")"))}var C=b?Ss.resizeBilinear(S,[b.height,b.width]):S;return br(C,[2])}throw new Error("Unsupported number of tensor channels ".concat(w))})}(o,nft):null,[2,{landmarks:c,auxiliaryLandmarks:u,poseScore:a,worldLandmarks:d,segmentationMask:p}]}})})},n.prototype.poseLandmarksToRoi=function(e,t){return Cj(X3(xj(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,Tj)},n.prototype.poseLandmarkFiltering=function(e,t,r,i){var s,o,a;if(this.timestamp!=null&&this.enableSmoothing){var l=X3(xj(t),i,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new kj(Ej)),s=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new kj(Ej)),o=this.visibilitySmoothingFilterAuxiliary.apply(t),a=this.visibilitySmoothingFilterActual.apply(r),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new J3(Qht)),s=this.landmarksSmoothingFilterActual.apply(s,this.timestamp,i,!0,l),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new J3(eft)),o=this.landmarksSmoothingFilterAuxiliary.apply(o,this.timestamp,i,!0,l),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new J3(tft)),a=this.worldLandmarksSmoothingFilterActual.apply(r,this.timestamp)}else s=e,o=t,a=r;return{actualLandmarksFiltered:s,auxiliaryLandmarksFiltered:o,actualWorldLandmarksFiltered:a}},n}();function aft(n){return lr(this,void 0,void 0,function(){var e,t,r,i,s,o;return cr(this,function(a){switch(a.label){case 0:return e=function(l){var c=qr({},l??B0);if(c.enableSmoothing==null&&(c.enableSmoothing=B0.enableSmoothing),c.enableSegmentation==null&&(c.enableSegmentation=B0.enableSegmentation),c.smoothSegmentation==null&&(c.smoothSegmentation=B0.smoothSegmentation),c.modelType==null&&(c.modelType=B0.modelType),c.detectorModelUrl==null&&(c.detectorModelUrl=B0.detectorModelUrl),c.landmarkModelUrl==null)switch(c.modelType){case"lite":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return c}(n),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([Pl(e.detectorModelUrl,{fromTFHub:t}),Pl(e.landmarkModelUrl,{fromTFHub:r})])];case 1:return i=a.sent(),s=i[0],o=i[1],[2,new oft(s,o,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var Km,so,uoe=function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(t.maxTracks));if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(t.maxAge));if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(t.keypointTrackerParams.keypointConfidenceThreshold));if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(t.keypointTrackerParams.minNumberOfKeypoints));for(var r=0,i=t.keypointTrackerParams.keypointFalloff;r<i.length;r++){var s=i[r];if(s<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(s))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var r=this.computeSimilarity(e);return this.assignTracks(e,r,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(r){return e-r.lastTimestamp<=t.maxAge})},n.prototype.assignTracks=function(e,t,r){for(var i=Array.from(Array(t[0].length).keys()),s=[],o=0,a=Array.from(Array(e.length).keys());o<a.length;o++){var l=a[o];if(i.length!==0){for(var c=-1,u=-1,h=0,f=i;h<f.length;h++){var d=f[h],p=t[l][d];p>=this.minSimilarity&&p>u&&(c=d,u=p)}if(c>=0){var m=this.tracks[c];m=Object.assign(m,this.createTrack(e[l],r,m.id)),e[l].id=m.id;var g=i.indexOf(c);i.splice(g,1)}else s.push(l)}else s.push(l)}for(var y=0,b=s;y<b.length;y++){l=b[y];var _=this.createTrack(e[l],r);this.tracks.push(_),e[l].id=_.id}},n.prototype.updateTracks=function(e){this.tracks.sort(function(t,r){return r.lastTimestamp-t.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,r){var i={id:r||this.nextTrackID(),lastTimestamp:t,keypoints:Bm([],e.keypoints,!0).map(function(s){return qr({},s)})};return e.box!==void 0&&(i.box=qr({},e.box)),i},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(r){return!e.includes(r.id)})},n.prototype.reset=function(){this.tracks=[]},n}(),lft=function(n){function e(t){return n.call(this,t)||this}return eoe(e,n),e.prototype.computeSimilarity=function(t){var r=this;return t.length===0||this.tracks.length===0?[[]]:t.map(function(i){return r.tracks.map(function(s){return r.iou(i,s)})})},e.prototype.iou=function(t,r){var i=Math.max(t.box.xMin,r.box.xMin),s=Math.max(t.box.yMin,r.box.yMin),o=Math.min(t.box.xMax,r.box.xMax),a=Math.min(t.box.yMax,r.box.yMax);if(i>=o||s>=a)return 0;var l=(o-i)*(a-s);return l/(t.box.width*t.box.height+r.box.width*r.box.height-l)},e}(uoe),cft=function(n){function e(t){var r=n.call(this,t)||this;return r.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,r.keypointFalloff=t.keypointTrackerParams.keypointFalloff,r.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,r}return eoe(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var r=[],i=0,s=t;i<s.length;i++){for(var o=s[i],a=[],l=0,c=this.tracks;l<c.length;l++){var u=c[l];a.push(this.oks(o,u))}r.push(a)}return r},e.prototype.oks=function(t,r){for(var i=this.area(r.keypoints)+1e-6,s=0,o=0,a=0;a<t.keypoints.length;++a){var l=t.keypoints[a],c=r.keypoints[a];if(!(l.score<this.keypointThreshold||c.score<this.keypointThreshold)){o+=1;var u=Math.pow(l.x-c.x,2)+Math.pow(l.y-c.y,2),h=2*this.keypointFalloff[a];s+=Math.exp(-1*u/(2*i*Math.pow(h,2)))}}return o<this.minNumKeyoints?0:s/o},e.prototype.area=function(t){var r=this,i=t.filter(function(l){return l.score>r.keypointThreshold}),s=Math.min.apply(Math,Bm([1],i.map(function(l){return l.x}),!1)),o=Math.max.apply(Math,Bm([0],i.map(function(l){return l.x}),!1)),a=Math.min.apply(Math,Bm([1],i.map(function(l){return l.y}),!1));return(o-s)*(Math.max.apply(Math,Bm([0],i.map(function(l){return l.y}),!1))-a)},e}(uoe);function hoe(n){switch(n){case so.BlazePose:return tS.reduce(function(e,t,r){return e[t]=r,e},{});case so.PoseNet:case so.MoveNet:return Th.reduce(function(e,t,r){return e[t]=r,e},{});default:throw new Error("Model ".concat(n," is not supported."))}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(Km||(Km={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(so||(so={}));var Ij=Object.freeze({__proto__:null,getKeypointIndexBySide:function(n){switch(n){case so.BlazePose:return kht;case so.PoseNet:case so.MoveNet:return Tht;default:throw new Error("Model ".concat(n," is not supported."))}},getAdjacentPairs:function(n){switch(n){case so.BlazePose:return Iht;case so.PoseNet:case so.MoveNet:return Eht;default:throw new Error("Model ".concat(n," is not supported."))}},getKeypointIndexByName:hoe}),Aj=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],foe={modelType:"SinglePose.Lightning",enableSmoothing:!0},Mj={},Nj={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},Q3={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},$j={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function uft(n,e,t,r){for(var i={},s=0,o=Th;s<o.length;s++){var a=o[s];i[a]=[e[t[a]].y*r.height,e[t[a]].x*r.width]}if(function(b,_){return(b[_.left_hip].score>.2||b[_.right_hip].score>.2)&&(b[_.left_shoulder].score>.2||b[_.right_shoulder].score>.2)}(e,t)){var l=(i.left_hip[0]+i.right_hip[0])/2,c=(i.left_hip[1]+i.right_hip[1])/2,u=function(b,_,w,S,C){for(var k=["left_shoulder","right_shoulder","left_hip","right_hip"],A=0,M=0,E=0;E<k.length;E++)(z=Math.abs(S-w[k[E]][0]))>A&&(A=z),(B=Math.abs(C-w[k[E]][1]))>M&&(M=B);for(var N=0,O=0,R=0,D=Object.keys(w);R<D.length;R++){var z,B,X=D[R];b[_[X]].score<.2||((z=Math.abs(S-w[X][0]))>N&&(N=z),(B=Math.abs(C-w[X][1]))>O&&(O=B))}return[A,M,N,O]}(e,t,i,l,c),h=u[0],f=u[1],d=u[2],p=u[3],m=Math.max(1.9*f,1.9*h,1.2*d,1.2*p),g=[l-(m=Math.min(m,Math.max(c,r.width-c,l,r.height-l))),c-m];if(m>Math.max(r.width,r.height)/2)return gF(n==null,r);var y=2*m;return{yMin:g[0]/r.height,xMin:g[1]/r.width,yMax:(g[0]+y)/r.height,xMax:(g[1]+y)/r.width,height:(g[0]+y)/r.height-g[0]/r.height,width:(g[1]+y)/r.width-g[1]/r.width}}return gF(n==null,r)}function gF(n,e){var t,r,i,s;return n?e.width>e.height?(t=1,r=e.height/e.width,i=0,s=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,r=1,i=(e.height/2-e.width/2)/e.height,s=0):e.width>e.height?(t=e.width/e.height,r=1,i=(e.height/2-e.width/2)/e.height,s=0):(t=1,r=e.height/e.width,i=0,s=(e.width/2-e.height/2)/e.width),{yMin:i,xMin:s,yMax:i+t,xMax:s+r,height:t,width:r}}function hft(n){var e,t=n==null?foe:qr({},n);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(Aj.indexOf(t.modelType)<0)throw new Error("Invalid architecture ".concat(t.modelType,". ")+"Should be one of ".concat(Aj));if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=Km.BoundingBox),t.trackerType===Km.Keypoint)t.trackerConfig!=null?t.trackerConfig=function(r){var i=Rj(Q3,r);return i.keypointTrackerParams=qr({},Q3.keypointTrackerParams),r.keypointTrackerParams!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold!=null&&(i.keypointTrackerParams.keypointConfidenceThreshold=r.keypointTrackerParams.keypointConfidenceThreshold),r.keypointTrackerParams.keypointFalloff!=null&&(i.keypointTrackerParams.keypointFalloff=r.keypointTrackerParams.keypointFalloff),r.keypointTrackerParams.minNumberOfKeypoints!=null&&(i.keypointTrackerParams.minNumberOfKeypoints=r.keypointTrackerParams.minNumberOfKeypoints)),i}(t.trackerConfig):t.trackerConfig=Q3;else{if(t.trackerType!==Km.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,Rj($j,e)):t.trackerConfig=$j}return t}function Rj(n,e){var t={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var fft=function(){function n(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=hoe(so.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new mF(Nj),this.cropRegionFilterYMin=new Dd(.9),this.cropRegionFilterXMin=new Dd(.9),this.cropRegionFilterYMax=new Dd(.9),this.cropRegionFilterXMax=new Dd(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===Km.Keypoint?this.tracker=new cft(t.trackerConfig):t.trackerType===Km.BoundingBox&&(this.tracker=new lft(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(e){return lr(this,void 0,void 0,function(){var t,r,i,s,o;return cr(this,function(a){switch(a.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return v_()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=a.sent(),a.label=3;case 3:for(t.dispose(),i={keypoints:[],score:0},s=0,o=0;o<17;++o)i.keypoints[o]={y:r[3*o],x:r[3*o+1],score:r[3*o+2]},i.keypoints[o].score>.2&&(++s,i.score+=i.keypoints[o].score);return s>0&&(i.score/=s),[2,i]}})})},n.prototype.runMultiPersonPoseModel=function(e){return lr(this,void 0,void 0,function(){var t,r,i,s,o,a,l,c;return cr(this,function(u){switch(u.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return v_()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=u.sent(),u.label=3;case 3:for(t.dispose(),i=[],s=r.length/56,o=0;o<s;++o)for(i[o]={keypoints:[]},a=56*o+51,i[o].box={yMin:r[a],xMin:r[a+1],yMax:r[a+2],xMax:r[a+3],width:r[a+3]-r[a+1],height:r[a+2]-r[a]},l=56*o+55,i[o].score=r[l],i[o].keypoints=[],c=0;c<17;++c)i[o].keypoints[c]={y:r[56*o+3*c],x:r[56*o+3*c+1],score:r[56*o+3*c+2]};return[2,i]}})})},n.prototype.estimatePoses=function(e,t,r){return t===void 0&&(t=Mj),lr(this,void 0,void 0,function(){var i,s,o,a,l,c;return cr(this,function(u){switch(u.label){case 0:return t=function(h){return h==null?Mj:qr({},h)}(t),e==null?(this.reset(),[2,[]]):(r==null?loe(e)&&(r=1e6*e.currentTime):r*=1e3,i=B4(e),s=hv(i),o=ss(i,0),e instanceof jn||i.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(o,s,r)]);case 1:return a=u.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(o,s,r)];case 3:a=u.sent(),u.label=4;case 4:for(l=0;l<a.length;++l)for(c=0;c<a[l].keypoints.length;++c)a[l].keypoints[c].name=Th[c],a[l].keypoints[c].y*=s.height,a[l].keypoints[c].x*=s.width;return[2,a]}})})},n.prototype.estimateSinglePose=function(e,t,r){return lr(this,void 0,void 0,function(){var i,s,o,a,l=this;return cr(this,function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=gF(this.cropRegion==null,t)),i=Se(function(){var u=ja([[l.cropRegion.yMin,l.cropRegion.xMin,l.cropRegion.yMax,l.cropRegion.xMax]]),h=pi([1],"int32"),f=[l.modelInputResolution.height,l.modelInputResolution.width];return St(Ss.cropAndResize(e,u,h,f,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(i)];case 1:if(s=c.sent(),i.dispose(),s.score<this.minPoseScore)return this.reset(),[2,[]];for(o=0;o<s.keypoints.length;++o)s.keypoints[o].y=this.cropRegion.yMin+s.keypoints[o].y*this.cropRegion.height,s.keypoints[o].x=this.cropRegion.xMin+s.keypoints[o].x*this.cropRegion.width;return r!=null&&this.enableSmoothing&&(s.keypoints=this.keypointFilter.apply(s.keypoints,r,1)),a=uft(this.cropRegion,s.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(a),[2,[s]]}})})},n.prototype.estimateMultiplePoses=function(e,t,r){return lr(this,void 0,void 0,function(){var i,s,o,a,l,c,u,h,f,d,p,m=this;return cr(this,function(g){switch(g.label){case 0:return t.width>t.height?(s=this.multiPoseMaxDimension,o=Math.round(this.multiPoseMaxDimension*t.height/t.width),i=Ss.resizeBilinear(e,[o,s]),l=s,c=32*Math.ceil(o/32),a=_u(i,[[0,0],[0,c-o],[0,0],[0,0]])):(s=Math.round(this.multiPoseMaxDimension*t.width/t.height),o=this.multiPoseMaxDimension,i=Ss.resizeBilinear(e,[o,s]),l=32*Math.ceil(s/32),c=o,a=_u(i,[[0,0],[0,0],[0,l-s],[0,0]])),i.dispose(),e.dispose(),u=St(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(u)];case 1:for(h=g.sent(),u.dispose(),h=h.filter(function(y){return y.score>=m.minPoseScore}),d=0;d<h.length;++d)for(f=0;f<h[d].keypoints.length;++f)h[d].keypoints[f].y*=c/o,h[d].keypoints[f].x*=l/s;if(this.enableTracking&&(this.tracker.apply(h,r),this.enableSmoothing)){for(d=0;d<h.length;++d)this.keypointFilterMap.has(h[d].id)||this.keypointFilterMap.set(h[d].id,new mF(Nj)),h[d].keypoints=this.keypointFilterMap.get(h[d].id).apply(h[d].keypoints,r,1);p=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(y,b){p.has(b)||m.keypointFilterMap.delete(b)})}return[2,h]}})})},n.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),r=this.cropRegionFilterXMin.apply(e.xMin),i=this.cropRegionFilterYMax.apply(e.yMax),s=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:r,yMax:i,xMax:s,height:i-t,width:s-r}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n}();function dft(n){return n===void 0&&(n=foe),lr(this,void 0,void 0,function(){var e,t,r,i;return cr(this,function(s){switch(s.label){case 0:return e=hft(n),r=!0,e.modelUrl?(r=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Pl(e.modelUrl,{fromTFHub:r})]):[3,2];case 1:return t=s.sent(),[3,4];case 2:return i=void 0,e.modelType==="SinglePose.Lightning"?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(i="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,Pl(i,{fromTFHub:r})];case 3:t=s.sent(),s.label=4;case 4:return v_()==="webgl"&&Ie().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new fft(t,e)]}})})}var Pj={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},Dj=["MobileNetV1","ResNet50"],Oj={MobileNetV1:[8,16],ResNet50:[16]},pft=[8,16,32],Fj={MobileNetV1:[.5,.75,1],ResNet50:[1]},Lj=[1,2,4],zj={maxPoses:1,flipHorizontal:!1},mft={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},gft=[-123.15,-115.9,-103.06];function eP(n){return Math.floor(n/2)}var yft=function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(eP(e),e);)this.exchange(e,eP(e)),e=eP(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=r},n}();function bft(n,e,t,r,i,s){for(var o=s.shape,a=o[0],l=o[1],c=!0,u=Math.max(t-i,0),h=Math.min(t+i+1,a),f=u;f<h;++f){for(var d=Math.max(r-i,0),p=Math.min(r+i+1,l),m=d;m<p;++m)if(s.get(f,m,n)>e){c=!1;break}if(!c)break}return c}function vft(n){return lr(this,void 0,void 0,function(){return cr(this,function(e){return[2,Promise.all(n.map(function(t){return t.buffer()}))]})})}function doe(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+17)}}function poe(n,e,t){var r=doe(n.heatmapY,n.heatmapX,n.id,t),i=r.y,s=r.x;return{x:n.heatmapX*e+s,y:n.heatmapY*e+i}}function moe(n,e,t,r){var i=t.x,s=t.y;return n.some(function(o){var a,l,c,u,h,f,d=o.keypoints;return a=s,l=i,c=d[r].y,u=d[r].x,(h=c-a)*h+(f=u-l)*f<=e})}var Bj=Th.reduce(function(n,e,t){return n[e]=t,n},{}),goe=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var e=n[0],t=n[1];return[Bj[e],Bj[t]]}),tP=goe.map(function(n){return n[1]}),Vj=goe.map(function(n){return n[0]});function Uj(n,e,t){return n<e?e:n>t?t:n}function nP(n,e,t,r){return{y:Uj(Math.round(n.y/e),0,t-1),x:Uj(Math.round(n.x/e),0,r-1)}}function Wj(n,e){return{x:n.x+e.x,y:n.y+e.y}}function Hj(n,e,t,r,i,s,o,a){a===void 0&&(a=2);for(var l=r.shape,c=l[0],u=l[1],h={y:e.y,x:e.x},f=Wj(h,function(b,_,w){var S=w.shape[2]/2;return{y:w.get(_.y,_.x,b),x:w.get(_.y,_.x,S+b)}}(n,nP(h,s,c,u),o)),d=0;d<a;d++){var p=nP(f,s,c,u),m=doe(p.y,p.x,t,i);f=Wj({x:p.x*s,y:p.y*s},{x:m.x,y:m.y})}var g=nP(f,s,c,u),y=r.get(g.y,g.x,t);return{y:f.y,x:f.x,name:Th[t],score:y}}function wft(n,e,t,r,i,s){var o=e.shape[2],a=tP.length,l=new Array(o),c=n.part,u=n.score,h=poe(c,r,t);l[c.id]={score:u,name:Th[c.id],y:h.y,x:h.x};for(var f=a-1;f>=0;--f){var d=tP[f],p=Vj[f];l[d]&&!l[p]&&(l[p]=Hj(f,l[d],p,e,t,r,s))}for(f=0;f<a;++f)d=Vj[f],p=tP[f],l[d]&&!l[p]&&(l[p]=Hj(f,l[d],p,e,t,r,i));return l}function xft(n,e,t){return t.reduce(function(r,i,s){var o=i.y,a=i.x,l=i.score;return moe(n,e,{y:o,x:a},s)||(r+=l),r},0)/t.length}function _ft(n,e,t,r,i,s,o,a){return o===void 0&&(o=.5),a===void 0&&(a=20),lr(this,void 0,void 0,function(){var l,c,u,h,f,d,p,m,g,y,b,_;return cr(this,function(w){switch(w.label){case 0:return[4,vft([n,e,t,r])];case 1:for(l=w.sent(),c=l[0],u=l[1],h=l[2],f=l[3],d=[],p=function(S,C,k){for(var A=k.shape,M=A[0],E=A[1],N=A[2],O=new yft(M*E*N,function(X){return X.score}),R=0;R<M;++R)for(var D=0;D<E;++D)for(var z=0;z<N;++z){var B=k.get(R,D,z);B<S||bft(z,B,R,D,C,k)&&O.enqueue({score:B,part:{heatmapY:R,heatmapX:D,id:z}})}return O}(o,1,c),m=a*a;d.length<s&&!p.empty();)g=p.dequeue(),y=poe(g.part,i,u),moe(d,m,y,g.part.id)||(b=wft(g,c,u,i,h,f),_=xft(d,m,b),d.push({keypoints:b,score:_}));return[2,d]}})})}function yoe(){for(var n,e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];switch(e.length){case 0:n="fn main() ";break;case 1:n="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return n}var Sft=function(){function n(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=Ot(this.outputShape),this.dispatch=Tt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return n.prototype.getUserCode=function(){return`
        `.concat(yoe("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},n}();function Cft(n,e){if(rg()instanceof Bw)return function(t,r){var i=rg(),s=new Sft(r.shape),o=i.runWebGPUProgram(s,[t,r],"float32");return wo().makeTensorFromTensorInfo(o)}(n,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var kft=function(){function n(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=Ot(t),this.dispatch=Tt(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return n.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(yoe("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},n}();function Tft(n,e){if(rg()instanceof Bw)return function(t,r){var i=rg(),s=new kft(t.shape),o=i.runWebGPUProgram(s,[t,r],"float32");return wo().makeTensorFromTensorInfo(o)}(n,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function boe(n){var e=n.shape,t=e[0],r=e[1],i=e[2];return Se(function(){var s,o,a=ve(n,[t*r,i]),l=ig(a,0),c=ss(Lt(l,Qt(r,"int32")),1),u=ss((s=l,o=r,Se(function(){var h=Lt(s,Qt(o,"int32"));return Dt(s,fe(h,Qt(o,"int32")))})),1);return li([c,u],1)})}function Eft(n,e,t){return Se(function(){var r=function(i,s){for(var o=[],a=0;a<Th.length;a++){var l=i.get(a,0).valueOf(),c=i.get(a,1).valueOf(),u=Ift(l,c,a,s),h=u.x,f=u.y;o.push(f),o.push(h)}return ja(o,[Th.length,2])}(n,t);return Xe(St(fe(n.toTensor(),Qt(e,"int32")),"float32"),r)})}function Ift(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+Th.length)}}function Aft(n,e,t){return lr(this,void 0,void 0,function(){var r,i,s,o,a,l,c,u,h,f;return cr(this,function(d){switch(d.label){case 0:return r=0,i=boe(n),[4,Promise.all([n.buffer(),e.buffer(),i.buffer()])];case 1:return s=d.sent(),o=s[0],a=s[1],l=s[2],[4,(c=Eft(l,t,a)).buffer()];case 2:return u=d.sent(),h=Array.from(function(p,m){for(var g=m.shape[0],y=new Float32Array(g),b=0;b<g;b++){var _=m.get(b,0),w=m.get(b,1);y[b]=p.get(_,w,b)}return y}(o,l)),f=h.map(function(p,m){return r+=p,{y:u.get(m,0),x:u.get(m,1),score:p,name:Th[m]}}),i.dispose(),c.dispose(),[2,{keypoints:f,score:r/f.length}]}})})}function Mft(n,e,t){return lr(this,void 0,void 0,function(){var r,i,s;return cr(this,function(o){return r=boe(n),i=function(a,l,c){return Se(function(){var u=Tft(a,c);return Xe(St(fe(a,Qt(l,"int32")),"float32"),u)})}(r,t,e),s=Cft(n,r),[2,[i,s]]})})}function Gj(n,e){return(n-1)%e==0}var jj="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",qj="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function Xj(n,e){return function(t,r){return(t-1)%r==0}(n,e)?n:Math.floor(n/e)*e+1}var Kj=function(){function n(e,t){this.posenetModel=e;var r=this.posenetModel.inputs[0].shape;U(r[1]===-1&&r[2]===-1,function(){return"Input shape [".concat(r[1],", ").concat(r[2],"] ")+"must both be equal to or -1"});var i,s,o=(i=t.inputResolution,s=t.outputStride,{height:Xj(i.height,s),width:Xj(i.width,s)});(function(a){U(pft.indexOf(a)>=0,function(){return"outputStride of ".concat(a," is invalid. ")+"It must be either 8 or 16."})})(t.outputStride),function(a,l){U(Gj(a.height,l),function(){return"height of ".concat(a.height," is invalid for output stride ")+"".concat(l,".")}),U(Gj(a.width,l),function(){return"width of ".concat(a.width," is invalid for output stride ")+"".concat(l,".")})}(o,t.outputStride),this.inputResolution=o,this.outputStride=t.outputStride,this.architecture=t.architecture}return n.prototype.estimatePoses=function(e,t){return t===void 0&&(t=zj),lr(this,void 0,void 0,function(){return cr(this,function(r){return[2,this.estimatePosesGPU(e,t,!1)]})})},n.prototype.estimatePosesGPU=function(e,t,r){return t===void 0&&(t=zj),r===void 0&&(r=!1),lr(this,void 0,void 0,function(){var i,s,o,a,l,c,u,h,f,d,p,m,g,y,b,_,w,S;return cr(this,function(C){switch(C.label){case 0:return i=function(k){var A=k;if(A.maxPoses==null&&(A.maxPoses=1),A.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(A.maxPoses,". Should be > 0."));if(A.maxPoses>1){if((A=qr(qr({},mft),A)).scoreThreshold<0||A.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(A.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(A.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(A.nmsRadius,"."))}return A}(t),e==null?[2,r?[[],[]]:[]]:(this.maxPoses=i.maxPoses,s=pF(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),o=s.imageTensor,a=s.padding,l=this.architecture==="ResNet50"?Xe(o,gft):aoe(o,[-1,1]),c=this.posenetModel.predict(l),this.architecture==="ResNet50"?(u=br(c[2],[0]),h=br(c[3],[0]),f=br(c[0],[0]),d=br(c[1],[0])):(u=br(c[0],[0]),h=br(c[1],[0]),f=br(c[2],[0]),d=br(c[3],[0])),p=Il(h),this.maxPoses!==1?[3,5]:r?[4,Mft(p,u,this.outputStride)]:[3,2]);case 1:return g=C.sent(),b=g[0],y=g[1],m=[b,y],[3,4];case 2:return[4,Aft(p,u,this.outputStride)];case 3:b=C.sent(),m=[b],C.label=4;case 4:return[3,7];case 5:if(r)throw new Error("GPU renderer only supports single pose!");return[4,_ft(p,u,f,d,this.outputStride,this.maxPoses,i.scoreThreshold,i.nmsRadius)];case 6:m=C.sent(),C.label=7;case 7:if(r){if(i.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");_=this.getCanvasInfo(hv(e),this.inputResolution,a)}else S=hv(e),w=function(k,A,M,E){var N=A.height,O=A.width,R=N/(M.height*(1-E.top-E.bottom)),D=O/(M.width*(1-E.left-E.right)),z=-E.top*M.height,B=-E.left*M.width;if(D===1&&R===1&&z===0&&B===0)return k;for(var X=0,H=k;X<H.length;X++)for(var te=0,ge=H[X].keypoints;te<ge.length;te++){var ae=ge[te];ae.x=(ae.x+B)*D,ae.y=(ae.y+z)*R}return k}(m,S,this.inputResolution,a),i.flipHorizontal&&(w=function(k,A){for(var M=0,E=k;M<E.length;M++)for(var N=0,O=E[M].keypoints;N<O.length;N++){var R=O[N];R.x=A.width-1-R.x}return k}(w,S));return o.dispose(),l.dispose(),nn(c),u.dispose(),h.dispose(),f.dispose(),d.dispose(),p.dispose(),[2,r?[m,_]:w]}})})},n.prototype.getCanvasInfo=function(e,t,r){var i=e.height,s=e.width,o=i/(t.height*(1-r.top-r.bottom)),a=s/(t.width*(1-r.left-r.right)),l=-r.top*t.height;return[-r.left*t.width,l,a,o,e.width,e.height]},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n}();function Nft(n){return n===void 0&&(n=Pj),lr(this,void 0,void 0,function(){var e,t,r,i,s;return cr(this,function(o){switch(o.label){case 0:return(e=function(u){var h=u||Pj;if(h.architecture==null&&(h.architecture="MobileNetV1"),Dj.indexOf(h.architecture)<0)throw new Error("Invalid architecture ".concat(h.architecture,". ")+"Should be one of ".concat(Dj));if(h.inputResolution==null&&(h.inputResolution={height:257,width:257}),h.outputStride==null&&(h.outputStride=16),Oj[h.architecture].indexOf(h.outputStride)<0)throw new Error("Invalid outputStride ".concat(h.outputStride,". ")+"Should be one of ".concat(Oj[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.multiplier==null&&(h.multiplier=1),Fj[h.architecture].indexOf(h.multiplier)<0)throw new Error("Invalid multiplier ".concat(h.multiplier,". ")+"Should be one of ".concat(Fj[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.quantBytes==null&&(h.quantBytes=4),Lj.indexOf(h.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(h.quantBytes,". ")+"Should be one of ".concat(Lj," ")+"for architecture ".concat(h.architecture,"."));if(h.architecture==="MobileNetV1"&&h.outputStride===32&&h.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return h}(n)).architecture!=="ResNet50"?[3,2]:(a=e.outputStride,l=e.quantBytes,c="model-stride".concat(a,".json"),t=l===4?qj+"float/"+c:qj+"quant".concat(l,"/")+c,[4,Pl(e.modelUrl||t)]);case 1:return r=o.sent(),[2,new Kj(r,e)];case 2:return i=function(u,h,f){var d={1:"100",.75:"075",.5:"050"},p="model-stride".concat(u,".json");return f===4?jj+"float/".concat(d[h],"/")+p:jj+"quant".concat(f,"/").concat(d[h],"/")+p}(e.outputStride,e.multiplier,e.quantBytes),[4,Pl(e.modelUrl||i)];case 3:return s=o.sent(),[2,new Kj(s,e)]}var a,l,c})})}function $ft(n,e){return lr(this,void 0,void 0,function(){var t,r;return cr(this,function(i){switch(n){case so.PoseNet:return[2,Nft(e)];case so.BlazePose:if(r=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,aft(e)];if(t.runtime==="mediapipe")return[2,Rht(e)];r=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(r));case so.MoveNet:return[2,dft(e)];default:throw new Error("".concat(n," is not a supported model name."))}})})}var V4={},U4={},W4={};const H4="125",xf={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},_f={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},voe=0,yF=1,woe=2,Rft=3,Pft=0,G4=1,xoe=2,Sb=3,nx=0,ms=1,DC=2,j4=1,Dft=2,Mf=0,Db=1,bF=2,vF=3,wF=4,_oe=5,Pm=100,Soe=101,Coe=102,xF=103,_F=104,koe=200,Toe=201,Eoe=202,Ioe=203,q4=204,X4=205,Aoe=206,Moe=207,Noe=208,$oe=209,Roe=210,Poe=0,Doe=1,Ooe=2,xA=3,Foe=4,Loe=5,zoe=6,Boe=7,OC=0,Voe=1,Uoe=2,Ym=0,Woe=1,Hoe=2,Goe=3,joe=4,qoe=5,E$=300,FC=301,LC=302,_A=303,SA=304,rx=306,zC=307,nS=1e3,ma=1001,rS=1002,Us=1003,CA=1004,Oft=1004,kA=1005,Fft=1005,lo=1006,K4=1007,Lft=1007,ix=1008,zft=1008,sx=1009,Xoe=1010,Koe=1011,iS=1012,Yoe=1013,i_=1014,kf=1015,sS=1016,Zoe=1017,Joe=1018,Qoe=1019,Ob=1020,eae=1021,jd=1022,Ml=1023,tae=1024,nae=1025,rae=Ml,Zm=1026,fv=1027,iae=1028,sae=1029,oae=1030,aae=1031,lae=1032,cae=1033,SF=33776,CF=33777,kF=33778,TF=33779,EF=35840,IF=35841,AF=35842,MF=35843,uae=36196,NF=37492,$F=37496,hae=37808,fae=37809,dae=37810,pae=37811,mae=37812,gae=37813,yae=37814,bae=37815,vae=37816,wae=37817,xae=37818,_ae=37819,Sae=37820,Cae=37821,kae=36492,Tae=37840,Eae=37841,Iae=37842,Aae=37843,Mae=37844,Nae=37845,$ae=37846,Rae=37847,Pae=37848,Dae=37849,Oae=37850,Fae=37851,Lae=37852,zae=37853,Bae=2200,Vae=2201,Uae=2202,oS=2300,s_=2301,QE=2302,Vm=2400,Um=2401,aS=2402,I$=2500,Y4=2501,Wae=0,Bft=1,Vft=2,ka=3e3,BC=3001,A$=3007,M$=3002,Hae=3003,Z4=3004,J4=3005,Q4=3006,Gae=3200,jae=3201,Zy=0,qae=1,Uft=0,eI=7680,Wft=7681,Hft=7682,Gft=7683,jft=34055,qft=34056,Xft=5386,Kft=512,Yft=513,Zft=514,Jft=515,Qft=516,edt=517,tdt=518,Xae=519,VC=35044,yg=35048,ndt=35040,rdt=35045,idt=35049,sdt=35041,odt=35046,adt=35050,ldt=35042,cdt="100",RF="300 es";function Wu(){}Object.assign(Wu.prototype,{addEventListener:function(n,e){this._listeners===void 0&&(this._listeners={});const t=this._listeners;t[n]===void 0&&(t[n]=[]),t[n].indexOf(e)===-1&&t[n].push(e)},hasEventListener:function(n,e){if(this._listeners===void 0)return!1;const t=this._listeners;return t[n]!==void 0&&t[n].indexOf(e)!==-1},removeEventListener:function(n,e){if(this._listeners===void 0)return;const r=this._listeners[n];if(r!==void 0){const i=r.indexOf(e);i!==-1&&r.splice(i,1)}},dispatchEvent:function(n){if(this._listeners===void 0)return;const t=this._listeners[n.type];if(t!==void 0){n.target=this;const r=t.slice(0);for(let i=0,s=r.length;i<s;i++)r[i].call(this,n)}}});const vo=[];for(let n=0;n<256;n++)vo[n]=(n<16?"0":"")+n.toString(16);let RT=1234567;const In={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,r=Math.random()*4294967295|0;return(vo[n&255]+vo[n>>8&255]+vo[n>>16&255]+vo[n>>24&255]+"-"+vo[e&255]+vo[e>>8&255]+"-"+vo[e>>16&15|64]+vo[e>>24&255]+"-"+vo[t&63|128]+vo[t>>8&255]+"-"+vo[t>>16&255]+vo[t>>24&255]+vo[r&255]+vo[r>>8&255]+vo[r>>16&255]+vo[r>>24&255]).toUpperCase()},clamp:function(n,e,t){return Math.max(e,Math.min(t,n))},euclideanModulo:function(n,e){return(n%e+e)%e},mapLinear:function(n,e,t,r,i){return r+(n-e)*(i-r)/(t-e)},lerp:function(n,e,t){return(1-t)*n+t*e},damp:function(n,e,t,r){return In.lerp(n,e,1-Math.exp(-t*r))},pingpong:function(n,e=1){return e-Math.abs(In.euclideanModulo(n,e*2)-e)},smoothstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))},smootherstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))},randInt:function(n,e){return n+Math.floor(Math.random()*(e-n+1))},randFloat:function(n,e){return n+Math.random()*(e-n)},randFloatSpread:function(n){return n*(.5-Math.random())},seededRandom:function(n){return n!==void 0&&(RT=n%2147483647),RT=RT*16807%2147483647,(RT-1)/2147483646},degToRad:function(n){return n*In.DEG2RAD},radToDeg:function(n){return n*In.RAD2DEG},isPowerOfTwo:function(n){return(n&n-1)===0&&n!==0},ceilPowerOfTwo:function(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))},floorPowerOfTwo:function(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))},setQuaternionFromProperEuler:function(n,e,t,r,i){const s=Math.cos,o=Math.sin,a=s(t/2),l=o(t/2),c=s((e+r)/2),u=o((e+r)/2),h=s((e-r)/2),f=o((e-r)/2),d=s((r-e)/2),p=o((r-e)/2);switch(i){case"XYX":n.set(a*u,l*h,l*f,a*c);break;case"YZY":n.set(l*f,a*u,l*h,a*c);break;case"ZXZ":n.set(l*h,l*f,a*u,a*c);break;case"XZX":n.set(a*u,l*p,l*d,a*c);break;case"YXY":n.set(l*d,a*u,l*p,a*c);break;case"ZYZ":n.set(l*p,l*d,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}};class st{constructor(e=0,t=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,r=this.y,i=e.elements;return this.x=i[0]*t+i[3]*r+i[6],this.y=i[1]*t+i[4]*r+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y;return t*t+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const r=Math.cos(t),i=Math.sin(t),s=this.x-e.x,o=this.y-e.y;return this.x=s*r-o*i+e.x,this.y=s*i+o*r+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}class kl{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,r,i,s,o,a,l,c){const u=this.elements;return u[0]=e,u[1]=i,u[2]=a,u[3]=t,u[4]=s,u[5]=l,u[6]=r,u[7]=o,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return new this.constructor().fromArray(this.elements)}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],this}extractBasis(e,t,r){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),r.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,i=t.elements,s=this.elements,o=r[0],a=r[3],l=r[6],c=r[1],u=r[4],h=r[7],f=r[2],d=r[5],p=r[8],m=i[0],g=i[3],y=i[6],b=i[1],_=i[4],w=i[7],S=i[2],C=i[5],k=i[8];return s[0]=o*m+a*b+l*S,s[3]=o*g+a*_+l*C,s[6]=o*y+a*w+l*k,s[1]=c*m+u*b+h*S,s[4]=c*g+u*_+h*C,s[7]=c*y+u*w+h*k,s[2]=f*m+d*b+p*S,s[5]=f*g+d*_+p*C,s[8]=f*y+d*w+p*k,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8];return t*o*u-t*a*c-r*s*u+r*a*l+i*s*c-i*o*l}invert(){const e=this.elements,t=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=u*o-a*c,f=a*l-u*s,d=c*s-o*l,p=t*h+r*f+i*d;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return e[0]=h*m,e[1]=(i*c-u*r)*m,e[2]=(a*r-i*o)*m,e[3]=f*m,e[4]=(u*t-i*l)*m,e[5]=(i*s-a*t)*m,e[6]=d*m,e[7]=(r*l-c*t)*m,e[8]=(o*t-r*s)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).copy(this).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,r,i,s,o,a){const l=Math.cos(s),c=Math.sin(s);return this.set(r*l,r*c,-r*(l*o+c*a)+o+e,-i*c,i*l,-i*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){const r=this.elements;return r[0]*=e,r[3]*=e,r[6]*=e,r[1]*=t,r[4]*=t,r[7]*=t,this}rotate(e){const t=Math.cos(e),r=Math.sin(e),i=this.elements,s=i[0],o=i[3],a=i[6],l=i[1],c=i[4],u=i[7];return i[0]=t*s+r*l,i[3]=t*o+r*c,i[6]=t*a+r*u,i[1]=-r*s+t*l,i[4]=-r*o+t*c,i[7]=-r*a+t*u,this}translate(e,t){const r=this.elements;return r[0]+=e*r[2],r[3]+=e*r[5],r[6]+=e*r[8],r[1]+=t*r[2],r[4]+=t*r[5],r[7]+=t*r[8],this}equals(e){const t=this.elements,r=e.elements;for(let i=0;i<9;i++)if(t[i]!==r[i])return!1;return!0}fromArray(e,t=0){for(let r=0;r<9;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e}}let V0;const Jy={getDataURL:function(n){if(/^data:/i.test(n.src)||typeof HTMLCanvasElement>"u")return n.src;let e;if(n instanceof HTMLCanvasElement)e=n;else{V0===void 0&&(V0=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),V0.width=n.width,V0.height=n.height;const t=V0.getContext("2d");n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0,n.width,n.height),e=V0}return e.width>2048||e.height>2048?e.toDataURL("image/jpeg",.6):e.toDataURL("image/png")}};let udt=0;function Kr(n=Kr.DEFAULT_IMAGE,e=Kr.DEFAULT_MAPPING,t=ma,r=ma,i=lo,s=ix,o=Ml,a=sx,l=1,c=ka){Object.defineProperty(this,"id",{value:udt++}),this.uuid=In.generateUUID(),this.name="",this.image=n,this.mipmaps=[],this.mapping=e,this.wrapS=t,this.wrapT=r,this.magFilter=i,this.minFilter=s,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new st(0,0),this.repeat=new st(1,1),this.center=new st(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new kl,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.version=0,this.onUpdate=null}Kr.DEFAULT_IMAGE=void 0;Kr.DEFAULT_MAPPING=E$;Kr.prototype=Object.assign(Object.create(Wu.prototype),{constructor:Kr,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return new this.constructor().copy(this)},copy:function(n){return this.name=n.name,this.image=n.image,this.mipmaps=n.mipmaps.slice(0),this.mapping=n.mapping,this.wrapS=n.wrapS,this.wrapT=n.wrapT,this.magFilter=n.magFilter,this.minFilter=n.minFilter,this.anisotropy=n.anisotropy,this.format=n.format,this.internalFormat=n.internalFormat,this.type=n.type,this.offset.copy(n.offset),this.repeat.copy(n.repeat),this.center.copy(n.center),this.rotation=n.rotation,this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrix.copy(n.matrix),this.generateMipmaps=n.generateMipmaps,this.premultiplyAlpha=n.premultiplyAlpha,this.flipY=n.flipY,this.unpackAlignment=n.unpackAlignment,this.encoding=n.encoding,this},toJSON:function(n){const e=n===void 0||typeof n=="string";if(!e&&n.textures[this.uuid]!==void 0)return n.textures[this.uuid];const t={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const r=this.image;if(r.uuid===void 0&&(r.uuid=In.generateUUID()),!e&&n.images[r.uuid]===void 0){let i;if(Array.isArray(r)){i=[];for(let s=0,o=r.length;s<o;s++)r[s].isDataTexture?i.push(rP(r[s].image)):i.push(rP(r[s]))}else i=rP(r);n.images[r.uuid]={uuid:r.uuid,url:i}}t.image=r.uuid}return e||(n.textures[this.uuid]=t),t},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(n){if(this.mapping!==E$)return n;if(n.applyMatrix3(this.matrix),n.x<0||n.x>1)switch(this.wrapS){case nS:n.x=n.x-Math.floor(n.x);break;case ma:n.x=n.x<0?0:1;break;case rS:Math.abs(Math.floor(n.x)%2)===1?n.x=Math.ceil(n.x)-n.x:n.x=n.x-Math.floor(n.x);break}if(n.y<0||n.y>1)switch(this.wrapT){case nS:n.y=n.y-Math.floor(n.y);break;case ma:n.y=n.y<0?0:1;break;case rS:Math.abs(Math.floor(n.y)%2)===1?n.y=Math.ceil(n.y)-n.y:n.y=n.y-Math.floor(n.y);break}return this.flipY&&(n.y=1-n.y),n}});Object.defineProperty(Kr.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});function rP(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?Jy.getDataURL(n):n.data?{data:Array.prototype.slice.call(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class Gr{constructor(e=0,t=0,r=0,i=1){Object.defineProperty(this,"isVector4",{value:!0}),this.x=e,this.y=t,this.z=r,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,r,i){return this.x=e,this.y=t,this.z=r,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,r=this.y,i=this.z,s=this.w,o=e.elements;return this.x=o[0]*t+o[4]*r+o[8]*i+o[12]*s,this.y=o[1]*t+o[5]*r+o[9]*i+o[13]*s,this.z=o[2]*t+o[6]*r+o[10]*i+o[14]*s,this.w=o[3]*t+o[7]*r+o[11]*i+o[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,r,i,s;const l=e.elements,c=l[0],u=l[4],h=l[8],f=l[1],d=l[5],p=l[9],m=l[2],g=l[6],y=l[10];if(Math.abs(u-f)<.01&&Math.abs(h-m)<.01&&Math.abs(p-g)<.01){if(Math.abs(u+f)<.1&&Math.abs(h+m)<.1&&Math.abs(p+g)<.1&&Math.abs(c+d+y-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const _=(c+1)/2,w=(d+1)/2,S=(y+1)/2,C=(u+f)/4,k=(h+m)/4,A=(p+g)/4;return _>w&&_>S?_<.01?(r=0,i=.707106781,s=.707106781):(r=Math.sqrt(_),i=C/r,s=k/r):w>S?w<.01?(r=.707106781,i=0,s=.707106781):(i=Math.sqrt(w),r=C/i,s=A/i):S<.01?(r=.707106781,i=.707106781,s=0):(s=Math.sqrt(S),r=k/s,i=A/s),this.set(r,i,s,t),this}let b=Math.sqrt((g-p)*(g-p)+(h-m)*(h-m)+(f-u)*(f-u));return Math.abs(b)<.001&&(b=1),this.x=(g-p)/b,this.y=(h-m)/b,this.z=(f-u)/b,this.w=Math.acos((c+d+y-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this.w=e.w+(t.w-e.w)*r,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}class qd extends Wu{constructor(e,t,r){super(),Object.defineProperty(this,"isWebGLRenderTarget",{value:!0}),this.width=e,this.height=t,this.scissor=new Gr(0,0,e,t),this.scissorTest=!1,this.viewport=new Gr(0,0,e,t),r=r||{},this.texture=new Kr(void 0,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.generateMipmaps=r.generateMipmaps!==void 0?r.generateMipmaps:!1,this.texture.minFilter=r.minFilter!==void 0?r.minFilter:lo,this.depthBuffer=r.depthBuffer!==void 0?r.depthBuffer:!0,this.stencilBuffer=r.stencilBuffer!==void 0?r.stencilBuffer:!1,this.depthTexture=r.depthTexture!==void 0?r.depthTexture:null}setSize(e,t){(this.width!==e||this.height!==t)&&(this.width=e,this.height=t,this.texture.image.width=e,this.texture.image.height=t,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}class hdt extends qd{constructor(e,t,r){super(e,t,r),Object.defineProperty(this,"isWebGLMultisampleRenderTarget",{value:!0}),this.samples=4}copy(e){return super.copy.call(this,e),this.samples=e.samples,this}}class co{constructor(e=0,t=0,r=0,i=1){Object.defineProperty(this,"isQuaternion",{value:!0}),this._x=e,this._y=t,this._z=r,this._w=i}static slerp(e,t,r,i){return r.copy(e).slerp(t,i)}static slerpFlat(e,t,r,i,s,o,a){let l=r[i+0],c=r[i+1],u=r[i+2],h=r[i+3];const f=s[o+0],d=s[o+1],p=s[o+2],m=s[o+3];if(h!==m||l!==f||c!==d||u!==p){let g=1-a;const y=l*f+c*d+u*p+h*m,b=y>=0?1:-1,_=1-y*y;if(_>Number.EPSILON){const S=Math.sqrt(_),C=Math.atan2(S,y*b);g=Math.sin(g*C)/S,a=Math.sin(a*C)/S}const w=a*b;if(l=l*g+f*w,c=c*g+d*w,u=u*g+p*w,h=h*g+m*w,g===1-a){const S=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=S,c*=S,u*=S,h*=S}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,r,i,s,o){const a=r[i],l=r[i+1],c=r[i+2],u=r[i+3],h=s[o],f=s[o+1],d=s[o+2],p=s[o+3];return e[t]=a*p+u*h+l*d-c*f,e[t+1]=l*p+u*f+c*h-a*d,e[t+2]=c*p+u*d+a*f-l*h,e[t+3]=u*p-a*h-l*f-c*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,r,i){return this._x=e,this._y=t,this._z=r,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const r=e._x,i=e._y,s=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(r/2),u=a(i/2),h=a(s/2),f=l(r/2),d=l(i/2),p=l(s/2);switch(o){case"XYZ":this._x=f*u*h+c*d*p,this._y=c*d*h-f*u*p,this._z=c*u*p+f*d*h,this._w=c*u*h-f*d*p;break;case"YXZ":this._x=f*u*h+c*d*p,this._y=c*d*h-f*u*p,this._z=c*u*p-f*d*h,this._w=c*u*h+f*d*p;break;case"ZXY":this._x=f*u*h-c*d*p,this._y=c*d*h+f*u*p,this._z=c*u*p+f*d*h,this._w=c*u*h-f*d*p;break;case"ZYX":this._x=f*u*h-c*d*p,this._y=c*d*h+f*u*p,this._z=c*u*p-f*d*h,this._w=c*u*h+f*d*p;break;case"YZX":this._x=f*u*h+c*d*p,this._y=c*d*h+f*u*p,this._z=c*u*p-f*d*h,this._w=c*u*h-f*d*p;break;case"XZY":this._x=f*u*h-c*d*p,this._y=c*d*h-f*u*p,this._z=c*u*p+f*d*h,this._w=c*u*h+f*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const r=t/2,i=Math.sin(r);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(r),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,r=t[0],i=t[4],s=t[8],o=t[1],a=t[5],l=t[9],c=t[2],u=t[6],h=t[10],f=r+a+h;if(f>0){const d=.5/Math.sqrt(f+1);this._w=.25/d,this._x=(u-l)*d,this._y=(s-c)*d,this._z=(o-i)*d}else if(r>a&&r>h){const d=2*Math.sqrt(1+r-a-h);this._w=(u-l)/d,this._x=.25*d,this._y=(i+o)/d,this._z=(s+c)/d}else if(a>h){const d=2*Math.sqrt(1+a-r-h);this._w=(s-c)/d,this._x=(i+o)/d,this._y=.25*d,this._z=(l+u)/d}else{const d=2*Math.sqrt(1+h-r-a);this._w=(o-i)/d,this._x=(s+c)/d,this._y=(l+u)/d,this._z=.25*d}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let i=e.dot(t)+1;return i<1e-6?(i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=i):(this._x=0,this._y=-e.z,this._z=e.y,this._w=i)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=i),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(In.clamp(this.dot(e),-1,1)))}rotateTowards(e,t){const r=this.angleTo(e);if(r===0)return this;const i=Math.min(1,t/r);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const r=e._x,i=e._y,s=e._z,o=e._w,a=t._x,l=t._y,c=t._z,u=t._w;return this._x=r*u+o*a+i*c-s*l,this._y=i*u+o*l+s*a-r*c,this._z=s*u+o*c+r*l-i*a,this._w=o*u-r*a-i*l-s*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const r=this._x,i=this._y,s=this._z,o=this._w;let a=o*e._w+r*e._x+i*e._y+s*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=r,this._y=i,this._z=s,this;const l=1-a*a;if(l<=Number.EPSILON){const d=1-t;return this._w=d*o+t*this._w,this._x=d*r+t*this._x,this._y=d*i+t*this._y,this._z=d*s+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,a),h=Math.sin((1-t)*u)/c,f=Math.sin(t*u)/c;return this._w=o*h+this._w*f,this._x=r*h+this._x*f,this._y=i*h+this._y*f,this._z=s*h+this._z*f,this._onChangeCallback(),this}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}class Q{constructor(e=0,t=0,r=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=e,this.y=t,this.z=r}set(e,t,r){return r===void 0&&(r=this.z),this.x=e,this.y=t,this.z=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Yj.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(Yj.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,r=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[3]*r+s[6]*i,this.y=s[1]*t+s[4]*r+s[7]*i,this.z=s[2]*t+s[5]*r+s[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,r=this.y,i=this.z,s=e.elements,o=1/(s[3]*t+s[7]*r+s[11]*i+s[15]);return this.x=(s[0]*t+s[4]*r+s[8]*i+s[12])*o,this.y=(s[1]*t+s[5]*r+s[9]*i+s[13])*o,this.z=(s[2]*t+s[6]*r+s[10]*i+s[14])*o,this}applyQuaternion(e){const t=this.x,r=this.y,i=this.z,s=e.x,o=e.y,a=e.z,l=e.w,c=l*t+o*i-a*r,u=l*r+a*t-s*i,h=l*i+s*r-o*t,f=-s*t-o*r-a*i;return this.x=c*l+f*-s+u*-a-h*-o,this.y=u*l+f*-o+h*-s-c*-a,this.z=h*l+f*-a+c*-o-u*-s,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,r=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[4]*r+s[8]*i,this.y=s[1]*t+s[5]*r+s[9]*i,this.z=s[2]*t+s[6]*r+s[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const r=e.x,i=e.y,s=e.z,o=t.x,a=t.y,l=t.z;return this.x=i*l-s*a,this.y=s*o-r*l,this.z=r*a-i*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const r=e.dot(this)/t;return this.copy(e).multiplyScalar(r)}projectOnPlane(e){return iP.copy(this).projectOnVector(e),this.sub(iP)}reflect(e){return this.sub(iP.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const r=this.dot(e)/t;return Math.acos(In.clamp(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y,i=this.z-e.z;return t*t+r*r+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,r){const i=Math.sin(t)*e;return this.x=i*Math.sin(r),this.y=Math.cos(t)*e,this.z=i*Math.cos(r),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,r){return this.x=e*Math.sin(t),this.y=r,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),r=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=r,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}const iP=new Q,Yj=new co;class qf{constructor(e,t){Object.defineProperty(this,"isBox3",{value:!0}),this.min=e!==void 0?e:new Q(1/0,1/0,1/0),this.max=t!==void 0?t:new Q(-1/0,-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,r=1/0,i=1/0,s=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.length;l<c;l+=3){const u=e[l],h=e[l+1],f=e[l+2];u<t&&(t=u),h<r&&(r=h),f<i&&(i=f),u>s&&(s=u),h>o&&(o=h),f>a&&(a=f)}return this.min.set(t,r,i),this.max.set(s,o,a),this}setFromBufferAttribute(e){let t=1/0,r=1/0,i=1/0,s=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.count;l<c;l++){const u=e.getX(l),h=e.getY(l),f=e.getZ(l);u<t&&(t=u),h<r&&(r=h),f<i&&(i=f),u>s&&(s=u),h>o&&(o=h),f>a&&(a=f)}return this.min.set(t,r,i),this.max.set(s,o,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const r=Jx.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return e===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new Q),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new Q),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),oP.copy(t.boundingBox),oP.applyMatrix4(e.matrixWorld),this.union(oP));const r=e.children;for(let i=0,s=r.length;i<s;i++)this.expandByObject(r[i]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),t=new Q),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Jx),Jx.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,r;return e.normal.x>0?(t=e.normal.x*this.min.x,r=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,r=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,r+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,r+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,r+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,r+=e.normal.z*this.min.z),t<=-e.constant&&r>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Qx),PT.subVectors(this.max,Qx),U0.subVectors(e.a,Qx),W0.subVectors(e.b,Qx),H0.subVectors(e.c,Qx),ud.subVectors(W0,U0),hd.subVectors(H0,W0),lm.subVectors(U0,H0);let t=[0,-ud.z,ud.y,0,-hd.z,hd.y,0,-lm.z,lm.y,ud.z,0,-ud.x,hd.z,0,-hd.x,lm.z,0,-lm.x,-ud.y,ud.x,0,-hd.y,hd.x,0,-lm.y,lm.x,0];return!sP(t,U0,W0,H0,PT)||(t=[1,0,0,0,1,0,0,0,1],!sP(t,U0,W0,H0,PT))?!1:(DT.crossVectors(ud,hd),t=[DT.x,DT.y,DT.z],sP(t,U0,W0,H0,PT))}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),t=new Q),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Jx.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return e===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=this.getSize(Jx).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(of[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),of[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),of[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),of[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),of[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),of[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),of[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),of[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(of),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}function sP(n,e,t,r,i){for(let s=0,o=n.length-3;s<=o;s+=3){cm.fromArray(n,s);const a=i.x*Math.abs(cm.x)+i.y*Math.abs(cm.y)+i.z*Math.abs(cm.z),l=e.dot(cm),c=t.dot(cm),u=r.dot(cm);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>a)return!1}return!0}const of=[new Q,new Q,new Q,new Q,new Q,new Q,new Q,new Q],Jx=new Q,oP=new qf,U0=new Q,W0=new Q,H0=new Q,ud=new Q,hd=new Q,lm=new Q,Qx=new Q,PT=new Q,DT=new Q,cm=new Q,fdt=new qf;class Op{constructor(e,t){this.center=e!==void 0?e:new Q,this.radius=t!==void 0?t:-1}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const r=this.center;t!==void 0?r.copy(t):fdt.setFromPoints(e).getCenter(r);let i=0;for(let s=0,o=e.length;s<o;s++)i=Math.max(i,r.distanceToSquared(e[s]));return this.radius=Math.sqrt(i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const r=this.center.distanceToSquared(e);return t===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),t=new Q),t.copy(e),r>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return e===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new qf),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}}const af=new Q,aP=new Q,OT=new Q,fd=new Q,lP=new Q,FT=new Q,cP=new Q;class ox{constructor(e,t){this.origin=e!==void 0?e:new Q,this.direction=t!==void 0?t:new Q(0,0,-1)}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}clone(){return new this.constructor().copy(this)}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t===void 0&&(console.warn("THREE.Ray: .at() target is now required"),t=new Q),t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,af)),this}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),t=new Q),t.subVectors(e,this.origin);const r=t.dot(this.direction);return r<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(r).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=af.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(af.copy(this.direction).multiplyScalar(t).add(this.origin),af.distanceToSquared(e))}distanceSqToSegment(e,t,r,i){aP.copy(e).add(t).multiplyScalar(.5),OT.copy(t).sub(e).normalize(),fd.copy(this.origin).sub(aP);const s=e.distanceTo(t)*.5,o=-this.direction.dot(OT),a=fd.dot(this.direction),l=-fd.dot(OT),c=fd.lengthSq(),u=Math.abs(1-o*o);let h,f,d,p;if(u>0)if(h=o*l-a,f=o*a-l,p=s*u,h>=0)if(f>=-p)if(f<=p){const m=1/u;h*=m,f*=m,d=h*(h+o*f+2*a)+f*(o*h+f+2*l)+c}else f=s,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+c;else f=-s,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+c;else f<=-p?(h=Math.max(0,-(-o*s+a)),f=h>0?-s:Math.min(Math.max(-s,-l),s),d=-h*h+f*(f+2*l)+c):f<=p?(h=0,f=Math.min(Math.max(-s,-l),s),d=f*(f+2*l)+c):(h=Math.max(0,-(o*s+a)),f=h>0?s:Math.min(Math.max(-s,-l),s),d=-h*h+f*(f+2*l)+c);else f=o>0?-s:s,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+c;return r&&r.copy(this.direction).multiplyScalar(h).add(this.origin),i&&i.copy(OT).multiplyScalar(f).add(aP),d}intersectSphere(e,t){af.subVectors(e.center,this.origin);const r=af.dot(this.direction),i=af.dot(af)-r*r,s=e.radius*e.radius;if(i>s)return null;const o=Math.sqrt(s-i),a=r-o,l=r+o;return a<0&&l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const r=-(this.origin.dot(e.normal)+e.constant)/t;return r>=0?r:null}intersectPlane(e,t){const r=this.distanceToPlane(e);return r===null?null:this.at(r,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let r,i,s,o,a,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,f=this.origin;return c>=0?(r=(e.min.x-f.x)*c,i=(e.max.x-f.x)*c):(r=(e.max.x-f.x)*c,i=(e.min.x-f.x)*c),u>=0?(s=(e.min.y-f.y)*u,o=(e.max.y-f.y)*u):(s=(e.max.y-f.y)*u,o=(e.min.y-f.y)*u),r>o||s>i||((s>r||r!==r)&&(r=s),(o<i||i!==i)&&(i=o),h>=0?(a=(e.min.z-f.z)*h,l=(e.max.z-f.z)*h):(a=(e.max.z-f.z)*h,l=(e.min.z-f.z)*h),r>l||a>i)||((a>r||r!==r)&&(r=a),(l<i||i!==i)&&(i=l),i<0)?null:this.at(r>=0?r:i,t)}intersectsBox(e){return this.intersectBox(e,af)!==null}intersectTriangle(e,t,r,i,s){lP.subVectors(t,e),FT.subVectors(r,e),cP.crossVectors(lP,FT);let o=this.direction.dot(cP),a;if(o>0){if(i)return null;a=1}else if(o<0)a=-1,o=-o;else return null;fd.subVectors(this.origin,e);const l=a*this.direction.dot(FT.crossVectors(fd,FT));if(l<0)return null;const c=a*this.direction.dot(lP.cross(fd));if(c<0||l+c>o)return null;const u=-a*fd.dot(cP);return u<0?null:this.at(u/o,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}}class Zn{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,r,i,s,o,a,l,c,u,h,f,d,p,m,g){const y=this.elements;return y[0]=e,y[4]=t,y[8]=r,y[12]=i,y[1]=s,y[5]=o,y[9]=a,y[13]=l,y[2]=c,y[6]=u,y[10]=h,y[14]=f,y[3]=d,y[7]=p,y[11]=m,y[15]=g,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Zn().fromArray(this.elements)}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],t[9]=r[9],t[10]=r[10],t[11]=r[11],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15],this}copyPosition(e){const t=this.elements,r=e.elements;return t[12]=r[12],t[13]=r[13],t[14]=r[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,r){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),r.setFromMatrixColumn(this,2),this}makeBasis(e,t,r){return this.set(e.x,t.x,r.x,0,e.y,t.y,r.y,0,e.z,t.z,r.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,r=e.elements,i=1/G0.setFromMatrixColumn(e,0).length(),s=1/G0.setFromMatrixColumn(e,1).length(),o=1/G0.setFromMatrixColumn(e,2).length();return t[0]=r[0]*i,t[1]=r[1]*i,t[2]=r[2]*i,t[3]=0,t[4]=r[4]*s,t[5]=r[5]*s,t[6]=r[6]*s,t[7]=0,t[8]=r[8]*o,t[9]=r[9]*o,t[10]=r[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,r=e.x,i=e.y,s=e.z,o=Math.cos(r),a=Math.sin(r),l=Math.cos(i),c=Math.sin(i),u=Math.cos(s),h=Math.sin(s);if(e.order==="XYZ"){const f=o*u,d=o*h,p=a*u,m=a*h;t[0]=l*u,t[4]=-l*h,t[8]=c,t[1]=d+p*c,t[5]=f-m*c,t[9]=-a*l,t[2]=m-f*c,t[6]=p+d*c,t[10]=o*l}else if(e.order==="YXZ"){const f=l*u,d=l*h,p=c*u,m=c*h;t[0]=f+m*a,t[4]=p*a-d,t[8]=o*c,t[1]=o*h,t[5]=o*u,t[9]=-a,t[2]=d*a-p,t[6]=m+f*a,t[10]=o*l}else if(e.order==="ZXY"){const f=l*u,d=l*h,p=c*u,m=c*h;t[0]=f-m*a,t[4]=-o*h,t[8]=p+d*a,t[1]=d+p*a,t[5]=o*u,t[9]=m-f*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const f=o*u,d=o*h,p=a*u,m=a*h;t[0]=l*u,t[4]=p*c-d,t[8]=f*c+m,t[1]=l*h,t[5]=m*c+f,t[9]=d*c-p,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const f=o*l,d=o*c,p=a*l,m=a*c;t[0]=l*u,t[4]=m-f*h,t[8]=p*h+d,t[1]=h,t[5]=o*u,t[9]=-a*u,t[2]=-c*u,t[6]=d*h+p,t[10]=f-m*h}else if(e.order==="XZY"){const f=o*l,d=o*c,p=a*l,m=a*c;t[0]=l*u,t[4]=-h,t[8]=c*u,t[1]=f*h+m,t[5]=o*u,t[9]=d*h-p,t[2]=p*h-d,t[6]=a*u,t[10]=m*h+f}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(ddt,e,pdt)}lookAt(e,t,r){const i=this.elements;return ul.subVectors(e,t),ul.lengthSq()===0&&(ul.z=1),ul.normalize(),dd.crossVectors(r,ul),dd.lengthSq()===0&&(Math.abs(r.z)===1?ul.x+=1e-4:ul.z+=1e-4,ul.normalize(),dd.crossVectors(r,ul)),dd.normalize(),LT.crossVectors(ul,dd),i[0]=dd.x,i[4]=LT.x,i[8]=ul.x,i[1]=dd.y,i[5]=LT.y,i[9]=ul.y,i[2]=dd.z,i[6]=LT.z,i[10]=ul.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,i=t.elements,s=this.elements,o=r[0],a=r[4],l=r[8],c=r[12],u=r[1],h=r[5],f=r[9],d=r[13],p=r[2],m=r[6],g=r[10],y=r[14],b=r[3],_=r[7],w=r[11],S=r[15],C=i[0],k=i[4],A=i[8],M=i[12],E=i[1],N=i[5],O=i[9],R=i[13],D=i[2],z=i[6],B=i[10],X=i[14],H=i[3],te=i[7],ge=i[11],ae=i[15];return s[0]=o*C+a*E+l*D+c*H,s[4]=o*k+a*N+l*z+c*te,s[8]=o*A+a*O+l*B+c*ge,s[12]=o*M+a*R+l*X+c*ae,s[1]=u*C+h*E+f*D+d*H,s[5]=u*k+h*N+f*z+d*te,s[9]=u*A+h*O+f*B+d*ge,s[13]=u*M+h*R+f*X+d*ae,s[2]=p*C+m*E+g*D+y*H,s[6]=p*k+m*N+g*z+y*te,s[10]=p*A+m*O+g*B+y*ge,s[14]=p*M+m*R+g*X+y*ae,s[3]=b*C+_*E+w*D+S*H,s[7]=b*k+_*N+w*z+S*te,s[11]=b*A+_*O+w*B+S*ge,s[15]=b*M+_*R+w*X+S*ae,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[4],i=e[8],s=e[12],o=e[1],a=e[5],l=e[9],c=e[13],u=e[2],h=e[6],f=e[10],d=e[14],p=e[3],m=e[7],g=e[11],y=e[15];return p*(+s*l*h-i*c*h-s*a*f+r*c*f+i*a*d-r*l*d)+m*(+t*l*d-t*c*f+s*o*f-i*o*d+i*c*u-s*l*u)+g*(+t*c*h-t*a*d-s*o*h+r*o*d+s*a*u-r*c*u)+y*(-i*a*u-t*l*h+t*a*f+i*o*h-r*o*f+r*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,r){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=r),this}invert(){const e=this.elements,t=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],f=e[10],d=e[11],p=e[12],m=e[13],g=e[14],y=e[15],b=h*g*c-m*f*c+m*l*d-a*g*d-h*l*y+a*f*y,_=p*f*c-u*g*c-p*l*d+o*g*d+u*l*y-o*f*y,w=u*m*c-p*h*c+p*a*d-o*m*d-u*a*y+o*h*y,S=p*h*l-u*m*l-p*a*f+o*m*f+u*a*g-o*h*g,C=t*b+r*_+i*w+s*S;if(C===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const k=1/C;return e[0]=b*k,e[1]=(m*f*s-h*g*s-m*i*d+r*g*d+h*i*y-r*f*y)*k,e[2]=(a*g*s-m*l*s+m*i*c-r*g*c-a*i*y+r*l*y)*k,e[3]=(h*l*s-a*f*s-h*i*c+r*f*c+a*i*d-r*l*d)*k,e[4]=_*k,e[5]=(u*g*s-p*f*s+p*i*d-t*g*d-u*i*y+t*f*y)*k,e[6]=(p*l*s-o*g*s-p*i*c+t*g*c+o*i*y-t*l*y)*k,e[7]=(o*f*s-u*l*s+u*i*c-t*f*c-o*i*d+t*l*d)*k,e[8]=w*k,e[9]=(p*h*s-u*m*s-p*r*d+t*m*d+u*r*y-t*h*y)*k,e[10]=(o*m*s-p*a*s+p*r*c-t*m*c-o*r*y+t*a*y)*k,e[11]=(u*a*s-o*h*s-u*r*c+t*h*c+o*r*d-t*a*d)*k,e[12]=S*k,e[13]=(u*m*i-p*h*i+p*r*f-t*m*f-u*r*g+t*h*g)*k,e[14]=(p*a*i-o*m*i-p*r*l+t*m*l+o*r*g-t*a*g)*k,e[15]=(o*h*i-u*a*i+u*r*l-t*h*l-o*r*f+t*a*f)*k,this}scale(e){const t=this.elements,r=e.x,i=e.y,s=e.z;return t[0]*=r,t[4]*=i,t[8]*=s,t[1]*=r,t[5]*=i,t[9]*=s,t[2]*=r,t[6]*=i,t[10]*=s,t[3]*=r,t[7]*=i,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,r,i))}makeTranslation(e,t,r){return this.set(1,0,0,e,0,1,0,t,0,0,1,r,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),r=Math.sin(e);return this.set(1,0,0,0,0,t,-r,0,0,r,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,0,r,0,0,1,0,0,-r,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,-r,0,0,r,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const r=Math.cos(t),i=Math.sin(t),s=1-r,o=e.x,a=e.y,l=e.z,c=s*o,u=s*a;return this.set(c*o+r,c*a-i*l,c*l+i*a,0,c*a+i*l,u*a+r,u*l-i*o,0,c*l-i*a,u*l+i*o,s*l*l+r,0,0,0,0,1),this}makeScale(e,t,r){return this.set(e,0,0,0,0,t,0,0,0,0,r,0,0,0,0,1),this}makeShear(e,t,r){return this.set(1,t,r,0,e,1,r,0,e,t,1,0,0,0,0,1),this}compose(e,t,r){const i=this.elements,s=t._x,o=t._y,a=t._z,l=t._w,c=s+s,u=o+o,h=a+a,f=s*c,d=s*u,p=s*h,m=o*u,g=o*h,y=a*h,b=l*c,_=l*u,w=l*h,S=r.x,C=r.y,k=r.z;return i[0]=(1-(m+y))*S,i[1]=(d+w)*S,i[2]=(p-_)*S,i[3]=0,i[4]=(d-w)*C,i[5]=(1-(f+y))*C,i[6]=(g+b)*C,i[7]=0,i[8]=(p+_)*k,i[9]=(g-b)*k,i[10]=(1-(f+m))*k,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,r){const i=this.elements;let s=G0.set(i[0],i[1],i[2]).length();const o=G0.set(i[4],i[5],i[6]).length(),a=G0.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),e.x=i[12],e.y=i[13],e.z=i[14],Qc.copy(this);const c=1/s,u=1/o,h=1/a;return Qc.elements[0]*=c,Qc.elements[1]*=c,Qc.elements[2]*=c,Qc.elements[4]*=u,Qc.elements[5]*=u,Qc.elements[6]*=u,Qc.elements[8]*=h,Qc.elements[9]*=h,Qc.elements[10]*=h,t.setFromRotationMatrix(Qc),r.x=s,r.y=o,r.z=a,this}makePerspective(e,t,r,i,s,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,l=2*s/(t-e),c=2*s/(r-i),u=(t+e)/(t-e),h=(r+i)/(r-i),f=-(o+s)/(o-s),d=-2*o*s/(o-s);return a[0]=l,a[4]=0,a[8]=u,a[12]=0,a[1]=0,a[5]=c,a[9]=h,a[13]=0,a[2]=0,a[6]=0,a[10]=f,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,r,i,s,o){const a=this.elements,l=1/(t-e),c=1/(r-i),u=1/(o-s),h=(t+e)*l,f=(r+i)*c,d=(o+s)*u;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-h,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-f,a[2]=0,a[6]=0,a[10]=-2*u,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,r=e.elements;for(let i=0;i<16;i++)if(t[i]!==r[i])return!1;return!0}fromArray(e,t=0){for(let r=0;r<16;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e[t+9]=r[9],e[t+10]=r[10],e[t+11]=r[11],e[t+12]=r[12],e[t+13]=r[13],e[t+14]=r[14],e[t+15]=r[15],e}}const G0=new Q,Qc=new Zn,ddt=new Q(0,0,0),pdt=new Q(1,1,1),dd=new Q,LT=new Q,ul=new Q;class ax{constructor(e=0,t=0,r=0,i=ax.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=e,this._y=t,this._z=r,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,r,i){return this._x=e,this._y=t,this._z=r,this._order=i||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t,r){const i=In.clamp,s=e.elements,o=s[0],a=s[4],l=s[8],c=s[1],u=s[5],h=s[9],f=s[2],d=s[6],p=s[10];switch(t=t||this._order,t){case"XYZ":this._y=Math.asin(i(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,p),this._z=Math.atan2(-a,o)):(this._x=Math.atan2(d,u),this._z=0);break;case"YXZ":this._x=Math.asin(-i(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(l,p),this._z=Math.atan2(c,u)):(this._y=Math.atan2(-f,o),this._z=0);break;case"ZXY":this._x=Math.asin(i(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-f,p),this._z=Math.atan2(-a,u)):(this._y=0,this._z=Math.atan2(c,o));break;case"ZYX":this._y=Math.asin(-i(f,-1,1)),Math.abs(f)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(c,o)):(this._x=0,this._z=Math.atan2(-a,u));break;case"YZX":this._z=Math.asin(i(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-h,u),this._y=Math.atan2(-f,o)):(this._x=0,this._y=Math.atan2(l,p));break;case"XZY":this._z=Math.asin(-i(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(d,u),this._y=Math.atan2(l,o)):(this._x=Math.atan2(-h,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,r!==!1&&this._onChangeCallback(),this}setFromQuaternion(e,t,r){return Zj.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Zj,t,r)}setFromVector3(e,t){return this.set(e.x,e.y,e.z,t||this._order)}reorder(e){return Jj.setFromEuler(this),this.setFromQuaternion(Jj,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new Q(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}ax.DefaultOrder="XYZ";ax.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];const Zj=new Zn,Jj=new co;class eV{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}}let mdt=0;const Qj=new Q,j0=new co,lf=new Zn,zT=new Q,e1=new Q,gdt=new Q,ydt=new co,e8=new Q(1,0,0),t8=new Q(0,1,0),n8=new Q(0,0,1),bdt={type:"added"},r8={type:"removed"};function rn(){Object.defineProperty(this,"id",{value:mdt++}),this.uuid=In.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=rn.DefaultUp.clone();const n=new Q,e=new ax,t=new co,r=new Q(1,1,1);function i(){t.setFromEuler(e,!1)}function s(){e.setFromQuaternion(t,void 0,!1)}e._onChange(i),t._onChange(s),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:n},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:t},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Zn},normalMatrix:{value:new kl}}),this.matrix=new Zn,this.matrixWorld=new Zn,this.matrixAutoUpdate=rn.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new eV,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}rn.DefaultUp=new Q(0,1,0);rn.DefaultMatrixAutoUpdate=!0;rn.prototype=Object.assign(Object.create(Wu.prototype),{constructor:rn,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(n){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(n),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(n){return this.quaternion.premultiply(n),this},setRotationFromAxisAngle:function(n,e){this.quaternion.setFromAxisAngle(n,e)},setRotationFromEuler:function(n){this.quaternion.setFromEuler(n,!0)},setRotationFromMatrix:function(n){this.quaternion.setFromRotationMatrix(n)},setRotationFromQuaternion:function(n){this.quaternion.copy(n)},rotateOnAxis:function(n,e){return j0.setFromAxisAngle(n,e),this.quaternion.multiply(j0),this},rotateOnWorldAxis:function(n,e){return j0.setFromAxisAngle(n,e),this.quaternion.premultiply(j0),this},rotateX:function(n){return this.rotateOnAxis(e8,n)},rotateY:function(n){return this.rotateOnAxis(t8,n)},rotateZ:function(n){return this.rotateOnAxis(n8,n)},translateOnAxis:function(n,e){return Qj.copy(n).applyQuaternion(this.quaternion),this.position.add(Qj.multiplyScalar(e)),this},translateX:function(n){return this.translateOnAxis(e8,n)},translateY:function(n){return this.translateOnAxis(t8,n)},translateZ:function(n){return this.translateOnAxis(n8,n)},localToWorld:function(n){return n.applyMatrix4(this.matrixWorld)},worldToLocal:function(n){return n.applyMatrix4(lf.copy(this.matrixWorld).invert())},lookAt:function(n,e,t){n.isVector3?zT.copy(n):zT.set(n,e,t);const r=this.parent;this.updateWorldMatrix(!0,!1),e1.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?lf.lookAt(e1,zT,this.up):lf.lookAt(zT,e1,this.up),this.quaternion.setFromRotationMatrix(lf),r&&(lf.extractRotation(r.matrixWorld),j0.setFromRotationMatrix(lf),this.quaternion.premultiply(j0.invert()))},add:function(n){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return n===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",n),this):(n&&n.isObject3D?(n.parent!==null&&n.parent.remove(n),n.parent=this,this.children.push(n),n.dispatchEvent(bdt)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",n),this)},remove:function(n){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(n);return e!==-1&&(n.parent=null,this.children.splice(e,1),n.dispatchEvent(r8)),this},clear:function(){for(let n=0;n<this.children.length;n++){const e=this.children[n];e.parent=null,e.dispatchEvent(r8)}return this.children.length=0,this},attach:function(n){return this.updateWorldMatrix(!0,!1),lf.copy(this.matrixWorld).invert(),n.parent!==null&&(n.parent.updateWorldMatrix(!0,!1),lf.multiply(n.parent.matrixWorld)),n.applyMatrix4(lf),n.updateWorldMatrix(!1,!1),this.add(n),this},getObjectById:function(n){return this.getObjectByProperty("id",n)},getObjectByName:function(n){return this.getObjectByProperty("name",n)},getObjectByProperty:function(n,e){if(this[n]===e)return this;for(let t=0,r=this.children.length;t<r;t++){const s=this.children[t].getObjectByProperty(n,e);if(s!==void 0)return s}},getWorldPosition:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),n=new Q),this.updateWorldMatrix(!0,!1),n.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),n=new co),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(e1,n,gdt),n},getWorldScale:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),n=new Q),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(e1,ydt,n),n},getWorldDirection:function(n){n===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),n=new Q),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return n.set(e[8],e[9],e[10]).normalize()},raycast:function(){},traverse:function(n){n(this);const e=this.children;for(let t=0,r=e.length;t<r;t++)e[t].traverse(n)},traverseVisible:function(n){if(this.visible===!1)return;n(this);const e=this.children;for(let t=0,r=e.length;t<r;t++)e[t].traverseVisible(n)},traverseAncestors:function(n){const e=this.parent;e!==null&&(n(e),e.traverseAncestors(n))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(n){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||n)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,n=!0);const e=this.children;for(let t=0,r=e.length;t<r;t++)e[t].updateMatrixWorld(n)},updateWorldMatrix:function(n,e){const t=this.parent;if(n===!0&&t!==null&&t.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const r=this.children;for(let i=0,s=r.length;i<s;i++)r[i].updateWorldMatrix(!1,!0)}},toJSON:function(n){const e=n===void 0||typeof n=="string",t={};e&&(n={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},t.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON());function i(o,a){return o[a.uuid]===void 0&&(o[a.uuid]=a.toJSON(n)),a.uuid}if(this.isMesh||this.isLine||this.isPoints){r.geometry=i(n.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const a=o.shapes;if(Array.isArray(a))for(let l=0,c=a.length;l<c;l++){const u=a[l];i(n.shapes,u)}else i(n.shapes,a)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(i(n.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let a=0,l=this.material.length;a<l;a++)o.push(i(n.materials,this.material[a]));r.material=o}else r.material=i(n.materials,this.material);if(this.children.length>0){r.children=[];for(let o=0;o<this.children.length;o++)r.children.push(this.children[o].toJSON(n).object)}if(this.animations.length>0){r.animations=[];for(let o=0;o<this.animations.length;o++){const a=this.animations[o];r.animations.push(i(n.animations,a))}}if(e){const o=s(n.geometries),a=s(n.materials),l=s(n.textures),c=s(n.images),u=s(n.shapes),h=s(n.skeletons),f=s(n.animations);o.length>0&&(t.geometries=o),a.length>0&&(t.materials=a),l.length>0&&(t.textures=l),c.length>0&&(t.images=c),u.length>0&&(t.shapes=u),h.length>0&&(t.skeletons=h),f.length>0&&(t.animations=f)}return t.object=r,t;function s(o){const a=[];for(const l in o){const c=o[l];delete c.metadata,a.push(c)}return a}},clone:function(n){return new this.constructor().copy(this,n)},copy:function(n,e=!0){if(this.name=n.name,this.up.copy(n.up),this.position.copy(n.position),this.rotation.order=n.rotation.order,this.quaternion.copy(n.quaternion),this.scale.copy(n.scale),this.matrix.copy(n.matrix),this.matrixWorld.copy(n.matrixWorld),this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrixWorldNeedsUpdate=n.matrixWorldNeedsUpdate,this.layers.mask=n.layers.mask,this.visible=n.visible,this.castShadow=n.castShadow,this.receiveShadow=n.receiveShadow,this.frustumCulled=n.frustumCulled,this.renderOrder=n.renderOrder,this.userData=JSON.parse(JSON.stringify(n.userData)),e===!0)for(let t=0;t<n.children.length;t++){const r=n.children[t];this.add(r.clone())}return this}});const uP=new Q,vdt=new Q,wdt=new kl;class uh{constructor(e,t){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=e!==void 0?e:new Q(1,0,0),this.constant=t!==void 0?t:0}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,r,i){return this.normal.set(e,t,r),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,r){const i=uP.subVectors(r,t).cross(vdt.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}clone(){return new this.constructor().copy(this)}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),t=new Q),t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){t===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),t=new Q);const r=e.delta(uP),i=this.normal.dot(r);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):void 0;const s=-(e.start.dot(this.normal)+this.constant)/i;if(!(s<0||s>1))return t.copy(r).multiplyScalar(s).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),r=this.distanceToPoint(e.end);return t<0&&r>0||r<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new Q),e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const r=t||wdt.getNormalMatrix(e),i=this.coplanarPoint(uP).applyMatrix4(e),s=this.normal.applyMatrix3(r).normalize();return this.constant=-i.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}}const eu=new Q,cf=new Q,hP=new Q,uf=new Q,q0=new Q,X0=new Q,i8=new Q,fP=new Q,dP=new Q,pP=new Q;class Xo{constructor(e,t,r){this.a=e!==void 0?e:new Q,this.b=t!==void 0?t:new Q,this.c=r!==void 0?r:new Q}static getNormal(e,t,r,i){i===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),i=new Q),i.subVectors(r,t),eu.subVectors(e,t),i.cross(eu);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(e,t,r,i,s){eu.subVectors(i,t),cf.subVectors(r,t),hP.subVectors(e,t);const o=eu.dot(eu),a=eu.dot(cf),l=eu.dot(hP),c=cf.dot(cf),u=cf.dot(hP),h=o*c-a*a;if(s===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),s=new Q),h===0)return s.set(-2,-1,-1);const f=1/h,d=(c*l-a*u)*f,p=(o*u-a*l)*f;return s.set(1-d-p,p,d)}static containsPoint(e,t,r,i){return this.getBarycoord(e,t,r,i,uf),uf.x>=0&&uf.y>=0&&uf.x+uf.y<=1}static getUV(e,t,r,i,s,o,a,l){return this.getBarycoord(e,t,r,i,uf),l.set(0,0),l.addScaledVector(s,uf.x),l.addScaledVector(o,uf.y),l.addScaledVector(a,uf.z),l}static isFrontFacing(e,t,r,i){return eu.subVectors(r,t),cf.subVectors(e,t),eu.cross(cf).dot(i)<0}set(e,t,r){return this.a.copy(e),this.b.copy(t),this.c.copy(r),this}setFromPointsAndIndices(e,t,r,i){return this.a.copy(e[t]),this.b.copy(e[r]),this.c.copy(e[i]),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return eu.subVectors(this.c,this.b),cf.subVectors(this.a,this.b),eu.cross(cf).length()*.5}getMidpoint(e){return e===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new Q),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Xo.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new uh),e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Xo.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,r,i,s){return Xo.getUV(e,this.a,this.b,this.c,t,r,i,s)}containsPoint(e){return Xo.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Xo.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),t=new Q);const r=this.a,i=this.b,s=this.c;let o,a;q0.subVectors(i,r),X0.subVectors(s,r),fP.subVectors(e,r);const l=q0.dot(fP),c=X0.dot(fP);if(l<=0&&c<=0)return t.copy(r);dP.subVectors(e,i);const u=q0.dot(dP),h=X0.dot(dP);if(u>=0&&h<=u)return t.copy(i);const f=l*h-u*c;if(f<=0&&l>=0&&u<=0)return o=l/(l-u),t.copy(r).addScaledVector(q0,o);pP.subVectors(e,s);const d=q0.dot(pP),p=X0.dot(pP);if(p>=0&&d<=p)return t.copy(s);const m=d*c-l*p;if(m<=0&&c>=0&&p<=0)return a=c/(c-p),t.copy(r).addScaledVector(X0,a);const g=u*p-d*h;if(g<=0&&h-u>=0&&d-p>=0)return i8.subVectors(s,i),a=(h-u)/(h-u+(d-p)),t.copy(i).addScaledVector(i8,a);const y=1/(g+m+f);return o=m*y,a=f*y,t.copy(r).addScaledVector(q0,o).addScaledVector(X0,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const Kae={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},tu={h:0,s:0,l:0},BT={h:0,s:0,l:0};function mP(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}function gP(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function yP(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}class Gt{constructor(e,t,r){return Object.defineProperty(this,"isColor",{value:!0}),t===void 0&&r===void 0?this.set(e):this.setRGB(e,t,r)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this}setRGB(e,t,r){return this.r=e,this.g=t,this.b=r,this}setHSL(e,t,r){if(e=In.euclideanModulo(e,1),t=In.clamp(t,0,1),r=In.clamp(r,0,1),t===0)this.r=this.g=this.b=r;else{const i=r<=.5?r*(1+t):r+t-r*t,s=2*r-i;this.r=mP(s,i,e+1/3),this.g=mP(s,i,e),this.b=mP(s,i,e-1/3)}return this}setStyle(e){function t(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let i;const s=r[1],o=r[2];switch(s){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(i[1],10))/255,this.g=Math.min(255,parseInt(i[2],10))/255,this.b=Math.min(255,parseInt(i[3],10))/255,t(i[4]),this;if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(i[1],10))/100,this.g=Math.min(100,parseInt(i[2],10))/100,this.b=Math.min(100,parseInt(i[3],10))/100,t(i[4]),this;break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const a=parseFloat(i[1])/360,l=parseInt(i[2],10)/100,c=parseInt(i[3],10)/100;return t(i[4]),this.setHSL(a,l,c)}break}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const i=r[1],s=i.length;if(s===3)return this.r=parseInt(i.charAt(0)+i.charAt(0),16)/255,this.g=parseInt(i.charAt(1)+i.charAt(1),16)/255,this.b=parseInt(i.charAt(2)+i.charAt(2),16)/255,this;if(s===6)return this.r=parseInt(i.charAt(0)+i.charAt(1),16)/255,this.g=parseInt(i.charAt(2)+i.charAt(3),16)/255,this.b=parseInt(i.charAt(4)+i.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=Kae[e];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const r=t>0?1/t:1;return this.r=Math.pow(e.r,r),this.g=Math.pow(e.g,r),this.b=Math.pow(e.b,r),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=gP(e.r),this.g=gP(e.g),this.b=gP(e.b),this}copyLinearToSRGB(e){return this.r=yP(e.r),this.g=yP(e.g),this.b=yP(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){e===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const t=this.r,r=this.g,i=this.b,s=Math.max(t,r,i),o=Math.min(t,r,i);let a,l;const c=(o+s)/2;if(o===s)a=0,l=0;else{const u=s-o;switch(l=c<=.5?u/(s+o):u/(2-s-o),s){case t:a=(r-i)/u+(r<i?6:0);break;case r:a=(i-t)/u+2;break;case i:a=(t-r)/u+4;break}a/=6}return e.h=a,e.s=l,e.l=c,e}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(e,t,r){return this.getHSL(tu),tu.h+=e,tu.s+=t,tu.l+=r,this.setHSL(tu.h,tu.s,tu.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,r){return this.r=e.r+(t.r-e.r)*r,this.g=e.g+(t.g-e.g)*r,this.b=e.b+(t.b-e.b)*r,this}lerpHSL(e,t){this.getHSL(tu),e.getHSL(BT);const r=In.lerp(tu.h,BT.h,t),i=In.lerp(tu.s,BT.s,t),s=In.lerp(tu.l,BT.l,t);return this.setHSL(r,i,s),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Gt.NAMES=Kae;Gt.prototype.r=1;Gt.prototype.g=1;Gt.prototype.b=1;class tV{constructor(e,t,r,i,s,o=0){this.a=e,this.b=t,this.c=r,this.normal=i&&i.isVector3?i:new Q,this.vertexNormals=Array.isArray(i)?i:[],this.color=s&&s.isColor?s:new Gt,this.vertexColors=Array.isArray(s)?s:[],this.materialIndex=o}clone(){return new this.constructor().copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,r=e.vertexNormals.length;t<r;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,r=e.vertexColors.length;t<r;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}let xdt=0;function kn(){Object.defineProperty(this,"id",{value:xdt++}),this.uuid=In.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=Db,this.side=nx,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=q4,this.blendDst=X4,this.blendEquation=Pm,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=xA,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Xae,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=eI,this.stencilZFail=eI,this.stencilZPass=eI,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}kn.prototype=Object.assign(Object.create(Wu.prototype),{constructor:kn,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(n){if(n!==void 0)for(const e in n){const t=n[e];if(t===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=t===j4;continue}const r=this[e];if(r===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}r&&r.isColor?r.set(t):r&&r.isVector3&&t&&t.isVector3?r.copy(t):this[e]=t}},toJSON:function(n){const e=n===void 0||typeof n=="string";e&&(n={textures:{},images:{}});const t={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),this.color&&this.color.isColor&&(t.color=this.color.getHex()),this.roughness!==void 0&&(t.roughness=this.roughness),this.metalness!==void 0&&(t.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(t.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(t.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(t.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(t.specular=this.specular.getHex()),this.shininess!==void 0&&(t.shininess=this.shininess),this.clearcoat!==void 0&&(t.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(t.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(t.clearcoatMap=this.clearcoatMap.toJSON(n).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(t.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(n).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(t.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(n).uuid,t.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(t.map=this.map.toJSON(n).uuid),this.matcap&&this.matcap.isTexture&&(t.matcap=this.matcap.toJSON(n).uuid),this.alphaMap&&this.alphaMap.isTexture&&(t.alphaMap=this.alphaMap.toJSON(n).uuid),this.lightMap&&this.lightMap.isTexture&&(t.lightMap=this.lightMap.toJSON(n).uuid),this.aoMap&&this.aoMap.isTexture&&(t.aoMap=this.aoMap.toJSON(n).uuid,t.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(t.bumpMap=this.bumpMap.toJSON(n).uuid,t.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(t.normalMap=this.normalMap.toJSON(n).uuid,t.normalMapType=this.normalMapType,t.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(t.displacementMap=this.displacementMap.toJSON(n).uuid,t.displacementScale=this.displacementScale,t.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(t.roughnessMap=this.roughnessMap.toJSON(n).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(t.metalnessMap=this.metalnessMap.toJSON(n).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(t.emissiveMap=this.emissiveMap.toJSON(n).uuid),this.specularMap&&this.specularMap.isTexture&&(t.specularMap=this.specularMap.toJSON(n).uuid),this.envMap&&this.envMap.isTexture&&(t.envMap=this.envMap.toJSON(n).uuid,t.reflectivity=this.reflectivity,t.refractionRatio=this.refractionRatio,this.combine!==void 0&&(t.combine=this.combine),this.envMapIntensity!==void 0&&(t.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(t.gradientMap=this.gradientMap.toJSON(n).uuid),this.size!==void 0&&(t.size=this.size),this.sizeAttenuation!==void 0&&(t.sizeAttenuation=this.sizeAttenuation),this.blending!==Db&&(t.blending=this.blending),this.flatShading===!0&&(t.flatShading=this.flatShading),this.side!==nx&&(t.side=this.side),this.vertexColors&&(t.vertexColors=!0),this.opacity<1&&(t.opacity=this.opacity),this.transparent===!0&&(t.transparent=this.transparent),t.depthFunc=this.depthFunc,t.depthTest=this.depthTest,t.depthWrite=this.depthWrite,t.stencilWrite=this.stencilWrite,t.stencilWriteMask=this.stencilWriteMask,t.stencilFunc=this.stencilFunc,t.stencilRef=this.stencilRef,t.stencilFuncMask=this.stencilFuncMask,t.stencilFail=this.stencilFail,t.stencilZFail=this.stencilZFail,t.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(t.rotation=this.rotation),this.polygonOffset===!0&&(t.polygonOffset=!0),this.polygonOffsetFactor!==0&&(t.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(t.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(t.linewidth=this.linewidth),this.dashSize!==void 0&&(t.dashSize=this.dashSize),this.gapSize!==void 0&&(t.gapSize=this.gapSize),this.scale!==void 0&&(t.scale=this.scale),this.dithering===!0&&(t.dithering=!0),this.alphaTest>0&&(t.alphaTest=this.alphaTest),this.premultipliedAlpha===!0&&(t.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(t.wireframe=this.wireframe),this.wireframeLinewidth>1&&(t.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(t.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(t.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(t.morphTargets=!0),this.morphNormals===!0&&(t.morphNormals=!0),this.skinning===!0&&(t.skinning=!0),this.visible===!1&&(t.visible=!1),this.toneMapped===!1&&(t.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(t.userData=this.userData);function r(i){const s=[];for(const o in i){const a=i[o];delete a.metadata,s.push(a)}return s}if(e){const i=r(n.textures),s=r(n.images);i.length>0&&(t.textures=i),s.length>0&&(t.images=s)}return t},clone:function(){return new this.constructor().copy(this)},copy:function(n){this.name=n.name,this.fog=n.fog,this.blending=n.blending,this.side=n.side,this.flatShading=n.flatShading,this.vertexColors=n.vertexColors,this.opacity=n.opacity,this.transparent=n.transparent,this.blendSrc=n.blendSrc,this.blendDst=n.blendDst,this.blendEquation=n.blendEquation,this.blendSrcAlpha=n.blendSrcAlpha,this.blendDstAlpha=n.blendDstAlpha,this.blendEquationAlpha=n.blendEquationAlpha,this.depthFunc=n.depthFunc,this.depthTest=n.depthTest,this.depthWrite=n.depthWrite,this.stencilWriteMask=n.stencilWriteMask,this.stencilFunc=n.stencilFunc,this.stencilRef=n.stencilRef,this.stencilFuncMask=n.stencilFuncMask,this.stencilFail=n.stencilFail,this.stencilZFail=n.stencilZFail,this.stencilZPass=n.stencilZPass,this.stencilWrite=n.stencilWrite;const e=n.clippingPlanes;let t=null;if(e!==null){const r=e.length;t=new Array(r);for(let i=0;i!==r;++i)t[i]=e[i].clone()}return this.clippingPlanes=t,this.clipIntersection=n.clipIntersection,this.clipShadows=n.clipShadows,this.shadowSide=n.shadowSide,this.colorWrite=n.colorWrite,this.precision=n.precision,this.polygonOffset=n.polygonOffset,this.polygonOffsetFactor=n.polygonOffsetFactor,this.polygonOffsetUnits=n.polygonOffsetUnits,this.dithering=n.dithering,this.alphaTest=n.alphaTest,this.premultipliedAlpha=n.premultipliedAlpha,this.visible=n.visible,this.toneMapped=n.toneMapped,this.userData=JSON.parse(JSON.stringify(n.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Object.defineProperty(kn.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});function Dl(n){kn.call(this),this.type="MeshBasicMaterial",this.color=new Gt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=OC,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(n)}Dl.prototype=Object.create(kn.prototype);Dl.prototype.constructor=Dl;Dl.prototype.isMeshBasicMaterial=!0;Dl.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this};const ii=new Q,VT=new st;function Cn(n,e,t){if(Array.isArray(n))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=n,this.itemSize=e,this.count=n!==void 0?n.length/e:0,this.normalized=t===!0,this.usage=VC,this.updateRange={offset:0,count:-1},this.version=0}Object.defineProperty(Cn.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(Cn.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(n){return this.usage=n,this},copy:function(n){return this.name=n.name,this.array=new n.array.constructor(n.array),this.itemSize=n.itemSize,this.count=n.count,this.normalized=n.normalized,this.usage=n.usage,this},copyAt:function(n,e,t){n*=this.itemSize,t*=e.itemSize;for(let r=0,i=this.itemSize;r<i;r++)this.array[n+r]=e.array[t+r];return this},copyArray:function(n){return this.array.set(n),this},copyColorsArray:function(n){const e=this.array;let t=0;for(let r=0,i=n.length;r<i;r++){let s=n[r];s===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),s=new Gt),e[t++]=s.r,e[t++]=s.g,e[t++]=s.b}return this},copyVector2sArray:function(n){const e=this.array;let t=0;for(let r=0,i=n.length;r<i;r++){let s=n[r];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),s=new st),e[t++]=s.x,e[t++]=s.y}return this},copyVector3sArray:function(n){const e=this.array;let t=0;for(let r=0,i=n.length;r<i;r++){let s=n[r];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),s=new Q),e[t++]=s.x,e[t++]=s.y,e[t++]=s.z}return this},copyVector4sArray:function(n){const e=this.array;let t=0;for(let r=0,i=n.length;r<i;r++){let s=n[r];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),s=new Gr),e[t++]=s.x,e[t++]=s.y,e[t++]=s.z,e[t++]=s.w}return this},applyMatrix3:function(n){if(this.itemSize===2)for(let e=0,t=this.count;e<t;e++)VT.fromBufferAttribute(this,e),VT.applyMatrix3(n),this.setXY(e,VT.x,VT.y);else if(this.itemSize===3)for(let e=0,t=this.count;e<t;e++)ii.fromBufferAttribute(this,e),ii.applyMatrix3(n),this.setXYZ(e,ii.x,ii.y,ii.z);return this},applyMatrix4:function(n){for(let e=0,t=this.count;e<t;e++)ii.x=this.getX(e),ii.y=this.getY(e),ii.z=this.getZ(e),ii.applyMatrix4(n),this.setXYZ(e,ii.x,ii.y,ii.z);return this},applyNormalMatrix:function(n){for(let e=0,t=this.count;e<t;e++)ii.x=this.getX(e),ii.y=this.getY(e),ii.z=this.getZ(e),ii.applyNormalMatrix(n),this.setXYZ(e,ii.x,ii.y,ii.z);return this},transformDirection:function(n){for(let e=0,t=this.count;e<t;e++)ii.x=this.getX(e),ii.y=this.getY(e),ii.z=this.getZ(e),ii.transformDirection(n),this.setXYZ(e,ii.x,ii.y,ii.z);return this},set:function(n,e=0){return this.array.set(n,e),this},getX:function(n){return this.array[n*this.itemSize]},setX:function(n,e){return this.array[n*this.itemSize]=e,this},getY:function(n){return this.array[n*this.itemSize+1]},setY:function(n,e){return this.array[n*this.itemSize+1]=e,this},getZ:function(n){return this.array[n*this.itemSize+2]},setZ:function(n,e){return this.array[n*this.itemSize+2]=e,this},getW:function(n){return this.array[n*this.itemSize+3]},setW:function(n,e){return this.array[n*this.itemSize+3]=e,this},setXY:function(n,e,t){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this},setXYZ:function(n,e,t,r){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=r,this},setXYZW:function(n,e,t,r,i){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=r,this.array[n+3]=i,this},onUpload:function(n){return this.onUploadCallback=n,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}});function lS(n,e,t){Cn.call(this,new Int8Array(n),e,t)}lS.prototype=Object.create(Cn.prototype);lS.prototype.constructor=lS;function cS(n,e,t){Cn.call(this,new Uint8Array(n),e,t)}cS.prototype=Object.create(Cn.prototype);cS.prototype.constructor=cS;function uS(n,e,t){Cn.call(this,new Uint8ClampedArray(n),e,t)}uS.prototype=Object.create(Cn.prototype);uS.prototype.constructor=uS;function hS(n,e,t){Cn.call(this,new Int16Array(n),e,t)}hS.prototype=Object.create(Cn.prototype);hS.prototype.constructor=hS;function bg(n,e,t){Cn.call(this,new Uint16Array(n),e,t)}bg.prototype=Object.create(Cn.prototype);bg.prototype.constructor=bg;function fS(n,e,t){Cn.call(this,new Int32Array(n),e,t)}fS.prototype=Object.create(Cn.prototype);fS.prototype.constructor=fS;function vg(n,e,t){Cn.call(this,new Uint32Array(n),e,t)}vg.prototype=Object.create(Cn.prototype);vg.prototype.constructor=vg;function dS(n,e,t){Cn.call(this,new Uint16Array(n),e,t)}dS.prototype=Object.create(Cn.prototype);dS.prototype.constructor=dS;dS.prototype.isFloat16BufferAttribute=!0;function qt(n,e,t){Cn.call(this,new Float32Array(n),e,t)}qt.prototype=Object.create(Cn.prototype);qt.prototype.constructor=qt;function pS(n,e,t){Cn.call(this,new Float64Array(n),e,t)}pS.prototype=Object.create(Cn.prototype);pS.prototype.constructor=pS;function Yae(n){if(n.length===0)return-1/0;let e=n[0];for(let t=1,r=n.length;t<r;++t)n[t]>e&&(e=n[t]);return e}const _dt={Int8Array,Uint8Array,Uint8ClampedArray:typeof Uint8ClampedArray<"u"?Uint8ClampedArray:Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function $1(n,e){return new _dt[n](e)}let Sdt=0;const Qu=new Zn,bP=new rn,K0=new Q,hl=new qf,t1=new qf,no=new Q;function un(){Object.defineProperty(this,"id",{value:Sdt++}),this.uuid=In.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}un.prototype=Object.assign(Object.create(Wu.prototype),{constructor:un,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(n){return Array.isArray(n)?this.index=new(Yae(n)>65535?vg:bg)(n,1):this.index=n,this},getAttribute:function(n){return this.attributes[n]},setAttribute:function(n,e){return this.attributes[n]=e,this},deleteAttribute:function(n){return delete this.attributes[n],this},hasAttribute:function(n){return this.attributes[n]!==void 0},addGroup:function(n,e,t=0){this.groups.push({start:n,count:e,materialIndex:t})},clearGroups:function(){this.groups=[]},setDrawRange:function(n,e){this.drawRange.start=n,this.drawRange.count=e},applyMatrix4:function(n){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(n),e.needsUpdate=!0);const t=this.attributes.normal;if(t!==void 0){const i=new kl().getNormalMatrix(n);t.applyNormalMatrix(i),t.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(n),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this},rotateX:function(n){return Qu.makeRotationX(n),this.applyMatrix4(Qu),this},rotateY:function(n){return Qu.makeRotationY(n),this.applyMatrix4(Qu),this},rotateZ:function(n){return Qu.makeRotationZ(n),this.applyMatrix4(Qu),this},translate:function(n,e,t){return Qu.makeTranslation(n,e,t),this.applyMatrix4(Qu),this},scale:function(n,e,t){return Qu.makeScale(n,e,t),this.applyMatrix4(Qu),this},lookAt:function(n){return bP.lookAt(n),bP.updateMatrix(),this.applyMatrix4(bP.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(K0).negate(),this.translate(K0.x,K0.y,K0.z),this},setFromPoints:function(n){const e=[];for(let t=0,r=n.length;t<r;t++){const i=n[t];e.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new qt(e,3)),this},computeBoundingBox:function(){this.boundingBox===null&&(this.boundingBox=new qf);const n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new Q(-1/0,-1/0,-1/0),new Q(1/0,1/0,1/0));return}if(n!==void 0){if(this.boundingBox.setFromBufferAttribute(n),e)for(let t=0,r=e.length;t<r;t++){const i=e[t];hl.setFromBufferAttribute(i),this.morphTargetsRelative?(no.addVectors(this.boundingBox.min,hl.min),this.boundingBox.expandByPoint(no),no.addVectors(this.boundingBox.max,hl.max),this.boundingBox.expandByPoint(no)):(this.boundingBox.expandByPoint(hl.min),this.boundingBox.expandByPoint(hl.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){this.boundingSphere===null&&(this.boundingSphere=new Op);const n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new Q,1/0);return}if(n){const t=this.boundingSphere.center;if(hl.setFromBufferAttribute(n),e)for(let i=0,s=e.length;i<s;i++){const o=e[i];t1.setFromBufferAttribute(o),this.morphTargetsRelative?(no.addVectors(hl.min,t1.min),hl.expandByPoint(no),no.addVectors(hl.max,t1.max),hl.expandByPoint(no)):(hl.expandByPoint(t1.min),hl.expandByPoint(t1.max))}hl.getCenter(t);let r=0;for(let i=0,s=n.count;i<s;i++)no.fromBufferAttribute(n,i),r=Math.max(r,t.distanceToSquared(no));if(e)for(let i=0,s=e.length;i<s;i++){const o=e[i],a=this.morphTargetsRelative;for(let l=0,c=o.count;l<c;l++)no.fromBufferAttribute(o,l),a&&(K0.fromBufferAttribute(n,l),no.add(K0)),r=Math.max(r,t.distanceToSquared(no))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeTangents:function(){const n=this.index,e=this.attributes;if(n===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const t=n.array,r=e.position.array,i=e.normal.array,s=e.uv.array,o=r.length/3;e.tangent===void 0&&this.setAttribute("tangent",new Cn(new Float32Array(4*o),4));const a=e.tangent.array,l=[],c=[];for(let M=0;M<o;M++)l[M]=new Q,c[M]=new Q;const u=new Q,h=new Q,f=new Q,d=new st,p=new st,m=new st,g=new Q,y=new Q;function b(M,E,N){u.fromArray(r,M*3),h.fromArray(r,E*3),f.fromArray(r,N*3),d.fromArray(s,M*2),p.fromArray(s,E*2),m.fromArray(s,N*2),h.sub(u),f.sub(u),p.sub(d),m.sub(d);const O=1/(p.x*m.y-m.x*p.y);isFinite(O)&&(g.copy(h).multiplyScalar(m.y).addScaledVector(f,-p.y).multiplyScalar(O),y.copy(f).multiplyScalar(p.x).addScaledVector(h,-m.x).multiplyScalar(O),l[M].add(g),l[E].add(g),l[N].add(g),c[M].add(y),c[E].add(y),c[N].add(y))}let _=this.groups;_.length===0&&(_=[{start:0,count:t.length}]);for(let M=0,E=_.length;M<E;++M){const N=_[M],O=N.start,R=N.count;for(let D=O,z=O+R;D<z;D+=3)b(t[D+0],t[D+1],t[D+2])}const w=new Q,S=new Q,C=new Q,k=new Q;function A(M){C.fromArray(i,M*3),k.copy(C);const E=l[M];w.copy(E),w.sub(C.multiplyScalar(C.dot(E))).normalize(),S.crossVectors(k,E);const O=S.dot(c[M])<0?-1:1;a[M*4]=w.x,a[M*4+1]=w.y,a[M*4+2]=w.z,a[M*4+3]=O}for(let M=0,E=_.length;M<E;++M){const N=_[M],O=N.start,R=N.count;for(let D=O,z=O+R;D<z;D+=3)A(t[D+0]),A(t[D+1]),A(t[D+2])}},computeVertexNormals:function(){const n=this.index,e=this.getAttribute("position");if(e!==void 0){let t=this.getAttribute("normal");if(t===void 0)t=new Cn(new Float32Array(e.count*3),3),this.setAttribute("normal",t);else for(let h=0,f=t.count;h<f;h++)t.setXYZ(h,0,0,0);const r=new Q,i=new Q,s=new Q,o=new Q,a=new Q,l=new Q,c=new Q,u=new Q;if(n)for(let h=0,f=n.count;h<f;h+=3){const d=n.getX(h+0),p=n.getX(h+1),m=n.getX(h+2);r.fromBufferAttribute(e,d),i.fromBufferAttribute(e,p),s.fromBufferAttribute(e,m),c.subVectors(s,i),u.subVectors(r,i),c.cross(u),o.fromBufferAttribute(t,d),a.fromBufferAttribute(t,p),l.fromBufferAttribute(t,m),o.add(c),a.add(c),l.add(c),t.setXYZ(d,o.x,o.y,o.z),t.setXYZ(p,a.x,a.y,a.z),t.setXYZ(m,l.x,l.y,l.z)}else for(let h=0,f=e.count;h<f;h+=3)r.fromBufferAttribute(e,h+0),i.fromBufferAttribute(e,h+1),s.fromBufferAttribute(e,h+2),c.subVectors(s,i),u.subVectors(r,i),c.cross(u),t.setXYZ(h+0,c.x,c.y,c.z),t.setXYZ(h+1,c.x,c.y,c.z),t.setXYZ(h+2,c.x,c.y,c.z);this.normalizeNormals(),t.needsUpdate=!0}},merge:function(n,e){if(!(n&&n.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",n);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const t=this.attributes;for(const r in t){if(n.attributes[r]===void 0)continue;const s=t[r].array,o=n.attributes[r],a=o.array,l=o.itemSize*e,c=Math.min(a.length,s.length-l);for(let u=0,h=l;u<c;u++,h++)s[h]=a[u]}return this},normalizeNormals:function(){const n=this.attributes.normal;for(let e=0,t=n.count;e<t;e++)no.fromBufferAttribute(n,e),no.normalize(),n.setXYZ(e,no.x,no.y,no.z)},toNonIndexed:function(){function n(o,a){const l=o.array,c=o.itemSize,u=o.normalized,h=new l.constructor(a.length*c);let f=0,d=0;for(let p=0,m=a.length;p<m;p++){f=a[p]*c;for(let g=0;g<c;g++)h[d++]=l[f++]}return new Cn(h,c,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new un,t=this.index.array,r=this.attributes;for(const o in r){const a=r[o],l=n(a,t);e.setAttribute(o,l)}const i=this.morphAttributes;for(const o in i){const a=[],l=i[o];for(let c=0,u=l.length;c<u;c++){const h=l[c],f=n(h,t);a.push(f)}e.morphAttributes[o]=a}e.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let o=0,a=s.length;o<a;o++){const l=s[o];e.addGroup(l.start,l.count,l.materialIndex)}return e},toJSON:function(){const n={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),Object.keys(this.userData).length>0&&(n.userData=this.userData),this.parameters!==void 0){const a=this.parameters;for(const l in a)a[l]!==void 0&&(n[l]=a[l]);return n}n.data={attributes:{}};const e=this.index;e!==null&&(n.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const t=this.attributes;for(const a in t){const l=t[a],c=l.toJSON(n.data);l.name!==""&&(c.name=l.name),n.data.attributes[a]=c}const r={};let i=!1;for(const a in this.morphAttributes){const l=this.morphAttributes[a],c=[];for(let u=0,h=l.length;u<h;u++){const f=l[u],d=f.toJSON(n.data);f.name!==""&&(d.name=f.name),c.push(d)}c.length>0&&(r[a]=c,i=!0)}i&&(n.data.morphAttributes=r,n.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(n.data.groups=JSON.parse(JSON.stringify(s)));const o=this.boundingSphere;return o!==null&&(n.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),n},clone:function(){return new un().copy(this)},copy:function(n){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=n.name;const t=n.index;t!==null&&this.setIndex(t.clone(e));const r=n.attributes;for(const l in r){const c=r[l];this.setAttribute(l,c.clone(e))}const i=n.morphAttributes;for(const l in i){const c=[],u=i[l];for(let h=0,f=u.length;h<f;h++)c.push(u[h].clone(e));this.morphAttributes[l]=c}this.morphTargetsRelative=n.morphTargetsRelative;const s=n.groups;for(let l=0,c=s.length;l<c;l++){const u=s[l];this.addGroup(u.start,u.count,u.materialIndex)}const o=n.boundingBox;o!==null&&(this.boundingBox=o.clone());const a=n.boundingSphere;return a!==null&&(this.boundingSphere=a.clone()),this.drawRange.start=n.drawRange.start,this.drawRange.count=n.drawRange.count,this.userData=n.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const s8=new Zn,Y0=new ox,vP=new Op,pd=new Q,md=new Q,gd=new Q,wP=new Q,xP=new Q,_P=new Q,UT=new Q,WT=new Q,HT=new Q,GT=new st,jT=new st,qT=new st,SP=new Q,XT=new Q;function ui(n=new un,e=new Dl){rn.call(this),this.type="Mesh",this.geometry=n,this.material=e,this.updateMorphTargets()}ui.prototype=Object.assign(Object.create(rn.prototype),{constructor:ui,isMesh:!0,copy:function(n){return rn.prototype.copy.call(this,n),n.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=n.morphTargetInfluences.slice()),n.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},n.morphTargetDictionary)),this.material=n.material,this.geometry=n.geometry,this},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const r=e[t[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,s=r.length;i<s;i++){const o=r[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=i}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(n,e){const t=this.geometry,r=this.material,i=this.matrixWorld;if(r===void 0||(t.boundingSphere===null&&t.computeBoundingSphere(),vP.copy(t.boundingSphere),vP.applyMatrix4(i),n.ray.intersectsSphere(vP)===!1)||(s8.copy(i).invert(),Y0.copy(n.ray).applyMatrix4(s8),t.boundingBox!==null&&Y0.intersectsBox(t.boundingBox)===!1))return;let s;if(t.isBufferGeometry){const o=t.index,a=t.attributes.position,l=t.morphAttributes.position,c=t.morphTargetsRelative,u=t.attributes.uv,h=t.attributes.uv2,f=t.groups,d=t.drawRange;if(o!==null)if(Array.isArray(r))for(let p=0,m=f.length;p<m;p++){const g=f[p],y=r[g.materialIndex],b=Math.max(g.start,d.start),_=Math.min(g.start+g.count,d.start+d.count);for(let w=b,S=_;w<S;w+=3){const C=o.getX(w),k=o.getX(w+1),A=o.getX(w+2);s=KT(this,y,n,Y0,a,l,c,u,h,C,k,A),s&&(s.faceIndex=Math.floor(w/3),s.face.materialIndex=g.materialIndex,e.push(s))}}else{const p=Math.max(0,d.start),m=Math.min(o.count,d.start+d.count);for(let g=p,y=m;g<y;g+=3){const b=o.getX(g),_=o.getX(g+1),w=o.getX(g+2);s=KT(this,r,n,Y0,a,l,c,u,h,b,_,w),s&&(s.faceIndex=Math.floor(g/3),e.push(s))}}else if(a!==void 0)if(Array.isArray(r))for(let p=0,m=f.length;p<m;p++){const g=f[p],y=r[g.materialIndex],b=Math.max(g.start,d.start),_=Math.min(g.start+g.count,d.start+d.count);for(let w=b,S=_;w<S;w+=3){const C=w,k=w+1,A=w+2;s=KT(this,y,n,Y0,a,l,c,u,h,C,k,A),s&&(s.faceIndex=Math.floor(w/3),s.face.materialIndex=g.materialIndex,e.push(s))}}else{const p=Math.max(0,d.start),m=Math.min(a.count,d.start+d.count);for(let g=p,y=m;g<y;g+=3){const b=g,_=g+1,w=g+2;s=KT(this,r,n,Y0,a,l,c,u,h,b,_,w),s&&(s.faceIndex=Math.floor(g/3),e.push(s))}}}else t.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}});function Cdt(n,e,t,r,i,s,o,a){let l;if(e.side===ms?l=r.intersectTriangle(o,s,i,!0,a):l=r.intersectTriangle(i,s,o,e.side!==DC,a),l===null)return null;XT.copy(a),XT.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(XT);return c<t.near||c>t.far?null:{distance:c,point:XT.clone(),object:n}}function KT(n,e,t,r,i,s,o,a,l,c,u,h){pd.fromBufferAttribute(i,c),md.fromBufferAttribute(i,u),gd.fromBufferAttribute(i,h);const f=n.morphTargetInfluences;if(e.morphTargets&&s&&f){UT.set(0,0,0),WT.set(0,0,0),HT.set(0,0,0);for(let p=0,m=s.length;p<m;p++){const g=f[p],y=s[p];g!==0&&(wP.fromBufferAttribute(y,c),xP.fromBufferAttribute(y,u),_P.fromBufferAttribute(y,h),o?(UT.addScaledVector(wP,g),WT.addScaledVector(xP,g),HT.addScaledVector(_P,g)):(UT.addScaledVector(wP.sub(pd),g),WT.addScaledVector(xP.sub(md),g),HT.addScaledVector(_P.sub(gd),g)))}pd.add(UT),md.add(WT),gd.add(HT)}n.isSkinnedMesh&&(n.boneTransform(c,pd),n.boneTransform(u,md),n.boneTransform(h,gd));const d=Cdt(n,e,t,r,pd,md,gd,SP);if(d){a&&(GT.fromBufferAttribute(a,c),jT.fromBufferAttribute(a,u),qT.fromBufferAttribute(a,h),d.uv=Xo.getUV(SP,pd,md,gd,GT,jT,qT,new st)),l&&(GT.fromBufferAttribute(l,c),jT.fromBufferAttribute(l,u),qT.fromBufferAttribute(l,h),d.uv2=Xo.getUV(SP,pd,md,gd,GT,jT,qT,new st));const p=new tV(c,u,h);Xo.getNormal(pd,md,gd,p.normal),d.face=p}return d}class wg extends un{constructor(e=1,t=1,r=1,i=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:r,widthSegments:i,heightSegments:s,depthSegments:o};const a=this;i=Math.floor(i),s=Math.floor(s),o=Math.floor(o);const l=[],c=[],u=[],h=[];let f=0,d=0;p("z","y","x",-1,-1,r,t,e,o,s,0),p("z","y","x",1,-1,r,t,-e,o,s,1),p("x","z","y",1,1,e,r,t,i,o,2),p("x","z","y",1,-1,e,r,-t,i,o,3),p("x","y","z",1,-1,e,t,r,i,s,4),p("x","y","z",-1,-1,e,t,-r,i,s,5),this.setIndex(l),this.setAttribute("position",new qt(c,3)),this.setAttribute("normal",new qt(u,3)),this.setAttribute("uv",new qt(h,2));function p(m,g,y,b,_,w,S,C,k,A,M){const E=w/k,N=S/A,O=w/2,R=S/2,D=C/2,z=k+1,B=A+1;let X=0,H=0;const te=new Q;for(let ge=0;ge<B;ge++){const ae=ge*N-R;for(let Ne=0;Ne<z;Ne++){const Te=Ne*E-O;te[m]=Te*b,te[g]=ae*_,te[y]=D,c.push(te.x,te.y,te.z),te[m]=0,te[g]=0,te[y]=C>0?1:-1,u.push(te.x,te.y,te.z),h.push(Ne/k),h.push(1-ge/A),X+=1}}for(let ge=0;ge<A;ge++)for(let ae=0;ae<k;ae++){const Ne=f+ae+z*ge,Te=f+ae+z*(ge+1),De=f+(ae+1)+z*(ge+1),be=f+(ae+1)+z*ge;l.push(Ne,Te,be),l.push(Te,De,be),H+=6}a.addGroup(d,H,M),d+=H,f+=X}}}function dv(n){const e={};for(const t in n){e[t]={};for(const r in n[t]){const i=n[t][r];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture)?e[t][r]=i.clone():Array.isArray(i)?e[t][r]=i.slice():e[t][r]=i}}return e}function zo(n){const e={};for(let t=0;t<n.length;t++){const r=dv(n[t]);for(const i in r)e[i]=r[i]}return e}const Zae={clone:dv,merge:zo};var kdt=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,Tdt=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;function Ta(n){kn.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=kdt,this.fragmentShader=Tdt,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,n!==void 0&&(n.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(n))}Ta.prototype=Object.create(kn.prototype);Ta.prototype.constructor=Ta;Ta.prototype.isShaderMaterial=!0;Ta.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.fragmentShader=n.fragmentShader,this.vertexShader=n.vertexShader,this.uniforms=dv(n.uniforms),this.defines=Object.assign({},n.defines),this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.lights=n.lights,this.clipping=n.clipping,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this.extensions=Object.assign({},n.extensions),this.glslVersion=n.glslVersion,this};Ta.prototype.toJSON=function(n){const e=kn.prototype.toJSON.call(this,n);e.glslVersion=this.glslVersion,e.uniforms={};for(const r in this.uniforms){const s=this.uniforms[r].value;s&&s.isTexture?e.uniforms[r]={type:"t",value:s.toJSON(n).uuid}:s&&s.isColor?e.uniforms[r]={type:"c",value:s.getHex()}:s&&s.isVector2?e.uniforms[r]={type:"v2",value:s.toArray()}:s&&s.isVector3?e.uniforms[r]={type:"v3",value:s.toArray()}:s&&s.isVector4?e.uniforms[r]={type:"v4",value:s.toArray()}:s&&s.isMatrix3?e.uniforms[r]={type:"m3",value:s.toArray()}:s&&s.isMatrix4?e.uniforms[r]={type:"m4",value:s.toArray()}:e.uniforms[r]={value:s}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const t={};for(const r in this.extensions)this.extensions[r]===!0&&(t[r]=!0);return Object.keys(t).length>0&&(e.extensions=t),e};function Eh(){rn.call(this),this.type="Camera",this.matrixWorldInverse=new Zn,this.projectionMatrix=new Zn,this.projectionMatrixInverse=new Zn}Eh.prototype=Object.assign(Object.create(rn.prototype),{constructor:Eh,isCamera:!0,copy:function(n,e){return rn.prototype.copy.call(this,n,e),this.matrixWorldInverse.copy(n.matrixWorldInverse),this.projectionMatrix.copy(n.projectionMatrix),this.projectionMatrixInverse.copy(n.projectionMatrixInverse),this},getWorldDirection:function(n){n===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),n=new Q),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return n.set(-e[8],-e[9],-e[10]).normalize()},updateMatrixWorld:function(n){rn.prototype.updateMatrixWorld.call(this,n),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(n,e){rn.prototype.updateWorldMatrix.call(this,n,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return new this.constructor().copy(this)}});function _s(n=50,e=1,t=.1,r=2e3){Eh.call(this),this.type="PerspectiveCamera",this.fov=n,this.zoom=1,this.near=t,this.far=r,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}_s.prototype=Object.assign(Object.create(Eh.prototype),{constructor:_s,isPerspectiveCamera:!0,copy:function(n,e){return Eh.prototype.copy.call(this,n,e),this.fov=n.fov,this.zoom=n.zoom,this.near=n.near,this.far=n.far,this.focus=n.focus,this.aspect=n.aspect,this.view=n.view===null?null:Object.assign({},n.view),this.filmGauge=n.filmGauge,this.filmOffset=n.filmOffset,this},setFocalLength:function(n){const e=.5*this.getFilmHeight()/n;this.fov=In.RAD2DEG*2*Math.atan(e),this.updateProjectionMatrix()},getFocalLength:function(){const n=Math.tan(In.DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/n},getEffectiveFOV:function(){return In.RAD2DEG*2*Math.atan(Math.tan(In.DEG2RAD*.5*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(n,e,t,r,i,s){this.aspect=n/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=r,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const n=this.near;let e=n*Math.tan(In.DEG2RAD*.5*this.fov)/this.zoom,t=2*e,r=this.aspect*t,i=-.5*r;const s=this.view;if(this.view!==null&&this.view.enabled){const a=s.fullWidth,l=s.fullHeight;i+=s.offsetX*r/a,e-=s.offsetY*t/l,r*=s.width/a,t*=s.height/l}const o=this.filmOffset;o!==0&&(i+=n*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+r,e,e-t,n,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}});const Z0=90,J0=1;function xg(n,e,t){if(rn.call(this),this.type="CubeCamera",t.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=t;const r=new _s(Z0,J0,n,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new Q(1,0,0)),this.add(r);const i=new _s(Z0,J0,n,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new Q(-1,0,0)),this.add(i);const s=new _s(Z0,J0,n,e);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new Q(0,1,0)),this.add(s);const o=new _s(Z0,J0,n,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new Q(0,-1,0)),this.add(o);const a=new _s(Z0,J0,n,e);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new Q(0,0,1)),this.add(a);const l=new _s(Z0,J0,n,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new Q(0,0,-1)),this.add(l),this.update=function(c,u){this.parent===null&&this.updateMatrixWorld();const h=c.xr.enabled,f=c.getRenderTarget();c.xr.enabled=!1;const d=t.texture.generateMipmaps;t.texture.generateMipmaps=!1,c.setRenderTarget(t,0),c.render(u,r),c.setRenderTarget(t,1),c.render(u,i),c.setRenderTarget(t,2),c.render(u,s),c.setRenderTarget(t,3),c.render(u,o),c.setRenderTarget(t,4),c.render(u,a),t.texture.generateMipmaps=d,c.setRenderTarget(t,5),c.render(u,l),c.setRenderTarget(f),c.xr.enabled=h}}xg.prototype=Object.create(rn.prototype);xg.prototype.constructor=xg;function Ih(n,e,t,r,i,s,o,a,l,c){n=n!==void 0?n:[],e=e!==void 0?e:FC,o=o!==void 0?o:jd,Kr.call(this,n,e,t,r,i,s,o,a,l,c),this.flipY=!1,this._needsFlipEnvMap=!0}Ih.prototype=Object.create(Kr.prototype);Ih.prototype.constructor=Ih;Ih.prototype.isCubeTexture=!0;Object.defineProperty(Ih.prototype,"images",{get:function(){return this.image},set:function(n){this.image=n}});class nV extends qd{constructor(e,t,r){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=r),super(e,e,t),Object.defineProperty(this,"isWebGLCubeRenderTarget",{value:!0}),t=t||{},this.texture=new Ih(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=Ml,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const r={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new wg(5,5,5),s=new Ta({name:"CubemapFromEquirect",uniforms:dv(r.uniforms),vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,side:ms,blending:Mf});s.uniforms.tEquirect.value=t;const o=new ui(i,s),a=t.minFilter;return t.minFilter===ix&&(t.minFilter=lo),new xg(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,r,i){const s=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,r,i);e.setRenderTarget(s)}}function Of(n,e,t,r,i,s,o,a,l,c,u,h){Kr.call(this,null,s,o,a,l,c,r,i,u,h),this.image={data:n||null,width:e||1,height:t||1},this.magFilter=l!==void 0?l:Us,this.minFilter=c!==void 0?c:Us,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}Of.prototype=Object.create(Kr.prototype);Of.prototype.constructor=Of;Of.prototype.isDataTexture=!0;const Q0=new Op,YT=new Q;class UC{constructor(e,t,r,i,s,o){this.planes=[e!==void 0?e:new uh,t!==void 0?t:new uh,r!==void 0?r:new uh,i!==void 0?i:new uh,s!==void 0?s:new uh,o!==void 0?o:new uh]}set(e,t,r,i,s,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(r),a[3].copy(i),a[4].copy(s),a[5].copy(o),this}clone(){return new this.constructor().copy(this)}copy(e){const t=this.planes;for(let r=0;r<6;r++)t[r].copy(e.planes[r]);return this}setFromProjectionMatrix(e){const t=this.planes,r=e.elements,i=r[0],s=r[1],o=r[2],a=r[3],l=r[4],c=r[5],u=r[6],h=r[7],f=r[8],d=r[9],p=r[10],m=r[11],g=r[12],y=r[13],b=r[14],_=r[15];return t[0].setComponents(a-i,h-l,m-f,_-g).normalize(),t[1].setComponents(a+i,h+l,m+f,_+g).normalize(),t[2].setComponents(a+s,h+c,m+d,_+y).normalize(),t[3].setComponents(a-s,h-c,m-d,_-y).normalize(),t[4].setComponents(a-o,h-u,m-p,_-b).normalize(),t[5].setComponents(a+o,h+u,m+p,_+b).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),Q0.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Q0)}intersectsSprite(e){return Q0.center.set(0,0,0),Q0.radius=.7071067811865476,Q0.applyMatrix4(e.matrixWorld),this.intersectsSphere(Q0)}intersectsSphere(e){const t=this.planes,r=e.center,i=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(r)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let r=0;r<6;r++){const i=t[r];if(YT.x=i.normal.x>0?e.max.x:e.min.x,YT.y=i.normal.y>0?e.max.y:e.min.y,YT.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(YT)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let r=0;r<6;r++)if(t[r].distanceToPoint(e)<0)return!1;return!0}}function Jae(){let n=null,e=!1,t=null,r=null;function i(s,o){t(s,o),r=n.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(r=n.requestAnimationFrame(i),e=!0)},stop:function(){n.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){n=s}}}function Edt(n,e){const t=e.isWebGL2,r=new WeakMap;function i(c,u){const h=c.array,f=c.usage,d=n.createBuffer();n.bindBuffer(u,d),n.bufferData(u,h,f),c.onUploadCallback();let p=5126;return h instanceof Float32Array?p=5126:h instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):h instanceof Uint16Array?c.isFloat16BufferAttribute?t?p=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):p=5123:h instanceof Int16Array?p=5122:h instanceof Uint32Array?p=5125:h instanceof Int32Array?p=5124:h instanceof Int8Array?p=5120:h instanceof Uint8Array&&(p=5121),{buffer:d,type:p,bytesPerElement:h.BYTES_PER_ELEMENT,version:c.version}}function s(c,u,h){const f=u.array,d=u.updateRange;n.bindBuffer(h,c),d.count===-1?n.bufferSubData(h,0,f):(t?n.bufferSubData(h,d.offset*f.BYTES_PER_ELEMENT,f,d.offset,d.count):n.bufferSubData(h,d.offset*f.BYTES_PER_ELEMENT,f.subarray(d.offset,d.offset+d.count)),d.count=-1)}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),r.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const u=r.get(c);u&&(n.deleteBuffer(u.buffer),r.delete(c))}function l(c,u){if(c.isGLBufferAttribute){const f=r.get(c);(!f||f.version<c.version)&&r.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const h=r.get(c);h===void 0?r.set(c,i(c,u)):h.version<c.version&&(s(h.buffer,c,u),h.version=c.version)}return{get:o,remove:a,update:l}}class mS extends un{constructor(e=1,t=1,r=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:r,heightSegments:i};const s=e/2,o=t/2,a=Math.floor(r),l=Math.floor(i),c=a+1,u=l+1,h=e/a,f=t/l,d=[],p=[],m=[],g=[];for(let y=0;y<u;y++){const b=y*f-o;for(let _=0;_<c;_++){const w=_*h-s;p.push(w,-b,0),m.push(0,0,1),g.push(_/a),g.push(1-y/l)}}for(let y=0;y<l;y++)for(let b=0;b<a;b++){const _=b+c*y,w=b+c*(y+1),S=b+1+c*(y+1),C=b+1+c*y;d.push(_,w,C),d.push(w,S,C)}this.setIndex(d),this.setAttribute("position",new qt(p,3)),this.setAttribute("normal",new qt(m,3)),this.setAttribute("uv",new qt(g,2))}}var Idt=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,Adt=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Mdt=`#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,Ndt=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,$dt=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,Rdt="vec3 transformed = vec3( position );",Pdt=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,Ddt=`vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,Odt=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Fdt=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,Ldt=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,zdt=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Bdt=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,Vdt=`#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`,Udt=`#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,Wdt=`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Hdt=`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor.xyz *= color.xyz;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Gdt=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,jdt=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,qdt=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Xdt=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Kdt=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,Ydt=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Zdt=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Jdt="gl_FragColor = linearToOutputTexel( gl_FragColor );",Qdt=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,ept=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,tpt=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,npt=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,rpt=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,ipt=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,spt=`#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,opt=`#ifdef USE_FOG
	varying float fogDepth;
#endif`,apt=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,lpt=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,cpt=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,upt=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,hpt=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,fpt=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,dpt=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,ppt=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,mpt=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,gpt=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,ypt=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,bpt=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,vpt=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,wpt=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,xpt=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,_pt=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,Spt=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,Cpt=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,kpt=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Tpt=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,Ept=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,Ipt=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,Apt=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,Mpt=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,Npt=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,$pt=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,Rpt=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,Ppt=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,Dpt=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,Opt=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,Fpt=`#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,Lpt=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif`,zpt=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif`,Bpt=`#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,Vpt=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );
	#endif
#endif`,Upt=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,Wpt=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,Hpt=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Gpt=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,jpt=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,qpt=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Xpt=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Kpt=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Ypt=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,Zpt=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Jpt=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,Qpt=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,emt=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,tmt=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,nmt=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,rmt=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,imt=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,smt=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,omt=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,amt=`#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,lmt=`#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`,cmt=`#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`,umt=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,hmt=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,fmt=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,dmt=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,pmt=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,mmt=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,gmt=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,ymt=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,bmt=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,vmt=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,wmt=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,xmt=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,_mt=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,Smt=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,Cmt=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,kmt=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Tmt=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,Emt=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Imt=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Amt=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Mmt=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,Nmt=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,$mt=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Rmt=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Pmt=`#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Dmt=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Omt=`#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Fmt=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Lmt=`#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,zmt=`#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Bmt=`#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Vmt=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,Umt=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Wmt=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Hmt=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Gmt=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,jmt=`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,qmt=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Xmt=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;const Jn={alphamap_fragment:Idt,alphamap_pars_fragment:Adt,alphatest_fragment:Mdt,aomap_fragment:Ndt,aomap_pars_fragment:$dt,begin_vertex:Rdt,beginnormal_vertex:Pdt,bsdfs:Ddt,bumpmap_pars_fragment:Odt,clipping_planes_fragment:Fdt,clipping_planes_pars_fragment:Ldt,clipping_planes_pars_vertex:zdt,clipping_planes_vertex:Bdt,color_fragment:Vdt,color_pars_fragment:Udt,color_pars_vertex:Wdt,color_vertex:Hdt,common:Gdt,cube_uv_reflection_fragment:jdt,defaultnormal_vertex:qdt,displacementmap_pars_vertex:Xdt,displacementmap_vertex:Kdt,emissivemap_fragment:Ydt,emissivemap_pars_fragment:Zdt,encodings_fragment:Jdt,encodings_pars_fragment:Qdt,envmap_fragment:ept,envmap_common_pars_fragment:tpt,envmap_pars_fragment:npt,envmap_pars_vertex:rpt,envmap_physical_pars_fragment:ppt,envmap_vertex:ipt,fog_vertex:spt,fog_pars_vertex:opt,fog_fragment:apt,fog_pars_fragment:lpt,gradientmap_pars_fragment:cpt,lightmap_fragment:upt,lightmap_pars_fragment:hpt,lights_lambert_vertex:fpt,lights_pars_begin:dpt,lights_toon_fragment:mpt,lights_toon_pars_fragment:gpt,lights_phong_fragment:ypt,lights_phong_pars_fragment:bpt,lights_physical_fragment:vpt,lights_physical_pars_fragment:wpt,lights_fragment_begin:xpt,lights_fragment_maps:_pt,lights_fragment_end:Spt,logdepthbuf_fragment:Cpt,logdepthbuf_pars_fragment:kpt,logdepthbuf_pars_vertex:Tpt,logdepthbuf_vertex:Ept,map_fragment:Ipt,map_pars_fragment:Apt,map_particle_fragment:Mpt,map_particle_pars_fragment:Npt,metalnessmap_fragment:$pt,metalnessmap_pars_fragment:Rpt,morphnormal_vertex:Ppt,morphtarget_pars_vertex:Dpt,morphtarget_vertex:Opt,normal_fragment_begin:Fpt,normal_fragment_maps:Lpt,normalmap_pars_fragment:zpt,clearcoat_normal_fragment_begin:Bpt,clearcoat_normal_fragment_maps:Vpt,clearcoat_pars_fragment:Upt,packing:Wpt,premultiplied_alpha_fragment:Hpt,project_vertex:Gpt,dithering_fragment:jpt,dithering_pars_fragment:qpt,roughnessmap_fragment:Xpt,roughnessmap_pars_fragment:Kpt,shadowmap_pars_fragment:Ypt,shadowmap_pars_vertex:Zpt,shadowmap_vertex:Jpt,shadowmask_pars_fragment:Qpt,skinbase_vertex:emt,skinning_pars_vertex:tmt,skinning_vertex:nmt,skinnormal_vertex:rmt,specularmap_fragment:imt,specularmap_pars_fragment:smt,tonemapping_fragment:omt,tonemapping_pars_fragment:amt,transmissionmap_fragment:lmt,transmissionmap_pars_fragment:cmt,uv_pars_fragment:umt,uv_pars_vertex:hmt,uv_vertex:fmt,uv2_pars_fragment:dmt,uv2_pars_vertex:pmt,uv2_vertex:mmt,worldpos_vertex:gmt,background_frag:ymt,background_vert:bmt,cube_frag:vmt,cube_vert:wmt,depth_frag:xmt,depth_vert:_mt,distanceRGBA_frag:Smt,distanceRGBA_vert:Cmt,equirect_frag:kmt,equirect_vert:Tmt,linedashed_frag:Emt,linedashed_vert:Imt,meshbasic_frag:Amt,meshbasic_vert:Mmt,meshlambert_frag:Nmt,meshlambert_vert:$mt,meshmatcap_frag:Rmt,meshmatcap_vert:Pmt,meshtoon_frag:Dmt,meshtoon_vert:Omt,meshphong_frag:Fmt,meshphong_vert:Lmt,meshphysical_frag:zmt,meshphysical_vert:Bmt,normal_frag:Vmt,normal_vert:Umt,points_frag:Wmt,points_vert:Hmt,shadow_frag:Gmt,shadow_vert:jmt,sprite_frag:qmt,sprite_vert:Xmt},Pt={common:{diffuse:{value:new Gt(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new kl},uv2Transform:{value:new kl},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new st(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Gt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Gt(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new kl}},sprite:{diffuse:{value:new Gt(15658734)},opacity:{value:1},center:{value:new st(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new kl}}},uu={basic:{uniforms:zo([Pt.common,Pt.specularmap,Pt.envmap,Pt.aomap,Pt.lightmap,Pt.fog]),vertexShader:Jn.meshbasic_vert,fragmentShader:Jn.meshbasic_frag},lambert:{uniforms:zo([Pt.common,Pt.specularmap,Pt.envmap,Pt.aomap,Pt.lightmap,Pt.emissivemap,Pt.fog,Pt.lights,{emissive:{value:new Gt(0)}}]),vertexShader:Jn.meshlambert_vert,fragmentShader:Jn.meshlambert_frag},phong:{uniforms:zo([Pt.common,Pt.specularmap,Pt.envmap,Pt.aomap,Pt.lightmap,Pt.emissivemap,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,Pt.fog,Pt.lights,{emissive:{value:new Gt(0)},specular:{value:new Gt(1118481)},shininess:{value:30}}]),vertexShader:Jn.meshphong_vert,fragmentShader:Jn.meshphong_frag},standard:{uniforms:zo([Pt.common,Pt.envmap,Pt.aomap,Pt.lightmap,Pt.emissivemap,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,Pt.roughnessmap,Pt.metalnessmap,Pt.fog,Pt.lights,{emissive:{value:new Gt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Jn.meshphysical_vert,fragmentShader:Jn.meshphysical_frag},toon:{uniforms:zo([Pt.common,Pt.aomap,Pt.lightmap,Pt.emissivemap,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,Pt.gradientmap,Pt.fog,Pt.lights,{emissive:{value:new Gt(0)}}]),vertexShader:Jn.meshtoon_vert,fragmentShader:Jn.meshtoon_frag},matcap:{uniforms:zo([Pt.common,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,Pt.fog,{matcap:{value:null}}]),vertexShader:Jn.meshmatcap_vert,fragmentShader:Jn.meshmatcap_frag},points:{uniforms:zo([Pt.points,Pt.fog]),vertexShader:Jn.points_vert,fragmentShader:Jn.points_frag},dashed:{uniforms:zo([Pt.common,Pt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Jn.linedashed_vert,fragmentShader:Jn.linedashed_frag},depth:{uniforms:zo([Pt.common,Pt.displacementmap]),vertexShader:Jn.depth_vert,fragmentShader:Jn.depth_frag},normal:{uniforms:zo([Pt.common,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,{opacity:{value:1}}]),vertexShader:Jn.normal_vert,fragmentShader:Jn.normal_frag},sprite:{uniforms:zo([Pt.sprite,Pt.fog]),vertexShader:Jn.sprite_vert,fragmentShader:Jn.sprite_frag},background:{uniforms:{uvTransform:{value:new kl},t2D:{value:null}},vertexShader:Jn.background_vert,fragmentShader:Jn.background_frag},cube:{uniforms:zo([Pt.envmap,{opacity:{value:1}}]),vertexShader:Jn.cube_vert,fragmentShader:Jn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Jn.equirect_vert,fragmentShader:Jn.equirect_frag},distanceRGBA:{uniforms:zo([Pt.common,Pt.displacementmap,{referencePosition:{value:new Q},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Jn.distanceRGBA_vert,fragmentShader:Jn.distanceRGBA_frag},shadow:{uniforms:zo([Pt.lights,Pt.fog,{color:{value:new Gt(0)},opacity:{value:1}}]),vertexShader:Jn.shadow_vert,fragmentShader:Jn.shadow_frag}};uu.physical={uniforms:zo([uu.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new st(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Gt(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:Jn.meshphysical_vert,fragmentShader:Jn.meshphysical_frag};function Kmt(n,e,t,r,i){const s=new Gt(0);let o=0,a,l,c=null,u=0,h=null;function f(p,m,g,y){let b=m.isScene===!0?m.background:null;b&&b.isTexture&&(b=e.get(b));const _=n.xr,w=_.getSession&&_.getSession();w&&w.environmentBlendMode==="additive"&&(b=null),b===null?d(s,o):b&&b.isColor&&(d(b,1),y=!0),(n.autoClear||y)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),b&&(b.isCubeTexture||b.isWebGLCubeRenderTarget||b.mapping===rx)?(l===void 0&&(l=new ui(new wg(1,1,1),new Ta({name:"BackgroundCubeMaterial",uniforms:dv(uu.cube.uniforms),vertexShader:uu.cube.vertexShader,fragmentShader:uu.cube.fragmentShader,side:ms,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(S,C,k){this.matrixWorld.copyPosition(k.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(l)),b.isWebGLCubeRenderTarget&&(b=b.texture),l.material.uniforms.envMap.value=b,l.material.uniforms.flipEnvMap.value=b.isCubeTexture&&b._needsFlipEnvMap?-1:1,(c!==b||u!==b.version||h!==n.toneMapping)&&(l.material.needsUpdate=!0,c=b,u=b.version,h=n.toneMapping),p.unshift(l,l.geometry,l.material,0,0,null)):b&&b.isTexture&&(a===void 0&&(a=new ui(new mS(2,2),new Ta({name:"BackgroundMaterial",uniforms:dv(uu.background.uniforms),vertexShader:uu.background.vertexShader,fragmentShader:uu.background.fragmentShader,side:nx,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(a)),a.material.uniforms.t2D.value=b,b.matrixAutoUpdate===!0&&b.updateMatrix(),a.material.uniforms.uvTransform.value.copy(b.matrix),(c!==b||u!==b.version||h!==n.toneMapping)&&(a.material.needsUpdate=!0,c=b,u=b.version,h=n.toneMapping),p.unshift(a,a.geometry,a.material,0,0,null))}function d(p,m){t.buffers.color.setClear(p.r,p.g,p.b,m,i)}return{getClearColor:function(){return s},setClearColor:function(p,m=1){s.set(p),o=m,d(s,o)},getClearAlpha:function(){return o},setClearAlpha:function(p){o=p,d(s,o)},render:f}}function Ymt(n,e,t,r){const i=n.getParameter(34921),s=r.isWebGL2?null:e.get("OES_vertex_array_object"),o=r.isWebGL2||s!==null,a={},l=m(null);let c=l;function u(R,D,z,B,X){let H=!1;if(o){const te=p(B,z,D);c!==te&&(c=te,f(c.object)),H=g(B,X),H&&y(B,X)}else{const te=D.wireframe===!0;(c.geometry!==B.id||c.program!==z.id||c.wireframe!==te)&&(c.geometry=B.id,c.program=z.id,c.wireframe=te,H=!0)}R.isInstancedMesh===!0&&(H=!0),X!==null&&t.update(X,34963),H&&(k(R,D,z,B),X!==null&&n.bindBuffer(34963,t.get(X).buffer))}function h(){return r.isWebGL2?n.createVertexArray():s.createVertexArrayOES()}function f(R){return r.isWebGL2?n.bindVertexArray(R):s.bindVertexArrayOES(R)}function d(R){return r.isWebGL2?n.deleteVertexArray(R):s.deleteVertexArrayOES(R)}function p(R,D,z){const B=z.wireframe===!0;let X=a[R.id];X===void 0&&(X={},a[R.id]=X);let H=X[D.id];H===void 0&&(H={},X[D.id]=H);let te=H[B];return te===void 0&&(te=m(h()),H[B]=te),te}function m(R){const D=[],z=[],B=[];for(let X=0;X<i;X++)D[X]=0,z[X]=0,B[X]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:D,enabledAttributes:z,attributeDivisors:B,object:R,attributes:{},index:null}}function g(R,D){const z=c.attributes,B=R.attributes;let X=0;for(const H in B){const te=z[H],ge=B[H];if(te===void 0||te.attribute!==ge||te.data!==ge.data)return!0;X++}return c.attributesNum!==X||c.index!==D}function y(R,D){const z={},B=R.attributes;let X=0;for(const H in B){const te=B[H],ge={};ge.attribute=te,te.data&&(ge.data=te.data),z[H]=ge,X++}c.attributes=z,c.attributesNum=X,c.index=D}function b(){const R=c.newAttributes;for(let D=0,z=R.length;D<z;D++)R[D]=0}function _(R){w(R,0)}function w(R,D){const z=c.newAttributes,B=c.enabledAttributes,X=c.attributeDivisors;z[R]=1,B[R]===0&&(n.enableVertexAttribArray(R),B[R]=1),X[R]!==D&&((r.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](R,D),X[R]=D)}function S(){const R=c.newAttributes,D=c.enabledAttributes;for(let z=0,B=D.length;z<B;z++)D[z]!==R[z]&&(n.disableVertexAttribArray(z),D[z]=0)}function C(R,D,z,B,X,H){r.isWebGL2===!0&&(z===5124||z===5125)?n.vertexAttribIPointer(R,D,z,X,H):n.vertexAttribPointer(R,D,z,B,X,H)}function k(R,D,z,B){if(r.isWebGL2===!1&&(R.isInstancedMesh||B.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;b();const X=B.attributes,H=z.getAttributes(),te=D.defaultAttributeValues;for(const ge in H){const ae=H[ge];if(ae>=0){const Ne=X[ge];if(Ne!==void 0){const Te=Ne.normalized,De=Ne.itemSize,be=t.get(Ne);if(be===void 0)continue;const Ke=be.buffer,Oe=be.type,ot=be.bytesPerElement;if(Ne.isInterleavedBufferAttribute){const He=Ne.data,mt=He.stride,ht=Ne.offset;He&&He.isInstancedInterleavedBuffer?(w(ae,He.meshPerAttribute),B._maxInstanceCount===void 0&&(B._maxInstanceCount=He.meshPerAttribute*He.count)):_(ae),n.bindBuffer(34962,Ke),C(ae,De,Oe,Te,mt*ot,ht*ot)}else Ne.isInstancedBufferAttribute?(w(ae,Ne.meshPerAttribute),B._maxInstanceCount===void 0&&(B._maxInstanceCount=Ne.meshPerAttribute*Ne.count)):_(ae),n.bindBuffer(34962,Ke),C(ae,De,Oe,Te,0,0)}else if(ge==="instanceMatrix"){const Te=t.get(R.instanceMatrix);if(Te===void 0)continue;const De=Te.buffer,be=Te.type;w(ae+0,1),w(ae+1,1),w(ae+2,1),w(ae+3,1),n.bindBuffer(34962,De),n.vertexAttribPointer(ae+0,4,be,!1,64,0),n.vertexAttribPointer(ae+1,4,be,!1,64,16),n.vertexAttribPointer(ae+2,4,be,!1,64,32),n.vertexAttribPointer(ae+3,4,be,!1,64,48)}else if(ge==="instanceColor"){const Te=t.get(R.instanceColor);if(Te===void 0)continue;const De=Te.buffer,be=Te.type;w(ae,1),n.bindBuffer(34962,De),n.vertexAttribPointer(ae,3,be,!1,12,0)}else if(te!==void 0){const Te=te[ge];if(Te!==void 0)switch(Te.length){case 2:n.vertexAttrib2fv(ae,Te);break;case 3:n.vertexAttrib3fv(ae,Te);break;case 4:n.vertexAttrib4fv(ae,Te);break;default:n.vertexAttrib1fv(ae,Te)}}}}S()}function A(){N();for(const R in a){const D=a[R];for(const z in D){const B=D[z];for(const X in B)d(B[X].object),delete B[X];delete D[z]}delete a[R]}}function M(R){if(a[R.id]===void 0)return;const D=a[R.id];for(const z in D){const B=D[z];for(const X in B)d(B[X].object),delete B[X];delete D[z]}delete a[R.id]}function E(R){for(const D in a){const z=a[D];if(z[R.id]===void 0)continue;const B=z[R.id];for(const X in B)d(B[X].object),delete B[X];delete z[R.id]}}function N(){O(),c!==l&&(c=l,f(c.object))}function O(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:u,reset:N,resetDefaultState:O,dispose:A,releaseStatesOfGeometry:M,releaseStatesOfProgram:E,initAttributes:b,enableAttribute:_,disableUnusedAttributes:S}}function Zmt(n,e,t,r){const i=r.isWebGL2;let s;function o(c){s=c}function a(c,u){n.drawArrays(s,c,u),t.update(u,s,1)}function l(c,u,h){if(h===0)return;let f,d;if(i)f=n,d="drawArraysInstanced";else if(f=e.get("ANGLE_instanced_arrays"),d="drawArraysInstancedANGLE",f===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}f[d](s,c,u,h),t.update(u,s,h)}this.setMode=o,this.render=a,this.renderInstances=l}function Jmt(n,e,t){let r;function i(){if(r!==void 0)return r;const C=e.get("EXT_texture_filter_anisotropic");return C!==null?r=n.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT):r=0,r}function s(C){if(C==="highp"){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";C="mediump"}return C==="mediump"&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&n instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&n instanceof WebGL2ComputeRenderingContext;let a=t.precision!==void 0?t.precision:"highp";const l=s(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=t.logarithmicDepthBuffer===!0,u=n.getParameter(34930),h=n.getParameter(35660),f=n.getParameter(3379),d=n.getParameter(34076),p=n.getParameter(34921),m=n.getParameter(36347),g=n.getParameter(36348),y=n.getParameter(36349),b=h>0,_=o||!!e.get("OES_texture_float"),w=b&&_,S=o?n.getParameter(36183):0;return{isWebGL2:o,getMaxAnisotropy:i,getMaxPrecision:s,precision:a,logarithmicDepthBuffer:c,maxTextures:u,maxVertexTextures:h,maxTextureSize:f,maxCubemapSize:d,maxAttributes:p,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:y,vertexTextures:b,floatFragmentTextures:_,floatVertexTextures:w,maxSamples:S}}function Qmt(n){const e=this;let t=null,r=0,i=!1,s=!1;const o=new uh,a=new kl,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,f,d){const p=h.length!==0||f||r!==0||i;return i=f,t=u(h,d,0),r=h.length,p},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1,c()},this.setState=function(h,f,d){const p=h.clippingPlanes,m=h.clipIntersection,g=h.clipShadows,y=n.get(h);if(!i||p===null||p.length===0||s&&!g)s?u(null):c();else{const b=s?0:r,_=b*4;let w=y.clippingState||null;l.value=w,w=u(p,f,_,d);for(let S=0;S!==_;++S)w[S]=t[S];y.clippingState=w,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=b}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function u(h,f,d,p){const m=h!==null?h.length:0;let g=null;if(m!==0){if(g=l.value,p!==!0||g===null){const y=d+m*4,b=f.matrixWorldInverse;a.getNormalMatrix(b),(g===null||g.length<y)&&(g=new Float32Array(y));for(let _=0,w=d;_!==m;++_,w+=4)o.copy(h[_]).applyMatrix4(b,a),o.normal.toArray(g,w),g[w+3]=o.constant}l.value=g,l.needsUpdate=!0}return e.numPlanes=m,e.numIntersection=0,g}}function egt(n){let e=new WeakMap;function t(o,a){return a===_A?o.mapping=FC:a===SA&&(o.mapping=LC),o}function r(o){if(o&&o.isTexture){const a=o.mapping;if(a===_A||a===SA)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=n.getRenderList(),u=n.getRenderTarget(),h=new nV(l.height/2);return h.fromEquirectangularTexture(n,o),e.set(o,h),n.setRenderTarget(u),n.setRenderList(c),o.addEventListener("dispose",i),t(h.texture,o.mapping)}else return null}}return o}function i(o){const a=o.target;a.removeEventListener("dispose",i);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function s(){e=new WeakMap}return{get:r,dispose:s}}function tgt(n){const e={};function t(r){if(e[r]!==void 0)return e[r];let i;switch(r){case"WEBGL_depth_texture":i=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=n.getExtension(r)}return e[r]=i,i}return{has:function(r){return t(r)!==null},init:function(r){r.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float")},get:function(r){const i=t(r);return i===null&&console.warn("THREE.WebGLRenderer: "+r+" extension not supported."),i}}}function ngt(n,e,t,r){const i={},s=new WeakMap;function o(h){const f=h.target;f.index!==null&&e.remove(f.index);for(const p in f.attributes)e.remove(f.attributes[p]);f.removeEventListener("dispose",o),delete i[f.id];const d=s.get(f);d&&(e.remove(d),s.delete(f)),r.releaseStatesOfGeometry(f),f.isInstancedBufferGeometry===!0&&delete f._maxInstanceCount,t.memory.geometries--}function a(h,f){return i[f.id]===!0||(f.addEventListener("dispose",o),i[f.id]=!0,t.memory.geometries++),f}function l(h){const f=h.attributes;for(const p in f)e.update(f[p],34962);const d=h.morphAttributes;for(const p in d){const m=d[p];for(let g=0,y=m.length;g<y;g++)e.update(m[g],34962)}}function c(h){const f=[],d=h.index,p=h.attributes.position;let m=0;if(d!==null){const b=d.array;m=d.version;for(let _=0,w=b.length;_<w;_+=3){const S=b[_+0],C=b[_+1],k=b[_+2];f.push(S,C,C,k,k,S)}}else{const b=p.array;m=p.version;for(let _=0,w=b.length/3-1;_<w;_+=3){const S=_+0,C=_+1,k=_+2;f.push(S,C,C,k,k,S)}}const g=new(Yae(f)>65535?vg:bg)(f,1);g.version=m;const y=s.get(h);y&&e.remove(y),s.set(h,g)}function u(h){const f=s.get(h);if(f){const d=h.index;d!==null&&f.version<d.version&&c(h)}else c(h);return s.get(h)}return{get:a,update:l,getWireframeAttribute:u}}function rgt(n,e,t,r){const i=r.isWebGL2;let s;function o(f){s=f}let a,l;function c(f){a=f.type,l=f.bytesPerElement}function u(f,d){n.drawElements(s,d,a,f*l),t.update(d,s,1)}function h(f,d,p){if(p===0)return;let m,g;if(i)m=n,g="drawElementsInstanced";else if(m=e.get("ANGLE_instanced_arrays"),g="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[g](s,d,a,f*l,p),t.update(d,s,p)}this.setMode=o,this.setIndex=c,this.render=u,this.renderInstances=h}function igt(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function r(s,o,a){switch(t.calls++,o){case 4:t.triangles+=a*(s/3);break;case 1:t.lines+=a*(s/2);break;case 3:t.lines+=a*(s-1);break;case 2:t.lines+=a*s;break;case 0:t.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function i(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:r}}function sgt(n,e){return n[0]-e[0]}function ogt(n,e){return Math.abs(e[1])-Math.abs(n[1])}function agt(n){const e={},t=new Float32Array(8),r=[];for(let s=0;s<8;s++)r[s]=[s,0];function i(s,o,a,l){const c=s.morphTargetInfluences,u=c===void 0?0:c.length;let h=e[o.id];if(h===void 0){h=[];for(let g=0;g<u;g++)h[g]=[g,0];e[o.id]=h}for(let g=0;g<u;g++){const y=h[g];y[0]=g,y[1]=c[g]}h.sort(ogt);for(let g=0;g<8;g++)g<u&&h[g][1]?(r[g][0]=h[g][0],r[g][1]=h[g][1]):(r[g][0]=Number.MAX_SAFE_INTEGER,r[g][1]=0);r.sort(sgt);const f=a.morphTargets&&o.morphAttributes.position,d=a.morphNormals&&o.morphAttributes.normal;let p=0;for(let g=0;g<8;g++){const y=r[g],b=y[0],_=y[1];b!==Number.MAX_SAFE_INTEGER&&_?(f&&o.getAttribute("morphTarget"+g)!==f[b]&&o.setAttribute("morphTarget"+g,f[b]),d&&o.getAttribute("morphNormal"+g)!==d[b]&&o.setAttribute("morphNormal"+g,d[b]),t[g]=_,p+=_):(f&&o.hasAttribute("morphTarget"+g)===!0&&o.deleteAttribute("morphTarget"+g),d&&o.hasAttribute("morphNormal"+g)===!0&&o.deleteAttribute("morphNormal"+g),t[g]=0)}const m=o.morphTargetsRelative?1:1-p;l.getUniforms().setValue(n,"morphTargetBaseInfluence",m),l.getUniforms().setValue(n,"morphTargetInfluences",t)}return{update:i}}function lgt(n,e,t,r){let i=new WeakMap;function s(l){const c=r.render.frame,u=l.geometry,h=e.get(l,u);return i.get(h)!==c&&(e.update(h),i.set(h,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),t.update(l.instanceMatrix,34962),l.instanceColor!==null&&t.update(l.instanceColor,34962)),h}function o(){i=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:s,dispose:o}}function pv(n=null,e=1,t=1,r=1){Kr.call(this,null),this.image={data:n,width:e,height:t,depth:r},this.magFilter=Us,this.minFilter=Us,this.wrapR=ma,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}pv.prototype=Object.create(Kr.prototype);pv.prototype.constructor=pv;pv.prototype.isDataTexture2DArray=!0;function mv(n=null,e=1,t=1,r=1){Kr.call(this,null),this.image={data:n,width:e,height:t,depth:r},this.magFilter=Us,this.minFilter=Us,this.wrapR=ma,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}mv.prototype=Object.create(Kr.prototype);mv.prototype.constructor=mv;mv.prototype.isDataTexture3D=!0;const Qae=new Kr,cgt=new pv,ugt=new mv,ele=new Ih,o8=[],a8=[],l8=new Float32Array(16),c8=new Float32Array(9),u8=new Float32Array(4);function lx(n,e,t){const r=n[0];if(r<=0||r>0)return n;const i=e*t;let s=o8[i];if(s===void 0&&(s=new Float32Array(i),o8[i]=s),e!==0){r.toArray(s,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(s,a)}return s}function Mc(n,e){if(n.length!==e.length)return!1;for(let t=0,r=n.length;t<r;t++)if(n[t]!==e[t])return!1;return!0}function Ol(n,e){for(let t=0,r=e.length;t<r;t++)n[t]=e[t]}function tle(n,e){let t=a8[e];t===void 0&&(t=new Int32Array(e),a8[e]=t);for(let r=0;r!==e;++r)t[r]=n.allocateTextureUnit();return t}function hgt(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function fgt(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Mc(t,e))return;n.uniform2fv(this.addr,e),Ol(t,e)}}function dgt(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Mc(t,e))return;n.uniform3fv(this.addr,e),Ol(t,e)}}function pgt(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Mc(t,e))return;n.uniform4fv(this.addr,e),Ol(t,e)}}function mgt(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Mc(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Ol(t,e)}else{if(Mc(t,r))return;u8.set(r),n.uniformMatrix2fv(this.addr,!1,u8),Ol(t,r)}}function ggt(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Mc(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Ol(t,e)}else{if(Mc(t,r))return;c8.set(r),n.uniformMatrix3fv(this.addr,!1,c8),Ol(t,r)}}function ygt(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Mc(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Ol(t,e)}else{if(Mc(t,r))return;l8.set(r),n.uniformMatrix4fv(this.addr,!1,l8),Ol(t,r)}}function bgt(n,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(n.uniform1i(this.addr,i),r[0]=i),t.safeSetTexture2D(e||Qae,i)}function vgt(n,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(n.uniform1i(this.addr,i),r[0]=i),t.setTexture2DArray(e||cgt,i)}function wgt(n,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(n.uniform1i(this.addr,i),r[0]=i),t.setTexture3D(e||ugt,i)}function xgt(n,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(n.uniform1i(this.addr,i),r[0]=i),t.safeSetTextureCube(e||ele,i)}function _gt(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function Sgt(n,e){const t=this.cache;Mc(t,e)||(n.uniform2iv(this.addr,e),Ol(t,e))}function Cgt(n,e){const t=this.cache;Mc(t,e)||(n.uniform3iv(this.addr,e),Ol(t,e))}function kgt(n,e){const t=this.cache;Mc(t,e)||(n.uniform4iv(this.addr,e),Ol(t,e))}function Tgt(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function Egt(n){switch(n){case 5126:return hgt;case 35664:return fgt;case 35665:return dgt;case 35666:return pgt;case 35674:return mgt;case 35675:return ggt;case 35676:return ygt;case 5124:case 35670:return _gt;case 35667:case 35671:return Sgt;case 35668:case 35672:return Cgt;case 35669:case 35673:return kgt;case 5125:return Tgt;case 35678:case 36198:case 36298:case 36306:case 35682:return bgt;case 35679:case 36299:case 36307:return wgt;case 35680:case 36300:case 36308:case 36293:return xgt;case 36289:case 36303:case 36311:case 36292:return vgt}}function Igt(n,e){n.uniform1fv(this.addr,e)}function Agt(n,e){n.uniform1iv(this.addr,e)}function Mgt(n,e){n.uniform2iv(this.addr,e)}function Ngt(n,e){n.uniform3iv(this.addr,e)}function $gt(n,e){n.uniform4iv(this.addr,e)}function Rgt(n,e){const t=lx(e,this.size,2);n.uniform2fv(this.addr,t)}function Pgt(n,e){const t=lx(e,this.size,3);n.uniform3fv(this.addr,t)}function Dgt(n,e){const t=lx(e,this.size,4);n.uniform4fv(this.addr,t)}function Ogt(n,e){const t=lx(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function Fgt(n,e){const t=lx(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function Lgt(n,e){const t=lx(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function zgt(n,e,t){const r=e.length,i=tle(t,r);n.uniform1iv(this.addr,i);for(let s=0;s!==r;++s)t.safeSetTexture2D(e[s]||Qae,i[s])}function Bgt(n,e,t){const r=e.length,i=tle(t,r);n.uniform1iv(this.addr,i);for(let s=0;s!==r;++s)t.safeSetTextureCube(e[s]||ele,i[s])}function Vgt(n){switch(n){case 5126:return Igt;case 35664:return Rgt;case 35665:return Pgt;case 35666:return Dgt;case 35674:return Ogt;case 35675:return Fgt;case 35676:return Lgt;case 5124:case 35670:return Agt;case 35667:case 35671:return Mgt;case 35668:case 35672:return Ngt;case 35669:case 35673:return $gt;case 35678:case 36198:case 36298:case 36306:case 35682:return zgt;case 35680:case 36300:case 36308:case 36293:return Bgt}}function Ugt(n,e,t){this.id=n,this.addr=t,this.cache=[],this.setValue=Egt(e.type)}function nle(n,e,t){this.id=n,this.addr=t,this.cache=[],this.size=e.size,this.setValue=Vgt(e.type)}nle.prototype.updateCache=function(n){const e=this.cache;n instanceof Float32Array&&e.length!==n.length&&(this.cache=new Float32Array(n.length)),Ol(e,n)};function rle(n){this.id=n,this.seq=[],this.map={}}rle.prototype.setValue=function(n,e,t){const r=this.seq;for(let i=0,s=r.length;i!==s;++i){const o=r[i];o.setValue(n,e[o.id],t)}};const CP=/(\w+)(\])?(\[|\.)?/g;function h8(n,e){n.seq.push(e),n.map[e.id]=e}function Wgt(n,e,t){const r=n.name,i=r.length;for(CP.lastIndex=0;;){const s=CP.exec(r),o=CP.lastIndex;let a=s[1];const l=s[2]==="]",c=s[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===i){h8(t,c===void 0?new Ugt(a,n,e):new nle(a,n,e));break}else{let h=t.map[a];h===void 0&&(h=new rle(a),h8(t,h)),t=h}}}function Xd(n,e){this.seq=[],this.map={};const t=n.getProgramParameter(e,35718);for(let r=0;r<t;++r){const i=n.getActiveUniform(e,r),s=n.getUniformLocation(e,i.name);Wgt(i,s,this)}}Xd.prototype.setValue=function(n,e,t,r){const i=this.map[e];i!==void 0&&i.setValue(n,t,r)};Xd.prototype.setOptional=function(n,e,t){const r=e[t];r!==void 0&&this.setValue(n,t,r)};Xd.upload=function(n,e,t,r){for(let i=0,s=e.length;i!==s;++i){const o=e[i],a=t[o.id];a.needsUpdate!==!1&&o.setValue(n,a.value,r)}};Xd.seqWithValue=function(n,e){const t=[];for(let r=0,i=n.length;r!==i;++r){const s=n[r];s.id in e&&t.push(s)}return t};function f8(n,e,t){const r=n.createShader(e);return n.shaderSource(r,t),n.compileShader(r),r}let Hgt=0;function Ggt(n){const e=n.split(`
`);for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join(`
`)}function ile(n){switch(n){case ka:return["Linear","( value )"];case BC:return["sRGB","( value )"];case M$:return["RGBE","( value )"];case Z4:return["RGBM","( value, 7.0 )"];case J4:return["RGBM","( value, 16.0 )"];case Q4:return["RGBD","( value, 256.0 )"];case A$:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case Hae:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}function d8(n,e,t){const r=n.getShaderParameter(e,35713),i=n.getShaderInfoLog(e).trim();if(r&&i==="")return"";const s=n.getShaderSource(e);return"THREE.WebGLShader: gl.getShaderInfoLog() "+t+`
`+i+Ggt(s)}function n1(n,e){const t=ile(e);return"vec4 "+n+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function jgt(n,e){const t=ile(e);return"vec4 "+n+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function qgt(n,e){let t;switch(e){case Woe:t="Linear";break;case Hoe:t="Reinhard";break;case Goe:t="OptimizedCineon";break;case joe:t="ACESFilmic";break;case qoe:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function Xgt(n){return[n.extensionDerivatives||n.envMapCubeUV||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(R1).join(`
`)}function Kgt(n){const e=[];for(const t in n){const r=n[t];r!==!1&&e.push("#define "+t+" "+r)}return e.join(`
`)}function Ygt(n,e){const t={},r=n.getProgramParameter(e,35721);for(let i=0;i<r;i++){const o=n.getActiveAttrib(e,i).name;t[o]=n.getAttribLocation(e,o)}return t}function R1(n){return n!==""}function p8(n,e){return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function m8(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Zgt=/^[ \t]*#include +<([\w\d./]+)>/gm;function PF(n){return n.replace(Zgt,Jgt)}function Jgt(n,e){const t=Jn[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return PF(t)}const Qgt=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,eyt=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function g8(n){return n.replace(eyt,sle).replace(Qgt,tyt)}function tyt(n,e,t,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),sle(n,e,t,r)}function sle(n,e,t,r){let i="";for(let s=parseInt(e);s<parseInt(t);s++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function y8(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function nyt(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===G4?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===xoe?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===Sb&&(e="SHADOWMAP_TYPE_VSM"),e}function ryt(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case FC:case LC:e="ENVMAP_TYPE_CUBE";break;case rx:case zC:e="ENVMAP_TYPE_CUBE_UV";break}return e}function iyt(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case LC:case zC:e="ENVMAP_MODE_REFRACTION";break}return e}function syt(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case OC:e="ENVMAP_BLENDING_MULTIPLY";break;case Voe:e="ENVMAP_BLENDING_MIX";break;case Uoe:e="ENVMAP_BLENDING_ADD";break}return e}function oyt(n,e,t,r){const i=n.getContext(),s=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=nyt(t),c=ryt(t),u=iyt(t),h=syt(t),f=n.gammaFactor>0?n.gammaFactor:1,d=t.isWebGL2?"":Xgt(t),p=Kgt(s),m=i.createProgram();let g,y,b=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(g=[p].filter(R1).join(`
`),g.length>0&&(g+=`
`),y=[d,p].filter(R1).join(`
`),y.length>0&&(y+=`
`)):(g=[y8(t),"#define SHADER_NAME "+t.shaderName,p,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+f,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#ifdef USE_COLOR","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(R1).join(`
`),y=[d,y8(t),"#define SHADER_NAME "+t.shaderName,p,t.alphaTest?"#define ALPHATEST "+t.alphaTest+(t.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+f,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.sheen?"#define USE_SHEEN":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Ym?"#define TONE_MAPPING":"",t.toneMapping!==Ym?Jn.tonemapping_pars_fragment:"",t.toneMapping!==Ym?qgt("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",Jn.encodings_pars_fragment,t.map?n1("mapTexelToLinear",t.mapEncoding):"",t.matcap?n1("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?n1("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?n1("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.lightMap?n1("lightMapTexelToLinear",t.lightMapEncoding):"",jgt("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(R1).join(`
`)),o=PF(o),o=p8(o,t),o=m8(o,t),a=PF(a),a=p8(a,t),a=m8(a,t),o=g8(o),a=g8(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(b=`#version 300 es
`,g=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+g,y=["#define varying in",t.glslVersion===RF?"":"out highp vec4 pc_fragColor;",t.glslVersion===RF?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+y);const _=b+g+o,w=b+y+a,S=f8(i,35633,_),C=f8(i,35632,w);if(i.attachShader(m,S),i.attachShader(m,C),t.index0AttributeName!==void 0?i.bindAttribLocation(m,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(m,0,"position"),i.linkProgram(m),n.debug.checkShaderErrors){const M=i.getProgramInfoLog(m).trim(),E=i.getShaderInfoLog(S).trim(),N=i.getShaderInfoLog(C).trim();let O=!0,R=!0;if(i.getProgramParameter(m,35714)===!1){O=!1;const D=d8(i,S,"vertex"),z=d8(i,C,"fragment");console.error("THREE.WebGLProgram: shader error: ",i.getError(),"35715",i.getProgramParameter(m,35715),"gl.getProgramInfoLog",M,D,z)}else M!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",M):(E===""||N==="")&&(R=!1);R&&(this.diagnostics={runnable:O,programLog:M,vertexShader:{log:E,prefix:g},fragmentShader:{log:N,prefix:y}})}i.deleteShader(S),i.deleteShader(C);let k;this.getUniforms=function(){return k===void 0&&(k=new Xd(i,m)),k};let A;return this.getAttributes=function(){return A===void 0&&(A=Ygt(i,m)),A},this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(m),this.program=void 0},this.name=t.shaderName,this.id=Hgt++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=S,this.fragmentShader=C,this}function ayt(n,e,t,r,i,s){const o=[],a=r.isWebGL2,l=r.logarithmicDepthBuffer,c=r.floatVertexTextures,u=r.maxVertexUniforms,h=r.vertexTextures;let f=r.precision;const d={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},p=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function m(C){const A=C.skeleton.bones;if(c)return 1024;{const E=Math.floor((u-20)/4),N=Math.min(E,A.length);return N<A.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+A.length+" bones. This GPU supports "+N+"."),0):N}}function g(C){let k;return C&&C.isTexture?k=C.encoding:C&&C.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),k=C.texture.encoding):k=ka,k}function y(C,k,A,M,E){const N=M.fog,O=C.isMeshStandardMaterial?M.environment:null,R=e.get(C.envMap||O),D=d[C.type],z=E.isSkinnedMesh?m(E):0;C.precision!==null&&(f=r.getMaxPrecision(C.precision),f!==C.precision&&console.warn("THREE.WebGLProgram.getParameters:",C.precision,"not supported, using",f,"instead."));let B,X;if(D){const ge=uu[D];B=ge.vertexShader,X=ge.fragmentShader}else B=C.vertexShader,X=C.fragmentShader;const H=n.getRenderTarget();return{isWebGL2:a,shaderID:D,shaderName:C.type,vertexShader:B,fragmentShader:X,defines:C.defines,isRawShaderMaterial:C.isRawShaderMaterial===!0,glslVersion:C.glslVersion,precision:f,instancing:E.isInstancedMesh===!0,instancingColor:E.isInstancedMesh===!0&&E.instanceColor!==null,supportsVertexTextures:h,outputEncoding:H!==null?g(H.texture):n.outputEncoding,map:!!C.map,mapEncoding:g(C.map),matcap:!!C.matcap,matcapEncoding:g(C.matcap),envMap:!!R,envMapMode:R&&R.mapping,envMapEncoding:g(R),envMapCubeUV:!!R&&(R.mapping===rx||R.mapping===zC),lightMap:!!C.lightMap,lightMapEncoding:g(C.lightMap),aoMap:!!C.aoMap,emissiveMap:!!C.emissiveMap,emissiveMapEncoding:g(C.emissiveMap),bumpMap:!!C.bumpMap,normalMap:!!C.normalMap,objectSpaceNormalMap:C.normalMapType===qae,tangentSpaceNormalMap:C.normalMapType===Zy,clearcoatMap:!!C.clearcoatMap,clearcoatRoughnessMap:!!C.clearcoatRoughnessMap,clearcoatNormalMap:!!C.clearcoatNormalMap,displacementMap:!!C.displacementMap,roughnessMap:!!C.roughnessMap,metalnessMap:!!C.metalnessMap,specularMap:!!C.specularMap,alphaMap:!!C.alphaMap,gradientMap:!!C.gradientMap,sheen:!!C.sheen,transmissionMap:!!C.transmissionMap,combine:C.combine,vertexTangents:C.normalMap&&C.vertexTangents,vertexColors:C.vertexColors,vertexUvs:!!C.map||!!C.bumpMap||!!C.normalMap||!!C.specularMap||!!C.alphaMap||!!C.emissiveMap||!!C.roughnessMap||!!C.metalnessMap||!!C.clearcoatMap||!!C.clearcoatRoughnessMap||!!C.clearcoatNormalMap||!!C.displacementMap||!!C.transmissionMap,uvsVertexOnly:!(C.map||C.bumpMap||C.normalMap||C.specularMap||C.alphaMap||C.emissiveMap||C.roughnessMap||C.metalnessMap||C.clearcoatNormalMap||C.transmissionMap)&&!!C.displacementMap,fog:!!N,useFog:C.fog,fogExp2:N&&N.isFogExp2,flatShading:C.flatShading,sizeAttenuation:C.sizeAttenuation,logarithmicDepthBuffer:l,skinning:C.skinning&&z>0,maxBones:z,useVertexTexture:c,morphTargets:C.morphTargets,morphNormals:C.morphNormals,maxMorphTargets:n.maxMorphTargets,maxMorphNormals:n.maxMorphNormals,numDirLights:k.directional.length,numPointLights:k.point.length,numSpotLights:k.spot.length,numRectAreaLights:k.rectArea.length,numHemiLights:k.hemi.length,numDirLightShadows:k.directionalShadowMap.length,numPointLightShadows:k.pointShadowMap.length,numSpotLightShadows:k.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:C.dithering,shadowMapEnabled:n.shadowMap.enabled&&A.length>0,shadowMapType:n.shadowMap.type,toneMapping:C.toneMapped?n.toneMapping:Ym,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:C.premultipliedAlpha,alphaTest:C.alphaTest,doubleSided:C.side===DC,flipSided:C.side===ms,depthPacking:C.depthPacking!==void 0?C.depthPacking:!1,index0AttributeName:C.index0AttributeName,extensionDerivatives:C.extensions&&C.extensions.derivatives,extensionFragDepth:C.extensions&&C.extensions.fragDepth,extensionDrawBuffers:C.extensions&&C.extensions.drawBuffers,extensionShaderTextureLOD:C.extensions&&C.extensions.shaderTextureLOD,rendererExtensionFragDepth:a||t.has("EXT_frag_depth"),rendererExtensionDrawBuffers:a||t.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:a||t.has("EXT_shader_texture_lod"),customProgramCacheKey:C.customProgramCacheKey()}}function b(C){const k=[];if(C.shaderID?k.push(C.shaderID):(k.push(C.fragmentShader),k.push(C.vertexShader)),C.defines!==void 0)for(const A in C.defines)k.push(A),k.push(C.defines[A]);if(C.isRawShaderMaterial===!1){for(let A=0;A<p.length;A++)k.push(C[p[A]]);k.push(n.outputEncoding),k.push(n.gammaFactor)}return k.push(C.customProgramCacheKey),k.join()}function _(C){const k=d[C.type];let A;if(k){const M=uu[k];A=Zae.clone(M.uniforms)}else A=C.uniforms;return A}function w(C,k){let A;for(let M=0,E=o.length;M<E;M++){const N=o[M];if(N.cacheKey===k){A=N,++A.usedTimes;break}}return A===void 0&&(A=new oyt(n,k,C,i),o.push(A)),A}function S(C){if(--C.usedTimes===0){const k=o.indexOf(C);o[k]=o[o.length-1],o.pop(),C.destroy()}}return{getParameters:y,getProgramCacheKey:b,getUniforms:_,acquireProgram:w,releaseProgram:S,programs:o}}function lyt(){let n=new WeakMap;function e(s){let o=n.get(s);return o===void 0&&(o={},n.set(s,o)),o}function t(s){n.delete(s)}function r(s,o,a){n.get(s)[o]=a}function i(){n=new WeakMap}return{get:e,remove:t,update:r,dispose:i}}function cyt(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.program!==e.program?n.program.id-e.program.id:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function uyt(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function b8(n){const e=[];let t=0;const r=[],i=[],s={id:-1};function o(){t=0,r.length=0,i.length=0}function a(f,d,p,m,g,y){let b=e[t];const _=n.get(p);return b===void 0?(b={id:f.id,object:f,geometry:d,material:p,program:_.program||s,groupOrder:m,renderOrder:f.renderOrder,z:g,group:y},e[t]=b):(b.id=f.id,b.object=f,b.geometry=d,b.material=p,b.program=_.program||s,b.groupOrder=m,b.renderOrder=f.renderOrder,b.z=g,b.group=y),t++,b}function l(f,d,p,m,g,y){const b=a(f,d,p,m,g,y);(p.transparent===!0?i:r).push(b)}function c(f,d,p,m,g,y){const b=a(f,d,p,m,g,y);(p.transparent===!0?i:r).unshift(b)}function u(f,d){r.length>1&&r.sort(f||cyt),i.length>1&&i.sort(d||uyt)}function h(){for(let f=t,d=e.length;f<d;f++){const p=e[f];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.program=null,p.group=null}}return{opaque:r,transparent:i,init:o,push:l,unshift:c,finish:h,sort:u}}function hyt(n){let e=new WeakMap;function t(i,s){const o=e.get(i);let a;return o===void 0?(a=new b8(n),e.set(i,new WeakMap),e.get(i).set(s,a)):(a=o.get(s),a===void 0&&(a=new b8(n),o.set(s,a))),a}function r(){e=new WeakMap}return{get:t,dispose:r}}function fyt(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new Q,color:new Gt};break;case"SpotLight":t={position:new Q,direction:new Q,color:new Gt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new Q,color:new Gt,distance:0,decay:0};break;case"HemisphereLight":t={direction:new Q,skyColor:new Gt,groundColor:new Gt};break;case"RectAreaLight":t={color:new Gt,position:new Q,halfWidth:new Q,halfHeight:new Q};break}return n[e.id]=t,t}}}function dyt(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new st};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new st};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new st,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let pyt=0;function myt(n,e){return(e.castShadow?1:0)-(n.castShadow?1:0)}function gyt(n,e){const t=new fyt,r=dyt(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let u=0;u<9;u++)i.probe.push(new Q);const s=new Q,o=new Zn,a=new Zn;function l(u){let h=0,f=0,d=0;for(let k=0;k<9;k++)i.probe[k].set(0,0,0);let p=0,m=0,g=0,y=0,b=0,_=0,w=0,S=0;u.sort(myt);for(let k=0,A=u.length;k<A;k++){const M=u[k],E=M.color,N=M.intensity,O=M.distance,R=M.shadow&&M.shadow.map?M.shadow.map.texture:null;if(M.isAmbientLight)h+=E.r*N,f+=E.g*N,d+=E.b*N;else if(M.isLightProbe)for(let D=0;D<9;D++)i.probe[D].addScaledVector(M.sh.coefficients[D],N);else if(M.isDirectionalLight){const D=t.get(M);if(D.color.copy(M.color).multiplyScalar(M.intensity),M.castShadow){const z=M.shadow,B=r.get(M);B.shadowBias=z.bias,B.shadowNormalBias=z.normalBias,B.shadowRadius=z.radius,B.shadowMapSize=z.mapSize,i.directionalShadow[p]=B,i.directionalShadowMap[p]=R,i.directionalShadowMatrix[p]=M.shadow.matrix,_++}i.directional[p]=D,p++}else if(M.isSpotLight){const D=t.get(M);if(D.position.setFromMatrixPosition(M.matrixWorld),D.color.copy(E).multiplyScalar(N),D.distance=O,D.coneCos=Math.cos(M.angle),D.penumbraCos=Math.cos(M.angle*(1-M.penumbra)),D.decay=M.decay,M.castShadow){const z=M.shadow,B=r.get(M);B.shadowBias=z.bias,B.shadowNormalBias=z.normalBias,B.shadowRadius=z.radius,B.shadowMapSize=z.mapSize,i.spotShadow[g]=B,i.spotShadowMap[g]=R,i.spotShadowMatrix[g]=M.shadow.matrix,S++}i.spot[g]=D,g++}else if(M.isRectAreaLight){const D=t.get(M);D.color.copy(E).multiplyScalar(N),D.halfWidth.set(M.width*.5,0,0),D.halfHeight.set(0,M.height*.5,0),i.rectArea[y]=D,y++}else if(M.isPointLight){const D=t.get(M);if(D.color.copy(M.color).multiplyScalar(M.intensity),D.distance=M.distance,D.decay=M.decay,M.castShadow){const z=M.shadow,B=r.get(M);B.shadowBias=z.bias,B.shadowNormalBias=z.normalBias,B.shadowRadius=z.radius,B.shadowMapSize=z.mapSize,B.shadowCameraNear=z.camera.near,B.shadowCameraFar=z.camera.far,i.pointShadow[m]=B,i.pointShadowMap[m]=R,i.pointShadowMatrix[m]=M.shadow.matrix,w++}i.point[m]=D,m++}else if(M.isHemisphereLight){const D=t.get(M);D.skyColor.copy(M.color).multiplyScalar(N),D.groundColor.copy(M.groundColor).multiplyScalar(N),i.hemi[b]=D,b++}}y>0&&(e.isWebGL2||n.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=Pt.LTC_FLOAT_1,i.rectAreaLTC2=Pt.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=Pt.LTC_HALF_1,i.rectAreaLTC2=Pt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=h,i.ambient[1]=f,i.ambient[2]=d;const C=i.hash;(C.directionalLength!==p||C.pointLength!==m||C.spotLength!==g||C.rectAreaLength!==y||C.hemiLength!==b||C.numDirectionalShadows!==_||C.numPointShadows!==w||C.numSpotShadows!==S)&&(i.directional.length=p,i.spot.length=g,i.rectArea.length=y,i.point.length=m,i.hemi.length=b,i.directionalShadow.length=_,i.directionalShadowMap.length=_,i.pointShadow.length=w,i.pointShadowMap.length=w,i.spotShadow.length=S,i.spotShadowMap.length=S,i.directionalShadowMatrix.length=_,i.pointShadowMatrix.length=w,i.spotShadowMatrix.length=S,C.directionalLength=p,C.pointLength=m,C.spotLength=g,C.rectAreaLength=y,C.hemiLength=b,C.numDirectionalShadows=_,C.numPointShadows=w,C.numSpotShadows=S,i.version=pyt++)}function c(u,h){let f=0,d=0,p=0,m=0,g=0;const y=h.matrixWorldInverse;for(let b=0,_=u.length;b<_;b++){const w=u[b];if(w.isDirectionalLight){const S=i.directional[f];S.direction.setFromMatrixPosition(w.matrixWorld),s.setFromMatrixPosition(w.target.matrixWorld),S.direction.sub(s),S.direction.transformDirection(y),f++}else if(w.isSpotLight){const S=i.spot[p];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(y),S.direction.setFromMatrixPosition(w.matrixWorld),s.setFromMatrixPosition(w.target.matrixWorld),S.direction.sub(s),S.direction.transformDirection(y),p++}else if(w.isRectAreaLight){const S=i.rectArea[m];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(y),a.identity(),o.copy(w.matrixWorld),o.premultiply(y),a.extractRotation(o),S.halfWidth.set(w.width*.5,0,0),S.halfHeight.set(0,w.height*.5,0),S.halfWidth.applyMatrix4(a),S.halfHeight.applyMatrix4(a),m++}else if(w.isPointLight){const S=i.point[d];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(y),d++}else if(w.isHemisphereLight){const S=i.hemi[g];S.direction.setFromMatrixPosition(w.matrixWorld),S.direction.transformDirection(y),S.direction.normalize(),g++}}}return{setup:l,setupView:c,state:i}}function v8(n,e){const t=new gyt(n,e),r=[],i=[];function s(){r.length=0,i.length=0}function o(h){r.push(h)}function a(h){i.push(h)}function l(){t.setup(r)}function c(h){t.setupView(r,h)}return{init:s,state:{lightsArray:r,shadowsArray:i,lights:t},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function yyt(n,e){let t=new WeakMap;function r(s,o=0){let a;return t.has(s)===!1?(a=new v8(n,e),t.set(s,[]),t.get(s).push(a)):o>=t.get(s).length?(a=new v8(n,e),t.get(s).push(a)):a=t.get(s)[o],a}function i(){t=new WeakMap}return{get:r,dispose:i}}function fp(n){kn.call(this),this.type="MeshDepthMaterial",this.depthPacking=Gae,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(n)}fp.prototype=Object.create(kn.prototype);fp.prototype.constructor=fp;fp.prototype.isMeshDepthMaterial=!0;fp.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.depthPacking=n.depthPacking,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this};function dp(n){kn.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new Q,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(n)}dp.prototype=Object.create(kn.prototype);dp.prototype.constructor=dp;dp.prototype.isMeshDistanceMaterial=!0;dp.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.referencePosition.copy(n.referencePosition),this.nearDistance=n.nearDistance,this.farDistance=n.farDistance,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this};var byt=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,vyt=`void main() {
	gl_Position = vec4( position, 1.0 );
}`;function ole(n,e,t){let r=new UC;const i=new st,s=new st,o=new Gr,a=[],l=[],c={},u={0:ms,1:nx,2:DC},h=new Ta({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new st},radius:{value:4}},vertexShader:vyt,fragmentShader:byt}),f=h.clone();f.defines.HORIZONTAL_PASS=1;const d=new un;d.setAttribute("position",new Cn(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const p=new ui(d,h),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=G4,this.render=function(S,C,k){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||S.length===0)return;const A=n.getRenderTarget(),M=n.getActiveCubeFace(),E=n.getActiveMipmapLevel(),N=n.state;N.setBlending(Mf),N.buffers.color.setClear(1,1,1,1),N.buffers.depth.setTest(!0),N.setScissorTest(!1);for(let O=0,R=S.length;O<R;O++){const D=S[O],z=D.shadow;if(z===void 0){console.warn("THREE.WebGLShadowMap:",D,"has no shadow.");continue}if(z.autoUpdate===!1&&z.needsUpdate===!1)continue;i.copy(z.mapSize);const B=z.getFrameExtents();if(i.multiply(B),s.copy(z.mapSize),(i.x>t||i.y>t)&&(i.x>t&&(s.x=Math.floor(t/B.x),i.x=s.x*B.x,z.mapSize.x=s.x),i.y>t&&(s.y=Math.floor(t/B.y),i.y=s.y*B.y,z.mapSize.y=s.y)),z.map===null&&!z.isPointLightShadow&&this.type===Sb){const H={minFilter:lo,magFilter:lo,format:Ml};z.map=new qd(i.x,i.y,H),z.map.texture.name=D.name+".shadowMap",z.mapPass=new qd(i.x,i.y,H),z.camera.updateProjectionMatrix()}if(z.map===null){const H={minFilter:Us,magFilter:Us,format:Ml};z.map=new qd(i.x,i.y,H),z.map.texture.name=D.name+".shadowMap",z.camera.updateProjectionMatrix()}n.setRenderTarget(z.map),n.clear();const X=z.getViewportCount();for(let H=0;H<X;H++){const te=z.getViewport(H);o.set(s.x*te.x,s.y*te.y,s.x*te.z,s.y*te.w),N.viewport(o),z.updateMatrices(D,H),r=z.getFrustum(),w(C,k,z.camera,D,this.type)}!z.isPointLightShadow&&this.type===Sb&&g(z,k),z.needsUpdate=!1}m.needsUpdate=!1,n.setRenderTarget(A,M,E)};function g(S,C){const k=e.update(p);h.uniforms.shadow_pass.value=S.map.texture,h.uniforms.resolution.value=S.mapSize,h.uniforms.radius.value=S.radius,n.setRenderTarget(S.mapPass),n.clear(),n.renderBufferDirect(C,null,k,h,p,null),f.uniforms.shadow_pass.value=S.mapPass.texture,f.uniforms.resolution.value=S.mapSize,f.uniforms.radius.value=S.radius,n.setRenderTarget(S.map),n.clear(),n.renderBufferDirect(C,null,k,f,p,null)}function y(S,C,k){const A=S<<0|C<<1|k<<2;let M=a[A];return M===void 0&&(M=new fp({depthPacking:jae,morphTargets:S,skinning:C}),a[A]=M),M}function b(S,C,k){const A=S<<0|C<<1|k<<2;let M=l[A];return M===void 0&&(M=new dp({morphTargets:S,skinning:C}),l[A]=M),M}function _(S,C,k,A,M,E,N){let O=null,R=y,D=S.customDepthMaterial;if(A.isPointLight===!0&&(R=b,D=S.customDistanceMaterial),D===void 0){let z=!1;k.morphTargets===!0&&(z=C.morphAttributes&&C.morphAttributes.position&&C.morphAttributes.position.length>0);let B=!1;S.isSkinnedMesh===!0&&(k.skinning===!0?B=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",S));const X=S.isInstancedMesh===!0;O=R(z,B,X)}else O=D;if(n.localClippingEnabled&&k.clipShadows===!0&&k.clippingPlanes.length!==0){const z=O.uuid,B=k.uuid;let X=c[z];X===void 0&&(X={},c[z]=X);let H=X[B];H===void 0&&(H=O.clone(),X[B]=H),O=H}return O.visible=k.visible,O.wireframe=k.wireframe,N===Sb?O.side=k.shadowSide!==null?k.shadowSide:k.side:O.side=k.shadowSide!==null?k.shadowSide:u[k.side],O.clipShadows=k.clipShadows,O.clippingPlanes=k.clippingPlanes,O.clipIntersection=k.clipIntersection,O.wireframeLinewidth=k.wireframeLinewidth,O.linewidth=k.linewidth,A.isPointLight===!0&&O.isMeshDistanceMaterial===!0&&(O.referencePosition.setFromMatrixPosition(A.matrixWorld),O.nearDistance=M,O.farDistance=E),O}function w(S,C,k,A,M){if(S.visible===!1)return;if(S.layers.test(C.layers)&&(S.isMesh||S.isLine||S.isPoints)&&(S.castShadow||S.receiveShadow&&M===Sb)&&(!S.frustumCulled||r.intersectsObject(S))){S.modelViewMatrix.multiplyMatrices(k.matrixWorldInverse,S.matrixWorld);const O=e.update(S),R=S.material;if(Array.isArray(R)){const D=O.groups;for(let z=0,B=D.length;z<B;z++){const X=D[z],H=R[X.materialIndex];if(H&&H.visible){const te=_(S,O,H,A,k.near,k.far,M);n.renderBufferDirect(k,null,O,te,S,X)}}}else if(R.visible){const D=_(S,O,R,A,k.near,k.far,M);n.renderBufferDirect(k,null,O,D,S,null)}}const N=S.children;for(let O=0,R=N.length;O<R;O++)w(N[O],C,k,A,M)}}function wyt(n,e,t){const r=t.isWebGL2;function i(){let ye=!1;const Je=new Gr;let bt=null;const It=new Gr(0,0,0,0);return{setMask:function(pt){bt!==pt&&!ye&&(n.colorMask(pt,pt,pt,pt),bt=pt)},setLocked:function(pt){ye=pt},setClear:function(pt,ce,rt,Et,yt){yt===!0&&(pt*=Et,ce*=Et,rt*=Et),Je.set(pt,ce,rt,Et),It.equals(Je)===!1&&(n.clearColor(pt,ce,rt,Et),It.copy(Je))},reset:function(){ye=!1,bt=null,It.set(-1,0,0,0)}}}function s(){let ye=!1,Je=null,bt=null,It=null;return{setTest:function(pt){pt?ge(2929):ae(2929)},setMask:function(pt){Je!==pt&&!ye&&(n.depthMask(pt),Je=pt)},setFunc:function(pt){if(bt!==pt){if(pt)switch(pt){case Poe:n.depthFunc(512);break;case Doe:n.depthFunc(519);break;case Ooe:n.depthFunc(513);break;case xA:n.depthFunc(515);break;case Foe:n.depthFunc(514);break;case Loe:n.depthFunc(518);break;case zoe:n.depthFunc(516);break;case Boe:n.depthFunc(517);break;default:n.depthFunc(515)}else n.depthFunc(515);bt=pt}},setLocked:function(pt){ye=pt},setClear:function(pt){It!==pt&&(n.clearDepth(pt),It=pt)},reset:function(){ye=!1,Je=null,bt=null,It=null}}}function o(){let ye=!1,Je=null,bt=null,It=null,pt=null,ce=null,rt=null,Et=null,yt=null;return{setTest:function(Ht){ye||(Ht?ge(2960):ae(2960))},setMask:function(Ht){Je!==Ht&&!ye&&(n.stencilMask(Ht),Je=Ht)},setFunc:function(Ht,Mn,Cr){(bt!==Ht||It!==Mn||pt!==Cr)&&(n.stencilFunc(Ht,Mn,Cr),bt=Ht,It=Mn,pt=Cr)},setOp:function(Ht,Mn,Cr){(ce!==Ht||rt!==Mn||Et!==Cr)&&(n.stencilOp(Ht,Mn,Cr),ce=Ht,rt=Mn,Et=Cr)},setLocked:function(Ht){ye=Ht},setClear:function(Ht){yt!==Ht&&(n.clearStencil(Ht),yt=Ht)},reset:function(){ye=!1,Je=null,bt=null,It=null,pt=null,ce=null,rt=null,Et=null,yt=null}}}const a=new i,l=new s,c=new o;let u={},h=null,f=null,d=null,p=null,m=null,g=null,y=null,b=null,_=null,w=!1,S=null,C=null,k=null,A=null,M=null;const E=n.getParameter(35661);let N=!1,O=0;const R=n.getParameter(7938);R.indexOf("WebGL")!==-1?(O=parseFloat(/^WebGL (\d)/.exec(R)[1]),N=O>=1):R.indexOf("OpenGL ES")!==-1&&(O=parseFloat(/^OpenGL ES (\d)/.exec(R)[1]),N=O>=2);let D=null,z={};const B=new Gr,X=new Gr;function H(ye,Je,bt){const It=new Uint8Array(4),pt=n.createTexture();n.bindTexture(ye,pt),n.texParameteri(ye,10241,9728),n.texParameteri(ye,10240,9728);for(let ce=0;ce<bt;ce++)n.texImage2D(Je+ce,0,6408,1,1,0,6408,5121,It);return pt}const te={};te[3553]=H(3553,3553,1),te[34067]=H(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),ge(2929),l.setFunc(xA),Oe(!1),ot(yF),ge(2884),be(Mf);function ge(ye){u[ye]!==!0&&(n.enable(ye),u[ye]=!0)}function ae(ye){u[ye]!==!1&&(n.disable(ye),u[ye]=!1)}function Ne(ye){return h!==ye?(n.useProgram(ye),h=ye,!0):!1}const Te={[Pm]:32774,[Soe]:32778,[Coe]:32779};if(r)Te[xF]=32775,Te[_F]=32776;else{const ye=e.get("EXT_blend_minmax");ye!==null&&(Te[xF]=ye.MIN_EXT,Te[_F]=ye.MAX_EXT)}const De={[koe]:0,[Toe]:1,[Eoe]:768,[q4]:770,[Roe]:776,[Noe]:774,[Aoe]:772,[Ioe]:769,[X4]:771,[$oe]:775,[Moe]:773};function be(ye,Je,bt,It,pt,ce,rt,Et){if(ye===Mf){f&&(ae(3042),f=!1);return}if(f||(ge(3042),f=!0),ye!==_oe){if(ye!==d||Et!==w){if((p!==Pm||y!==Pm)&&(n.blendEquation(32774),p=Pm,y=Pm),Et)switch(ye){case Db:n.blendFuncSeparate(1,771,1,771);break;case bF:n.blendFunc(1,1);break;case vF:n.blendFuncSeparate(0,0,769,771);break;case wF:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",ye);break}else switch(ye){case Db:n.blendFuncSeparate(770,771,1,771);break;case bF:n.blendFunc(770,1);break;case vF:n.blendFunc(0,769);break;case wF:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",ye);break}m=null,g=null,b=null,_=null,d=ye,w=Et}return}pt=pt||Je,ce=ce||bt,rt=rt||It,(Je!==p||pt!==y)&&(n.blendEquationSeparate(Te[Je],Te[pt]),p=Je,y=pt),(bt!==m||It!==g||ce!==b||rt!==_)&&(n.blendFuncSeparate(De[bt],De[It],De[ce],De[rt]),m=bt,g=It,b=ce,_=rt),d=ye,w=null}function Ke(ye,Je){ye.side===DC?ae(2884):ge(2884);let bt=ye.side===ms;Je&&(bt=!bt),Oe(bt),ye.blending===Db&&ye.transparent===!1?be(Mf):be(ye.blending,ye.blendEquation,ye.blendSrc,ye.blendDst,ye.blendEquationAlpha,ye.blendSrcAlpha,ye.blendDstAlpha,ye.premultipliedAlpha),l.setFunc(ye.depthFunc),l.setTest(ye.depthTest),l.setMask(ye.depthWrite),a.setMask(ye.colorWrite);const It=ye.stencilWrite;c.setTest(It),It&&(c.setMask(ye.stencilWriteMask),c.setFunc(ye.stencilFunc,ye.stencilRef,ye.stencilFuncMask),c.setOp(ye.stencilFail,ye.stencilZFail,ye.stencilZPass)),mt(ye.polygonOffset,ye.polygonOffsetFactor,ye.polygonOffsetUnits)}function Oe(ye){S!==ye&&(ye?n.frontFace(2304):n.frontFace(2305),S=ye)}function ot(ye){ye!==voe?(ge(2884),ye!==C&&(ye===yF?n.cullFace(1029):ye===woe?n.cullFace(1028):n.cullFace(1032))):ae(2884),C=ye}function He(ye){ye!==k&&(N&&n.lineWidth(ye),k=ye)}function mt(ye,Je,bt){ye?(ge(32823),(A!==Je||M!==bt)&&(n.polygonOffset(Je,bt),A=Je,M=bt)):ae(32823)}function ht(ye){ye?ge(3089):ae(3089)}function Ue(ye){ye===void 0&&(ye=33984+E-1),D!==ye&&(n.activeTexture(ye),D=ye)}function Be(ye,Je){D===null&&Ue();let bt=z[D];bt===void 0&&(bt={type:void 0,texture:void 0},z[D]=bt),(bt.type!==ye||bt.texture!==Je)&&(n.bindTexture(ye,Je||te[ye]),bt.type=ye,bt.texture=Je)}function Ve(){const ye=z[D];ye!==void 0&&ye.type!==void 0&&(n.bindTexture(ye.type,null),ye.type=void 0,ye.texture=void 0)}function ft(){try{n.compressedTexImage2D.apply(n,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function Ye(){try{n.texImage2D.apply(n,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function ee(){try{n.texImage3D.apply(n,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function J(ye){B.equals(ye)===!1&&(n.scissor(ye.x,ye.y,ye.z,ye.w),B.copy(ye))}function it(ye){X.equals(ye)===!1&&(n.viewport(ye.x,ye.y,ye.z,ye.w),X.copy(ye))}function Ge(){u={},D=null,z={},h=null,f=null,d=null,p=null,m=null,g=null,y=null,b=null,_=null,w=!1,S=null,C=null,k=null,A=null,M=null,a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:ge,disable:ae,useProgram:Ne,setBlending:be,setMaterial:Ke,setFlipSided:Oe,setCullFace:ot,setLineWidth:He,setPolygonOffset:mt,setScissorTest:ht,activeTexture:Ue,bindTexture:Be,unbindTexture:Ve,compressedTexImage2D:ft,texImage2D:Ye,texImage3D:ee,scissor:J,viewport:it,reset:Ge}}function xyt(n,e,t,r,i,s,o){const a=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,u=i.maxTextureSize,h=i.maxSamples,f=new WeakMap;let d,p=!1;try{p=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function m(ee,J){return p?new OffscreenCanvas(ee,J):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function g(ee,J,it,Ge){let ye=1;if((ee.width>Ge||ee.height>Ge)&&(ye=Ge/Math.max(ee.width,ee.height)),ye<1||J===!0)if(typeof HTMLImageElement<"u"&&ee instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&ee instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&ee instanceof ImageBitmap){const Je=J?In.floorPowerOfTwo:Math.floor,bt=Je(ye*ee.width),It=Je(ye*ee.height);d===void 0&&(d=m(bt,It));const pt=it?m(bt,It):d;return pt.width=bt,pt.height=It,pt.getContext("2d").drawImage(ee,0,0,bt,It),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+ee.width+"x"+ee.height+") to ("+bt+"x"+It+")."),pt}else return"data"in ee&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+ee.width+"x"+ee.height+")."),ee;return ee}function y(ee){return In.isPowerOfTwo(ee.width)&&In.isPowerOfTwo(ee.height)}function b(ee){return a?!1:ee.wrapS!==ma||ee.wrapT!==ma||ee.minFilter!==Us&&ee.minFilter!==lo}function _(ee,J){return ee.generateMipmaps&&J&&ee.minFilter!==Us&&ee.minFilter!==lo}function w(ee,J,it,Ge){n.generateMipmap(ee);const ye=r.get(J);ye.__maxMipLevel=Math.log(Math.max(it,Ge))*Math.LOG2E}function S(ee,J,it){if(a===!1)return J;if(ee!==null){if(n[ee]!==void 0)return n[ee];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+ee+"'")}let Ge=J;return J===6403&&(it===5126&&(Ge=33326),it===5131&&(Ge=33325),it===5121&&(Ge=33321)),J===6407&&(it===5126&&(Ge=34837),it===5131&&(Ge=34843),it===5121&&(Ge=32849)),J===6408&&(it===5126&&(Ge=34836),it===5131&&(Ge=34842),it===5121&&(Ge=32856)),(Ge===33325||Ge===33326||Ge===34842||Ge===34836)&&e.get("EXT_color_buffer_float"),Ge}function C(ee){return ee===Us||ee===CA||ee===kA?9728:9729}function k(ee){const J=ee.target;J.removeEventListener("dispose",k),M(J),J.isVideoTexture&&f.delete(J),o.memory.textures--}function A(ee){const J=ee.target;J.removeEventListener("dispose",A),E(J),o.memory.textures--}function M(ee){const J=r.get(ee);J.__webglInit!==void 0&&(n.deleteTexture(J.__webglTexture),r.remove(ee))}function E(ee){const J=r.get(ee),it=r.get(ee.texture);if(ee){if(it.__webglTexture!==void 0&&n.deleteTexture(it.__webglTexture),ee.depthTexture&&ee.depthTexture.dispose(),ee.isWebGLCubeRenderTarget)for(let Ge=0;Ge<6;Ge++)n.deleteFramebuffer(J.__webglFramebuffer[Ge]),J.__webglDepthbuffer&&n.deleteRenderbuffer(J.__webglDepthbuffer[Ge]);else n.deleteFramebuffer(J.__webglFramebuffer),J.__webglDepthbuffer&&n.deleteRenderbuffer(J.__webglDepthbuffer),J.__webglMultisampledFramebuffer&&n.deleteFramebuffer(J.__webglMultisampledFramebuffer),J.__webglColorRenderbuffer&&n.deleteRenderbuffer(J.__webglColorRenderbuffer),J.__webglDepthRenderbuffer&&n.deleteRenderbuffer(J.__webglDepthRenderbuffer);r.remove(ee.texture),r.remove(ee)}}let N=0;function O(){N=0}function R(){const ee=N;return ee>=l&&console.warn("THREE.WebGLTextures: Trying to use "+ee+" texture units while this GPU supports only "+l),N+=1,ee}function D(ee,J){const it=r.get(ee);if(ee.isVideoTexture&&Ue(ee),ee.version>0&&it.__version!==ee.version){const Ge=ee.image;if(Ge===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(Ge.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Ne(it,ee,J);return}}t.activeTexture(33984+J),t.bindTexture(3553,it.__webglTexture)}function z(ee,J){const it=r.get(ee);if(ee.version>0&&it.__version!==ee.version){Ne(it,ee,J);return}t.activeTexture(33984+J),t.bindTexture(35866,it.__webglTexture)}function B(ee,J){const it=r.get(ee);if(ee.version>0&&it.__version!==ee.version){Ne(it,ee,J);return}t.activeTexture(33984+J),t.bindTexture(32879,it.__webglTexture)}function X(ee,J){const it=r.get(ee);if(ee.version>0&&it.__version!==ee.version){Te(it,ee,J);return}t.activeTexture(33984+J),t.bindTexture(34067,it.__webglTexture)}const H={[nS]:10497,[ma]:33071,[rS]:33648},te={[Us]:9728,[CA]:9984,[kA]:9986,[lo]:9729,[K4]:9985,[ix]:9987};function ge(ee,J,it){it?(n.texParameteri(ee,10242,H[J.wrapS]),n.texParameteri(ee,10243,H[J.wrapT]),(ee===32879||ee===35866)&&n.texParameteri(ee,32882,H[J.wrapR]),n.texParameteri(ee,10240,te[J.magFilter]),n.texParameteri(ee,10241,te[J.minFilter])):(n.texParameteri(ee,10242,33071),n.texParameteri(ee,10243,33071),(ee===32879||ee===35866)&&n.texParameteri(ee,32882,33071),(J.wrapS!==ma||J.wrapT!==ma)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(ee,10240,C(J.magFilter)),n.texParameteri(ee,10241,C(J.minFilter)),J.minFilter!==Us&&J.minFilter!==lo&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const Ge=e.get("EXT_texture_filter_anisotropic");if(Ge){if(J.type===kf&&e.get("OES_texture_float_linear")===null||J.type===sS&&(a||e.get("OES_texture_half_float_linear"))===null)return;(J.anisotropy>1||r.get(J).__currentAnisotropy)&&(n.texParameterf(ee,Ge.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(J.anisotropy,i.getMaxAnisotropy())),r.get(J).__currentAnisotropy=J.anisotropy)}}function ae(ee,J){ee.__webglInit===void 0&&(ee.__webglInit=!0,J.addEventListener("dispose",k),ee.__webglTexture=n.createTexture(),o.memory.textures++)}function Ne(ee,J,it){let Ge=3553;J.isDataTexture2DArray&&(Ge=35866),J.isDataTexture3D&&(Ge=32879),ae(ee,J),t.activeTexture(33984+it),t.bindTexture(Ge,ee.__webglTexture),n.pixelStorei(37440,J.flipY),n.pixelStorei(37441,J.premultiplyAlpha),n.pixelStorei(3317,J.unpackAlignment);const ye=b(J)&&y(J.image)===!1,Je=g(J.image,ye,!1,u),bt=y(Je)||a,It=s.convert(J.format);let pt=s.convert(J.type),ce=S(J.internalFormat,It,pt);ge(Ge,J,bt);let rt;const Et=J.mipmaps;if(J.isDepthTexture)ce=6402,a?J.type===kf?ce=36012:J.type===i_?ce=33190:J.type===Ob?ce=35056:ce=33189:J.type===kf&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),J.format===Zm&&ce===6402&&J.type!==iS&&J.type!==i_&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),J.type=iS,pt=s.convert(J.type)),J.format===fv&&ce===6402&&(ce=34041,J.type!==Ob&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),J.type=Ob,pt=s.convert(J.type))),t.texImage2D(3553,0,ce,Je.width,Je.height,0,It,pt,null);else if(J.isDataTexture)if(Et.length>0&&bt){for(let yt=0,Ht=Et.length;yt<Ht;yt++)rt=Et[yt],t.texImage2D(3553,yt,ce,rt.width,rt.height,0,It,pt,rt.data);J.generateMipmaps=!1,ee.__maxMipLevel=Et.length-1}else t.texImage2D(3553,0,ce,Je.width,Je.height,0,It,pt,Je.data),ee.__maxMipLevel=0;else if(J.isCompressedTexture){for(let yt=0,Ht=Et.length;yt<Ht;yt++)rt=Et[yt],J.format!==Ml&&J.format!==jd?It!==null?t.compressedTexImage2D(3553,yt,ce,rt.width,rt.height,0,rt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,yt,ce,rt.width,rt.height,0,It,pt,rt.data);ee.__maxMipLevel=Et.length-1}else if(J.isDataTexture2DArray)t.texImage3D(35866,0,ce,Je.width,Je.height,Je.depth,0,It,pt,Je.data),ee.__maxMipLevel=0;else if(J.isDataTexture3D)t.texImage3D(32879,0,ce,Je.width,Je.height,Je.depth,0,It,pt,Je.data),ee.__maxMipLevel=0;else if(Et.length>0&&bt){for(let yt=0,Ht=Et.length;yt<Ht;yt++)rt=Et[yt],t.texImage2D(3553,yt,ce,It,pt,rt);J.generateMipmaps=!1,ee.__maxMipLevel=Et.length-1}else t.texImage2D(3553,0,ce,It,pt,Je),ee.__maxMipLevel=0;_(J,bt)&&w(Ge,J,Je.width,Je.height),ee.__version=J.version,J.onUpdate&&J.onUpdate(J)}function Te(ee,J,it){if(J.image.length!==6)return;ae(ee,J),t.activeTexture(33984+it),t.bindTexture(34067,ee.__webglTexture),n.pixelStorei(37440,J.flipY),n.pixelStorei(37441,J.premultiplyAlpha),n.pixelStorei(3317,J.unpackAlignment);const Ge=J&&(J.isCompressedTexture||J.image[0].isCompressedTexture),ye=J.image[0]&&J.image[0].isDataTexture,Je=[];for(let yt=0;yt<6;yt++)!Ge&&!ye?Je[yt]=g(J.image[yt],!1,!0,c):Je[yt]=ye?J.image[yt].image:J.image[yt];const bt=Je[0],It=y(bt)||a,pt=s.convert(J.format),ce=s.convert(J.type),rt=S(J.internalFormat,pt,ce);ge(34067,J,It);let Et;if(Ge){for(let yt=0;yt<6;yt++){Et=Je[yt].mipmaps;for(let Ht=0;Ht<Et.length;Ht++){const Mn=Et[Ht];J.format!==Ml&&J.format!==jd?pt!==null?t.compressedTexImage2D(34069+yt,Ht,rt,Mn.width,Mn.height,0,Mn.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+yt,Ht,rt,Mn.width,Mn.height,0,pt,ce,Mn.data)}}ee.__maxMipLevel=Et.length-1}else{Et=J.mipmaps;for(let yt=0;yt<6;yt++)if(ye){t.texImage2D(34069+yt,0,rt,Je[yt].width,Je[yt].height,0,pt,ce,Je[yt].data);for(let Ht=0;Ht<Et.length;Ht++){const Cr=Et[Ht].image[yt].image;t.texImage2D(34069+yt,Ht+1,rt,Cr.width,Cr.height,0,pt,ce,Cr.data)}}else{t.texImage2D(34069+yt,0,rt,pt,ce,Je[yt]);for(let Ht=0;Ht<Et.length;Ht++){const Mn=Et[Ht];t.texImage2D(34069+yt,Ht+1,rt,pt,ce,Mn.image[yt])}}ee.__maxMipLevel=Et.length}_(J,It)&&w(34067,J,bt.width,bt.height),ee.__version=J.version,J.onUpdate&&J.onUpdate(J)}function De(ee,J,it,Ge){const ye=s.convert(J.texture.format),Je=s.convert(J.texture.type),bt=S(J.texture.internalFormat,ye,Je);t.texImage2D(Ge,0,bt,J.width,J.height,0,ye,Je,null),n.bindFramebuffer(36160,ee),n.framebufferTexture2D(36160,it,Ge,r.get(J.texture).__webglTexture,0),n.bindFramebuffer(36160,null)}function be(ee,J,it){if(n.bindRenderbuffer(36161,ee),J.depthBuffer&&!J.stencilBuffer){let Ge=33189;if(it){const ye=J.depthTexture;ye&&ye.isDepthTexture&&(ye.type===kf?Ge=36012:ye.type===i_&&(Ge=33190));const Je=ht(J);n.renderbufferStorageMultisample(36161,Je,Ge,J.width,J.height)}else n.renderbufferStorage(36161,Ge,J.width,J.height);n.framebufferRenderbuffer(36160,36096,36161,ee)}else if(J.depthBuffer&&J.stencilBuffer){if(it){const Ge=ht(J);n.renderbufferStorageMultisample(36161,Ge,35056,J.width,J.height)}else n.renderbufferStorage(36161,34041,J.width,J.height);n.framebufferRenderbuffer(36160,33306,36161,ee)}else{const Ge=s.convert(J.texture.format),ye=s.convert(J.texture.type),Je=S(J.texture.internalFormat,Ge,ye);if(it){const bt=ht(J);n.renderbufferStorageMultisample(36161,bt,Je,J.width,J.height)}else n.renderbufferStorage(36161,Je,J.width,J.height)}n.bindRenderbuffer(36161,null)}function Ke(ee,J){if(J&&J.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,ee),!(J.depthTexture&&J.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!r.get(J.depthTexture).__webglTexture||J.depthTexture.image.width!==J.width||J.depthTexture.image.height!==J.height)&&(J.depthTexture.image.width=J.width,J.depthTexture.image.height=J.height,J.depthTexture.needsUpdate=!0),D(J.depthTexture,0);const Ge=r.get(J.depthTexture).__webglTexture;if(J.depthTexture.format===Zm)n.framebufferTexture2D(36160,36096,3553,Ge,0);else if(J.depthTexture.format===fv)n.framebufferTexture2D(36160,33306,3553,Ge,0);else throw new Error("Unknown depthTexture format")}function Oe(ee){const J=r.get(ee),it=ee.isWebGLCubeRenderTarget===!0;if(ee.depthTexture){if(it)throw new Error("target.depthTexture not supported in Cube render targets");Ke(J.__webglFramebuffer,ee)}else if(it){J.__webglDepthbuffer=[];for(let Ge=0;Ge<6;Ge++)n.bindFramebuffer(36160,J.__webglFramebuffer[Ge]),J.__webglDepthbuffer[Ge]=n.createRenderbuffer(),be(J.__webglDepthbuffer[Ge],ee,!1)}else n.bindFramebuffer(36160,J.__webglFramebuffer),J.__webglDepthbuffer=n.createRenderbuffer(),be(J.__webglDepthbuffer,ee,!1);n.bindFramebuffer(36160,null)}function ot(ee){const J=r.get(ee),it=r.get(ee.texture);ee.addEventListener("dispose",A),it.__webglTexture=n.createTexture(),o.memory.textures++;const Ge=ee.isWebGLCubeRenderTarget===!0,ye=ee.isWebGLMultisampleRenderTarget===!0,Je=y(ee)||a;if(a&&ee.texture.format===jd&&(ee.texture.type===kf||ee.texture.type===sS)&&(ee.texture.format=Ml,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),Ge){J.__webglFramebuffer=[];for(let bt=0;bt<6;bt++)J.__webglFramebuffer[bt]=n.createFramebuffer()}else if(J.__webglFramebuffer=n.createFramebuffer(),ye)if(a){J.__webglMultisampledFramebuffer=n.createFramebuffer(),J.__webglColorRenderbuffer=n.createRenderbuffer(),n.bindRenderbuffer(36161,J.__webglColorRenderbuffer);const bt=s.convert(ee.texture.format),It=s.convert(ee.texture.type),pt=S(ee.texture.internalFormat,bt,It),ce=ht(ee);n.renderbufferStorageMultisample(36161,ce,pt,ee.width,ee.height),n.bindFramebuffer(36160,J.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064,36161,J.__webglColorRenderbuffer),n.bindRenderbuffer(36161,null),ee.depthBuffer&&(J.__webglDepthRenderbuffer=n.createRenderbuffer(),be(J.__webglDepthRenderbuffer,ee,!0)),n.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(Ge){t.bindTexture(34067,it.__webglTexture),ge(34067,ee.texture,Je);for(let bt=0;bt<6;bt++)De(J.__webglFramebuffer[bt],ee,36064,34069+bt);_(ee.texture,Je)&&w(34067,ee.texture,ee.width,ee.height),t.bindTexture(34067,null)}else t.bindTexture(3553,it.__webglTexture),ge(3553,ee.texture,Je),De(J.__webglFramebuffer,ee,36064,3553),_(ee.texture,Je)&&w(3553,ee.texture,ee.width,ee.height),t.bindTexture(3553,null);ee.depthBuffer&&Oe(ee)}function He(ee){const J=ee.texture,it=y(ee)||a;if(_(J,it)){const Ge=ee.isWebGLCubeRenderTarget?34067:3553,ye=r.get(J).__webglTexture;t.bindTexture(Ge,ye),w(Ge,J,ee.width,ee.height),t.bindTexture(Ge,null)}}function mt(ee){if(ee.isWebGLMultisampleRenderTarget)if(a){const J=r.get(ee);n.bindFramebuffer(36008,J.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,J.__webglFramebuffer);const it=ee.width,Ge=ee.height;let ye=16384;ee.depthBuffer&&(ye|=256),ee.stencilBuffer&&(ye|=1024),n.blitFramebuffer(0,0,it,Ge,0,0,it,Ge,ye,9728),n.bindFramebuffer(36160,J.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function ht(ee){return a&&ee.isWebGLMultisampleRenderTarget?Math.min(h,ee.samples):0}function Ue(ee){const J=o.render.frame;f.get(ee)!==J&&(f.set(ee,J),ee.update())}let Be=!1,Ve=!1;function ft(ee,J){ee&&ee.isWebGLRenderTarget&&(Be===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Be=!0),ee=ee.texture),D(ee,J)}function Ye(ee,J){ee&&ee.isWebGLCubeRenderTarget&&(Ve===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),Ve=!0),ee=ee.texture),X(ee,J)}this.allocateTextureUnit=R,this.resetTextureUnits=O,this.setTexture2D=D,this.setTexture2DArray=z,this.setTexture3D=B,this.setTextureCube=X,this.setupRenderTarget=ot,this.updateRenderTargetMipmap=He,this.updateMultisampleRenderTarget=mt,this.safeSetTexture2D=ft,this.safeSetTextureCube=Ye}function ale(n,e,t){const r=t.isWebGL2;function i(s){let o;if(s===sx)return 5121;if(s===Zoe)return 32819;if(s===Joe)return 32820;if(s===Qoe)return 33635;if(s===Xoe)return 5120;if(s===Koe)return 5122;if(s===iS)return 5123;if(s===Yoe)return 5124;if(s===i_)return 5125;if(s===kf)return 5126;if(s===sS)return r?5131:(o=e.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(s===eae)return 6406;if(s===jd)return 6407;if(s===Ml)return 6408;if(s===tae)return 6409;if(s===nae)return 6410;if(s===Zm)return 6402;if(s===fv)return 34041;if(s===iae)return 6403;if(s===sae)return 36244;if(s===oae)return 33319;if(s===aae)return 33320;if(s===lae)return 36248;if(s===cae)return 36249;if(s===SF||s===CF||s===kF||s===TF)if(o=e.get("WEBGL_compressed_texture_s3tc"),o!==null){if(s===SF)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===CF)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===kF)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===TF)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===EF||s===IF||s===AF||s===MF)if(o=e.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(s===EF)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===IF)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===AF)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===MF)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===uae)return o=e.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if((s===NF||s===$F)&&(o=e.get("WEBGL_compressed_texture_etc"),o!==null)){if(s===NF)return o.COMPRESSED_RGB8_ETC2;if(s===$F)return o.COMPRESSED_RGBA8_ETC2_EAC}if(s===hae||s===fae||s===dae||s===pae||s===mae||s===gae||s===yae||s===bae||s===vae||s===wae||s===xae||s===_ae||s===Sae||s===Cae||s===Tae||s===Eae||s===Iae||s===Aae||s===Mae||s===Nae||s===$ae||s===Rae||s===Pae||s===Dae||s===Oae||s===Fae||s===Lae||s===zae)return o=e.get("WEBGL_compressed_texture_astc"),o!==null?s:null;if(s===kae)return o=e.get("EXT_texture_compression_bptc"),o!==null?s:null;if(s===Ob)return r?34042:(o=e.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:i}}function TA(n=[]){_s.call(this),this.cameras=n}TA.prototype=Object.assign(Object.create(_s.prototype),{constructor:TA,isArrayCamera:!0});function Od(){rn.call(this),this.type="Group"}Od.prototype=Object.assign(Object.create(rn.prototype),{constructor:Od,isGroup:!0});function o_(){this._targetRay=null,this._grip=null,this._hand=null}Object.assign(o_.prototype,{constructor:o_,getHandSpace:function(){return this._hand===null&&(this._hand=new Od,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand},getTargetRaySpace:function(){return this._targetRay===null&&(this._targetRay=new Od,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return this._grip===null&&(this._grip=new Od,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(n){return this._targetRay!==null&&this._targetRay.dispatchEvent(n),this._grip!==null&&this._grip.dispatchEvent(n),this._hand!==null&&this._hand.dispatchEvent(n),this},disconnect:function(n){return this.dispatchEvent({type:"disconnected",data:n}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this},update:function(n,e,t){let r=null,i=null,s=null;const o=this._targetRay,a=this._grip,l=this._hand;if(n&&e.session.visibilityState!=="visible-blurred")if(l&&n.hand){s=!0;for(const p of n.hand.values()){const m=e.getJointPose(p,t);if(l.joints[p.jointName]===void 0){const y=new Od;y.matrixAutoUpdate=!1,y.visible=!1,l.joints[p.jointName]=y,l.add(y)}const g=l.joints[p.jointName];m!==null&&(g.matrix.fromArray(m.transform.matrix),g.matrix.decompose(g.position,g.rotation,g.scale),g.jointRadius=m.radius),g.visible=m!==null}const c=l.joints["index-finger-tip"],u=l.joints["thumb-tip"],h=c.position.distanceTo(u.position),f=.02,d=.005;l.inputState.pinching&&h>f+d?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:n.handedness,target:this})):!l.inputState.pinching&&h<=f-d&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:n.handedness,target:this}))}else o!==null&&(r=e.getPose(n.targetRaySpace,t),r!==null&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale))),a!==null&&n.gripSpace&&(i=e.getPose(n.gripSpace,t),i!==null&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale)));return o!==null&&(o.visible=r!==null),a!==null&&(a.visible=i!==null),l!==null&&(l.visible=s!==null),this}});function lle(n,e){const t=this;let r=null,i=1,s=null,o="local-floor",a=null;const l=[],c=new Map,u=new _s;u.layers.enable(1),u.viewport=new Gr;const h=new _s;h.layers.enable(2),h.viewport=new Gr;const f=[u,h],d=new TA;d.layers.enable(1),d.layers.enable(2);let p=null,m=null;this.enabled=!1,this.isPresenting=!1,this.getController=function(E){let N=l[E];return N===void 0&&(N=new o_,l[E]=N),N.getTargetRaySpace()},this.getControllerGrip=function(E){let N=l[E];return N===void 0&&(N=new o_,l[E]=N),N.getGripSpace()},this.getHand=function(E){let N=l[E];return N===void 0&&(N=new o_,l[E]=N),N.getHandSpace()};function g(E){const N=c.get(E.inputSource);N&&N.dispatchEvent({type:E.type,data:E.inputSource})}function y(){c.forEach(function(E,N){E.disconnect(N)}),c.clear(),p=null,m=null,n.setFramebuffer(null),n.setRenderTarget(n.getRenderTarget()),M.stop(),t.isPresenting=!1,t.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(E){i=E,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(E){o=E,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return s},this.getSession=function(){return r},this.setSession=async function(E){if(r=E,r!==null){r.addEventListener("select",g),r.addEventListener("selectstart",g),r.addEventListener("selectend",g),r.addEventListener("squeeze",g),r.addEventListener("squeezestart",g),r.addEventListener("squeezeend",g),r.addEventListener("end",y),r.addEventListener("inputsourceschange",b);const N=e.getContextAttributes();N.xrCompatible!==!0&&await e.makeXRCompatible();const O={antialias:N.antialias,alpha:N.alpha,depth:N.depth,stencil:N.stencil,framebufferScaleFactor:i},R=new XRWebGLLayer(r,e,O);r.updateRenderState({baseLayer:R}),s=await r.requestReferenceSpace(o),M.setContext(r),M.start(),t.isPresenting=!0,t.dispatchEvent({type:"sessionstart"})}};function b(E){const N=r.inputSources;for(let O=0;O<l.length;O++)c.set(N[O],l[O]);for(let O=0;O<E.removed.length;O++){const R=E.removed[O],D=c.get(R);D&&(D.dispatchEvent({type:"disconnected",data:R}),c.delete(R))}for(let O=0;O<E.added.length;O++){const R=E.added[O],D=c.get(R);D&&D.dispatchEvent({type:"connected",data:R})}}const _=new Q,w=new Q;function S(E,N,O){_.setFromMatrixPosition(N.matrixWorld),w.setFromMatrixPosition(O.matrixWorld);const R=_.distanceTo(w),D=N.projectionMatrix.elements,z=O.projectionMatrix.elements,B=D[14]/(D[10]-1),X=D[14]/(D[10]+1),H=(D[9]+1)/D[5],te=(D[9]-1)/D[5],ge=(D[8]-1)/D[0],ae=(z[8]+1)/z[0],Ne=B*ge,Te=B*ae,De=R/(-ge+ae),be=De*-ge;N.matrixWorld.decompose(E.position,E.quaternion,E.scale),E.translateX(be),E.translateZ(De),E.matrixWorld.compose(E.position,E.quaternion,E.scale),E.matrixWorldInverse.copy(E.matrixWorld).invert();const Ke=B+De,Oe=X+De,ot=Ne-be,He=Te+(R-be),mt=H*X/Oe*Ke,ht=te*X/Oe*Ke;E.projectionMatrix.makePerspective(ot,He,mt,ht,Ke,Oe)}function C(E,N){N===null?E.matrixWorld.copy(E.matrix):E.matrixWorld.multiplyMatrices(N.matrixWorld,E.matrix),E.matrixWorldInverse.copy(E.matrixWorld).invert()}this.getCamera=function(E){d.near=h.near=u.near=E.near,d.far=h.far=u.far=E.far,(p!==d.near||m!==d.far)&&(r.updateRenderState({depthNear:d.near,depthFar:d.far}),p=d.near,m=d.far);const N=E.parent,O=d.cameras;C(d,N);for(let D=0;D<O.length;D++)C(O[D],N);E.matrixWorld.copy(d.matrixWorld),E.matrix.copy(d.matrix),E.matrix.decompose(E.position,E.quaternion,E.scale);const R=E.children;for(let D=0,z=R.length;D<z;D++)R[D].updateMatrixWorld(!0);return O.length===2?S(d,u,h):d.projectionMatrix.copy(u.projectionMatrix),d};let k=null;function A(E,N){if(a=N.getViewerPose(s),a!==null){const R=a.views,D=r.renderState.baseLayer;n.setFramebuffer(D.framebuffer);let z=!1;R.length!==d.cameras.length&&(d.cameras.length=0,z=!0);for(let B=0;B<R.length;B++){const X=R[B],H=D.getViewport(X),te=f[B];te.matrix.fromArray(X.transform.matrix),te.projectionMatrix.fromArray(X.projectionMatrix),te.viewport.set(H.x,H.y,H.width,H.height),B===0&&d.matrix.copy(te.matrix),z===!0&&d.cameras.push(te)}}const O=r.inputSources;for(let R=0;R<l.length;R++){const D=l[R],z=O[R];D.update(z,N,s)}k&&k(E,N)}const M=new Jae;M.setAnimationLoop(A),this.setAnimationLoop=function(E){k=E},this.dispose=function(){}}Object.assign(lle.prototype,Wu.prototype);function _yt(n){function e(y,b){y.fogColor.value.copy(b.color),b.isFog?(y.fogNear.value=b.near,y.fogFar.value=b.far):b.isFogExp2&&(y.fogDensity.value=b.density)}function t(y,b,_,w){b.isMeshBasicMaterial?r(y,b):b.isMeshLambertMaterial?(r(y,b),l(y,b)):b.isMeshToonMaterial?(r(y,b),u(y,b)):b.isMeshPhongMaterial?(r(y,b),c(y,b)):b.isMeshStandardMaterial?(r(y,b),b.isMeshPhysicalMaterial?f(y,b):h(y,b)):b.isMeshMatcapMaterial?(r(y,b),d(y,b)):b.isMeshDepthMaterial?(r(y,b),p(y,b)):b.isMeshDistanceMaterial?(r(y,b),m(y,b)):b.isMeshNormalMaterial?(r(y,b),g(y,b)):b.isLineBasicMaterial?(i(y,b),b.isLineDashedMaterial&&s(y,b)):b.isPointsMaterial?o(y,b,_,w):b.isSpriteMaterial?a(y,b):b.isShadowMaterial?(y.color.value.copy(b.color),y.opacity.value=b.opacity):b.isShaderMaterial&&(b.uniformsNeedUpdate=!1)}function r(y,b){y.opacity.value=b.opacity,b.color&&y.diffuse.value.copy(b.color),b.emissive&&y.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity),b.map&&(y.map.value=b.map),b.alphaMap&&(y.alphaMap.value=b.alphaMap),b.specularMap&&(y.specularMap.value=b.specularMap);const _=n.get(b).envMap;if(_){y.envMap.value=_,y.flipEnvMap.value=_.isCubeTexture&&_._needsFlipEnvMap?-1:1,y.reflectivity.value=b.reflectivity,y.refractionRatio.value=b.refractionRatio;const C=n.get(_).__maxMipLevel;C!==void 0&&(y.maxMipLevel.value=C)}b.lightMap&&(y.lightMap.value=b.lightMap,y.lightMapIntensity.value=b.lightMapIntensity),b.aoMap&&(y.aoMap.value=b.aoMap,y.aoMapIntensity.value=b.aoMapIntensity);let w;b.map?w=b.map:b.specularMap?w=b.specularMap:b.displacementMap?w=b.displacementMap:b.normalMap?w=b.normalMap:b.bumpMap?w=b.bumpMap:b.roughnessMap?w=b.roughnessMap:b.metalnessMap?w=b.metalnessMap:b.alphaMap?w=b.alphaMap:b.emissiveMap?w=b.emissiveMap:b.clearcoatMap?w=b.clearcoatMap:b.clearcoatNormalMap?w=b.clearcoatNormalMap:b.clearcoatRoughnessMap&&(w=b.clearcoatRoughnessMap),w!==void 0&&(w.isWebGLRenderTarget&&(w=w.texture),w.matrixAutoUpdate===!0&&w.updateMatrix(),y.uvTransform.value.copy(w.matrix));let S;b.aoMap?S=b.aoMap:b.lightMap&&(S=b.lightMap),S!==void 0&&(S.isWebGLRenderTarget&&(S=S.texture),S.matrixAutoUpdate===!0&&S.updateMatrix(),y.uv2Transform.value.copy(S.matrix))}function i(y,b){y.diffuse.value.copy(b.color),y.opacity.value=b.opacity}function s(y,b){y.dashSize.value=b.dashSize,y.totalSize.value=b.dashSize+b.gapSize,y.scale.value=b.scale}function o(y,b,_,w){y.diffuse.value.copy(b.color),y.opacity.value=b.opacity,y.size.value=b.size*_,y.scale.value=w*.5,b.map&&(y.map.value=b.map),b.alphaMap&&(y.alphaMap.value=b.alphaMap);let S;b.map?S=b.map:b.alphaMap&&(S=b.alphaMap),S!==void 0&&(S.matrixAutoUpdate===!0&&S.updateMatrix(),y.uvTransform.value.copy(S.matrix))}function a(y,b){y.diffuse.value.copy(b.color),y.opacity.value=b.opacity,y.rotation.value=b.rotation,b.map&&(y.map.value=b.map),b.alphaMap&&(y.alphaMap.value=b.alphaMap);let _;b.map?_=b.map:b.alphaMap&&(_=b.alphaMap),_!==void 0&&(_.matrixAutoUpdate===!0&&_.updateMatrix(),y.uvTransform.value.copy(_.matrix))}function l(y,b){b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap)}function c(y,b){y.specular.value.copy(b.specular),y.shininess.value=Math.max(b.shininess,1e-4),b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===ms&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===ms&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function u(y,b){b.gradientMap&&(y.gradientMap.value=b.gradientMap),b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===ms&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===ms&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function h(y,b){y.roughness.value=b.roughness,y.metalness.value=b.metalness,b.roughnessMap&&(y.roughnessMap.value=b.roughnessMap),b.metalnessMap&&(y.metalnessMap.value=b.metalnessMap),b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===ms&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===ms&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias),n.get(b).envMap&&(y.envMapIntensity.value=b.envMapIntensity)}function f(y,b){h(y,b),y.reflectivity.value=b.reflectivity,y.clearcoat.value=b.clearcoat,y.clearcoatRoughness.value=b.clearcoatRoughness,b.sheen&&y.sheen.value.copy(b.sheen),b.clearcoatMap&&(y.clearcoatMap.value=b.clearcoatMap),b.clearcoatRoughnessMap&&(y.clearcoatRoughnessMap.value=b.clearcoatRoughnessMap),b.clearcoatNormalMap&&(y.clearcoatNormalScale.value.copy(b.clearcoatNormalScale),y.clearcoatNormalMap.value=b.clearcoatNormalMap,b.side===ms&&y.clearcoatNormalScale.value.negate()),y.transmission.value=b.transmission,b.transmissionMap&&(y.transmissionMap.value=b.transmissionMap)}function d(y,b){b.matcap&&(y.matcap.value=b.matcap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===ms&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===ms&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function p(y,b){b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function m(y,b){b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias),y.referencePosition.value.copy(b.referencePosition),y.nearDistance.value=b.nearDistance,y.farDistance.value=b.farDistance}function g(y,b){b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===ms&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===ms&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}return{refreshFogUniforms:e,refreshMaterialUniforms:t}}function Syt(){const n=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return n.style.display="block",n}function WC(n){n=n||{};const e=n.canvas!==void 0?n.canvas:Syt(),t=n.context!==void 0?n.context:null,r=n.alpha!==void 0?n.alpha:!1,i=n.depth!==void 0?n.depth:!0,s=n.stencil!==void 0?n.stencil:!0,o=n.antialias!==void 0?n.antialias:!1,a=n.premultipliedAlpha!==void 0?n.premultipliedAlpha:!0,l=n.preserveDrawingBuffer!==void 0?n.preserveDrawingBuffer:!1,c=n.powerPreference!==void 0?n.powerPreference:"default",u=n.failIfMajorPerformanceCaveat!==void 0?n.failIfMajorPerformanceCaveat:!1;let h=null,f=null;const d=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=ka,this.physicallyCorrectLights=!1,this.toneMapping=Ym,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const p=this;let m=!1,g=null,y=0,b=0,_=null,w=null,S=-1,C=null;const k=new Gr,A=new Gr;let M=null,E=e.width,N=e.height,O=1,R=null,D=null;const z=new Gr(0,0,E,N),B=new Gr(0,0,E,N);let X=!1;const H=new UC;let te=!1,ge=!1;const ae=new Zn,Ne=new Q,Te={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function De(){return _===null?O:1}let be=t;function Ke(re,We){for(let Fe=0;Fe<re.length;Fe++){const Qe=re[Fe],wt=e.getContext(Qe,We);if(wt!==null)return wt}return null}try{const re={alpha:r,depth:i,stencil:s,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:u};if(e.addEventListener("webglcontextlost",Mn,!1),e.addEventListener("webglcontextrestored",Cr,!1),be===null){const We=["webgl2","webgl","experimental-webgl"];if(p.isWebGL1Renderer===!0&&We.shift(),be=Ke(We,re),be===null)throw Ke(We)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}be.getShaderPrecisionFormat===void 0&&(be.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(re){throw console.error("THREE.WebGLRenderer: "+re.message),re}let Oe,ot,He,mt,ht,Ue,Be,Ve,ft,Ye,ee,J,it,Ge,ye,Je,bt,It,pt,ce,rt;function Et(){Oe=new tgt(be),ot=new Jmt(be,Oe,n),Oe.init(ot),ce=new ale(be,Oe,ot),He=new wyt(be,Oe,ot),He.scissor(A.copy(B).multiplyScalar(O).floor()),He.viewport(k.copy(z).multiplyScalar(O).floor()),mt=new igt,ht=new lyt,Ue=new xyt(be,Oe,He,ht,ot,ce,mt),Be=new egt(p),Ve=new Edt(be,ot),rt=new Ymt(be,Oe,Ve,ot),ft=new ngt(be,Ve,mt,rt),Ye=new lgt(be,ft,Ve,mt),bt=new agt(be),ye=new Qmt(ht),ee=new ayt(p,Be,Oe,ot,rt,ye),J=new _yt(ht),it=new hyt(ht),Ge=new yyt(Oe,ot),Je=new Kmt(p,Be,He,Ye,a),It=new Zmt(be,Oe,mt,ot),pt=new rgt(be,Oe,mt,ot),mt.programs=ee.programs,p.capabilities=ot,p.extensions=Oe,p.properties=ht,p.renderLists=it,p.state=He,p.info=mt}Et();const yt=new lle(p,be);this.xr=yt;const Ht=new ole(p,Ye,ot.maxTextureSize);this.shadowMap=Ht,this.getContext=function(){return be},this.getContextAttributes=function(){return be.getContextAttributes()},this.forceContextLoss=function(){const re=Oe.get("WEBGL_lose_context");re&&re.loseContext()},this.forceContextRestore=function(){const re=Oe.get("WEBGL_lose_context");re&&re.restoreContext()},this.getPixelRatio=function(){return O},this.setPixelRatio=function(re){re!==void 0&&(O=re,this.setSize(E,N,!1))},this.getSize=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),re=new st),re.set(E,N)},this.setSize=function(re,We,Fe){if(yt.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}E=re,N=We,e.width=Math.floor(re*O),e.height=Math.floor(We*O),Fe!==!1&&(e.style.width=re+"px",e.style.height=We+"px"),this.setViewport(0,0,re,We)},this.getDrawingBufferSize=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),re=new st),re.set(E*O,N*O).floor()},this.setDrawingBufferSize=function(re,We,Fe){E=re,N=We,O=Fe,e.width=Math.floor(re*Fe),e.height=Math.floor(We*Fe),this.setViewport(0,0,re,We)},this.getCurrentViewport=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),re=new Gr),re.copy(k)},this.getViewport=function(re){return re.copy(z)},this.setViewport=function(re,We,Fe,Qe){re.isVector4?z.set(re.x,re.y,re.z,re.w):z.set(re,We,Fe,Qe),He.viewport(k.copy(z).multiplyScalar(O).floor())},this.getScissor=function(re){return re.copy(B)},this.setScissor=function(re,We,Fe,Qe){re.isVector4?B.set(re.x,re.y,re.z,re.w):B.set(re,We,Fe,Qe),He.scissor(A.copy(B).multiplyScalar(O).floor())},this.getScissorTest=function(){return X},this.setScissorTest=function(re){He.setScissorTest(X=re)},this.setOpaqueSort=function(re){R=re},this.setTransparentSort=function(re){D=re},this.getClearColor=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),re=new Gt),re.copy(Je.getClearColor())},this.setClearColor=function(){Je.setClearColor.apply(Je,arguments)},this.getClearAlpha=function(){return Je.getClearAlpha()},this.setClearAlpha=function(){Je.setClearAlpha.apply(Je,arguments)},this.clear=function(re,We,Fe){let Qe=0;(re===void 0||re)&&(Qe|=16384),(We===void 0||We)&&(Qe|=256),(Fe===void 0||Fe)&&(Qe|=1024),be.clear(Qe)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Mn,!1),e.removeEventListener("webglcontextrestored",Cr,!1),it.dispose(),Ge.dispose(),ht.dispose(),Be.dispose(),Ye.dispose(),rt.dispose(),yt.dispose(),mo.stop()};function Mn(re){re.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),m=!0}function Cr(){console.log("THREE.WebGLRenderer: Context Restored."),m=!1,Et()}function Bi(re){const We=re.target;We.removeEventListener("dispose",Bi),Ai(We)}function Ai(re){Mi(re),ht.remove(re)}function Mi(re){const We=ht.get(re).program;We!==void 0&&ee.releaseProgram(We)}function zh(re,We){re.render(function(Fe){p.renderBufferImmediate(Fe,We)})}this.renderBufferImmediate=function(re,We){rt.initAttributes();const Fe=ht.get(re);re.hasPositions&&!Fe.position&&(Fe.position=be.createBuffer()),re.hasNormals&&!Fe.normal&&(Fe.normal=be.createBuffer()),re.hasUvs&&!Fe.uv&&(Fe.uv=be.createBuffer()),re.hasColors&&!Fe.color&&(Fe.color=be.createBuffer());const Qe=We.getAttributes();re.hasPositions&&(be.bindBuffer(34962,Fe.position),be.bufferData(34962,re.positionArray,35048),rt.enableAttribute(Qe.position),be.vertexAttribPointer(Qe.position,3,5126,!1,0,0)),re.hasNormals&&(be.bindBuffer(34962,Fe.normal),be.bufferData(34962,re.normalArray,35048),rt.enableAttribute(Qe.normal),be.vertexAttribPointer(Qe.normal,3,5126,!1,0,0)),re.hasUvs&&(be.bindBuffer(34962,Fe.uv),be.bufferData(34962,re.uvArray,35048),rt.enableAttribute(Qe.uv),be.vertexAttribPointer(Qe.uv,2,5126,!1,0,0)),re.hasColors&&(be.bindBuffer(34962,Fe.color),be.bufferData(34962,re.colorArray,35048),rt.enableAttribute(Qe.color),be.vertexAttribPointer(Qe.color,3,5126,!1,0,0)),rt.disableUnusedAttributes(),be.drawArrays(4,0,re.count),re.count=0},this.renderBufferDirect=function(re,We,Fe,Qe,wt,Bn){We===null&&(We=Te);const sn=wt.isMesh&&wt.matrixWorld.determinant()<0,Tn=Bh(re,We,Qe,wt);He.setMaterial(Qe,sn);let En=Fe.index;const Nn=Fe.attributes.position;if(En===null){if(Nn===void 0||Nn.count===0)return}else if(En.count===0)return;let tr=1;Qe.wireframe===!0&&(En=ft.getWireframeAttribute(Fe),tr=2),(Qe.morphTargets||Qe.morphNormals)&&bt.update(wt,Fe,Qe,Tn),rt.setup(wt,Qe,Tn,Fe,En);let _n,hr=It;En!==null&&(_n=Ve.get(En),hr=pt,hr.setIndex(_n));const Ds=En!==null?En.count:Nn.count,xr=Fe.drawRange.start*tr,Zs=Fe.drawRange.count*tr,Ar=Bn!==null?Bn.start*tr:0,Mo=Bn!==null?Bn.count*tr:1/0,ri=Math.max(xr,Ar),go=Math.min(Ds,xr+Zs,Ar+Mo)-1,No=Math.max(0,go-ri+1);if(No!==0){if(wt.isMesh)Qe.wireframe===!0?(He.setLineWidth(Qe.wireframeLinewidth*De()),hr.setMode(1)):hr.setMode(4);else if(wt.isLine){let Ni=Qe.linewidth;Ni===void 0&&(Ni=1),He.setLineWidth(Ni*De()),wt.isLineSegments?hr.setMode(1):wt.isLineLoop?hr.setMode(2):hr.setMode(3)}else wt.isPoints?hr.setMode(0):wt.isSprite&&hr.setMode(4);if(wt.isInstancedMesh)hr.renderInstances(ri,No,wt.count);else if(Fe.isInstancedBufferGeometry){const Ni=Math.min(Fe.instanceCount,Fe._maxInstanceCount);hr.renderInstances(ri,No,Ni)}else hr.render(ri,No)}},this.compile=function(re,We){f=Ge.get(re),f.init(),re.traverseVisible(function(Qe){Qe.isLight&&Qe.layers.test(We.layers)&&(f.pushLight(Qe),Qe.castShadow&&f.pushShadow(Qe))}),f.setupLights();const Fe=new WeakMap;re.traverse(function(Qe){const wt=Qe.material;if(wt)if(Array.isArray(wt))for(let Bn=0;Bn<wt.length;Bn++){const sn=wt[Bn];Fe.has(sn)===!1&&(Ps(sn,re,Qe),Fe.set(sn))}else Fe.has(wt)===!1&&(Ps(wt,re,Qe),Fe.set(wt))})};let Ul=null;function Wl(re){yt.isPresenting||Ul&&Ul(re)}const mo=new Jae;mo.setAnimationLoop(Wl),typeof window<"u"&&mo.setContext(window),this.setAnimationLoop=function(re){Ul=re,yt.setAnimationLoop(re),re===null?mo.stop():mo.start()},this.render=function(re,We){let Fe,Qe;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),Fe=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),Qe=arguments[3]),We!==void 0&&We.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(m===!0)return;rt.resetDefaultState(),S=-1,C=null,re.autoUpdate===!0&&re.updateMatrixWorld(),We.parent===null&&We.updateMatrixWorld(),yt.enabled===!0&&yt.isPresenting===!0&&(We=yt.getCamera(We)),re.isScene===!0&&re.onBeforeRender(p,re,We,Fe||_),f=Ge.get(re,d.length),f.init(),d.push(f),ae.multiplyMatrices(We.projectionMatrix,We.matrixWorldInverse),H.setFromProjectionMatrix(ae),ge=this.localClippingEnabled,te=ye.init(this.clippingPlanes,ge,We),h=it.get(re,We),h.init(),Hl(re,We,0,p.sortObjects),h.finish(),p.sortObjects===!0&&h.sort(R,D),te===!0&&ye.beginShadows();const wt=f.state.shadowsArray;Ht.render(wt,re,We),f.setupLights(),f.setupLightsView(We),te===!0&&ye.endShadows(),this.info.autoReset===!0&&this.info.reset(),Fe!==void 0&&this.setRenderTarget(Fe),Je.render(h,re,We,Qe);const Bn=h.opaque,sn=h.transparent;Bn.length>0&&Bc(Bn,re,We),sn.length>0&&Bc(sn,re,We),re.isScene===!0&&re.onAfterRender(p,re,We),_!==null&&(Ue.updateRenderTargetMipmap(_),Ue.updateMultisampleRenderTarget(_)),He.buffers.depth.setTest(!0),He.buffers.depth.setMask(!0),He.buffers.color.setMask(!0),He.setPolygonOffset(!1),d.pop(),d.length>0?f=d[d.length-1]:f=null,h=null};function Hl(re,We,Fe,Qe){if(re.visible===!1)return;if(re.layers.test(We.layers)){if(re.isGroup)Fe=re.renderOrder;else if(re.isLOD)re.autoUpdate===!0&&re.update(We);else if(re.isLight)f.pushLight(re),re.castShadow&&f.pushShadow(re);else if(re.isSprite){if(!re.frustumCulled||H.intersectsSprite(re)){Qe&&Ne.setFromMatrixPosition(re.matrixWorld).applyMatrix4(ae);const sn=Ye.update(re),Tn=re.material;Tn.visible&&h.push(re,sn,Tn,Fe,Ne.z,null)}}else if(re.isImmediateRenderObject)Qe&&Ne.setFromMatrixPosition(re.matrixWorld).applyMatrix4(ae),h.push(re,null,re.material,Fe,Ne.z,null);else if((re.isMesh||re.isLine||re.isPoints)&&(re.isSkinnedMesh&&re.skeleton.frame!==mt.render.frame&&(re.skeleton.update(),re.skeleton.frame=mt.render.frame),!re.frustumCulled||H.intersectsObject(re))){Qe&&Ne.setFromMatrixPosition(re.matrixWorld).applyMatrix4(ae);const sn=Ye.update(re),Tn=re.material;if(Array.isArray(Tn)){const En=sn.groups;for(let Nn=0,tr=En.length;Nn<tr;Nn++){const _n=En[Nn],hr=Tn[_n.materialIndex];hr&&hr.visible&&h.push(re,sn,hr,Fe,Ne.z,_n)}}else Tn.visible&&h.push(re,sn,Tn,Fe,Ne.z,null)}}const Bn=re.children;for(let sn=0,Tn=Bn.length;sn<Tn;sn++)Hl(Bn[sn],We,Fe,Qe)}function Bc(re,We,Fe){const Qe=We.isScene===!0?We.overrideMaterial:null;for(let wt=0,Bn=re.length;wt<Bn;wt++){const sn=re[wt],Tn=sn.object,En=sn.geometry,Nn=Qe===null?sn.material:Qe,tr=sn.group;if(Fe.isArrayCamera){const _n=Fe.cameras;for(let hr=0,Ds=_n.length;hr<Ds;hr++){const xr=_n[hr];Tn.layers.test(xr.layers)&&(He.viewport(k.copy(xr.viewport)),f.setupLightsView(xr),Vc(Tn,We,xr,En,Nn,tr))}}else Vc(Tn,We,Fe,En,Nn,tr)}}function Vc(re,We,Fe,Qe,wt,Bn){if(re.onBeforeRender(p,We,Fe,Qe,wt,Bn),re.modelViewMatrix.multiplyMatrices(Fe.matrixWorldInverse,re.matrixWorld),re.normalMatrix.getNormalMatrix(re.modelViewMatrix),re.isImmediateRenderObject){const sn=Bh(Fe,We,wt,re);He.setMaterial(wt),rt.reset(),zh(re,sn)}else p.renderBufferDirect(Fe,We,Qe,wt,re,Bn);re.onAfterRender(p,We,Fe,Qe,wt,Bn)}function Ps(re,We,Fe){We.isScene!==!0&&(We=Te);const Qe=ht.get(re),wt=f.state.lights,Bn=f.state.shadowsArray,sn=wt.state.version,Tn=ee.getParameters(re,wt.state,Bn,We,Fe),En=ee.getProgramCacheKey(Tn);let Nn=Qe.program,tr=!0;if(Qe.environment=re.isMeshStandardMaterial?We.environment:null,Qe.fog=We.fog,Qe.envMap=Be.get(re.envMap||Qe.environment),Nn===void 0)re.addEventListener("dispose",Bi);else if(Nn.cacheKey!==En)Mi(re);else if(Qe.lightsStateVersion!==sn)tr=!1;else{if(Tn.shaderID!==void 0)return;tr=!1}tr&&(Tn.uniforms=ee.getUniforms(re),re.onBeforeCompile(Tn,p),Nn=ee.acquireProgram(Tn,En),Qe.program=Nn,Qe.uniforms=Tn.uniforms,Qe.outputEncoding=Tn.outputEncoding);const _n=Qe.uniforms;(!re.isShaderMaterial&&!re.isRawShaderMaterial||re.clipping===!0)&&(Qe.numClippingPlanes=ye.numPlanes,Qe.numIntersection=ye.numIntersection,_n.clippingPlanes=ye.uniform),Qe.needsLights=Vh(re),Qe.lightsStateVersion=sn,Qe.needsLights&&(_n.ambientLightColor.value=wt.state.ambient,_n.lightProbe.value=wt.state.probe,_n.directionalLights.value=wt.state.directional,_n.directionalLightShadows.value=wt.state.directionalShadow,_n.spotLights.value=wt.state.spot,_n.spotLightShadows.value=wt.state.spotShadow,_n.rectAreaLights.value=wt.state.rectArea,_n.ltc_1.value=wt.state.rectAreaLTC1,_n.ltc_2.value=wt.state.rectAreaLTC2,_n.pointLights.value=wt.state.point,_n.pointLightShadows.value=wt.state.pointShadow,_n.hemisphereLights.value=wt.state.hemi,_n.directionalShadowMap.value=wt.state.directionalShadowMap,_n.directionalShadowMatrix.value=wt.state.directionalShadowMatrix,_n.spotShadowMap.value=wt.state.spotShadowMap,_n.spotShadowMatrix.value=wt.state.spotShadowMatrix,_n.pointShadowMap.value=wt.state.pointShadowMap,_n.pointShadowMatrix.value=wt.state.pointShadowMatrix);const hr=Qe.program.getUniforms(),Ds=Xd.seqWithValue(hr.seq,_n);Qe.uniformsList=Ds}function Bh(re,We,Fe,Qe){We.isScene!==!0&&(We=Te),Ue.resetTextureUnits();const wt=We.fog,Bn=Fe.isMeshStandardMaterial?We.environment:null,sn=_===null?p.outputEncoding:_.texture.encoding,Tn=Be.get(Fe.envMap||Bn),En=ht.get(Fe),Nn=f.state.lights;if(te===!0&&(ge===!0||re!==C)){const Ar=re===C&&Fe.id===S;ye.setState(Fe,re,Ar)}Fe.version===En.__version?(Fe.fog&&En.fog!==wt||En.environment!==Bn||En.needsLights&&En.lightsStateVersion!==Nn.state.version||En.numClippingPlanes!==void 0&&(En.numClippingPlanes!==ye.numPlanes||En.numIntersection!==ye.numIntersection)||En.outputEncoding!==sn||En.envMap!==Tn)&&Ps(Fe,We,Qe):(Ps(Fe,We,Qe),En.__version=Fe.version);let tr=!1,_n=!1,hr=!1;const Ds=En.program,xr=Ds.getUniforms(),Zs=En.uniforms;if(He.useProgram(Ds.program)&&(tr=!0,_n=!0,hr=!0),Fe.id!==S&&(S=Fe.id,_n=!0),tr||C!==re){if(xr.setValue(be,"projectionMatrix",re.projectionMatrix),ot.logarithmicDepthBuffer&&xr.setValue(be,"logDepthBufFC",2/(Math.log(re.far+1)/Math.LN2)),C!==re&&(C=re,_n=!0,hr=!0),Fe.isShaderMaterial||Fe.isMeshPhongMaterial||Fe.isMeshToonMaterial||Fe.isMeshStandardMaterial||Fe.envMap){const Ar=xr.map.cameraPosition;Ar!==void 0&&Ar.setValue(be,Ne.setFromMatrixPosition(re.matrixWorld))}(Fe.isMeshPhongMaterial||Fe.isMeshToonMaterial||Fe.isMeshLambertMaterial||Fe.isMeshBasicMaterial||Fe.isMeshStandardMaterial||Fe.isShaderMaterial)&&xr.setValue(be,"isOrthographic",re.isOrthographicCamera===!0),(Fe.isMeshPhongMaterial||Fe.isMeshToonMaterial||Fe.isMeshLambertMaterial||Fe.isMeshBasicMaterial||Fe.isMeshStandardMaterial||Fe.isShaderMaterial||Fe.isShadowMaterial||Fe.skinning)&&xr.setValue(be,"viewMatrix",re.matrixWorldInverse)}if(Fe.skinning){xr.setOptional(be,Qe,"bindMatrix"),xr.setOptional(be,Qe,"bindMatrixInverse");const Ar=Qe.skeleton;if(Ar){const Mo=Ar.bones;if(ot.floatVertexTextures){if(Ar.boneTexture===null){let ri=Math.sqrt(Mo.length*4);ri=In.ceilPowerOfTwo(ri),ri=Math.max(ri,4);const go=new Float32Array(ri*ri*4);go.set(Ar.boneMatrices);const No=new Of(go,ri,ri,Ml,kf);Ar.boneMatrices=go,Ar.boneTexture=No,Ar.boneTextureSize=ri}xr.setValue(be,"boneTexture",Ar.boneTexture,Ue),xr.setValue(be,"boneTextureSize",Ar.boneTextureSize)}else xr.setOptional(be,Ar,"boneMatrices")}}return(_n||En.receiveShadow!==Qe.receiveShadow)&&(En.receiveShadow=Qe.receiveShadow,xr.setValue(be,"receiveShadow",Qe.receiveShadow)),_n&&(xr.setValue(be,"toneMappingExposure",p.toneMappingExposure),En.needsLights&&rl(Zs,hr),wt&&Fe.fog&&J.refreshFogUniforms(Zs,wt),J.refreshMaterialUniforms(Zs,Fe,O,N),Xd.upload(be,En.uniformsList,Zs,Ue)),Fe.isShaderMaterial&&Fe.uniformsNeedUpdate===!0&&(Xd.upload(be,En.uniformsList,Zs,Ue),Fe.uniformsNeedUpdate=!1),Fe.isSpriteMaterial&&xr.setValue(be,"center",Qe.center),xr.setValue(be,"modelViewMatrix",Qe.modelViewMatrix),xr.setValue(be,"normalMatrix",Qe.normalMatrix),xr.setValue(be,"modelMatrix",Qe.matrixWorld),Ds}function rl(re,We){re.ambientLightColor.needsUpdate=We,re.lightProbe.needsUpdate=We,re.directionalLights.needsUpdate=We,re.directionalLightShadows.needsUpdate=We,re.pointLights.needsUpdate=We,re.pointLightShadows.needsUpdate=We,re.spotLights.needsUpdate=We,re.spotLightShadows.needsUpdate=We,re.rectAreaLights.needsUpdate=We,re.hemisphereLights.needsUpdate=We}function Vh(re){return re.isMeshLambertMaterial||re.isMeshToonMaterial||re.isMeshPhongMaterial||re.isMeshStandardMaterial||re.isShadowMaterial||re.isShaderMaterial&&re.lights===!0}this.setFramebuffer=function(re){g!==re&&_===null&&be.bindFramebuffer(36160,re),g=re},this.getActiveCubeFace=function(){return y},this.getActiveMipmapLevel=function(){return b},this.getRenderList=function(){return h},this.setRenderList=function(re){h=re},this.getRenderTarget=function(){return _},this.setRenderTarget=function(re,We=0,Fe=0){_=re,y=We,b=Fe,re&&ht.get(re).__webglFramebuffer===void 0&&Ue.setupRenderTarget(re);let Qe=g,wt=!1;if(re){const Bn=ht.get(re).__webglFramebuffer;re.isWebGLCubeRenderTarget?(Qe=Bn[We],wt=!0):re.isWebGLMultisampleRenderTarget?Qe=ht.get(re).__webglMultisampledFramebuffer:Qe=Bn,k.copy(re.viewport),A.copy(re.scissor),M=re.scissorTest}else k.copy(z).multiplyScalar(O).floor(),A.copy(B).multiplyScalar(O).floor(),M=X;if(w!==Qe&&(be.bindFramebuffer(36160,Qe),w=Qe),He.viewport(k),He.scissor(A),He.setScissorTest(M),wt){const Bn=ht.get(re.texture);be.framebufferTexture2D(36160,36064,34069+We,Bn.__webglTexture,Fe)}},this.readRenderTargetPixels=function(re,We,Fe,Qe,wt,Bn,sn){if(!(re&&re.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Tn=ht.get(re).__webglFramebuffer;if(re.isWebGLCubeRenderTarget&&sn!==void 0&&(Tn=Tn[sn]),Tn){let En=!1;Tn!==w&&(be.bindFramebuffer(36160,Tn),En=!0);try{const Nn=re.texture,tr=Nn.format,_n=Nn.type;if(tr!==Ml&&ce.convert(tr)!==be.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const hr=_n===sS&&(Oe.has("EXT_color_buffer_half_float")||ot.isWebGL2&&Oe.has("EXT_color_buffer_float"));if(_n!==sx&&ce.convert(_n)!==be.getParameter(35738)&&!(_n===kf&&(ot.isWebGL2||Oe.has("OES_texture_float")||Oe.has("WEBGL_color_buffer_float")))&&!hr){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}be.checkFramebufferStatus(36160)===36053?We>=0&&We<=re.width-Qe&&Fe>=0&&Fe<=re.height-wt&&be.readPixels(We,Fe,Qe,wt,ce.convert(tr),ce.convert(_n),Bn):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{En&&be.bindFramebuffer(36160,w)}}},this.copyFramebufferToTexture=function(re,We,Fe=0){const Qe=Math.pow(2,-Fe),wt=Math.floor(We.image.width*Qe),Bn=Math.floor(We.image.height*Qe),sn=ce.convert(We.format);Ue.setTexture2D(We,0),be.copyTexImage2D(3553,Fe,sn,re.x,re.y,wt,Bn,0),He.unbindTexture()},this.copyTextureToTexture=function(re,We,Fe,Qe=0){const wt=We.image.width,Bn=We.image.height,sn=ce.convert(Fe.format),Tn=ce.convert(Fe.type);Ue.setTexture2D(Fe,0),be.pixelStorei(37440,Fe.flipY),be.pixelStorei(37441,Fe.premultiplyAlpha),be.pixelStorei(3317,Fe.unpackAlignment),We.isDataTexture?be.texSubImage2D(3553,Qe,re.x,re.y,wt,Bn,sn,Tn,We.image.data):We.isCompressedTexture?be.compressedTexSubImage2D(3553,Qe,re.x,re.y,We.mipmaps[0].width,We.mipmaps[0].height,sn,We.mipmaps[0].data):be.texSubImage2D(3553,Qe,re.x,re.y,sn,Tn,We.image),Qe===0&&Fe.generateMipmaps&&be.generateMipmap(3553),He.unbindTexture()},this.initTexture=function(re){Ue.setTexture2D(re,0),He.unbindTexture()},this.resetState=function(){He.reset(),rt.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function DF(n){WC.call(this,n)}DF.prototype=Object.assign(Object.create(WC.prototype),{constructor:DF,isWebGL1Renderer:!0});class N${constructor(e,t){Object.defineProperty(this,"isFogExp2",{value:!0}),this.name="",this.color=new Gt(e),this.density=t!==void 0?t:25e-5}clone(){return new N$(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class $${constructor(e,t,r){Object.defineProperty(this,"isFog",{value:!0}),this.name="",this.color=new Gt(e),this.near=t!==void 0?t:1,this.far=r!==void 0?r:1e3}clone(){return new $$(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class rV extends rn{constructor(){super(),Object.defineProperty(this,"isScene",{value:!0}),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.background!==null&&(t.object.background=this.background.toJSON(e)),this.environment!==null&&(t.object.environment=this.environment.toJSON(e)),this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}function Tl(n,e){this.array=n,this.stride=e,this.count=n!==void 0?n.length/e:0,this.usage=VC,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=In.generateUUID()}Object.defineProperty(Tl.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(Tl.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(n){return this.usage=n,this},copy:function(n){return this.array=new n.array.constructor(n.array),this.count=n.count,this.stride=n.stride,this.usage=n.usage,this},copyAt:function(n,e,t){n*=this.stride,t*=e.stride;for(let r=0,i=this.stride;r<i;r++)this.array[n+r]=e.array[t+r];return this},set:function(n,e=0){return this.array.set(n,e),this},clone:function(n){n.arrayBuffers===void 0&&(n.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=In.generateUUID()),n.arrayBuffers[this.array.buffer._uuid]===void 0&&(n.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(n.arrayBuffers[this.array.buffer._uuid]),t=new Tl(e,this.stride);return t.setUsage(this.usage),t},onUpload:function(n){return this.onUploadCallback=n,this},toJSON:function(n){return n.arrayBuffers===void 0&&(n.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=In.generateUUID()),n.arrayBuffers[this.array.buffer._uuid]===void 0&&(n.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const um=new Q;function pp(n,e,t,r){this.name="",this.data=n,this.itemSize=e,this.offset=t,this.normalized=r===!0}Object.defineProperties(pp.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(n){this.data.needsUpdate=n}}});Object.assign(pp.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(n){for(let e=0,t=this.data.count;e<t;e++)um.x=this.getX(e),um.y=this.getY(e),um.z=this.getZ(e),um.applyMatrix4(n),this.setXYZ(e,um.x,um.y,um.z);return this},setX:function(n,e){return this.data.array[n*this.data.stride+this.offset]=e,this},setY:function(n,e){return this.data.array[n*this.data.stride+this.offset+1]=e,this},setZ:function(n,e){return this.data.array[n*this.data.stride+this.offset+2]=e,this},setW:function(n,e){return this.data.array[n*this.data.stride+this.offset+3]=e,this},getX:function(n){return this.data.array[n*this.data.stride+this.offset]},getY:function(n){return this.data.array[n*this.data.stride+this.offset+1]},getZ:function(n){return this.data.array[n*this.data.stride+this.offset+2]},getW:function(n){return this.data.array[n*this.data.stride+this.offset+3]},setXY:function(n,e,t){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this},setXYZ:function(n,e,t,r){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=r,this},setXYZW:function(n,e,t,r,i){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=r,this.data.array[n+3]=i,this},clone:function(n){if(n===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const r=t*this.data.stride+this.offset;for(let i=0;i<this.itemSize;i++)e.push(this.data.array[r+i])}return new Cn(new this.array.constructor(e),this.itemSize,this.normalized)}else return n.interleavedBuffers===void 0&&(n.interleavedBuffers={}),n.interleavedBuffers[this.data.uuid]===void 0&&(n.interleavedBuffers[this.data.uuid]=this.data.clone(n)),new pp(n.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(n){if(n===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const r=t*this.data.stride+this.offset;for(let i=0;i<this.itemSize;i++)e.push(this.data.array[r+i])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return n.interleavedBuffers===void 0&&(n.interleavedBuffers={}),n.interleavedBuffers[this.data.uuid]===void 0&&(n.interleavedBuffers[this.data.uuid]=this.data.toJSON(n)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}});function mp(n){kn.call(this),this.type="SpriteMaterial",this.color=new Gt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(n)}mp.prototype=Object.create(kn.prototype);mp.prototype.constructor=mp;mp.prototype.isSpriteMaterial=!0;mp.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.rotation=n.rotation,this.sizeAttenuation=n.sizeAttenuation,this};let eb;const r1=new Q,tb=new Q,nb=new Q,rb=new st,i1=new st,cle=new Zn,ZT=new Q,s1=new Q,JT=new Q,w8=new st,kP=new st,x8=new st;function gS(n){if(rn.call(this),this.type="Sprite",eb===void 0){eb=new un;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),t=new Tl(e,5);eb.setIndex([0,1,2,0,2,3]),eb.setAttribute("position",new pp(t,3,0,!1)),eb.setAttribute("uv",new pp(t,2,3,!1))}this.geometry=eb,this.material=n!==void 0?n:new mp,this.center=new st(.5,.5)}gS.prototype=Object.assign(Object.create(rn.prototype),{constructor:gS,isSprite:!0,raycast:function(n,e){n.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),tb.setFromMatrixScale(this.matrixWorld),cle.copy(n.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(n.camera.matrixWorldInverse,this.matrixWorld),nb.setFromMatrixPosition(this.modelViewMatrix),n.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&tb.multiplyScalar(-nb.z);const t=this.material.rotation;let r,i;t!==0&&(i=Math.cos(t),r=Math.sin(t));const s=this.center;QT(ZT.set(-.5,-.5,0),nb,s,tb,r,i),QT(s1.set(.5,-.5,0),nb,s,tb,r,i),QT(JT.set(.5,.5,0),nb,s,tb,r,i),w8.set(0,0),kP.set(1,0),x8.set(1,1);let o=n.ray.intersectTriangle(ZT,s1,JT,!1,r1);if(o===null&&(QT(s1.set(-.5,.5,0),nb,s,tb,r,i),kP.set(0,1),o=n.ray.intersectTriangle(ZT,JT,s1,!1,r1),o===null))return;const a=n.ray.origin.distanceTo(r1);a<n.near||a>n.far||e.push({distance:a,point:r1.clone(),uv:Xo.getUV(r1,ZT,s1,JT,w8,kP,x8,new st),face:null,object:this})},copy:function(n){return rn.prototype.copy.call(this,n),n.center!==void 0&&this.center.copy(n.center),this.material=n.material,this}});function QT(n,e,t,r,i,s){rb.subVectors(n,t).addScalar(.5).multiply(r),i!==void 0?(i1.x=s*rb.x-i*rb.y,i1.y=i*rb.x+s*rb.y):i1.copy(rb),n.copy(e),n.x+=i1.x,n.y+=i1.y,n.applyMatrix4(cle)}const eE=new Q,_8=new Q;function yS(){rn.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}yS.prototype=Object.assign(Object.create(rn.prototype),{constructor:yS,isLOD:!0,copy:function(n){rn.prototype.copy.call(this,n,!1);const e=n.levels;for(let t=0,r=e.length;t<r;t++){const i=e[t];this.addLevel(i.object.clone(),i.distance)}return this.autoUpdate=n.autoUpdate,this},addLevel:function(n,e=0){e=Math.abs(e);const t=this.levels;let r;for(r=0;r<t.length&&!(e<t[r].distance);r++);return t.splice(r,0,{distance:e,object:n}),this.add(n),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(n){const e=this.levels;if(e.length>0){let t,r;for(t=1,r=e.length;t<r&&!(n<e[t].distance);t++);return e[t-1].object}return null},raycast:function(n,e){if(this.levels.length>0){eE.setFromMatrixPosition(this.matrixWorld);const r=n.ray.origin.distanceTo(eE);this.getObjectForDistance(r).raycast(n,e)}},update:function(n){const e=this.levels;if(e.length>1){eE.setFromMatrixPosition(n.matrixWorld),_8.setFromMatrixPosition(this.matrixWorld);const t=eE.distanceTo(_8)/n.zoom;e[0].object.visible=!0;let r,i;for(r=1,i=e.length;r<i&&t>=e[r].distance;r++)e[r-1].object.visible=!1,e[r].object.visible=!0;for(this._currentLevel=r-1;r<i;r++)e[r].object.visible=!1}},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);this.autoUpdate===!1&&(e.object.autoUpdate=!1),e.object.levels=[];const t=this.levels;for(let r=0,i=t.length;r<i;r++){const s=t[r];e.object.levels.push({object:s.object.uuid,distance:s.distance})}return e}});const S8=new Q,C8=new Gr,k8=new Gr,Cyt=new Q,T8=new Zn;function bS(n,e){n&&n.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),ui.call(this,n,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Zn,this.bindMatrixInverse=new Zn}bS.prototype=Object.assign(Object.create(ui.prototype),{constructor:bS,isSkinnedMesh:!0,copy:function(n){return ui.prototype.copy.call(this,n),this.bindMode=n.bindMode,this.bindMatrix.copy(n.bindMatrix),this.bindMatrixInverse.copy(n.bindMatrixInverse),this.skeleton=n.skeleton,this},bind:function(n,e){this.skeleton=n,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const n=new Gr,e=this.geometry.attributes.skinWeight;for(let t=0,r=e.count;t<r;t++){n.x=e.getX(t),n.y=e.getY(t),n.z=e.getZ(t),n.w=e.getW(t);const i=1/n.manhattanLength();i!==1/0?n.multiplyScalar(i):n.set(1,0,0,0),e.setXYZW(t,n.x,n.y,n.z,n.w)}},updateMatrixWorld:function(n){ui.prototype.updateMatrixWorld.call(this,n),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(n,e){const t=this.skeleton,r=this.geometry;C8.fromBufferAttribute(r.attributes.skinIndex,n),k8.fromBufferAttribute(r.attributes.skinWeight,n),S8.fromBufferAttribute(r.attributes.position,n).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let i=0;i<4;i++){const s=k8.getComponent(i);if(s!==0){const o=C8.getComponent(i);T8.multiplyMatrices(t.bones[o].matrixWorld,t.boneInverses[o]),e.addScaledVector(Cyt.copy(S8).applyMatrix4(T8),s)}}return e.applyMatrix4(this.bindMatrixInverse)}});function vS(){rn.call(this),this.type="Bone"}vS.prototype=Object.assign(Object.create(rn.prototype),{constructor:vS,isBone:!0});const E8=new Zn,kyt=new Zn;function wS(n=[],e=[]){this.uuid=In.generateUUID(),this.bones=n.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}Object.assign(wS.prototype,{init:function(){const n=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(n.length*16),e.length===0)this.calculateInverses();else if(n.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,r=this.bones.length;t<r;t++)this.boneInverses.push(new Zn)}},calculateInverses:function(){this.boneInverses.length=0;for(let n=0,e=this.bones.length;n<e;n++){const t=new Zn;this.bones[n]&&t.copy(this.bones[n].matrixWorld).invert(),this.boneInverses.push(t)}},pose:function(){for(let n=0,e=this.bones.length;n<e;n++){const t=this.bones[n];t&&t.matrixWorld.copy(this.boneInverses[n]).invert()}for(let n=0,e=this.bones.length;n<e;n++){const t=this.bones[n];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}},update:function(){const n=this.bones,e=this.boneInverses,t=this.boneMatrices,r=this.boneTexture;for(let i=0,s=n.length;i<s;i++){const o=n[i]?n[i].matrixWorld:kyt;E8.multiplyMatrices(o,e[i]),E8.toArray(t,i*16)}r!==null&&(r.needsUpdate=!0)},clone:function(){return new wS(this.bones,this.boneInverses)},getBoneByName:function(n){for(let e=0,t=this.bones.length;e<t;e++){const r=this.bones[e];if(r.name===n)return r}},dispose:function(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)},fromJSON:function(n,e){this.uuid=n.uuid;for(let t=0,r=n.bones.length;t<r;t++){const i=n.bones[t];let s=e[i];s===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),s=new vS),this.bones.push(s),this.boneInverses.push(new Zn().fromArray(n.boneInverses[t]))}return this.init(),this},toJSON:function(){const n={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};n.uuid=this.uuid;const e=this.bones,t=this.boneInverses;for(let r=0,i=e.length;r<i;r++){const s=e[r];n.bones.push(s.uuid);const o=t[r];n.boneInverses.push(o.toArray())}return n}});const I8=new Zn,A8=new Zn,tE=[],o1=new ui;function EA(n,e,t){ui.call(this,n,e),this.instanceMatrix=new Cn(new Float32Array(t*16),16),this.instanceColor=null,this.count=t,this.frustumCulled=!1}EA.prototype=Object.assign(Object.create(ui.prototype),{constructor:EA,isInstancedMesh:!0,copy:function(n){return ui.prototype.copy.call(this,n),this.instanceMatrix.copy(n.instanceMatrix),n.instanceColor!==null&&(this.instanceColor=n.instanceColor.clone()),this.count=n.count,this},getColorAt:function(n,e){e.fromArray(this.instanceColor.array,n*3)},getMatrixAt:function(n,e){e.fromArray(this.instanceMatrix.array,n*16)},raycast:function(n,e){const t=this.matrixWorld,r=this.count;if(o1.geometry=this.geometry,o1.material=this.material,o1.material!==void 0)for(let i=0;i<r;i++){this.getMatrixAt(i,I8),A8.multiplyMatrices(t,I8),o1.matrixWorld=A8,o1.raycast(n,tE);for(let s=0,o=tE.length;s<o;s++){const a=tE[s];a.instanceId=i,a.object=this,e.push(a)}tE.length=0}},setColorAt:function(n,e){this.instanceColor===null&&(this.instanceColor=new Cn(new Float32Array(this.count*3),3)),e.toArray(this.instanceColor.array,n*3)},setMatrixAt:function(n,e){e.toArray(this.instanceMatrix.array,n*16)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}});function Ei(n){kn.call(this),this.type="LineBasicMaterial",this.color=new Gt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(n)}Ei.prototype=Object.create(kn.prototype);Ei.prototype.constructor=Ei;Ei.prototype.isLineBasicMaterial=!0;Ei.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.linewidth=n.linewidth,this.linecap=n.linecap,this.linejoin=n.linejoin,this.morphTargets=n.morphTargets,this};const M8=new Q,N8=new Q,$8=new Zn,TP=new ox,nE=new Op;function Nc(n=new un,e=new Ei){rn.call(this),this.type="Line",this.geometry=n,this.material=e,this.updateMorphTargets()}Nc.prototype=Object.assign(Object.create(rn.prototype),{constructor:Nc,isLine:!0,copy:function(n){return rn.prototype.copy.call(this,n),this.material=n.material,this.geometry=n.geometry,this},computeLineDistances:function(){const n=this.geometry;if(n.isBufferGeometry)if(n.index===null){const e=n.attributes.position,t=[0];for(let r=1,i=e.count;r<i;r++)M8.fromBufferAttribute(e,r-1),N8.fromBufferAttribute(e,r),t[r]=t[r-1],t[r]+=M8.distanceTo(N8);n.setAttribute("lineDistance",new qt(t,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else n.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this},raycast:function(n,e){const t=this.geometry,r=this.matrixWorld,i=n.params.Line.threshold;if(t.boundingSphere===null&&t.computeBoundingSphere(),nE.copy(t.boundingSphere),nE.applyMatrix4(r),nE.radius+=i,n.ray.intersectsSphere(nE)===!1)return;$8.copy(r).invert(),TP.copy(n.ray).applyMatrix4($8);const s=i/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s,a=new Q,l=new Q,c=new Q,u=new Q,h=this.isLineSegments?2:1;if(t.isBufferGeometry){const f=t.index,p=t.attributes.position;if(f!==null){const m=f.array;for(let g=0,y=m.length-1;g<y;g+=h){const b=m[g],_=m[g+1];if(a.fromBufferAttribute(p,b),l.fromBufferAttribute(p,_),TP.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const S=n.ray.origin.distanceTo(u);S<n.near||S>n.far||e.push({distance:S,point:c.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this})}}else for(let m=0,g=p.count-1;m<g;m+=h){if(a.fromBufferAttribute(p,m),l.fromBufferAttribute(p,m+1),TP.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const b=n.ray.origin.distanceTo(u);b<n.near||b>n.far||e.push({distance:b,point:c.clone().applyMatrix4(this.matrixWorld),index:m,face:null,faceIndex:null,object:this})}}else t.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const r=e[t[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,s=r.length;i<s;i++){const o=r[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=i}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const R8=new Q,P8=new Q;function Ea(n,e){Nc.call(this,n,e),this.type="LineSegments"}Ea.prototype=Object.assign(Object.create(Nc.prototype),{constructor:Ea,isLineSegments:!0,computeLineDistances:function(){const n=this.geometry;if(n.isBufferGeometry)if(n.index===null){const e=n.attributes.position,t=[];for(let r=0,i=e.count;r<i;r+=2)R8.fromBufferAttribute(e,r),P8.fromBufferAttribute(e,r+1),t[r]=r===0?0:t[r-1],t[r+1]=t[r]+R8.distanceTo(P8);n.setAttribute("lineDistance",new qt(t,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else n.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}});function IA(n,e){Nc.call(this,n,e),this.type="LineLoop"}IA.prototype=Object.assign(Object.create(Nc.prototype),{constructor:IA,isLineLoop:!0});function Au(n){kn.call(this),this.type="PointsMaterial",this.color=new Gt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(n)}Au.prototype=Object.create(kn.prototype);Au.prototype.constructor=Au;Au.prototype.isPointsMaterial=!0;Au.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.size=n.size,this.sizeAttenuation=n.sizeAttenuation,this.morphTargets=n.morphTargets,this};const D8=new Zn,OF=new ox,rE=new Op,iE=new Q;function gv(n=new un,e=new Au){rn.call(this),this.type="Points",this.geometry=n,this.material=e,this.updateMorphTargets()}gv.prototype=Object.assign(Object.create(rn.prototype),{constructor:gv,isPoints:!0,copy:function(n){return rn.prototype.copy.call(this,n),this.material=n.material,this.geometry=n.geometry,this},raycast:function(n,e){const t=this.geometry,r=this.matrixWorld,i=n.params.Points.threshold;if(t.boundingSphere===null&&t.computeBoundingSphere(),rE.copy(t.boundingSphere),rE.applyMatrix4(r),rE.radius+=i,n.ray.intersectsSphere(rE)===!1)return;D8.copy(r).invert(),OF.copy(n.ray).applyMatrix4(D8);const s=i/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s;if(t.isBufferGeometry){const a=t.index,c=t.attributes.position;if(a!==null){const u=a.array;for(let h=0,f=u.length;h<f;h++){const d=u[h];iE.fromBufferAttribute(c,d),O8(iE,d,o,r,n,e,this)}}else for(let u=0,h=c.count;u<h;u++)iE.fromBufferAttribute(c,u),O8(iE,u,o,r,n,e,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const r=e[t[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,s=r.length;i<s;i++){const o=r[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=i}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});function O8(n,e,t,r,i,s,o){const a=OF.distanceSqToPoint(n);if(a<t){const l=new Q;OF.closestPointToPoint(n,l),l.applyMatrix4(r);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;s.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}function FF(n,e,t,r,i,s,o,a,l){Kr.call(this,n,e,t,r,i,s,o,a,l),this.format=o!==void 0?o:jd,this.minFilter=s!==void 0?s:lo,this.magFilter=i!==void 0?i:lo,this.generateMipmaps=!1;const c=this;function u(){c.needsUpdate=!0,n.requestVideoFrameCallback(u)}"requestVideoFrameCallback"in n&&n.requestVideoFrameCallback(u)}FF.prototype=Object.assign(Object.create(Kr.prototype),{constructor:FF,clone:function(){return new this.constructor(this.image).copy(this)},isVideoTexture:!0,update:function(){const n=this.image;"requestVideoFrameCallback"in n===!1&&n.readyState>=n.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}});function yv(n,e,t,r,i,s,o,a,l,c,u,h){Kr.call(this,null,s,o,a,l,c,r,i,u,h),this.image={width:e,height:t},this.mipmaps=n,this.flipY=!1,this.generateMipmaps=!1}yv.prototype=Object.create(Kr.prototype);yv.prototype.constructor=yv;yv.prototype.isCompressedTexture=!0;function xS(n,e,t,r,i,s,o,a,l){Kr.call(this,n,e,t,r,i,s,o,a,l),this.needsUpdate=!0}xS.prototype=Object.create(Kr.prototype);xS.prototype.constructor=xS;xS.prototype.isCanvasTexture=!0;function _S(n,e,t,r,i,s,o,a,l,c){if(c=c!==void 0?c:Zm,c!==Zm&&c!==fv)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");t===void 0&&c===Zm&&(t=iS),t===void 0&&c===fv&&(t=Ob),Kr.call(this,null,r,i,s,o,a,c,t,l),this.image={width:n,height:e},this.magFilter=o!==void 0?o:Us,this.minFilter=a!==void 0?a:Us,this.flipY=!1,this.generateMipmaps=!1}_S.prototype=Object.create(Kr.prototype);_S.prototype.constructor=_S;_S.prototype.isDepthTexture=!0;class AA extends un{constructor(e=1,t=8,r=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:r,thetaLength:i},t=Math.max(3,t);const s=[],o=[],a=[],l=[],c=new Q,u=new st;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let h=0,f=3;h<=t;h++,f+=3){const d=r+h/t*i;c.x=e*Math.cos(d),c.y=e*Math.sin(d),o.push(c.x,c.y,c.z),a.push(0,0,1),u.x=(o[f]/e+1)/2,u.y=(o[f+1]/e+1)/2,l.push(u.x,u.y)}for(let h=1;h<=t;h++)s.push(h,h+1,0);this.setIndex(s),this.setAttribute("position",new qt(o,3)),this.setAttribute("normal",new qt(a,3)),this.setAttribute("uv",new qt(l,2))}}class bv extends un{constructor(e=1,t=1,r=1,i=8,s=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:r,radialSegments:i,heightSegments:s,openEnded:o,thetaStart:a,thetaLength:l};const c=this;i=Math.floor(i),s=Math.floor(s);const u=[],h=[],f=[],d=[];let p=0;const m=[],g=r/2;let y=0;b(),o===!1&&(e>0&&_(!0),t>0&&_(!1)),this.setIndex(u),this.setAttribute("position",new qt(h,3)),this.setAttribute("normal",new qt(f,3)),this.setAttribute("uv",new qt(d,2));function b(){const w=new Q,S=new Q;let C=0;const k=(t-e)/r;for(let A=0;A<=s;A++){const M=[],E=A/s,N=E*(t-e)+e;for(let O=0;O<=i;O++){const R=O/i,D=R*l+a,z=Math.sin(D),B=Math.cos(D);S.x=N*z,S.y=-E*r+g,S.z=N*B,h.push(S.x,S.y,S.z),w.set(z,k,B).normalize(),f.push(w.x,w.y,w.z),d.push(R,1-E),M.push(p++)}m.push(M)}for(let A=0;A<i;A++)for(let M=0;M<s;M++){const E=m[M][A],N=m[M+1][A],O=m[M+1][A+1],R=m[M][A+1];u.push(E,N,R),u.push(N,O,R),C+=6}c.addGroup(y,C,0),y+=C}function _(w){const S=p,C=new st,k=new Q;let A=0;const M=w===!0?e:t,E=w===!0?1:-1;for(let O=1;O<=i;O++)h.push(0,g*E,0),f.push(0,E,0),d.push(.5,.5),p++;const N=p;for(let O=0;O<=i;O++){const D=O/i*l+a,z=Math.cos(D),B=Math.sin(D);k.x=M*B,k.y=g*E,k.z=M*z,h.push(k.x,k.y,k.z),f.push(0,E,0),C.x=z*.5+.5,C.y=B*.5*E+.5,d.push(C.x,C.y),p++}for(let O=0;O<i;O++){const R=S+O,D=N+O;w===!0?u.push(D,D+1,R):u.push(D+1,D,R),A+=3}c.addGroup(y,A,w===!0?1:2),y+=A}}}class MA extends bv{constructor(e=1,t=1,r=8,i=1,s=!1,o=0,a=Math.PI*2){super(0,e,t,r,i,s,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:r,heightSegments:i,openEnded:s,thetaStart:o,thetaLength:a}}}class gp extends un{constructor(e,t,r=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:r,detail:i};const s=[],o=[];a(i),c(r),u(),this.setAttribute("position",new qt(s,3)),this.setAttribute("normal",new qt(s.slice(),3)),this.setAttribute("uv",new qt(o,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function a(b){const _=new Q,w=new Q,S=new Q;for(let C=0;C<t.length;C+=3)d(t[C+0],_),d(t[C+1],w),d(t[C+2],S),l(_,w,S,b)}function l(b,_,w,S){const C=S+1,k=[];for(let A=0;A<=C;A++){k[A]=[];const M=b.clone().lerp(w,A/C),E=_.clone().lerp(w,A/C),N=C-A;for(let O=0;O<=N;O++)O===0&&A===C?k[A][O]=M:k[A][O]=M.clone().lerp(E,O/N)}for(let A=0;A<C;A++)for(let M=0;M<2*(C-A)-1;M++){const E=Math.floor(M/2);M%2===0?(f(k[A][E+1]),f(k[A+1][E]),f(k[A][E])):(f(k[A][E+1]),f(k[A+1][E+1]),f(k[A+1][E]))}}function c(b){const _=new Q;for(let w=0;w<s.length;w+=3)_.x=s[w+0],_.y=s[w+1],_.z=s[w+2],_.normalize().multiplyScalar(b),s[w+0]=_.x,s[w+1]=_.y,s[w+2]=_.z}function u(){const b=new Q;for(let _=0;_<s.length;_+=3){b.x=s[_+0],b.y=s[_+1],b.z=s[_+2];const w=g(b)/2/Math.PI+.5,S=y(b)/Math.PI+.5;o.push(w,1-S)}p(),h()}function h(){for(let b=0;b<o.length;b+=6){const _=o[b+0],w=o[b+2],S=o[b+4],C=Math.max(_,w,S),k=Math.min(_,w,S);C>.9&&k<.1&&(_<.2&&(o[b+0]+=1),w<.2&&(o[b+2]+=1),S<.2&&(o[b+4]+=1))}}function f(b){s.push(b.x,b.y,b.z)}function d(b,_){const w=b*3;_.x=e[w+0],_.y=e[w+1],_.z=e[w+2]}function p(){const b=new Q,_=new Q,w=new Q,S=new Q,C=new st,k=new st,A=new st;for(let M=0,E=0;M<s.length;M+=9,E+=6){b.set(s[M+0],s[M+1],s[M+2]),_.set(s[M+3],s[M+4],s[M+5]),w.set(s[M+6],s[M+7],s[M+8]),C.set(o[E+0],o[E+1]),k.set(o[E+2],o[E+3]),A.set(o[E+4],o[E+5]),S.copy(b).add(_).add(w).divideScalar(3);const N=g(S);m(C,E+0,b,N),m(k,E+2,_,N),m(A,E+4,w,N)}}function m(b,_,w,S){S<0&&b.x===1&&(o[_]=b.x-1),w.x===0&&w.z===0&&(o[_]=S/2/Math.PI+.5)}function g(b){return Math.atan2(b.z,-b.x)}function y(b){return Math.atan2(-b.y,Math.sqrt(b.x*b.x+b.z*b.z))}}}class NA extends gp{constructor(e=1,t=0){const r=(1+Math.sqrt(5))/2,i=1/r,s=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-r,0,-i,r,0,i,-r,0,i,r,-i,-r,0,-i,r,0,i,-r,0,i,r,0,-r,0,-i,r,0,-i,-r,0,i,r,0,i],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(s,o,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}}const sE=new Q,oE=new Q,EP=new Q,aE=new Xo;class iV extends un{constructor(e,t){if(super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:t},t=t!==void 0?t:1,e.isGeometry===!0){console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return}const i=Math.pow(10,4),s=Math.cos(In.DEG2RAD*t),o=e.getIndex(),a=e.getAttribute("position"),l=o?o.count:a.count,c=[0,0,0],u=["a","b","c"],h=new Array(3),f={},d=[];for(let p=0;p<l;p+=3){o?(c[0]=o.getX(p),c[1]=o.getX(p+1),c[2]=o.getX(p+2)):(c[0]=p,c[1]=p+1,c[2]=p+2);const{a:m,b:g,c:y}=aE;if(m.fromBufferAttribute(a,c[0]),g.fromBufferAttribute(a,c[1]),y.fromBufferAttribute(a,c[2]),aE.getNormal(EP),h[0]=`${Math.round(m.x*i)},${Math.round(m.y*i)},${Math.round(m.z*i)}`,h[1]=`${Math.round(g.x*i)},${Math.round(g.y*i)},${Math.round(g.z*i)}`,h[2]=`${Math.round(y.x*i)},${Math.round(y.y*i)},${Math.round(y.z*i)}`,!(h[0]===h[1]||h[1]===h[2]||h[2]===h[0]))for(let b=0;b<3;b++){const _=(b+1)%3,w=h[b],S=h[_],C=aE[u[b]],k=aE[u[_]],A=`${w}_${S}`,M=`${S}_${w}`;M in f&&f[M]?(EP.dot(f[M].normal)<=s&&(d.push(C.x,C.y,C.z),d.push(k.x,k.y,k.z)),f[M]=null):A in f||(f[A]={index0:c[b],index1:c[_],normal:EP.clone()})}}for(const p in f)if(f[p]){const{index0:m,index1:g}=f[p];sE.fromBufferAttribute(a,m),oE.fromBufferAttribute(a,g),d.push(sE.x,sE.y,sE.z),d.push(oE.x,oE.y,oE.z)}this.setAttribute("position",new qt(d,3))}}const Tyt={triangulate:function(n,e,t){t=t||2;const r=e&&e.length,i=r?e[0]*t:n.length;let s=ule(n,0,i,t,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,c,u,h,f,d;if(r&&(s=Nyt(n,e,s,t)),n.length>80*t){a=c=n[0],l=u=n[1];for(let p=t;p<i;p+=t)h=n[p],f=n[p+1],h<a&&(a=h),f<l&&(l=f),h>c&&(c=h),f>u&&(u=f);d=Math.max(c-a,u-l),d=d!==0?1/d:0}return SS(s,o,t,a,l,d),o}};function ule(n,e,t,r,i){let s,o;if(i===Uyt(n,e,t,r)>0)for(s=e;s<t;s+=r)o=F8(s,n[s],n[s+1],o);else for(s=t-r;s>=e;s-=r)o=F8(s,n[s],n[s+1],o);return o&&R$(o,o.next)&&(kS(o),o=o.next),o}function yp(n,e){if(!n)return n;e||(e=n);let t=n,r;do if(r=!1,!t.steiner&&(R$(t,t.next)||Oi(t.prev,t,t.next)===0)){if(kS(t),t=e=t.prev,t===t.next)break;r=!0}else t=t.next;while(r||t!==e);return e}function SS(n,e,t,r,i,s,o){if(!n)return;!o&&s&&Oyt(n,r,i,s);let a=n,l,c;for(;n.prev!==n.next;){if(l=n.prev,c=n.next,s?Iyt(n,r,i,s):Eyt(n)){e.push(l.i/t),e.push(n.i/t),e.push(c.i/t),kS(n),n=c.next,a=c.next;continue}if(n=c,n===a){o?o===1?(n=Ayt(yp(n),e,t),SS(n,e,t,r,i,s,2)):o===2&&Myt(n,e,t,r,i,s):SS(yp(n),e,t,r,i,s,1);break}}}function Eyt(n){const e=n.prev,t=n,r=n.next;if(Oi(e,t,r)>=0)return!1;let i=n.next.next;for(;i!==n.prev;){if(Cb(e.x,e.y,t.x,t.y,r.x,r.y,i.x,i.y)&&Oi(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function Iyt(n,e,t,r){const i=n.prev,s=n,o=n.next;if(Oi(i,s,o)>=0)return!1;const a=i.x<s.x?i.x<o.x?i.x:o.x:s.x<o.x?s.x:o.x,l=i.y<s.y?i.y<o.y?i.y:o.y:s.y<o.y?s.y:o.y,c=i.x>s.x?i.x>o.x?i.x:o.x:s.x>o.x?s.x:o.x,u=i.y>s.y?i.y>o.y?i.y:o.y:s.y>o.y?s.y:o.y,h=LF(a,l,e,t,r),f=LF(c,u,e,t,r);let d=n.prevZ,p=n.nextZ;for(;d&&d.z>=h&&p&&p.z<=f;){if(d!==n.prev&&d!==n.next&&Cb(i.x,i.y,s.x,s.y,o.x,o.y,d.x,d.y)&&Oi(d.prev,d,d.next)>=0||(d=d.prevZ,p!==n.prev&&p!==n.next&&Cb(i.x,i.y,s.x,s.y,o.x,o.y,p.x,p.y)&&Oi(p.prev,p,p.next)>=0))return!1;p=p.nextZ}for(;d&&d.z>=h;){if(d!==n.prev&&d!==n.next&&Cb(i.x,i.y,s.x,s.y,o.x,o.y,d.x,d.y)&&Oi(d.prev,d,d.next)>=0)return!1;d=d.prevZ}for(;p&&p.z<=f;){if(p!==n.prev&&p!==n.next&&Cb(i.x,i.y,s.x,s.y,o.x,o.y,p.x,p.y)&&Oi(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function Ayt(n,e,t){let r=n;do{const i=r.prev,s=r.next.next;!R$(i,s)&&hle(i,r,r.next,s)&&CS(i,s)&&CS(s,i)&&(e.push(i.i/t),e.push(r.i/t),e.push(s.i/t),kS(r),kS(r.next),r=n=s),r=r.next}while(r!==n);return yp(r)}function Myt(n,e,t,r,i,s){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&zyt(o,a)){let l=fle(o,a);o=yp(o,o.next),l=yp(l,l.next),SS(o,e,t,r,i,s),SS(l,e,t,r,i,s);return}a=a.next}o=o.next}while(o!==n)}function Nyt(n,e,t,r){const i=[];let s,o,a,l,c;for(s=0,o=e.length;s<o;s++)a=e[s]*r,l=s<o-1?e[s+1]*r:n.length,c=ule(n,a,l,r,!1),c===c.next&&(c.steiner=!0),i.push(Lyt(c));for(i.sort($yt),s=0;s<i.length;s++)Ryt(i[s],t),t=yp(t,t.next);return t}function $yt(n,e){return n.x-e.x}function Ryt(n,e){if(e=Pyt(n,e),e){const t=fle(e,n);yp(e,e.next),yp(t,t.next)}}function Pyt(n,e){let t=e;const r=n.x,i=n.y;let s=-1/0,o;do{if(i<=t.y&&i>=t.next.y&&t.next.y!==t.y){const f=t.x+(i-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(f<=r&&f>s){if(s=f,f===r){if(i===t.y)return t;if(i===t.next.y)return t.next}o=t.x<t.next.x?t:t.next}}t=t.next}while(t!==e);if(!o)return null;if(r===s)return o;const a=o,l=o.x,c=o.y;let u=1/0,h;t=o;do r>=t.x&&t.x>=l&&r!==t.x&&Cb(i<c?r:s,i,l,c,i<c?s:r,i,t.x,t.y)&&(h=Math.abs(i-t.y)/(r-t.x),CS(t,n)&&(h<u||h===u&&(t.x>o.x||t.x===o.x&&Dyt(o,t)))&&(o=t,u=h)),t=t.next;while(t!==a);return o}function Dyt(n,e){return Oi(n.prev,n,e.prev)<0&&Oi(e.next,n,n.next)<0}function Oyt(n,e,t,r){let i=n;do i.z===null&&(i.z=LF(i.x,i.y,e,t,r)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==n);i.prevZ.nextZ=null,i.prevZ=null,Fyt(i)}function Fyt(n){let e,t,r,i,s,o,a,l,c=1;do{for(t=n,n=null,s=null,o=0;t;){for(o++,r=t,a=0,e=0;e<c&&(a++,r=r.nextZ,!!r);e++);for(l=c;a>0||l>0&&r;)a!==0&&(l===0||!r||t.z<=r.z)?(i=t,t=t.nextZ,a--):(i=r,r=r.nextZ,l--),s?s.nextZ=i:n=i,i.prevZ=s,s=i;t=r}s.nextZ=null,c*=2}while(o>1);return n}function LF(n,e,t,r,i){return n=32767*(n-t)*i,e=32767*(e-r)*i,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function Lyt(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function Cb(n,e,t,r,i,s,o,a){return(i-o)*(e-a)-(n-o)*(s-a)>=0&&(n-o)*(r-a)-(t-o)*(e-a)>=0&&(t-o)*(s-a)-(i-o)*(r-a)>=0}function zyt(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!Byt(n,e)&&(CS(n,e)&&CS(e,n)&&Vyt(n,e)&&(Oi(n.prev,n,e.prev)||Oi(n,e.prev,e))||R$(n,e)&&Oi(n.prev,n,n.next)>0&&Oi(e.prev,e,e.next)>0)}function Oi(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function R$(n,e){return n.x===e.x&&n.y===e.y}function hle(n,e,t,r){const i=cE(Oi(n,e,t)),s=cE(Oi(n,e,r)),o=cE(Oi(t,r,n)),a=cE(Oi(t,r,e));return!!(i!==s&&o!==a||i===0&&lE(n,t,e)||s===0&&lE(n,r,e)||o===0&&lE(t,n,r)||a===0&&lE(t,e,r))}function lE(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function cE(n){return n>0?1:n<0?-1:0}function Byt(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&hle(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function CS(n,e){return Oi(n.prev,n,n.next)<0?Oi(n,e,n.next)>=0&&Oi(n,n.prev,e)>=0:Oi(n,e,n.prev)<0||Oi(n,n.next,e)<0}function Vyt(n,e){let t=n,r=!1;const i=(n.x+e.x)/2,s=(n.y+e.y)/2;do t.y>s!=t.next.y>s&&t.next.y!==t.y&&i<(t.next.x-t.x)*(s-t.y)/(t.next.y-t.y)+t.x&&(r=!r),t=t.next;while(t!==n);return r}function fle(n,e){const t=new zF(n.i,n.x,n.y),r=new zF(e.i,e.x,e.y),i=n.next,s=e.prev;return n.next=e,e.prev=n,t.next=i,i.prev=t,r.next=t,t.prev=r,s.next=r,r.prev=s,r}function F8(n,e,t,r){const i=new zF(n,e,t);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function kS(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function zF(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Uyt(n,e,t,r){let i=0;for(let s=e,o=t-r;s<t;s+=r)i+=(n[o]-n[s])*(n[s+1]+n[o+1]),o=s;return i}const Nf={area:function(n){const e=n.length;let t=0;for(let r=e-1,i=0;i<e;r=i++)t+=n[r].x*n[i].y-n[i].x*n[r].y;return t*.5},isClockWise:function(n){return Nf.area(n)<0},triangulateShape:function(n,e){const t=[],r=[],i=[];L8(n),z8(t,n);let s=n.length;e.forEach(L8);for(let a=0;a<e.length;a++)r.push(s),s+=e[a].length,z8(t,e[a]);const o=Tyt.triangulate(t,r);for(let a=0;a<o.length;a+=3)i.push(o.slice(a,a+3));return i}};function L8(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function z8(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class _g extends un{constructor(e,t){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const r=this,i=[],s=[];for(let a=0,l=e.length;a<l;a++){const c=e[a];o(c)}this.setAttribute("position",new qt(i,3)),this.setAttribute("uv",new qt(s,2)),this.computeVertexNormals();function o(a){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,u=t.steps!==void 0?t.steps:1;let h=t.depth!==void 0?t.depth:100,f=t.bevelEnabled!==void 0?t.bevelEnabled:!0,d=t.bevelThickness!==void 0?t.bevelThickness:6,p=t.bevelSize!==void 0?t.bevelSize:d-2,m=t.bevelOffset!==void 0?t.bevelOffset:0,g=t.bevelSegments!==void 0?t.bevelSegments:3;const y=t.extrudePath,b=t.UVGenerator!==void 0?t.UVGenerator:Wyt;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),h=t.amount);let _,w=!1,S,C,k,A;y&&(_=y.getSpacedPoints(u),w=!0,f=!1,S=y.computeFrenetFrames(u,!1),C=new Q,k=new Q,A=new Q),f||(g=0,d=0,p=0,m=0);const M=a.extractPoints(c);let E=M.shape;const N=M.holes;if(!Nf.isClockWise(E)){E=E.reverse();for(let Ue=0,Be=N.length;Ue<Be;Ue++){const Ve=N[Ue];Nf.isClockWise(Ve)&&(N[Ue]=Ve.reverse())}}const R=Nf.triangulateShape(E,N),D=E;for(let Ue=0,Be=N.length;Ue<Be;Ue++){const Ve=N[Ue];E=E.concat(Ve)}function z(Ue,Be,Ve){return Be||console.error("THREE.ExtrudeGeometry: vec does not exist"),Be.clone().multiplyScalar(Ve).add(Ue)}const B=E.length,X=R.length;function H(Ue,Be,Ve){let ft,Ye,ee;const J=Ue.x-Be.x,it=Ue.y-Be.y,Ge=Ve.x-Ue.x,ye=Ve.y-Ue.y,Je=J*J+it*it,bt=J*ye-it*Ge;if(Math.abs(bt)>Number.EPSILON){const It=Math.sqrt(Je),pt=Math.sqrt(Ge*Ge+ye*ye),ce=Be.x-it/It,rt=Be.y+J/It,Et=Ve.x-ye/pt,yt=Ve.y+Ge/pt,Ht=((Et-ce)*ye-(yt-rt)*Ge)/(J*ye-it*Ge);ft=ce+J*Ht-Ue.x,Ye=rt+it*Ht-Ue.y;const Mn=ft*ft+Ye*Ye;if(Mn<=2)return new st(ft,Ye);ee=Math.sqrt(Mn/2)}else{let It=!1;J>Number.EPSILON?Ge>Number.EPSILON&&(It=!0):J<-Number.EPSILON?Ge<-Number.EPSILON&&(It=!0):Math.sign(it)===Math.sign(ye)&&(It=!0),It?(ft=-it,Ye=J,ee=Math.sqrt(Je)):(ft=J,Ye=it,ee=Math.sqrt(Je/2))}return new st(ft/ee,Ye/ee)}const te=[];for(let Ue=0,Be=D.length,Ve=Be-1,ft=Ue+1;Ue<Be;Ue++,Ve++,ft++)Ve===Be&&(Ve=0),ft===Be&&(ft=0),te[Ue]=H(D[Ue],D[Ve],D[ft]);const ge=[];let ae,Ne=te.concat();for(let Ue=0,Be=N.length;Ue<Be;Ue++){const Ve=N[Ue];ae=[];for(let ft=0,Ye=Ve.length,ee=Ye-1,J=ft+1;ft<Ye;ft++,ee++,J++)ee===Ye&&(ee=0),J===Ye&&(J=0),ae[ft]=H(Ve[ft],Ve[ee],Ve[J]);ge.push(ae),Ne=Ne.concat(ae)}for(let Ue=0;Ue<g;Ue++){const Be=Ue/g,Ve=d*Math.cos(Be*Math.PI/2),ft=p*Math.sin(Be*Math.PI/2)+m;for(let Ye=0,ee=D.length;Ye<ee;Ye++){const J=z(D[Ye],te[Ye],ft);Oe(J.x,J.y,-Ve)}for(let Ye=0,ee=N.length;Ye<ee;Ye++){const J=N[Ye];ae=ge[Ye];for(let it=0,Ge=J.length;it<Ge;it++){const ye=z(J[it],ae[it],ft);Oe(ye.x,ye.y,-Ve)}}}const Te=p+m;for(let Ue=0;Ue<B;Ue++){const Be=f?z(E[Ue],Ne[Ue],Te):E[Ue];w?(k.copy(S.normals[0]).multiplyScalar(Be.x),C.copy(S.binormals[0]).multiplyScalar(Be.y),A.copy(_[0]).add(k).add(C),Oe(A.x,A.y,A.z)):Oe(Be.x,Be.y,0)}for(let Ue=1;Ue<=u;Ue++)for(let Be=0;Be<B;Be++){const Ve=f?z(E[Be],Ne[Be],Te):E[Be];w?(k.copy(S.normals[Ue]).multiplyScalar(Ve.x),C.copy(S.binormals[Ue]).multiplyScalar(Ve.y),A.copy(_[Ue]).add(k).add(C),Oe(A.x,A.y,A.z)):Oe(Ve.x,Ve.y,h/u*Ue)}for(let Ue=g-1;Ue>=0;Ue--){const Be=Ue/g,Ve=d*Math.cos(Be*Math.PI/2),ft=p*Math.sin(Be*Math.PI/2)+m;for(let Ye=0,ee=D.length;Ye<ee;Ye++){const J=z(D[Ye],te[Ye],ft);Oe(J.x,J.y,h+Ve)}for(let Ye=0,ee=N.length;Ye<ee;Ye++){const J=N[Ye];ae=ge[Ye];for(let it=0,Ge=J.length;it<Ge;it++){const ye=z(J[it],ae[it],ft);w?Oe(ye.x,ye.y+_[u-1].y,_[u-1].x+Ve):Oe(ye.x,ye.y,h+Ve)}}}De(),be();function De(){const Ue=i.length/3;if(f){let Be=0,Ve=B*Be;for(let ft=0;ft<X;ft++){const Ye=R[ft];ot(Ye[2]+Ve,Ye[1]+Ve,Ye[0]+Ve)}Be=u+g*2,Ve=B*Be;for(let ft=0;ft<X;ft++){const Ye=R[ft];ot(Ye[0]+Ve,Ye[1]+Ve,Ye[2]+Ve)}}else{for(let Be=0;Be<X;Be++){const Ve=R[Be];ot(Ve[2],Ve[1],Ve[0])}for(let Be=0;Be<X;Be++){const Ve=R[Be];ot(Ve[0]+B*u,Ve[1]+B*u,Ve[2]+B*u)}}r.addGroup(Ue,i.length/3-Ue,0)}function be(){const Ue=i.length/3;let Be=0;Ke(D,Be),Be+=D.length;for(let Ve=0,ft=N.length;Ve<ft;Ve++){const Ye=N[Ve];Ke(Ye,Be),Be+=Ye.length}r.addGroup(Ue,i.length/3-Ue,1)}function Ke(Ue,Be){let Ve=Ue.length;for(;--Ve>=0;){const ft=Ve;let Ye=Ve-1;Ye<0&&(Ye=Ue.length-1);for(let ee=0,J=u+g*2;ee<J;ee++){const it=B*ee,Ge=B*(ee+1),ye=Be+ft+it,Je=Be+Ye+it,bt=Be+Ye+Ge,It=Be+ft+Ge;He(ye,Je,bt,It)}}}function Oe(Ue,Be,Ve){l.push(Ue),l.push(Be),l.push(Ve)}function ot(Ue,Be,Ve){mt(Ue),mt(Be),mt(Ve);const ft=i.length/3,Ye=b.generateTopUV(r,i,ft-3,ft-2,ft-1);ht(Ye[0]),ht(Ye[1]),ht(Ye[2])}function He(Ue,Be,Ve,ft){mt(Ue),mt(Be),mt(ft),mt(Be),mt(Ve),mt(ft);const Ye=i.length/3,ee=b.generateSideWallUV(r,i,Ye-6,Ye-3,Ye-2,Ye-1);ht(ee[0]),ht(ee[1]),ht(ee[3]),ht(ee[1]),ht(ee[2]),ht(ee[3])}function mt(Ue){i.push(l[Ue*3+0]),i.push(l[Ue*3+1]),i.push(l[Ue*3+2])}function ht(Ue){s.push(Ue.x),s.push(Ue.y)}}}toJSON(){const e=un.prototype.toJSON.call(this),t=this.parameters.shapes,r=this.parameters.options;return Hyt(t,r,e)}}const Wyt={generateTopUV:function(n,e,t,r,i){const s=e[t*3],o=e[t*3+1],a=e[r*3],l=e[r*3+1],c=e[i*3],u=e[i*3+1];return[new st(s,o),new st(a,l),new st(c,u)]},generateSideWallUV:function(n,e,t,r,i,s){const o=e[t*3],a=e[t*3+1],l=e[t*3+2],c=e[r*3],u=e[r*3+1],h=e[r*3+2],f=e[i*3],d=e[i*3+1],p=e[i*3+2],m=e[s*3],g=e[s*3+1],y=e[s*3+2];return Math.abs(a-u)<.01?[new st(o,1-l),new st(c,1-h),new st(f,1-p),new st(m,1-y)]:[new st(a,1-l),new st(u,1-h),new st(d,1-p),new st(g,1-y)]}};function Hyt(n,e,t){if(t.shapes=[],Array.isArray(n))for(let r=0,i=n.length;r<i;r++){const s=n[r];t.shapes.push(s.uuid)}else t.shapes.push(n.uuid);return e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class $A extends gp{constructor(e=1,t=0){const r=(1+Math.sqrt(5))/2,i=[-1,r,0,1,r,0,-1,-r,0,1,-r,0,0,-1,r,0,1,r,0,-1,-r,0,1,-r,r,0,-1,r,0,1,-r,0,-1,-r,0,1],s=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,s,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}}class RA extends un{constructor(e,t=12,r=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:r,phiLength:i},t=Math.floor(t),i=In.clamp(i,0,Math.PI*2);const s=[],o=[],a=[],l=1/t,c=new Q,u=new st;for(let h=0;h<=t;h++){const f=r+h*l*i,d=Math.sin(f),p=Math.cos(f);for(let m=0;m<=e.length-1;m++)c.x=e[m].x*d,c.y=e[m].y,c.z=e[m].x*p,o.push(c.x,c.y,c.z),u.x=h/t,u.y=m/(e.length-1),a.push(u.x,u.y)}for(let h=0;h<t;h++)for(let f=0;f<e.length-1;f++){const d=f+h*e.length,p=d,m=d+e.length,g=d+e.length+1,y=d+1;s.push(p,m,y),s.push(m,g,y)}if(this.setIndex(s),this.setAttribute("position",new qt(o,3)),this.setAttribute("uv",new qt(a,2)),this.computeVertexNormals(),i===Math.PI*2){const h=this.attributes.normal.array,f=new Q,d=new Q,p=new Q,m=t*e.length*3;for(let g=0,y=0;g<e.length;g++,y+=3)f.x=h[y+0],f.y=h[y+1],f.z=h[y+2],d.x=h[m+y+0],d.y=h[m+y+1],d.z=h[m+y+2],p.addVectors(f,d).normalize(),h[y+0]=h[m+y+0]=p.x,h[y+1]=h[m+y+1]=p.y,h[y+2]=h[m+y+2]=p.z}}}class TS extends gp{constructor(e=1,t=0){const r=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(r,i,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}}function Sg(n,e,t){un.call(this),this.type="ParametricGeometry",this.parameters={func:n,slices:e,stacks:t};const r=[],i=[],s=[],o=[],a=1e-5,l=new Q,c=new Q,u=new Q,h=new Q,f=new Q;n.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const d=e+1;for(let p=0;p<=t;p++){const m=p/t;for(let g=0;g<=e;g++){const y=g/e;n(y,m,c),i.push(c.x,c.y,c.z),y-a>=0?(n(y-a,m,u),h.subVectors(c,u)):(n(y+a,m,u),h.subVectors(u,c)),m-a>=0?(n(y,m-a,u),f.subVectors(c,u)):(n(y,m+a,u),f.subVectors(u,c)),l.crossVectors(h,f).normalize(),s.push(l.x,l.y,l.z),o.push(y,m)}}for(let p=0;p<t;p++)for(let m=0;m<e;m++){const g=p*d+m,y=p*d+m+1,b=(p+1)*d+m+1,_=(p+1)*d+m;r.push(g,y,_),r.push(y,b,_)}this.setIndex(r),this.setAttribute("position",new qt(i,3)),this.setAttribute("normal",new qt(s,3)),this.setAttribute("uv",new qt(o,2))}Sg.prototype=Object.create(un.prototype);Sg.prototype.constructor=Sg;class PA extends un{constructor(e=.5,t=1,r=8,i=1,s=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:r,phiSegments:i,thetaStart:s,thetaLength:o},r=Math.max(3,r),i=Math.max(1,i);const a=[],l=[],c=[],u=[];let h=e;const f=(t-e)/i,d=new Q,p=new st;for(let m=0;m<=i;m++){for(let g=0;g<=r;g++){const y=s+g/r*o;d.x=h*Math.cos(y),d.y=h*Math.sin(y),l.push(d.x,d.y,d.z),c.push(0,0,1),p.x=(d.x/t+1)/2,p.y=(d.y/t+1)/2,u.push(p.x,p.y)}h+=f}for(let m=0;m<i;m++){const g=m*(r+1);for(let y=0;y<r;y++){const b=y+g,_=b,w=b+r+1,S=b+r+2,C=b+1;a.push(_,w,C),a.push(w,S,C)}}this.setIndex(a),this.setAttribute("position",new qt(l,3)),this.setAttribute("normal",new qt(c,3)),this.setAttribute("uv",new qt(u,2))}}class ES extends un{constructor(e,t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const r=[],i=[],s=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let u=0;u<e.length;u++)c(e[u]),this.addGroup(a,l,u),a+=l,l=0;this.setIndex(r),this.setAttribute("position",new qt(i,3)),this.setAttribute("normal",new qt(s,3)),this.setAttribute("uv",new qt(o,2));function c(u){const h=i.length/3,f=u.extractPoints(t);let d=f.shape;const p=f.holes;Nf.isClockWise(d)===!1&&(d=d.reverse());for(let g=0,y=p.length;g<y;g++){const b=p[g];Nf.isClockWise(b)===!0&&(p[g]=b.reverse())}const m=Nf.triangulateShape(d,p);for(let g=0,y=p.length;g<y;g++){const b=p[g];d=d.concat(b)}for(let g=0,y=d.length;g<y;g++){const b=d[g];i.push(b.x,b.y,0),s.push(0,0,1),o.push(b.x,b.y)}for(let g=0,y=m.length;g<y;g++){const b=m[g],_=b[0]+h,w=b[1]+h,S=b[2]+h;r.push(_,w,S),l+=3}}}toJSON(){const e=un.prototype.toJSON.call(this),t=this.parameters.shapes;return Gyt(t,e)}}function Gyt(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,r=n.length;t<r;t++){const i=n[t];e.shapes.push(i.uuid)}else e.shapes.push(n.uuid);return e}class IS extends un{constructor(e=1,t=8,r=6,i=0,s=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:r,phiStart:i,phiLength:s,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),r=Math.max(2,Math.floor(r));const l=Math.min(o+a,Math.PI);let c=0;const u=[],h=new Q,f=new Q,d=[],p=[],m=[],g=[];for(let y=0;y<=r;y++){const b=[],_=y/r;let w=0;y==0&&o==0?w=.5/t:y==r&&l==Math.PI&&(w=-.5/t);for(let S=0;S<=t;S++){const C=S/t;h.x=-e*Math.cos(i+C*s)*Math.sin(o+_*a),h.y=e*Math.cos(o+_*a),h.z=e*Math.sin(i+C*s)*Math.sin(o+_*a),p.push(h.x,h.y,h.z),f.copy(h).normalize(),m.push(f.x,f.y,f.z),g.push(C+w,1-_),b.push(c++)}u.push(b)}for(let y=0;y<r;y++)for(let b=0;b<t;b++){const _=u[y][b+1],w=u[y][b],S=u[y+1][b],C=u[y+1][b+1];(y!==0||o>0)&&d.push(_,w,C),(y!==r-1||l<Math.PI)&&d.push(w,S,C)}this.setIndex(d),this.setAttribute("position",new qt(p,3)),this.setAttribute("normal",new qt(m,3)),this.setAttribute("uv",new qt(g,2))}}class DA extends gp{constructor(e=1,t=0){const r=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(r,i,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}}class OA extends _g{constructor(e,t={}){const r=t.font;if(!(r&&r.isFont))return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new un;const i=r.generateShapes(e,t.size);t.depth=t.height!==void 0?t.height:50,t.bevelThickness===void 0&&(t.bevelThickness=10),t.bevelSize===void 0&&(t.bevelSize=8),t.bevelEnabled===void 0&&(t.bevelEnabled=!1),super(i,t),this.type="TextGeometry"}}class FA extends un{constructor(e=1,t=.4,r=8,i=6,s=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:r,tubularSegments:i,arc:s},r=Math.floor(r),i=Math.floor(i);const o=[],a=[],l=[],c=[],u=new Q,h=new Q,f=new Q;for(let d=0;d<=r;d++)for(let p=0;p<=i;p++){const m=p/i*s,g=d/r*Math.PI*2;h.x=(e+t*Math.cos(g))*Math.cos(m),h.y=(e+t*Math.cos(g))*Math.sin(m),h.z=t*Math.sin(g),a.push(h.x,h.y,h.z),u.x=e*Math.cos(m),u.y=e*Math.sin(m),f.subVectors(h,u).normalize(),l.push(f.x,f.y,f.z),c.push(p/i),c.push(d/r)}for(let d=1;d<=r;d++)for(let p=1;p<=i;p++){const m=(i+1)*d+p-1,g=(i+1)*(d-1)+p-1,y=(i+1)*(d-1)+p,b=(i+1)*d+p;o.push(m,g,b),o.push(g,y,b)}this.setIndex(o),this.setAttribute("position",new qt(a,3)),this.setAttribute("normal",new qt(l,3)),this.setAttribute("uv",new qt(c,2))}}class LA extends un{constructor(e=1,t=.4,r=64,i=8,s=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:r,radialSegments:i,p:s,q:o},r=Math.floor(r),i=Math.floor(i);const a=[],l=[],c=[],u=[],h=new Q,f=new Q,d=new Q,p=new Q,m=new Q,g=new Q,y=new Q;for(let _=0;_<=r;++_){const w=_/r*s*Math.PI*2;b(w,s,o,e,d),b(w+.01,s,o,e,p),g.subVectors(p,d),y.addVectors(p,d),m.crossVectors(g,y),y.crossVectors(m,g),m.normalize(),y.normalize();for(let S=0;S<=i;++S){const C=S/i*Math.PI*2,k=-t*Math.cos(C),A=t*Math.sin(C);h.x=d.x+(k*y.x+A*m.x),h.y=d.y+(k*y.y+A*m.y),h.z=d.z+(k*y.z+A*m.z),l.push(h.x,h.y,h.z),f.subVectors(h,d).normalize(),c.push(f.x,f.y,f.z),u.push(_/r),u.push(S/i)}}for(let _=1;_<=r;_++)for(let w=1;w<=i;w++){const S=(i+1)*(_-1)+(w-1),C=(i+1)*_+(w-1),k=(i+1)*_+w,A=(i+1)*(_-1)+w;a.push(S,C,A),a.push(C,k,A)}this.setIndex(a),this.setAttribute("position",new qt(l,3)),this.setAttribute("normal",new qt(c,3)),this.setAttribute("uv",new qt(u,2));function b(_,w,S,C,k){const A=Math.cos(_),M=Math.sin(_),E=S/w*_,N=Math.cos(E);k.x=C*(2+N)*.5*A,k.y=C*(2+N)*M*.5,k.z=C*Math.sin(E)*.5}}}class zA extends un{constructor(e,t=64,r=1,i=8,s=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:r,radialSegments:i,closed:s};const o=e.computeFrenetFrames(t,s);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new Q,l=new Q,c=new st;let u=new Q;const h=[],f=[],d=[],p=[];m(),this.setIndex(p),this.setAttribute("position",new qt(h,3)),this.setAttribute("normal",new qt(f,3)),this.setAttribute("uv",new qt(d,2));function m(){for(let _=0;_<t;_++)g(_);g(s===!1?t:0),b(),y()}function g(_){u=e.getPointAt(_/t,u);const w=o.normals[_],S=o.binormals[_];for(let C=0;C<=i;C++){const k=C/i*Math.PI*2,A=Math.sin(k),M=-Math.cos(k);l.x=M*w.x+A*S.x,l.y=M*w.y+A*S.y,l.z=M*w.z+A*S.z,l.normalize(),f.push(l.x,l.y,l.z),a.x=u.x+r*l.x,a.y=u.y+r*l.y,a.z=u.z+r*l.z,h.push(a.x,a.y,a.z)}}function y(){for(let _=1;_<=t;_++)for(let w=1;w<=i;w++){const S=(i+1)*(_-1)+(w-1),C=(i+1)*_+(w-1),k=(i+1)*_+w,A=(i+1)*(_-1)+w;p.push(S,C,A),p.push(C,k,A)}}function b(){for(let _=0;_<=t;_++)for(let w=0;w<=i;w++)c.x=_/t,c.y=w/i,d.push(c.x,c.y)}}toJSON(){const e=un.prototype.toJSON.call(this);return e.path=this.parameters.path.toJSON(),e}}class sV extends un{constructor(e){if(super(),this.type="WireframeGeometry",e.isGeometry===!0){console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return}const t=[],r=[0,0],i={},s=new Q;if(e.index!==null){const o=e.attributes.position,a=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:a.count,materialIndex:0}]);for(let c=0,u=l.length;c<u;++c){const h=l[c],f=h.start,d=h.count;for(let p=f,m=f+d;p<m;p+=3)for(let g=0;g<3;g++){const y=a.getX(p+g),b=a.getX(p+(g+1)%3);r[0]=Math.min(y,b),r[1]=Math.max(y,b);const _=r[0]+","+r[1];i[_]===void 0&&(i[_]={index1:r[0],index2:r[1]})}}for(const c in i){const u=i[c];s.fromBufferAttribute(o,u.index1),t.push(s.x,s.y,s.z),s.fromBufferAttribute(o,u.index2),t.push(s.x,s.y,s.z)}}else{const o=e.attributes.position;for(let a=0,l=o.count/3;a<l;a++)for(let c=0;c<3;c++){const u=3*a+c;s.fromBufferAttribute(o,u),t.push(s.x,s.y,s.z);const h=3*a+(c+1)%3;s.fromBufferAttribute(o,h),t.push(s.x,s.y,s.z)}}this.setAttribute("position",new qt(t,3))}}var ua=Object.freeze({__proto__:null,BoxGeometry:wg,BoxBufferGeometry:wg,CircleGeometry:AA,CircleBufferGeometry:AA,ConeGeometry:MA,ConeBufferGeometry:MA,CylinderGeometry:bv,CylinderBufferGeometry:bv,DodecahedronGeometry:NA,DodecahedronBufferGeometry:NA,EdgesGeometry:iV,ExtrudeGeometry:_g,ExtrudeBufferGeometry:_g,IcosahedronGeometry:$A,IcosahedronBufferGeometry:$A,LatheGeometry:RA,LatheBufferGeometry:RA,OctahedronGeometry:TS,OctahedronBufferGeometry:TS,ParametricGeometry:Sg,ParametricBufferGeometry:Sg,PlaneGeometry:mS,PlaneBufferGeometry:mS,PolyhedronGeometry:gp,PolyhedronBufferGeometry:gp,RingGeometry:PA,RingBufferGeometry:PA,ShapeGeometry:ES,ShapeBufferGeometry:ES,SphereGeometry:IS,SphereBufferGeometry:IS,TetrahedronGeometry:DA,TetrahedronBufferGeometry:DA,TextGeometry:OA,TextBufferGeometry:OA,TorusGeometry:FA,TorusBufferGeometry:FA,TorusKnotGeometry:LA,TorusKnotBufferGeometry:LA,TubeGeometry:zA,TubeBufferGeometry:zA,WireframeGeometry:sV});function Cg(n){kn.call(this),this.type="ShadowMaterial",this.color=new Gt(0),this.transparent=!0,this.setValues(n)}Cg.prototype=Object.create(kn.prototype);Cg.prototype.constructor=Cg;Cg.prototype.isShadowMaterial=!0;Cg.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this};function Ff(n){Ta.call(this,n),this.type="RawShaderMaterial"}Ff.prototype=Object.create(Ta.prototype);Ff.prototype.constructor=Ff;Ff.prototype.isRawShaderMaterial=!0;function Ah(n){kn.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Gt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Gt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zy,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(n)}Ah.prototype=Object.create(kn.prototype);Ah.prototype.constructor=Ah;Ah.prototype.isMeshStandardMaterial=!0;Ah.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.defines={STANDARD:""},this.color.copy(n.color),this.roughness=n.roughness,this.metalness=n.metalness,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.roughnessMap=n.roughnessMap,this.metalnessMap=n.metalnessMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.envMapIntensity=n.envMapIntensity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this.vertexTangents=n.vertexTangents,this};function bp(n){Ah.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new st(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(e){this.reflectivity=In.clamp(2.5*(e-1)/(e+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(n)}bp.prototype=Object.create(Ah.prototype);bp.prototype.constructor=bp;bp.prototype.isMeshPhysicalMaterial=!0;bp.prototype.copy=function(n){return Ah.prototype.copy.call(this,n),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=n.clearcoat,this.clearcoatMap=n.clearcoatMap,this.clearcoatRoughness=n.clearcoatRoughness,this.clearcoatRoughnessMap=n.clearcoatRoughnessMap,this.clearcoatNormalMap=n.clearcoatNormalMap,this.clearcoatNormalScale.copy(n.clearcoatNormalScale),this.reflectivity=n.reflectivity,n.sheen?this.sheen=(this.sheen||new Gt).copy(n.sheen):this.sheen=null,this.transmission=n.transmission,this.transmissionMap=n.transmissionMap,this};function vp(n){kn.call(this),this.type="MeshPhongMaterial",this.color=new Gt(16777215),this.specular=new Gt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Gt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zy,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=OC,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}vp.prototype=Object.create(kn.prototype);vp.prototype.constructor=vp;vp.prototype.isMeshPhongMaterial=!0;vp.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.specular.copy(n.specular),this.shininess=n.shininess,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function kg(n){kn.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Gt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Gt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zy,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}kg.prototype=Object.create(kn.prototype);kg.prototype.constructor=kg;kg.prototype.isMeshToonMaterial=!0;kg.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.gradientMap=n.gradientMap,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Tg(n){kn.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zy,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}Tg.prototype=Object.create(kn.prototype);Tg.prototype.constructor=Tg;Tg.prototype.isMeshNormalMaterial=!0;Tg.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Eg(n){kn.call(this),this.type="MeshLambertMaterial",this.color=new Gt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Gt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=OC,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}Eg.prototype=Object.create(kn.prototype);Eg.prototype.constructor=Eg;Eg.prototype.isMeshLambertMaterial=!0;Eg.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Ig(n){kn.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Gt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zy,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}Ig.prototype=Object.create(kn.prototype);Ig.prototype.constructor=Ig;Ig.prototype.isMeshMatcapMaterial=!0;Ig.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.defines={MATCAP:""},this.color.copy(n.color),this.matcap=n.matcap,this.map=n.map,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Ag(n){Ei.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(n)}Ag.prototype=Object.create(Ei.prototype);Ag.prototype.constructor=Ag;Ag.prototype.isLineDashedMaterial=!0;Ag.prototype.copy=function(n){return Ei.prototype.copy.call(this,n),this.scale=n.scale,this.dashSize=n.dashSize,this.gapSize=n.gapSize,this};var jyt=Object.freeze({__proto__:null,ShadowMaterial:Cg,SpriteMaterial:mp,RawShaderMaterial:Ff,ShaderMaterial:Ta,PointsMaterial:Au,MeshPhysicalMaterial:bp,MeshStandardMaterial:Ah,MeshPhongMaterial:vp,MeshToonMaterial:kg,MeshNormalMaterial:Tg,MeshLambertMaterial:Eg,MeshDepthMaterial:fp,MeshDistanceMaterial:dp,MeshBasicMaterial:Dl,MeshMatcapMaterial:Ig,LineDashedMaterial:Ag,LineBasicMaterial:Ei,Material:kn});const di={arraySlice:function(n,e,t){return di.isTypedArray(n)?new n.constructor(n.subarray(e,t!==void 0?t:n.length)):n.slice(e,t)},convertArray:function(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)},isTypedArray:function(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)},getKeyframeOrder:function(n){function e(i,s){return n[i]-n[s]}const t=n.length,r=new Array(t);for(let i=0;i!==t;++i)r[i]=i;return r.sort(e),r},sortedArray:function(n,e,t){const r=n.length,i=new n.constructor(r);for(let s=0,o=0;o!==r;++s){const a=t[s]*e;for(let l=0;l!==e;++l)i[o++]=n[a+l]}return i},flattenJSON:function(n,e,t,r){let i=1,s=n[0];for(;s!==void 0&&s[r]===void 0;)s=n[i++];if(s===void 0)return;let o=s[r];if(o!==void 0)if(Array.isArray(o))do o=s[r],o!==void 0&&(e.push(s.time),t.push.apply(t,o)),s=n[i++];while(s!==void 0);else if(o.toArray!==void 0)do o=s[r],o!==void 0&&(e.push(s.time),o.toArray(t,t.length)),s=n[i++];while(s!==void 0);else do o=s[r],o!==void 0&&(e.push(s.time),t.push(o)),s=n[i++];while(s!==void 0)},subclip:function(n,e,t,r,i=30){const s=n.clone();s.name=e;const o=[];for(let l=0;l<s.tracks.length;++l){const c=s.tracks[l],u=c.getValueSize(),h=[],f=[];for(let d=0;d<c.times.length;++d){const p=c.times[d]*i;if(!(p<t||p>=r)){h.push(c.times[d]);for(let m=0;m<u;++m)f.push(c.values[d*u+m])}}h.length!==0&&(c.times=di.convertArray(h,c.times.constructor),c.values=di.convertArray(f,c.values.constructor),o.push(c))}s.tracks=o;let a=1/0;for(let l=0;l<s.tracks.length;++l)a>s.tracks[l].times[0]&&(a=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*a);return s.resetDuration(),s},makeClipAdditive:function(n,e=0,t=n,r=30){r<=0&&(r=30);const i=t.tracks.length,s=e/r;for(let o=0;o<i;++o){const a=t.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=n.tracks.find(function(y){return y.name===a.name&&y.ValueTypeName===l});if(c===void 0)continue;let u=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=h/3);let f=0;const d=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=d/3);const p=a.times.length-1;let m;if(s<=a.times[0]){const y=u,b=h-u;m=di.arraySlice(a.values,y,b)}else if(s>=a.times[p]){const y=p*h+u,b=y+h-u;m=di.arraySlice(a.values,y,b)}else{const y=a.createInterpolant(),b=u,_=h-u;y.evaluate(s),m=di.arraySlice(y.resultBuffer,b,_)}l==="quaternion"&&new co().fromArray(m).normalize().conjugate().toArray(m);const g=c.times.length;for(let y=0;y<g;++y){const b=y*d+f;if(l==="quaternion")co.multiplyQuaternionsFlat(c.values,b,m,0,c.values,b);else{const _=d-f*2;for(let w=0;w<_;++w)c.values[b+w]-=m[w]}}}return n.blendMode=Y4,n}};function Nl(n,e,t,r){this.parameterPositions=n,this._cachedIndex=0,this.resultBuffer=r!==void 0?r:new e.constructor(t),this.sampleValues=e,this.valueSize=t}Object.assign(Nl.prototype,{evaluate:function(n){const e=this.parameterPositions;let t=this._cachedIndex,r=e[t],i=e[t-1];e:{t:{let s;n:{r:if(!(n<r)){for(let o=t+2;;){if(r===void 0){if(n<i)break r;return t=e.length,this._cachedIndex=t,this.afterEnd_(t-1,n,i)}if(t===o)break;if(i=r,r=e[++t],n<r)break t}s=e.length;break n}if(!(n>=i)){const o=e[1];n<o&&(t=2,i=o);for(let a=t-2;;){if(i===void 0)return this._cachedIndex=0,this.beforeStart_(0,n,r);if(t===a)break;if(r=i,i=e[--t-1],n>=i)break t}s=t,t=0;break n}break e}for(;t<s;){const o=t+s>>>1;n<e[o]?s=o:t=o+1}if(r=e[t],i=e[t-1],i===void 0)return this._cachedIndex=0,this.beforeStart_(0,n,r);if(r===void 0)return t=e.length,this._cachedIndex=t,this.afterEnd_(t-1,i,n)}this._cachedIndex=t,this.intervalChanged_(t,i,r)}return this.interpolate_(t,i,n,r)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(n){const e=this.resultBuffer,t=this.sampleValues,r=this.valueSize,i=n*r;for(let s=0;s!==r;++s)e[s]=t[i+s];return e},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}});Object.assign(Nl.prototype,{beforeStart_:Nl.prototype.copySampleValue_,afterEnd_:Nl.prototype.copySampleValue_});function BA(n,e,t,r){Nl.call(this,n,e,t,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}BA.prototype=Object.assign(Object.create(Nl.prototype),{constructor:BA,DefaultSettings_:{endingStart:Vm,endingEnd:Vm},intervalChanged_:function(n,e,t){const r=this.parameterPositions;let i=n-2,s=n+1,o=r[i],a=r[s];if(o===void 0)switch(this.getSettings_().endingStart){case Um:i=n,o=2*e-t;break;case aS:i=r.length-2,o=e+r[i]-r[i+1];break;default:i=n,o=t}if(a===void 0)switch(this.getSettings_().endingEnd){case Um:s=n,a=2*t-e;break;case aS:s=1,a=t+r[1]-r[0];break;default:s=n-1,a=e}const l=(t-e)*.5,c=this.valueSize;this._weightPrev=l/(e-o),this._weightNext=l/(a-t),this._offsetPrev=i*c,this._offsetNext=s*c},interpolate_:function(n,e,t,r){const i=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=n*o,l=a-o,c=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,f=this._weightNext,d=(t-e)/(r-e),p=d*d,m=p*d,g=-h*m+2*h*p-h*d,y=(1+h)*m+(-1.5-2*h)*p+(-.5+h)*d+1,b=(-1-f)*m+(1.5+f)*p+.5*d,_=f*m-f*p;for(let w=0;w!==o;++w)i[w]=g*s[c+w]+y*s[l+w]+b*s[a+w]+_*s[u+w];return i}});function AS(n,e,t,r){Nl.call(this,n,e,t,r)}AS.prototype=Object.assign(Object.create(Nl.prototype),{constructor:AS,interpolate_:function(n,e,t,r){const i=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=n*o,l=a-o,c=(t-e)/(r-e),u=1-c;for(let h=0;h!==o;++h)i[h]=s[l+h]*u+s[a+h]*c;return i}});function VA(n,e,t,r){Nl.call(this,n,e,t,r)}VA.prototype=Object.assign(Object.create(Nl.prototype),{constructor:VA,interpolate_:function(n){return this.copySampleValue_(n-1)}});function So(n,e,t,r){if(n===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+n);this.name=n,this.times=di.convertArray(e,this.TimeBufferType),this.values=di.convertArray(t,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}Object.assign(So,{toJSON:function(n){const e=n.constructor;let t;if(e.toJSON!==void 0)t=e.toJSON(n);else{t={name:n.name,times:di.convertArray(n.times,Array),values:di.convertArray(n.values,Array)};const r=n.getInterpolation();r!==n.DefaultInterpolation&&(t.interpolation=r)}return t.type=n.ValueTypeName,t}});Object.assign(So.prototype,{constructor:So,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:s_,InterpolantFactoryMethodDiscrete:function(n){return new VA(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodLinear:function(n){return new AS(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodSmooth:function(n){return new BA(this.times,this.values,this.getValueSize(),n)},setInterpolation:function(n){let e;switch(n){case oS:e=this.InterpolantFactoryMethodDiscrete;break;case s_:e=this.InterpolantFactoryMethodLinear;break;case QE:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(n!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(t);return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=e,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return oS;case this.InterpolantFactoryMethodLinear:return s_;case this.InterpolantFactoryMethodSmooth:return QE}},getValueSize:function(){return this.values.length/this.times.length},shift:function(n){if(n!==0){const e=this.times;for(let t=0,r=e.length;t!==r;++t)e[t]+=n}return this},scale:function(n){if(n!==1){const e=this.times;for(let t=0,r=e.length;t!==r;++t)e[t]*=n}return this},trim:function(n,e){const t=this.times,r=t.length;let i=0,s=r-1;for(;i!==r&&t[i]<n;)++i;for(;s!==-1&&t[s]>e;)--s;if(++s,i!==0||s!==r){i>=s&&(s=Math.max(s,1),i=s-1);const o=this.getValueSize();this.times=di.arraySlice(t,i,s),this.values=di.arraySlice(this.values,i*o,s*o)}return this},validate:function(){let n=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),n=!1);const t=this.times,r=this.values,i=t.length;i===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),n=!1);let s=null;for(let o=0;o!==i;o++){const a=t[o];if(typeof a=="number"&&isNaN(a)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,a),n=!1;break}if(s!==null&&s>a){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,a,s),n=!1;break}s=a}if(r!==void 0&&di.isTypedArray(r))for(let o=0,a=r.length;o!==a;++o){const l=r[o];if(isNaN(l)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,l),n=!1;break}}return n},optimize:function(){const n=di.arraySlice(this.times),e=di.arraySlice(this.values),t=this.getValueSize(),r=this.getInterpolation()===QE,i=n.length-1;let s=1;for(let o=1;o<i;++o){let a=!1;const l=n[o],c=n[o+1];if(l!==c&&(o!==1||l!==n[0]))if(r)a=!0;else{const u=o*t,h=u-t,f=u+t;for(let d=0;d!==t;++d){const p=e[u+d];if(p!==e[h+d]||p!==e[f+d]){a=!0;break}}}if(a){if(o!==s){n[s]=n[o];const u=o*t,h=s*t;for(let f=0;f!==t;++f)e[h+f]=e[u+f]}++s}}if(i>0){n[s]=n[i];for(let o=i*t,a=s*t,l=0;l!==t;++l)e[a+l]=e[o+l];++s}return s!==n.length?(this.times=di.arraySlice(n,0,s),this.values=di.arraySlice(e,0,s*t)):(this.times=n,this.values=e),this},clone:function(){const n=di.arraySlice(this.times,0),e=di.arraySlice(this.values,0),t=this.constructor,r=new t(this.name,n,e);return r.createInterpolant=this.createInterpolant,r}});function UA(n,e,t){So.call(this,n,e,t)}UA.prototype=Object.assign(Object.create(So.prototype),{constructor:UA,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:oS,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});function WA(n,e,t,r){So.call(this,n,e,t,r)}WA.prototype=Object.assign(Object.create(So.prototype),{constructor:WA,ValueTypeName:"color"});function vv(n,e,t,r){So.call(this,n,e,t,r)}vv.prototype=Object.assign(Object.create(So.prototype),{constructor:vv,ValueTypeName:"number"});function HA(n,e,t,r){Nl.call(this,n,e,t,r)}HA.prototype=Object.assign(Object.create(Nl.prototype),{constructor:HA,interpolate_:function(n,e,t,r){const i=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=(t-e)/(r-e);let l=n*o;for(let c=l+o;l!==c;l+=4)co.slerpFlat(i,0,s,l-o,s,l,a);return i}});function MS(n,e,t,r){So.call(this,n,e,t,r)}MS.prototype=Object.assign(Object.create(So.prototype),{constructor:MS,ValueTypeName:"quaternion",DefaultInterpolation:s_,InterpolantFactoryMethodLinear:function(n){return new HA(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodSmooth:void 0});function GA(n,e,t,r){So.call(this,n,e,t,r)}GA.prototype=Object.assign(Object.create(So.prototype),{constructor:GA,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:oS,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});function wv(n,e,t,r){So.call(this,n,e,t,r)}wv.prototype=Object.assign(Object.create(So.prototype),{constructor:wv,ValueTypeName:"vector"});function Sl(n,e=-1,t,r=I$){this.name=n,this.tracks=t,this.duration=e,this.blendMode=r,this.uuid=In.generateUUID(),this.duration<0&&this.resetDuration()}function qyt(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return vv;case"vector":case"vector2":case"vector3":case"vector4":return wv;case"color":return WA;case"quaternion":return MS;case"bool":case"boolean":return UA;case"string":return GA}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function Xyt(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=qyt(n.type);if(n.times===void 0){const t=[],r=[];di.flattenJSON(n.keys,t,r,"value"),n.times=t,n.values=r}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}Object.assign(Sl,{parse:function(n){const e=[],t=n.tracks,r=1/(n.fps||1);for(let s=0,o=t.length;s!==o;++s)e.push(Xyt(t[s]).scale(r));const i=new Sl(n.name,n.duration,e,n.blendMode);return i.uuid=n.uuid,i},toJSON:function(n){const e=[],t=n.tracks,r={name:n.name,duration:n.duration,tracks:e,uuid:n.uuid,blendMode:n.blendMode};for(let i=0,s=t.length;i!==s;++i)e.push(So.toJSON(t[i]));return r},CreateFromMorphTargetSequence:function(n,e,t,r){const i=e.length,s=[];for(let o=0;o<i;o++){let a=[],l=[];a.push((o+i-1)%i,o,(o+1)%i),l.push(0,1,0);const c=di.getKeyframeOrder(a);a=di.sortedArray(a,1,c),l=di.sortedArray(l,1,c),!r&&a[0]===0&&(a.push(i),l.push(l[0])),s.push(new vv(".morphTargetInfluences["+e[o].name+"]",a,l).scale(1/t))}return new Sl(n,-1,s)},findByName:function(n,e){let t=n;if(!Array.isArray(n)){const r=n;t=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<t.length;r++)if(t[r].name===e)return t[r];return null},CreateClipsFromMorphTargetSequences:function(n,e,t){const r={},i=/^([\w-]*?)([\d]+)$/;for(let o=0,a=n.length;o<a;o++){const l=n[o],c=l.name.match(i);if(c&&c.length>1){const u=c[1];let h=r[u];h||(r[u]=h=[]),h.push(l)}}const s=[];for(const o in r)s.push(Sl.CreateFromMorphTargetSequence(o,r[o],e,t));return s},parseAnimation:function(n,e){if(!n)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const t=function(u,h,f,d,p){if(f.length!==0){const m=[],g=[];di.flattenJSON(f,m,g,d),m.length!==0&&p.push(new u(h,m,g))}},r=[],i=n.name||"default",s=n.fps||30,o=n.blendMode;let a=n.length||-1;const l=n.hierarchy||[];for(let u=0;u<l.length;u++){const h=l[u].keys;if(!(!h||h.length===0))if(h[0].morphTargets){const f={};let d;for(d=0;d<h.length;d++)if(h[d].morphTargets)for(let p=0;p<h[d].morphTargets.length;p++)f[h[d].morphTargets[p]]=-1;for(const p in f){const m=[],g=[];for(let y=0;y!==h[d].morphTargets.length;++y){const b=h[d];m.push(b.time),g.push(b.morphTarget===p?1:0)}r.push(new vv(".morphTargetInfluence["+p+"]",m,g))}a=f.length*(s||1)}else{const f=".bones["+e[u].name+"]";t(wv,f+".position",h,"pos",r),t(MS,f+".quaternion",h,"rot",r),t(wv,f+".scale",h,"scl",r)}}return r.length===0?null:new Sl(i,a,r,o)}});Object.assign(Sl.prototype,{resetDuration:function(){const n=this.tracks;let e=0;for(let t=0,r=n.length;t!==r;++t){const i=this.tracks[t];e=Math.max(e,i.times[i.times.length-1])}return this.duration=e,this},trim:function(){for(let n=0;n<this.tracks.length;n++)this.tracks[n].trim(0,this.duration);return this},validate:function(){let n=!0;for(let e=0;e<this.tracks.length;e++)n=n&&this.tracks[e].validate();return n},optimize:function(){for(let n=0;n<this.tracks.length;n++)this.tracks[n].optimize();return this},clone:function(){const n=[];for(let e=0;e<this.tracks.length;e++)n.push(this.tracks[e].clone());return new Sl(this.name,this.duration,n,this.blendMode)},toJSON:function(){return Sl.toJSON(this)}});const Mg={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};function oV(n,e,t){const r=this;let i=!1,s=0,o=0,a;const l=[];this.onStart=void 0,this.onLoad=n,this.onProgress=e,this.onError=t,this.itemStart=function(c){o++,i===!1&&r.onStart!==void 0&&r.onStart(c,s,o),i=!0},this.itemEnd=function(c){s++,r.onProgress!==void 0&&r.onProgress(c,s,o),s===o&&(i=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(c){r.onError!==void 0&&r.onError(c)},this.resolveURL=function(c){return a?a(c):c},this.setURLModifier=function(c){return a=c,this},this.addHandler=function(c,u){return l.push(c,u),this},this.removeHandler=function(c){const u=l.indexOf(c);return u!==-1&&l.splice(u,2),this},this.getHandler=function(c){for(let u=0,h=l.length;u<h;u+=2){const f=l[u],d=l[u+1];if(f.global&&(f.lastIndex=0),f.test(c))return d}return null}}const dle=new oV;function zr(n){this.manager=n!==void 0?n:dle,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(zr.prototype,{load:function(){},loadAsync:function(n,e){const t=this;return new Promise(function(r,i){t.load(n,r,e,i)})},parse:function(){},setCrossOrigin:function(n){return this.crossOrigin=n,this},setWithCredentials:function(n){return this.withCredentials=n,this},setPath:function(n){return this.path=n,this},setResourcePath:function(n){return this.resourcePath=n,this},setRequestHeader:function(n){return this.requestHeader=n,this}});const nu={};function $c(n){zr.call(this,n)}$c.prototype=Object.assign(Object.create(zr.prototype),{constructor:$c,load:function(n,e,t,r){n===void 0&&(n=""),this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const i=this,s=Mg.get(n);if(s!==void 0)return i.manager.itemStart(n),setTimeout(function(){e&&e(s),i.manager.itemEnd(n)},0),s;if(nu[n]!==void 0){nu[n].push({onLoad:e,onProgress:t,onError:r});return}const o=/^data:(.*?)(;base64)?,(.*)$/,a=n.match(o);let l;if(a){const c=a[1],u=!!a[2];let h=a[3];h=decodeURIComponent(h),u&&(h=atob(h));try{let f;const d=(this.responseType||"").toLowerCase();switch(d){case"arraybuffer":case"blob":const p=new Uint8Array(h.length);for(let g=0;g<h.length;g++)p[g]=h.charCodeAt(g);d==="blob"?f=new Blob([p.buffer],{type:c}):f=p.buffer;break;case"document":f=new DOMParser().parseFromString(h,c);break;case"json":f=JSON.parse(h);break;default:f=h;break}setTimeout(function(){e&&e(f),i.manager.itemEnd(n)},0)}catch(f){setTimeout(function(){r&&r(f),i.manager.itemError(n),i.manager.itemEnd(n)},0)}}else{nu[n]=[],nu[n].push({onLoad:e,onProgress:t,onError:r}),l=new XMLHttpRequest,l.open("GET",n,!0),l.addEventListener("load",function(c){const u=this.response,h=nu[n];if(delete nu[n],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),Mg.add(n,u);for(let f=0,d=h.length;f<d;f++){const p=h[f];p.onLoad&&p.onLoad(u)}i.manager.itemEnd(n)}else{for(let f=0,d=h.length;f<d;f++){const p=h[f];p.onError&&p.onError(c)}i.manager.itemError(n),i.manager.itemEnd(n)}},!1),l.addEventListener("progress",function(c){const u=nu[n];for(let h=0,f=u.length;h<f;h++){const d=u[h];d.onProgress&&d.onProgress(c)}},!1),l.addEventListener("error",function(c){const u=nu[n];delete nu[n];for(let h=0,f=u.length;h<f;h++){const d=u[h];d.onError&&d.onError(c)}i.manager.itemError(n),i.manager.itemEnd(n)},!1),l.addEventListener("abort",function(c){const u=nu[n];delete nu[n];for(let h=0,f=u.length;h<f;h++){const d=u[h];d.onError&&d.onError(c)}i.manager.itemError(n),i.manager.itemEnd(n)},!1),this.responseType!==void 0&&(l.responseType=this.responseType),this.withCredentials!==void 0&&(l.withCredentials=this.withCredentials),l.overrideMimeType&&l.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const c in this.requestHeader)l.setRequestHeader(c,this.requestHeader[c]);l.send(null)}return i.manager.itemStart(n),l},setResponseType:function(n){return this.responseType=n,this},setMimeType:function(n){return this.mimeType=n,this}});function BF(n){zr.call(this,n)}BF.prototype=Object.assign(Object.create(zr.prototype),{constructor:BF,load:function(n,e,t,r){const i=this,s=new $c(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(n,function(o){try{e(i.parse(JSON.parse(o)))}catch(a){r?r(a):console.error(a),i.manager.itemError(n)}},t,r)},parse:function(n){const e=[];for(let t=0;t<n.length;t++){const r=Sl.parse(n[t]);e.push(r)}return e}});function VF(n){zr.call(this,n)}VF.prototype=Object.assign(Object.create(zr.prototype),{constructor:VF,load:function(n,e,t,r){const i=this,s=[],o=new yv,a=new $c(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(i.withCredentials);let l=0;function c(u){a.load(n[u],function(h){const f=i.parse(h,!0);s[u]={width:f.width,height:f.height,format:f.format,mipmaps:f.mipmaps},l+=1,l===6&&(f.mipmapCount===1&&(o.minFilter=lo),o.image=s,o.format=f.format,o.needsUpdate=!0,e&&e(o))},t,r)}if(Array.isArray(n))for(let u=0,h=n.length;u<h;++u)c(u);else a.load(n,function(u){const h=i.parse(u,!0);if(h.isCubemap){const f=h.mipmaps.length/h.mipmapCount;for(let d=0;d<f;d++){s[d]={mipmaps:[]};for(let p=0;p<h.mipmapCount;p++)s[d].mipmaps.push(h.mipmaps[d*h.mipmapCount+p]),s[d].format=h.format,s[d].width=h.width,s[d].height=h.height}o.image=s}else o.image.width=h.width,o.image.height=h.height,o.mipmaps=h.mipmaps;h.mipmapCount===1&&(o.minFilter=lo),o.format=h.format,o.needsUpdate=!0,e&&e(o)},t,r);return o}});function xv(n){zr.call(this,n)}xv.prototype=Object.assign(Object.create(zr.prototype),{constructor:xv,load:function(n,e,t,r){this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const i=this,s=Mg.get(n);if(s!==void 0)return i.manager.itemStart(n),setTimeout(function(){e&&e(s),i.manager.itemEnd(n)},0),s;const o=document.createElementNS("http://www.w3.org/1999/xhtml","img");function a(){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),Mg.add(n,this),e&&e(this),i.manager.itemEnd(n)}function l(c){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),r&&r(c),i.manager.itemError(n),i.manager.itemEnd(n)}return o.addEventListener("load",a,!1),o.addEventListener("error",l,!1),n.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),i.manager.itemStart(n),o.src=n,o}});function jA(n){zr.call(this,n)}jA.prototype=Object.assign(Object.create(zr.prototype),{constructor:jA,load:function(n,e,t,r){const i=new Ih,s=new xv(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let o=0;function a(l){s.load(n[l],function(c){i.images[l]=c,o++,o===6&&(i.needsUpdate=!0,e&&e(i))},void 0,r)}for(let l=0;l<n.length;++l)a(l);return i}});function qA(n){zr.call(this,n)}qA.prototype=Object.assign(Object.create(zr.prototype),{constructor:qA,load:function(n,e,t,r){const i=this,s=new Of,o=new $c(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(i.withCredentials),o.load(n,function(a){const l=i.parse(a);l&&(l.image!==void 0?s.image=l.image:l.data!==void 0&&(s.image.width=l.width,s.image.height=l.height,s.image.data=l.data),s.wrapS=l.wrapS!==void 0?l.wrapS:ma,s.wrapT=l.wrapT!==void 0?l.wrapT:ma,s.magFilter=l.magFilter!==void 0?l.magFilter:lo,s.minFilter=l.minFilter!==void 0?l.minFilter:lo,s.anisotropy=l.anisotropy!==void 0?l.anisotropy:1,l.encoding!==void 0&&(s.encoding=l.encoding),l.flipY!==void 0&&(s.flipY=l.flipY),l.format!==void 0&&(s.format=l.format),l.type!==void 0&&(s.type=l.type),l.mipmaps!==void 0&&(s.mipmaps=l.mipmaps,s.minFilter=ix),l.mipmapCount===1&&(s.minFilter=lo),s.needsUpdate=!0,e&&e(s,l))},t,r),s}});function XA(n){zr.call(this,n)}XA.prototype=Object.assign(Object.create(zr.prototype),{constructor:XA,load:function(n,e,t,r){const i=new Kr,s=new xv(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(n,function(o){i.image=o;const a=n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0;i.format=a?jd:Ml,i.needsUpdate=!0,e!==void 0&&e(i)},t,r),i}});function on(){this.type="Curve",this.arcLengthDivisions=200}Object.assign(on.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(n,e){const t=this.getUtoTmapping(n);return this.getPoint(t,e)},getPoints:function(n=5){const e=[];for(let t=0;t<=n;t++)e.push(this.getPoint(t/n));return e},getSpacedPoints:function(n=5){const e=[];for(let t=0;t<=n;t++)e.push(this.getPointAt(t/n));return e},getLength:function(){const n=this.getLengths();return n[n.length-1]},getLengths:function(n){if(n===void 0&&(n=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===n+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let t,r=this.getPoint(0),i=0;e.push(0);for(let s=1;s<=n;s++)t=this.getPoint(s/n),i+=t.distanceTo(r),e.push(i),r=t;return this.cacheArcLengths=e,e},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(n,e){const t=this.getLengths();let r=0;const i=t.length;let s;e?s=e:s=n*t[i-1];let o=0,a=i-1,l;for(;o<=a;)if(r=Math.floor(o+(a-o)/2),l=t[r]-s,l<0)o=r+1;else if(l>0)a=r-1;else{a=r;break}if(r=a,t[r]===s)return r/(i-1);const c=t[r],h=t[r+1]-c,f=(s-c)/h;return(r+f)/(i-1)},getTangent:function(n,e){let r=n-1e-4,i=n+1e-4;r<0&&(r=0),i>1&&(i=1);const s=this.getPoint(r),o=this.getPoint(i),a=e||(s.isVector2?new st:new Q);return a.copy(o).sub(s).normalize(),a},getTangentAt:function(n,e){const t=this.getUtoTmapping(n);return this.getTangent(t,e)},computeFrenetFrames:function(n,e){const t=new Q,r=[],i=[],s=[],o=new Q,a=new Zn;for(let f=0;f<=n;f++){const d=f/n;r[f]=this.getTangentAt(d,new Q),r[f].normalize()}i[0]=new Q,s[0]=new Q;let l=Number.MAX_VALUE;const c=Math.abs(r[0].x),u=Math.abs(r[0].y),h=Math.abs(r[0].z);c<=l&&(l=c,t.set(1,0,0)),u<=l&&(l=u,t.set(0,1,0)),h<=l&&t.set(0,0,1),o.crossVectors(r[0],t).normalize(),i[0].crossVectors(r[0],o),s[0].crossVectors(r[0],i[0]);for(let f=1;f<=n;f++){if(i[f]=i[f-1].clone(),s[f]=s[f-1].clone(),o.crossVectors(r[f-1],r[f]),o.length()>Number.EPSILON){o.normalize();const d=Math.acos(In.clamp(r[f-1].dot(r[f]),-1,1));i[f].applyMatrix4(a.makeRotationAxis(o,d))}s[f].crossVectors(r[f],i[f])}if(e===!0){let f=Math.acos(In.clamp(i[0].dot(i[n]),-1,1));f/=n,r[0].dot(o.crossVectors(i[0],i[n]))>0&&(f=-f);for(let d=1;d<=n;d++)i[d].applyMatrix4(a.makeRotationAxis(r[d],f*d)),s[d].crossVectors(r[d],i[d])}return{tangents:r,normals:i,binormals:s}},clone:function(){return new this.constructor().copy(this)},copy:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this},toJSON:function(){const n={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return n.arcLengthDivisions=this.arcLengthDivisions,n.type=this.type,n},fromJSON:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this}});function Fl(n,e,t,r,i,s,o,a){on.call(this),this.type="EllipseCurve",this.aX=n||0,this.aY=e||0,this.xRadius=t||1,this.yRadius=r||1,this.aStartAngle=i||0,this.aEndAngle=s||2*Math.PI,this.aClockwise=o||!1,this.aRotation=a||0}Fl.prototype=Object.create(on.prototype);Fl.prototype.constructor=Fl;Fl.prototype.isEllipseCurve=!0;Fl.prototype.getPoint=function(n,e){const t=e||new st,r=Math.PI*2;let i=this.aEndAngle-this.aStartAngle;const s=Math.abs(i)<Number.EPSILON;for(;i<0;)i+=r;for(;i>r;)i-=r;i<Number.EPSILON&&(s?i=0:i=r),this.aClockwise===!0&&!s&&(i===r?i=-r:i=i-r);const o=this.aStartAngle+n*i;let a=this.aX+this.xRadius*Math.cos(o),l=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const c=Math.cos(this.aRotation),u=Math.sin(this.aRotation),h=a-this.aX,f=l-this.aY;a=h*c-f*u+this.aX,l=h*u+f*c+this.aY}return t.set(a,l)};Fl.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this};Fl.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.aX=this.aX,n.aY=this.aY,n.xRadius=this.xRadius,n.yRadius=this.yRadius,n.aStartAngle=this.aStartAngle,n.aEndAngle=this.aEndAngle,n.aClockwise=this.aClockwise,n.aRotation=this.aRotation,n};Fl.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this};function _v(n,e,t,r,i,s){Fl.call(this,n,e,t,t,r,i,s),this.type="ArcCurve"}_v.prototype=Object.create(Fl.prototype);_v.prototype.constructor=_v;_v.prototype.isArcCurve=!0;function aV(){let n=0,e=0,t=0,r=0;function i(s,o,a,l){n=s,e=a,t=-3*s+3*o-2*a-l,r=2*s-2*o+a+l}return{initCatmullRom:function(s,o,a,l,c){i(o,a,c*(a-s),c*(l-o))},initNonuniformCatmullRom:function(s,o,a,l,c,u,h){let f=(o-s)/c-(a-s)/(c+u)+(a-o)/u,d=(a-o)/u-(l-o)/(u+h)+(l-a)/h;f*=u,d*=u,i(o,a,f,d)},calc:function(s){const o=s*s,a=o*s;return n+e*s+t*o+r*a}}}const uE=new Q,IP=new aV,AP=new aV,MP=new aV;function ta(n=[],e=!1,t="centripetal",r=.5){on.call(this),this.type="CatmullRomCurve3",this.points=n,this.closed=e,this.curveType=t,this.tension=r}ta.prototype=Object.create(on.prototype);ta.prototype.constructor=ta;ta.prototype.isCatmullRomCurve3=!0;ta.prototype.getPoint=function(n,e=new Q){const t=e,r=this.points,i=r.length,s=(i-(this.closed?0:1))*n;let o=Math.floor(s),a=s-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/i)+1)*i:a===0&&o===i-1&&(o=i-2,a=1);let l,c;this.closed||o>0?l=r[(o-1)%i]:(uE.subVectors(r[0],r[1]).add(r[0]),l=uE);const u=r[o%i],h=r[(o+1)%i];if(this.closed||o+2<i?c=r[(o+2)%i]:(uE.subVectors(r[i-1],r[i-2]).add(r[i-1]),c=uE),this.curveType==="centripetal"||this.curveType==="chordal"){const f=this.curveType==="chordal"?.5:.25;let d=Math.pow(l.distanceToSquared(u),f),p=Math.pow(u.distanceToSquared(h),f),m=Math.pow(h.distanceToSquared(c),f);p<1e-4&&(p=1),d<1e-4&&(d=p),m<1e-4&&(m=p),IP.initNonuniformCatmullRom(l.x,u.x,h.x,c.x,d,p,m),AP.initNonuniformCatmullRom(l.y,u.y,h.y,c.y,d,p,m),MP.initNonuniformCatmullRom(l.z,u.z,h.z,c.z,d,p,m)}else this.curveType==="catmullrom"&&(IP.initCatmullRom(l.x,u.x,h.x,c.x,this.tension),AP.initCatmullRom(l.y,u.y,h.y,c.y,this.tension),MP.initCatmullRom(l.z,u.z,h.z,c.z,this.tension));return t.set(IP.calc(a),AP.calc(a),MP.calc(a)),t};ta.prototype.copy=function(n){on.prototype.copy.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(r.clone())}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this};ta.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);n.points=[];for(let e=0,t=this.points.length;e<t;e++){const r=this.points[e];n.points.push(r.toArray())}return n.closed=this.closed,n.curveType=this.curveType,n.tension=this.tension,n};ta.prototype.fromJSON=function(n){on.prototype.fromJSON.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(new Q().fromArray(r))}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this};function B8(n,e,t,r,i){const s=(r-e)*.5,o=(i-t)*.5,a=n*n,l=n*a;return(2*t-2*r+s+o)*l+(-3*t+3*r-2*s-o)*a+s*n+t}function Kyt(n,e){const t=1-n;return t*t*e}function Yyt(n,e){return 2*(1-n)*n*e}function Zyt(n,e){return n*n*e}function a_(n,e,t,r){return Kyt(n,e)+Yyt(n,t)+Zyt(n,r)}function Jyt(n,e){const t=1-n;return t*t*t*e}function Qyt(n,e){const t=1-n;return 3*t*t*n*e}function e0t(n,e){return 3*(1-n)*n*n*e}function t0t(n,e){return n*n*n*e}function l_(n,e,t,r,i){return Jyt(n,e)+Qyt(n,t)+e0t(n,r)+t0t(n,i)}function Mu(n=new st,e=new st,t=new st,r=new st){on.call(this),this.type="CubicBezierCurve",this.v0=n,this.v1=e,this.v2=t,this.v3=r}Mu.prototype=Object.create(on.prototype);Mu.prototype.constructor=Mu;Mu.prototype.isCubicBezierCurve=!0;Mu.prototype.getPoint=function(n,e=new st){const t=e,r=this.v0,i=this.v1,s=this.v2,o=this.v3;return t.set(l_(n,r.x,i.x,s.x,o.x),l_(n,r.y,i.y,s.y,o.y)),t};Mu.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this};Mu.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n};Mu.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this};function Mh(n=new Q,e=new Q,t=new Q,r=new Q){on.call(this),this.type="CubicBezierCurve3",this.v0=n,this.v1=e,this.v2=t,this.v3=r}Mh.prototype=Object.create(on.prototype);Mh.prototype.constructor=Mh;Mh.prototype.isCubicBezierCurve3=!0;Mh.prototype.getPoint=function(n,e=new Q){const t=e,r=this.v0,i=this.v1,s=this.v2,o=this.v3;return t.set(l_(n,r.x,i.x,s.x,o.x),l_(n,r.y,i.y,s.y,o.y),l_(n,r.z,i.z,s.z,o.z)),t};Mh.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this};Mh.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n};Mh.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this};function Ya(n=new st,e=new st){on.call(this),this.type="LineCurve",this.v1=n,this.v2=e}Ya.prototype=Object.create(on.prototype);Ya.prototype.constructor=Ya;Ya.prototype.isLineCurve=!0;Ya.prototype.getPoint=function(n,e=new st){const t=e;return n===1?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t};Ya.prototype.getPointAt=function(n,e){return this.getPoint(n,e)};Ya.prototype.getTangent=function(n,e){const t=e||new st;return t.copy(this.v2).sub(this.v1).normalize(),t};Ya.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Ya.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Ya.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Nu(n=new Q,e=new Q){on.call(this),this.type="LineCurve3",this.v1=n,this.v2=e}Nu.prototype=Object.create(on.prototype);Nu.prototype.constructor=Nu;Nu.prototype.isLineCurve3=!0;Nu.prototype.getPoint=function(n,e=new Q){const t=e;return n===1?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t};Nu.prototype.getPointAt=function(n,e){return this.getPoint(n,e)};Nu.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Nu.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Nu.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function $u(n=new st,e=new st,t=new st){on.call(this),this.type="QuadraticBezierCurve",this.v0=n,this.v1=e,this.v2=t}$u.prototype=Object.create(on.prototype);$u.prototype.constructor=$u;$u.prototype.isQuadraticBezierCurve=!0;$u.prototype.getPoint=function(n,e=new st){const t=e,r=this.v0,i=this.v1,s=this.v2;return t.set(a_(n,r.x,i.x,s.x),a_(n,r.y,i.y,s.y)),t};$u.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this};$u.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};$u.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Nh(n=new Q,e=new Q,t=new Q){on.call(this),this.type="QuadraticBezierCurve3",this.v0=n,this.v1=e,this.v2=t}Nh.prototype=Object.create(on.prototype);Nh.prototype.constructor=Nh;Nh.prototype.isQuadraticBezierCurve3=!0;Nh.prototype.getPoint=function(n,e=new Q){const t=e,r=this.v0,i=this.v1,s=this.v2;return t.set(a_(n,r.x,i.x,s.x),a_(n,r.y,i.y,s.y),a_(n,r.z,i.z,s.z)),t};Nh.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Nh.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Nh.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Ru(n=[]){on.call(this),this.type="SplineCurve",this.points=n}Ru.prototype=Object.create(on.prototype);Ru.prototype.constructor=Ru;Ru.prototype.isSplineCurve=!0;Ru.prototype.getPoint=function(n,e=new st){const t=e,r=this.points,i=(r.length-1)*n,s=Math.floor(i),o=i-s,a=r[s===0?s:s-1],l=r[s],c=r[s>r.length-2?r.length-1:s+1],u=r[s>r.length-3?r.length-1:s+2];return t.set(B8(o,a.x,l.x,c.x,u.x),B8(o,a.y,l.y,c.y,u.y)),t};Ru.prototype.copy=function(n){on.prototype.copy.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(r.clone())}return this};Ru.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);n.points=[];for(let e=0,t=this.points.length;e<t;e++){const r=this.points[e];n.points.push(r.toArray())}return n};Ru.prototype.fromJSON=function(n){on.prototype.fromJSON.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(new st().fromArray(r))}return this};var UF=Object.freeze({__proto__:null,ArcCurve:_v,CatmullRomCurve3:ta,CubicBezierCurve:Mu,CubicBezierCurve3:Mh,EllipseCurve:Fl,LineCurve:Ya,LineCurve3:Nu,QuadraticBezierCurve:$u,QuadraticBezierCurve3:Nh,SplineCurve:Ru});function Fd(){on.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}Fd.prototype=Object.assign(Object.create(on.prototype),{constructor:Fd,add:function(n){this.curves.push(n)},closePath:function(){const n=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);n.equals(e)||this.curves.push(new Ya(e,n))},getPoint:function(n){const e=n*this.getLength(),t=this.getCurveLengths();let r=0;for(;r<t.length;){if(t[r]>=e){const i=t[r]-e,s=this.curves[r],o=s.getLength(),a=o===0?0:1-i/o;return s.getPointAt(a)}r++}return null},getLength:function(){const n=this.getCurveLengths();return n[n.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const n=[];let e=0;for(let t=0,r=this.curves.length;t<r;t++)e+=this.curves[t].getLength(),n.push(e);return this.cacheLengths=n,n},getSpacedPoints:function(n=40){const e=[];for(let t=0;t<=n;t++)e.push(this.getPoint(t/n));return this.autoClose&&e.push(e[0]),e},getPoints:function(n=12){const e=[];let t;for(let r=0,i=this.curves;r<i.length;r++){const s=i[r],o=s&&s.isEllipseCurve?n*2:s&&(s.isLineCurve||s.isLineCurve3)?1:s&&s.isSplineCurve?n*s.points.length:n,a=s.getPoints(o);for(let l=0;l<a.length;l++){const c=a[l];t&&t.equals(c)||(e.push(c),t=c)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e},copy:function(n){on.prototype.copy.call(this,n),this.curves=[];for(let e=0,t=n.curves.length;e<t;e++){const r=n.curves[e];this.curves.push(r.clone())}return this.autoClose=n.autoClose,this},toJSON:function(){const n=on.prototype.toJSON.call(this);n.autoClose=this.autoClose,n.curves=[];for(let e=0,t=this.curves.length;e<t;e++){const r=this.curves[e];n.curves.push(r.toJSON())}return n},fromJSON:function(n){on.prototype.fromJSON.call(this,n),this.autoClose=n.autoClose,this.curves=[];for(let e=0,t=n.curves.length;e<t;e++){const r=n.curves[e];this.curves.push(new UF[r.type]().fromJSON(r))}return this}});function fu(n){Fd.call(this),this.type="Path",this.currentPoint=new st,n&&this.setFromPoints(n)}fu.prototype=Object.assign(Object.create(Fd.prototype),{constructor:fu,setFromPoints:function(n){this.moveTo(n[0].x,n[0].y);for(let e=1,t=n.length;e<t;e++)this.lineTo(n[e].x,n[e].y);return this},moveTo:function(n,e){return this.currentPoint.set(n,e),this},lineTo:function(n,e){const t=new Ya(this.currentPoint.clone(),new st(n,e));return this.curves.push(t),this.currentPoint.set(n,e),this},quadraticCurveTo:function(n,e,t,r){const i=new $u(this.currentPoint.clone(),new st(n,e),new st(t,r));return this.curves.push(i),this.currentPoint.set(t,r),this},bezierCurveTo:function(n,e,t,r,i,s){const o=new Mu(this.currentPoint.clone(),new st(n,e),new st(t,r),new st(i,s));return this.curves.push(o),this.currentPoint.set(i,s),this},splineThru:function(n){const e=[this.currentPoint.clone()].concat(n),t=new Ru(e);return this.curves.push(t),this.currentPoint.copy(n[n.length-1]),this},arc:function(n,e,t,r,i,s){const o=this.currentPoint.x,a=this.currentPoint.y;return this.absarc(n+o,e+a,t,r,i,s),this},absarc:function(n,e,t,r,i,s){return this.absellipse(n,e,t,t,r,i,s),this},ellipse:function(n,e,t,r,i,s,o,a){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(n+l,e+c,t,r,i,s,o,a),this},absellipse:function(n,e,t,r,i,s,o,a){const l=new Fl(n,e,t,r,i,s,o,a);if(this.curves.length>0){const u=l.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this},copy:function(n){return Fd.prototype.copy.call(this,n),this.currentPoint.copy(n.currentPoint),this},toJSON:function(){const n=Fd.prototype.toJSON.call(this);return n.currentPoint=this.currentPoint.toArray(),n},fromJSON:function(n){return Fd.prototype.fromJSON.call(this,n),this.currentPoint.fromArray(n.currentPoint),this}});function Kd(n){fu.call(this,n),this.uuid=In.generateUUID(),this.type="Shape",this.holes=[]}Kd.prototype=Object.assign(Object.create(fu.prototype),{constructor:Kd,getPointsHoles:function(n){const e=[];for(let t=0,r=this.holes.length;t<r;t++)e[t]=this.holes[t].getPoints(n);return e},extractPoints:function(n){return{shape:this.getPoints(n),holes:this.getPointsHoles(n)}},copy:function(n){fu.prototype.copy.call(this,n),this.holes=[];for(let e=0,t=n.holes.length;e<t;e++){const r=n.holes[e];this.holes.push(r.clone())}return this},toJSON:function(){const n=fu.prototype.toJSON.call(this);n.uuid=this.uuid,n.holes=[];for(let e=0,t=this.holes.length;e<t;e++){const r=this.holes[e];n.holes.push(r.toJSON())}return n},fromJSON:function(n){fu.prototype.fromJSON.call(this,n),this.uuid=n.uuid,this.holes=[];for(let e=0,t=n.holes.length;e<t;e++){const r=n.holes[e];this.holes.push(new fu().fromJSON(r))}return this}});function hi(n,e=1){rn.call(this),this.type="Light",this.color=new Gt(n),this.intensity=e}hi.prototype=Object.assign(Object.create(rn.prototype),{constructor:hi,isLight:!0,copy:function(n){return rn.prototype.copy.call(this,n),this.color.copy(n.color),this.intensity=n.intensity,this},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}});function KA(n,e,t){hi.call(this,n,t),this.type="HemisphereLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.groundColor=new Gt(e)}KA.prototype=Object.assign(Object.create(hi.prototype),{constructor:KA,isHemisphereLight:!0,copy:function(n){return hi.prototype.copy.call(this,n),this.groundColor.copy(n.groundColor),this}});function Lf(n){this.camera=n,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new st(512,512),this.map=null,this.mapPass=null,this.matrix=new Zn,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new UC,this._frameExtents=new st(1,1),this._viewportCount=1,this._viewports=[new Gr(0,0,1,1)]}Object.assign(Lf.prototype,{_projScreenMatrix:new Zn,_lightPositionWorld:new Q,_lookTarget:new Q,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(n){const e=this.camera,t=this.matrix,r=this._projScreenMatrix,i=this._lookTarget,s=this._lightPositionWorld;s.setFromMatrixPosition(n.matrixWorld),e.position.copy(s),i.setFromMatrixPosition(n.target.matrixWorld),e.lookAt(i),e.updateMatrixWorld(),r.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(r),t.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),t.multiply(e.projectionMatrix),t.multiply(e.matrixWorldInverse)},getViewport:function(n){return this._viewports[n]},getFrameExtents:function(){return this._frameExtents},copy:function(n){return this.camera=n.camera.clone(),this.bias=n.bias,this.radius=n.radius,this.mapSize.copy(n.mapSize),this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const n={};return this.bias!==0&&(n.bias=this.bias),this.normalBias!==0&&(n.normalBias=this.normalBias),this.radius!==1&&(n.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(n.mapSize=this.mapSize.toArray()),n.camera=this.camera.toJSON(!1).object,delete n.camera.matrix,n}});function WF(){Lf.call(this,new _s(50,1,.5,500)),this.focus=1}WF.prototype=Object.assign(Object.create(Lf.prototype),{constructor:WF,isSpotLightShadow:!0,updateMatrices:function(n){const e=this.camera,t=In.RAD2DEG*2*n.angle*this.focus,r=this.mapSize.width/this.mapSize.height,i=n.distance||e.far;(t!==e.fov||r!==e.aspect||i!==e.far)&&(e.fov=t,e.aspect=r,e.far=i,e.updateProjectionMatrix()),Lf.prototype.updateMatrices.call(this,n)}});function YA(n,e,t,r,i,s){hi.call(this,n,e),this.type="SpotLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.target=new rn,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(o){this.intensity=o/Math.PI}}),this.distance=t!==void 0?t:0,this.angle=r!==void 0?r:Math.PI/3,this.penumbra=i!==void 0?i:0,this.decay=s!==void 0?s:1,this.shadow=new WF}YA.prototype=Object.assign(Object.create(hi.prototype),{constructor:YA,isSpotLight:!0,copy:function(n){return hi.prototype.copy.call(this,n),this.distance=n.distance,this.angle=n.angle,this.penumbra=n.penumbra,this.decay=n.decay,this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}});function HF(){Lf.call(this,new _s(90,1,.5,500)),this._frameExtents=new st(4,2),this._viewportCount=6,this._viewports=[new Gr(2,1,1,1),new Gr(0,1,1,1),new Gr(3,1,1,1),new Gr(1,1,1,1),new Gr(3,0,1,1),new Gr(1,0,1,1)],this._cubeDirections=[new Q(1,0,0),new Q(-1,0,0),new Q(0,0,1),new Q(0,0,-1),new Q(0,1,0),new Q(0,-1,0)],this._cubeUps=[new Q(0,1,0),new Q(0,1,0),new Q(0,1,0),new Q(0,1,0),new Q(0,0,1),new Q(0,0,-1)]}HF.prototype=Object.assign(Object.create(Lf.prototype),{constructor:HF,isPointLightShadow:!0,updateMatrices:function(n,e=0){const t=this.camera,r=this.matrix,i=this._lightPositionWorld,s=this._lookTarget,o=this._projScreenMatrix;i.setFromMatrixPosition(n.matrixWorld),t.position.copy(i),s.copy(t.position),s.add(this._cubeDirections[e]),t.up.copy(this._cubeUps[e]),t.lookAt(s),t.updateMatrixWorld(),r.makeTranslation(-i.x,-i.y,-i.z),o.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(o)}});function ZA(n,e,t,r){hi.call(this,n,e),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return this.intensity*4*Math.PI},set:function(i){this.intensity=i/(4*Math.PI)}}),this.distance=t!==void 0?t:0,this.decay=r!==void 0?r:1,this.shadow=new HF}ZA.prototype=Object.assign(Object.create(hi.prototype),{constructor:ZA,isPointLight:!0,copy:function(n){return hi.prototype.copy.call(this,n),this.distance=n.distance,this.decay=n.decay,this.shadow=n.shadow.clone(),this}});function Sv(n=-1,e=1,t=1,r=-1,i=.1,s=2e3){Eh.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=n,this.right=e,this.top=t,this.bottom=r,this.near=i,this.far=s,this.updateProjectionMatrix()}Sv.prototype=Object.assign(Object.create(Eh.prototype),{constructor:Sv,isOrthographicCamera:!0,copy:function(n,e){return Eh.prototype.copy.call(this,n,e),this.left=n.left,this.right=n.right,this.top=n.top,this.bottom=n.bottom,this.near=n.near,this.far=n.far,this.zoom=n.zoom,this.view=n.view===null?null:Object.assign({},n.view),this},setViewOffset:function(n,e,t,r,i,s){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=r,this.view.width=i,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const n=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),t=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let i=t-n,s=t+n,o=r+e,a=r-e;if(this.view!==null&&this.view.enabled){const l=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=l*this.view.offsetX,s=i+l*this.view.width,o-=c*this.view.offsetY,a=o-c*this.view.height}this.projectionMatrix.makeOrthographic(i,s,o,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}});function GF(){Lf.call(this,new Sv(-5,5,5,-5,.5,500))}GF.prototype=Object.assign(Object.create(Lf.prototype),{constructor:GF,isDirectionalLightShadow:!0,updateMatrices:function(n){Lf.prototype.updateMatrices.call(this,n)}});function JA(n,e){hi.call(this,n,e),this.type="DirectionalLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.target=new rn,this.shadow=new GF}JA.prototype=Object.assign(Object.create(hi.prototype),{constructor:JA,isDirectionalLight:!0,copy:function(n){return hi.prototype.copy.call(this,n),this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}});function QA(n,e){hi.call(this,n,e),this.type="AmbientLight"}QA.prototype=Object.assign(Object.create(hi.prototype),{constructor:QA,isAmbientLight:!0});function eM(n,e,t,r){hi.call(this,n,e),this.type="RectAreaLight",this.width=t!==void 0?t:10,this.height=r!==void 0?r:10}eM.prototype=Object.assign(Object.create(hi.prototype),{constructor:eM,isRectAreaLight:!0,copy:function(n){return hi.prototype.copy.call(this,n),this.width=n.width,this.height=n.height,this},toJSON:function(n){const e=hi.prototype.toJSON.call(this,n);return e.object.width=this.width,e.object.height=this.height,e}});class ple{constructor(){Object.defineProperty(this,"isSphericalHarmonics3",{value:!0}),this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new Q)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const r=e.x,i=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*i),t.addScaledVector(o[2],.488603*s),t.addScaledVector(o[3],.488603*r),t.addScaledVector(o[4],1.092548*(r*i)),t.addScaledVector(o[5],1.092548*(i*s)),t.addScaledVector(o[6],.315392*(3*s*s-1)),t.addScaledVector(o[7],1.092548*(r*s)),t.addScaledVector(o[8],.546274*(r*r-i*i)),t}getIrradianceAt(e,t){const r=e.x,i=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*i),t.addScaledVector(o[2],2*.511664*s),t.addScaledVector(o[3],2*.511664*r),t.addScaledVector(o[4],2*.429043*r*i),t.addScaledVector(o[5],2*.429043*i*s),t.addScaledVector(o[6],.743125*s*s-.247708),t.addScaledVector(o[7],2*.429043*r*s),t.addScaledVector(o[8],.429043*(r*r-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let r=0;r<9;r++)this.coefficients[r].addScaledVector(e.coefficients[r],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let r=0;r<9;r++)this.coefficients[r].lerp(e.coefficients[r],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const r=this.coefficients;for(let i=0;i<9;i++)r[i].fromArray(e,t+i*3);return this}toArray(e=[],t=0){const r=this.coefficients;for(let i=0;i<9;i++)r[i].toArray(e,t+i*3);return e}static getBasisAt(e,t){const r=e.x,i=e.y,s=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*s,t[3]=.488603*r,t[4]=1.092548*r*i,t[5]=1.092548*i*s,t[6]=.315392*(3*s*s-1),t[7]=1.092548*r*s,t[8]=.546274*(r*r-i*i)}}function _c(n,e){hi.call(this,void 0,e),this.type="LightProbe",this.sh=n!==void 0?n:new ple}_c.prototype=Object.assign(Object.create(hi.prototype),{constructor:_c,isLightProbe:!0,copy:function(n){return hi.prototype.copy.call(this,n),this.sh.copy(n.sh),this},fromJSON:function(n){return this.intensity=n.intensity,this.sh.fromArray(n.sh),this},toJSON:function(n){const e=hi.prototype.toJSON.call(this,n);return e.object.sh=this.sh.toArray(),e}});function tM(n){zr.call(this,n),this.textures={}}tM.prototype=Object.assign(Object.create(zr.prototype),{constructor:tM,load:function(n,e,t,r){const i=this,s=new $c(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(n,function(o){try{e(i.parse(JSON.parse(o)))}catch(a){r?r(a):console.error(a),i.manager.itemError(n)}},t,r)},parse:function(n){const e=this.textures;function t(i){return e[i]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",i),e[i]}const r=new jyt[n.type];if(n.uuid!==void 0&&(r.uuid=n.uuid),n.name!==void 0&&(r.name=n.name),n.color!==void 0&&r.color!==void 0&&r.color.setHex(n.color),n.roughness!==void 0&&(r.roughness=n.roughness),n.metalness!==void 0&&(r.metalness=n.metalness),n.sheen!==void 0&&(r.sheen=new Gt().setHex(n.sheen)),n.emissive!==void 0&&r.emissive!==void 0&&r.emissive.setHex(n.emissive),n.specular!==void 0&&r.specular!==void 0&&r.specular.setHex(n.specular),n.shininess!==void 0&&(r.shininess=n.shininess),n.clearcoat!==void 0&&(r.clearcoat=n.clearcoat),n.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=n.clearcoatRoughness),n.fog!==void 0&&(r.fog=n.fog),n.flatShading!==void 0&&(r.flatShading=n.flatShading),n.blending!==void 0&&(r.blending=n.blending),n.combine!==void 0&&(r.combine=n.combine),n.side!==void 0&&(r.side=n.side),n.opacity!==void 0&&(r.opacity=n.opacity),n.transparent!==void 0&&(r.transparent=n.transparent),n.alphaTest!==void 0&&(r.alphaTest=n.alphaTest),n.depthTest!==void 0&&(r.depthTest=n.depthTest),n.depthWrite!==void 0&&(r.depthWrite=n.depthWrite),n.colorWrite!==void 0&&(r.colorWrite=n.colorWrite),n.stencilWrite!==void 0&&(r.stencilWrite=n.stencilWrite),n.stencilWriteMask!==void 0&&(r.stencilWriteMask=n.stencilWriteMask),n.stencilFunc!==void 0&&(r.stencilFunc=n.stencilFunc),n.stencilRef!==void 0&&(r.stencilRef=n.stencilRef),n.stencilFuncMask!==void 0&&(r.stencilFuncMask=n.stencilFuncMask),n.stencilFail!==void 0&&(r.stencilFail=n.stencilFail),n.stencilZFail!==void 0&&(r.stencilZFail=n.stencilZFail),n.stencilZPass!==void 0&&(r.stencilZPass=n.stencilZPass),n.wireframe!==void 0&&(r.wireframe=n.wireframe),n.wireframeLinewidth!==void 0&&(r.wireframeLinewidth=n.wireframeLinewidth),n.wireframeLinecap!==void 0&&(r.wireframeLinecap=n.wireframeLinecap),n.wireframeLinejoin!==void 0&&(r.wireframeLinejoin=n.wireframeLinejoin),n.rotation!==void 0&&(r.rotation=n.rotation),n.linewidth!==1&&(r.linewidth=n.linewidth),n.dashSize!==void 0&&(r.dashSize=n.dashSize),n.gapSize!==void 0&&(r.gapSize=n.gapSize),n.scale!==void 0&&(r.scale=n.scale),n.polygonOffset!==void 0&&(r.polygonOffset=n.polygonOffset),n.polygonOffsetFactor!==void 0&&(r.polygonOffsetFactor=n.polygonOffsetFactor),n.polygonOffsetUnits!==void 0&&(r.polygonOffsetUnits=n.polygonOffsetUnits),n.skinning!==void 0&&(r.skinning=n.skinning),n.morphTargets!==void 0&&(r.morphTargets=n.morphTargets),n.morphNormals!==void 0&&(r.morphNormals=n.morphNormals),n.dithering!==void 0&&(r.dithering=n.dithering),n.vertexTangents!==void 0&&(r.vertexTangents=n.vertexTangents),n.visible!==void 0&&(r.visible=n.visible),n.toneMapped!==void 0&&(r.toneMapped=n.toneMapped),n.userData!==void 0&&(r.userData=n.userData),n.vertexColors!==void 0&&(typeof n.vertexColors=="number"?r.vertexColors=n.vertexColors>0:r.vertexColors=n.vertexColors),n.uniforms!==void 0)for(const i in n.uniforms){const s=n.uniforms[i];switch(r.uniforms[i]={},s.type){case"t":r.uniforms[i].value=t(s.value);break;case"c":r.uniforms[i].value=new Gt().setHex(s.value);break;case"v2":r.uniforms[i].value=new st().fromArray(s.value);break;case"v3":r.uniforms[i].value=new Q().fromArray(s.value);break;case"v4":r.uniforms[i].value=new Gr().fromArray(s.value);break;case"m3":r.uniforms[i].value=new kl().fromArray(s.value);break;case"m4":r.uniforms[i].value=new Zn().fromArray(s.value);break;default:r.uniforms[i].value=s.value}}if(n.defines!==void 0&&(r.defines=n.defines),n.vertexShader!==void 0&&(r.vertexShader=n.vertexShader),n.fragmentShader!==void 0&&(r.fragmentShader=n.fragmentShader),n.extensions!==void 0)for(const i in n.extensions)r.extensions[i]=n.extensions[i];if(n.shading!==void 0&&(r.flatShading=n.shading===1),n.size!==void 0&&(r.size=n.size),n.sizeAttenuation!==void 0&&(r.sizeAttenuation=n.sizeAttenuation),n.map!==void 0&&(r.map=t(n.map)),n.matcap!==void 0&&(r.matcap=t(n.matcap)),n.alphaMap!==void 0&&(r.alphaMap=t(n.alphaMap)),n.bumpMap!==void 0&&(r.bumpMap=t(n.bumpMap)),n.bumpScale!==void 0&&(r.bumpScale=n.bumpScale),n.normalMap!==void 0&&(r.normalMap=t(n.normalMap)),n.normalMapType!==void 0&&(r.normalMapType=n.normalMapType),n.normalScale!==void 0){let i=n.normalScale;Array.isArray(i)===!1&&(i=[i,i]),r.normalScale=new st().fromArray(i)}return n.displacementMap!==void 0&&(r.displacementMap=t(n.displacementMap)),n.displacementScale!==void 0&&(r.displacementScale=n.displacementScale),n.displacementBias!==void 0&&(r.displacementBias=n.displacementBias),n.roughnessMap!==void 0&&(r.roughnessMap=t(n.roughnessMap)),n.metalnessMap!==void 0&&(r.metalnessMap=t(n.metalnessMap)),n.emissiveMap!==void 0&&(r.emissiveMap=t(n.emissiveMap)),n.emissiveIntensity!==void 0&&(r.emissiveIntensity=n.emissiveIntensity),n.specularMap!==void 0&&(r.specularMap=t(n.specularMap)),n.envMap!==void 0&&(r.envMap=t(n.envMap)),n.envMapIntensity!==void 0&&(r.envMapIntensity=n.envMapIntensity),n.reflectivity!==void 0&&(r.reflectivity=n.reflectivity),n.refractionRatio!==void 0&&(r.refractionRatio=n.refractionRatio),n.lightMap!==void 0&&(r.lightMap=t(n.lightMap)),n.lightMapIntensity!==void 0&&(r.lightMapIntensity=n.lightMapIntensity),n.aoMap!==void 0&&(r.aoMap=t(n.aoMap)),n.aoMapIntensity!==void 0&&(r.aoMapIntensity=n.aoMapIntensity),n.gradientMap!==void 0&&(r.gradientMap=t(n.gradientMap)),n.clearcoatMap!==void 0&&(r.clearcoatMap=t(n.clearcoatMap)),n.clearcoatRoughnessMap!==void 0&&(r.clearcoatRoughnessMap=t(n.clearcoatRoughnessMap)),n.clearcoatNormalMap!==void 0&&(r.clearcoatNormalMap=t(n.clearcoatNormalMap)),n.clearcoatNormalScale!==void 0&&(r.clearcoatNormalScale=new st().fromArray(n.clearcoatNormalScale)),n.transmission!==void 0&&(r.transmission=n.transmission),n.transmissionMap!==void 0&&(r.transmissionMap=t(n.transmissionMap)),r},setTextures:function(n){return this.textures=n,this}});const lV={decodeText:function(n){if(typeof TextDecoder<"u")return new TextDecoder().decode(n);let e="";for(let t=0,r=n.length;t<r;t++)e+=String.fromCharCode(n[t]);try{return decodeURIComponent(escape(e))}catch{return e}},extractUrlBase:function(n){const e=n.lastIndexOf("/");return e===-1?"./":n.substr(0,e+1)}};function NS(){un.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}NS.prototype=Object.assign(Object.create(un.prototype),{constructor:NS,isInstancedBufferGeometry:!0,copy:function(n){return un.prototype.copy.call(this,n),this.instanceCount=n.instanceCount,this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const n=un.prototype.toJSON.call(this);return n.instanceCount=this.instanceCount,n.isInstancedBufferGeometry=!0,n}});function nM(n,e,t,r){typeof t=="number"&&(r=t,t=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),Cn.call(this,n,e,t),this.meshPerAttribute=r||1}nM.prototype=Object.assign(Object.create(Cn.prototype),{constructor:nM,isInstancedBufferAttribute:!0,copy:function(n){return Cn.prototype.copy.call(this,n),this.meshPerAttribute=n.meshPerAttribute,this},toJSON:function(){const n=Cn.prototype.toJSON.call(this);return n.meshPerAttribute=this.meshPerAttribute,n.isInstancedBufferAttribute=!0,n}});function rM(n){zr.call(this,n)}rM.prototype=Object.assign(Object.create(zr.prototype),{constructor:rM,load:function(n,e,t,r){const i=this,s=new $c(i.manager);s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(n,function(o){try{e(i.parse(JSON.parse(o)))}catch(a){r?r(a):console.error(a),i.manager.itemError(n)}},t,r)},parse:function(n){const e={},t={};function r(f,d){if(e[d]!==void 0)return e[d];const m=f.interleavedBuffers[d],g=i(f,m.buffer),y=$1(m.type,g),b=new Tl(y,m.stride);return b.uuid=m.uuid,e[d]=b,b}function i(f,d){if(t[d]!==void 0)return t[d];const m=f.arrayBuffers[d],g=new Uint32Array(m).buffer;return t[d]=g,g}const s=n.isInstancedBufferGeometry?new NS:new un,o=n.data.index;if(o!==void 0){const f=$1(o.type,o.array);s.setIndex(new Cn(f,1))}const a=n.data.attributes;for(const f in a){const d=a[f];let p;if(d.isInterleavedBufferAttribute){const m=r(n.data,d.data);p=new pp(m,d.itemSize,d.offset,d.normalized)}else{const m=$1(d.type,d.array),g=d.isInstancedBufferAttribute?nM:Cn;p=new g(m,d.itemSize,d.normalized)}d.name!==void 0&&(p.name=d.name),s.setAttribute(f,p)}const l=n.data.morphAttributes;if(l)for(const f in l){const d=l[f],p=[];for(let m=0,g=d.length;m<g;m++){const y=d[m];let b;if(y.isInterleavedBufferAttribute){const _=r(n.data,y.data);b=new pp(_,y.itemSize,y.offset,y.normalized)}else{const _=$1(y.type,y.array);b=new Cn(_,y.itemSize,y.normalized)}y.name!==void 0&&(b.name=y.name),p.push(b)}s.morphAttributes[f]=p}n.data.morphTargetsRelative&&(s.morphTargetsRelative=!0);const u=n.data.groups||n.data.drawcalls||n.data.offsets;if(u!==void 0)for(let f=0,d=u.length;f!==d;++f){const p=u[f];s.addGroup(p.start,p.count,p.materialIndex)}const h=n.data.boundingSphere;if(h!==void 0){const f=new Q;h.center!==void 0&&f.fromArray(h.center),s.boundingSphere=new Op(f,h.radius)}return n.name&&(s.name=n.name),n.userData&&(s.userData=n.userData),s}});class n0t extends zr{constructor(e){super(e)}load(e,t,r,i){const s=this,o=this.path===""?lV.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new $c(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){let c=null;try{c=JSON.parse(l)}catch(h){i!==void 0&&i(h),console.error("THREE:ObjectLoader: Can't parse "+e+".",h.message);return}const u=c.metadata;if(u===void 0||u.type===void 0||u.type.toLowerCase()==="geometry"){console.error("THREE.ObjectLoader: Can't load "+e);return}s.parse(c,t)},r,i)}parse(e,t){const r=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),s=this.parseGeometries(e.geometries,i),o=this.parseImages(e.images,function(){t!==void 0&&t(c)}),a=this.parseTextures(e.textures,o),l=this.parseMaterials(e.materials,a),c=this.parseObject(e.object,s,l,r),u=this.parseSkeletons(e.skeletons,c);if(this.bindSkeletons(c,u),t!==void 0){let h=!1;for(const f in o)if(o[f]instanceof HTMLImageElement){h=!0;break}h===!1&&t(c)}return c}parseShapes(e){const t={};if(e!==void 0)for(let r=0,i=e.length;r<i;r++){const s=new Kd().fromJSON(e[r]);t[s.uuid]=s}return t}parseSkeletons(e,t){const r={},i={};if(t.traverse(function(s){s.isBone&&(i[s.uuid]=s)}),e!==void 0)for(let s=0,o=e.length;s<o;s++){const a=new wS().fromJSON(e[s],i);r[a.uuid]=a}return r}parseGeometries(e,t){const r={};let i;if(e!==void 0){const s=new rM;for(let o=0,a=e.length;o<a;o++){let l;const c=e[o];switch(c.type){case"PlaneGeometry":case"PlaneBufferGeometry":l=new ua[c.type](c.width,c.height,c.widthSegments,c.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":l=new ua[c.type](c.width,c.height,c.depth,c.widthSegments,c.heightSegments,c.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":l=new ua[c.type](c.radius,c.segments,c.thetaStart,c.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":l=new ua[c.type](c.radiusTop,c.radiusBottom,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":l=new ua[c.type](c.radius,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":l=new ua[c.type](c.radius,c.widthSegments,c.heightSegments,c.phiStart,c.phiLength,c.thetaStart,c.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":l=new ua[c.type](c.radius,c.detail);break;case"RingGeometry":case"RingBufferGeometry":l=new ua[c.type](c.innerRadius,c.outerRadius,c.thetaSegments,c.phiSegments,c.thetaStart,c.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":l=new ua[c.type](c.radius,c.tube,c.radialSegments,c.tubularSegments,c.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":l=new ua[c.type](c.radius,c.tube,c.tubularSegments,c.radialSegments,c.p,c.q);break;case"TubeGeometry":case"TubeBufferGeometry":l=new ua[c.type](new UF[c.path.type]().fromJSON(c.path),c.tubularSegments,c.radius,c.radialSegments,c.closed);break;case"LatheGeometry":case"LatheBufferGeometry":l=new ua[c.type](c.points,c.segments,c.phiStart,c.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":l=new ua[c.type](c.vertices,c.indices,c.radius,c.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":i=[];for(let h=0,f=c.shapes.length;h<f;h++){const d=t[c.shapes[h]];i.push(d)}l=new ua[c.type](i,c.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":i=[];for(let h=0,f=c.shapes.length;h<f;h++){const d=t[c.shapes[h]];i.push(d)}const u=c.options.extrudePath;u!==void 0&&(c.options.extrudePath=new UF[u.type]().fromJSON(u)),l=new ua[c.type](i,c.options);break;case"BufferGeometry":case"InstancedBufferGeometry":l=s.parse(c);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+c.type+'"');continue}l.uuid=c.uuid,c.name!==void 0&&(l.name=c.name),l.isBufferGeometry===!0&&c.userData!==void 0&&(l.userData=c.userData),r[c.uuid]=l}}return r}parseMaterials(e,t){const r={},i={};if(e!==void 0){const s=new tM;s.setTextures(t);for(let o=0,a=e.length;o<a;o++){const l=e[o];if(l.type==="MultiMaterial"){const c=[];for(let u=0;u<l.materials.length;u++){const h=l.materials[u];r[h.uuid]===void 0&&(r[h.uuid]=s.parse(h)),c.push(r[h.uuid])}i[l.uuid]=c}else r[l.uuid]===void 0&&(r[l.uuid]=s.parse(l)),i[l.uuid]=r[l.uuid]}}return i}parseAnimations(e){const t={};if(e!==void 0)for(let r=0;r<e.length;r++){const i=e[r],s=Sl.parse(i);t[s.uuid]=s}return t}parseImages(e,t){const r=this,i={};let s;function o(l){return r.manager.itemStart(l),s.load(l,function(){r.manager.itemEnd(l)},void 0,function(){r.manager.itemError(l),r.manager.itemEnd(l)})}function a(l){if(typeof l=="string"){const c=l,u=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:r.resourcePath+c;return o(u)}else return l.data?{data:$1(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new oV(t);s=new xv(l),s.setCrossOrigin(this.crossOrigin);for(let c=0,u=e.length;c<u;c++){const h=e[c],f=h.url;if(Array.isArray(f)){i[h.uuid]=[];for(let d=0,p=f.length;d<p;d++){const m=f[d],g=a(m);g!==null&&(g instanceof HTMLImageElement?i[h.uuid].push(g):i[h.uuid].push(new Of(g.data,g.width,g.height)))}}else{const d=a(h.url);d!==null&&(i[h.uuid]=d)}}}return i}parseTextures(e,t){function r(s,o){return typeof s=="number"?s:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",s),o[s])}const i={};if(e!==void 0)for(let s=0,o=e.length;s<o;s++){const a=e[s];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);let l;const c=t[a.image];Array.isArray(c)?(l=new Ih(c),c.length===6&&(l.needsUpdate=!0)):(c&&c.data?l=new Of(c.data,c.width,c.height):l=new Kr(c),c&&(l.needsUpdate=!0)),l.uuid=a.uuid,a.name!==void 0&&(l.name=a.name),a.mapping!==void 0&&(l.mapping=r(a.mapping,r0t)),a.offset!==void 0&&l.offset.fromArray(a.offset),a.repeat!==void 0&&l.repeat.fromArray(a.repeat),a.center!==void 0&&l.center.fromArray(a.center),a.rotation!==void 0&&(l.rotation=a.rotation),a.wrap!==void 0&&(l.wrapS=r(a.wrap[0],V8),l.wrapT=r(a.wrap[1],V8)),a.format!==void 0&&(l.format=a.format),a.type!==void 0&&(l.type=a.type),a.encoding!==void 0&&(l.encoding=a.encoding),a.minFilter!==void 0&&(l.minFilter=r(a.minFilter,U8)),a.magFilter!==void 0&&(l.magFilter=r(a.magFilter,U8)),a.anisotropy!==void 0&&(l.anisotropy=a.anisotropy),a.flipY!==void 0&&(l.flipY=a.flipY),a.premultiplyAlpha!==void 0&&(l.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(l.unpackAlignment=a.unpackAlignment),i[a.uuid]=l}return i}parseObject(e,t,r,i){let s;function o(u){return t[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",u),t[u]}function a(u){if(u!==void 0){if(Array.isArray(u)){const h=[];for(let f=0,d=u.length;f<d;f++){const p=u[f];r[p]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",p),h.push(r[p])}return h}return r[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",u),r[u]}}let l,c;switch(e.type){case"Scene":s=new rV,e.background!==void 0&&Number.isInteger(e.background)&&(s.background=new Gt(e.background)),e.fog!==void 0&&(e.fog.type==="Fog"?s.fog=new $$(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(s.fog=new N$(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":s=new _s(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(s.focus=e.focus),e.zoom!==void 0&&(s.zoom=e.zoom),e.filmGauge!==void 0&&(s.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(s.filmOffset=e.filmOffset),e.view!==void 0&&(s.view=Object.assign({},e.view));break;case"OrthographicCamera":s=new Sv(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(s.zoom=e.zoom),e.view!==void 0&&(s.view=Object.assign({},e.view));break;case"AmbientLight":s=new QA(e.color,e.intensity);break;case"DirectionalLight":s=new JA(e.color,e.intensity);break;case"PointLight":s=new ZA(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":s=new eM(e.color,e.intensity,e.width,e.height);break;case"SpotLight":s=new YA(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":s=new KA(e.color,e.groundColor,e.intensity);break;case"LightProbe":s=new _c().fromJSON(e);break;case"SkinnedMesh":l=o(e.geometry),c=a(e.material),s=new bS(l,c),e.bindMode!==void 0&&(s.bindMode=e.bindMode),e.bindMatrix!==void 0&&s.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(s.skeleton=e.skeleton);break;case"Mesh":l=o(e.geometry),c=a(e.material),s=new ui(l,c);break;case"InstancedMesh":l=o(e.geometry),c=a(e.material);const u=e.count,h=e.instanceMatrix;s=new EA(l,c,u),s.instanceMatrix=new Cn(new Float32Array(h.array),16);break;case"LOD":s=new yS;break;case"Line":s=new Nc(o(e.geometry),a(e.material));break;case"LineLoop":s=new IA(o(e.geometry),a(e.material));break;case"LineSegments":s=new Ea(o(e.geometry),a(e.material));break;case"PointCloud":case"Points":s=new gv(o(e.geometry),a(e.material));break;case"Sprite":s=new gS(a(e.material));break;case"Group":s=new Od;break;case"Bone":s=new vS;break;default:s=new rn}if(s.uuid=e.uuid,e.name!==void 0&&(s.name=e.name),e.matrix!==void 0?(s.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(s.matrixAutoUpdate=e.matrixAutoUpdate),s.matrixAutoUpdate&&s.matrix.decompose(s.position,s.quaternion,s.scale)):(e.position!==void 0&&s.position.fromArray(e.position),e.rotation!==void 0&&s.rotation.fromArray(e.rotation),e.quaternion!==void 0&&s.quaternion.fromArray(e.quaternion),e.scale!==void 0&&s.scale.fromArray(e.scale)),e.castShadow!==void 0&&(s.castShadow=e.castShadow),e.receiveShadow!==void 0&&(s.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(s.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(s.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(s.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&s.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(s.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(s.visible=e.visible),e.frustumCulled!==void 0&&(s.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(s.renderOrder=e.renderOrder),e.userData!==void 0&&(s.userData=e.userData),e.layers!==void 0&&(s.layers.mask=e.layers),e.children!==void 0){const u=e.children;for(let h=0;h<u.length;h++)s.add(this.parseObject(u[h],t,r,i))}if(e.animations!==void 0){const u=e.animations;for(let h=0;h<u.length;h++){const f=u[h];s.animations.push(i[f])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(s.autoUpdate=e.autoUpdate);const u=e.levels;for(let h=0;h<u.length;h++){const f=u[h],d=s.getObjectByProperty("uuid",f.object);d!==void 0&&s.addLevel(d,f.distance)}}return s}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(r){if(r.isSkinnedMesh===!0&&r.skeleton!==void 0){const i=t[r.skeleton];i===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",r.skeleton):r.bind(i,r.bindMatrix)}})}setTexturePath(e){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(e)}}const r0t={UVMapping:E$,CubeReflectionMapping:FC,CubeRefractionMapping:LC,EquirectangularReflectionMapping:_A,EquirectangularRefractionMapping:SA,CubeUVReflectionMapping:rx,CubeUVRefractionMapping:zC},V8={RepeatWrapping:nS,ClampToEdgeWrapping:ma,MirroredRepeatWrapping:rS},U8={NearestFilter:Us,NearestMipmapNearestFilter:CA,NearestMipmapLinearFilter:kA,LinearFilter:lo,LinearMipmapNearestFilter:K4,LinearMipmapLinearFilter:ix};function jF(n){typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),zr.call(this,n),this.options={premultiplyAlpha:"none"}}jF.prototype=Object.assign(Object.create(zr.prototype),{constructor:jF,isImageBitmapLoader:!0,setOptions:function(e){return this.options=e,this},load:function(n,e,t,r){n===void 0&&(n=""),this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const i=this,s=Mg.get(n);if(s!==void 0)return i.manager.itemStart(n),setTimeout(function(){e&&e(s),i.manager.itemEnd(n)},0),s;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",fetch(n,o).then(function(a){return a.blob()}).then(function(a){return createImageBitmap(a,i.options)}).then(function(a){Mg.add(n,a),e&&e(a),i.manager.itemEnd(n)}).catch(function(a){r&&r(a),i.manager.itemError(n),i.manager.itemEnd(n)}),i.manager.itemStart(n)}});function cV(){this.type="ShapePath",this.color=new Gt,this.subPaths=[],this.currentPath=null}Object.assign(cV.prototype,{moveTo:function(n,e){return this.currentPath=new fu,this.subPaths.push(this.currentPath),this.currentPath.moveTo(n,e),this},lineTo:function(n,e){return this.currentPath.lineTo(n,e),this},quadraticCurveTo:function(n,e,t,r){return this.currentPath.quadraticCurveTo(n,e,t,r),this},bezierCurveTo:function(n,e,t,r,i,s){return this.currentPath.bezierCurveTo(n,e,t,r,i,s),this},splineThru:function(n){return this.currentPath.splineThru(n),this},toShapes:function(n,e){function t(y){const b=[];for(let _=0,w=y.length;_<w;_++){const S=y[_],C=new Kd;C.curves=S.curves,b.push(C)}return b}function r(y,b){const _=b.length;let w=!1;for(let S=_-1,C=0;C<_;S=C++){let k=b[S],A=b[C],M=A.x-k.x,E=A.y-k.y;if(Math.abs(E)>Number.EPSILON){if(E<0&&(k=b[C],M=-M,A=b[S],E=-E),y.y<k.y||y.y>A.y)continue;if(y.y===k.y){if(y.x===k.x)return!0}else{const N=E*(y.x-k.x)-M*(y.y-k.y);if(N===0)return!0;if(N<0)continue;w=!w}}else{if(y.y!==k.y)continue;if(A.x<=y.x&&y.x<=k.x||k.x<=y.x&&y.x<=A.x)return!0}}return w}const i=Nf.isClockWise,s=this.subPaths;if(s.length===0)return[];if(e===!0)return t(s);let o,a,l;const c=[];if(s.length===1)return a=s[0],l=new Kd,l.curves=a.curves,c.push(l),c;let u=!i(s[0].getPoints());u=n?!u:u;const h=[],f=[];let d=[],p=0,m;f[p]=void 0,d[p]=[];for(let y=0,b=s.length;y<b;y++)a=s[y],m=a.getPoints(),o=i(m),o=n?!o:o,o?(!u&&f[p]&&p++,f[p]={s:new Kd,p:m},f[p].s.curves=a.curves,u&&p++,d[p]=[]):d[p].push({h:a,p:m[0]});if(!f[0])return t(s);if(f.length>1){let y=!1;const b=[];for(let _=0,w=f.length;_<w;_++)h[_]=[];for(let _=0,w=f.length;_<w;_++){const S=d[_];for(let C=0;C<S.length;C++){const k=S[C];let A=!0;for(let M=0;M<f.length;M++)r(k.p,f[M].p)&&(_!==M&&b.push({froms:_,tos:M,hole:C}),A?(A=!1,h[M].push(k)):y=!0);A&&h[_].push(k)}}b.length>0&&(y||(d=h))}let g;for(let y=0,b=f.length;y<b;y++){l=f[y].s,c.push(l),g=d[y];for(let _=0,w=g.length;_<w;_++)l.holes.push(g[_].h)}return c}});class mle{constructor(e){Object.defineProperty(this,"isFont",{value:!0}),this.type="Font",this.data=e}generateShapes(e,t=100){const r=[],i=i0t(e,t,this.data);for(let s=0,o=i.length;s<o;s++)Array.prototype.push.apply(r,i[s].toShapes());return r}}function i0t(n,e,t){const r=Array.from?Array.from(n):String(n).split(""),i=e/t.resolution,s=(t.boundingBox.yMax-t.boundingBox.yMin+t.underlineThickness)*i,o=[];let a=0,l=0;for(let c=0;c<r.length;c++){const u=r[c];if(u===`
`)a=0,l-=s;else{const h=s0t(u,i,a,l,t);a+=h.offsetX,o.push(h.path)}}return o}function s0t(n,e,t,r,i){const s=i.glyphs[n]||i.glyphs["?"];if(!s){console.error('THREE.Font: character "'+n+'" does not exists in font family '+i.familyName+".");return}const o=new cV;let a,l,c,u,h,f,d,p;if(s.o){const m=s._cachedOutline||(s._cachedOutline=s.o.split(" "));for(let g=0,y=m.length;g<y;)switch(m[g++]){case"m":a=m[g++]*e+t,l=m[g++]*e+r,o.moveTo(a,l);break;case"l":a=m[g++]*e+t,l=m[g++]*e+r,o.lineTo(a,l);break;case"q":c=m[g++]*e+t,u=m[g++]*e+r,h=m[g++]*e+t,f=m[g++]*e+r,o.quadraticCurveTo(h,f,c,u);break;case"b":c=m[g++]*e+t,u=m[g++]*e+r,h=m[g++]*e+t,f=m[g++]*e+r,d=m[g++]*e+t,p=m[g++]*e+r,o.bezierCurveTo(h,f,d,p,c,u);break}}return{offsetX:s.ha*e,path:o}}function qF(n){zr.call(this,n)}qF.prototype=Object.assign(Object.create(zr.prototype),{constructor:qF,load:function(n,e,t,r){const i=this,s=new $c(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(i.withCredentials),s.load(n,function(o){let a;try{a=JSON.parse(o)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),a=JSON.parse(o.substring(65,o.length-2))}const l=i.parse(a);e&&e(l)},t,r)},parse:function(n){return new mle(n)}});let hE;const uV={getContext:function(){return hE===void 0&&(hE=new(window.AudioContext||window.webkitAudioContext)),hE},setContext:function(n){hE=n}};function iM(n){zr.call(this,n)}iM.prototype=Object.assign(Object.create(zr.prototype),{constructor:iM,load:function(n,e,t,r){const i=this,s=new $c(i.manager);s.setResponseType("arraybuffer"),s.setPath(i.path),s.setRequestHeader(i.requestHeader),s.setWithCredentials(i.withCredentials),s.load(n,function(o){try{const a=o.slice(0);uV.getContext().decodeAudioData(a,function(c){e(c)})}catch(a){r?r(a):console.error(a),i.manager.itemError(n)}},t,r)}});function XF(n,e,t){_c.call(this,void 0,t);const r=new Gt().set(n),i=new Gt().set(e),s=new Q(r.r,r.g,r.b),o=new Q(i.r,i.g,i.b),a=Math.sqrt(Math.PI),l=a*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)}XF.prototype=Object.assign(Object.create(_c.prototype),{constructor:XF,isHemisphereLightProbe:!0,copy:function(n){return _c.prototype.copy.call(this,n),this},toJSON:function(n){return _c.prototype.toJSON.call(this,n)}});function KF(n,e){_c.call(this,void 0,e);const t=new Gt().set(n);this.sh.coefficients[0].set(t.r,t.g,t.b).multiplyScalar(2*Math.sqrt(Math.PI))}KF.prototype=Object.assign(Object.create(_c.prototype),{constructor:KF,isAmbientLightProbe:!0,copy:function(n){return _c.prototype.copy.call(this,n),this},toJSON:function(n){return _c.prototype.toJSON.call(this,n)}});const W8=new Zn,H8=new Zn;function gle(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new _s,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new _s,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}Object.assign(gle.prototype,{update:function(n){const e=this._cache;if(e.focus!==n.focus||e.fov!==n.fov||e.aspect!==n.aspect*this.aspect||e.near!==n.near||e.far!==n.far||e.zoom!==n.zoom||e.eyeSep!==this.eyeSep){e.focus=n.focus,e.fov=n.fov,e.aspect=n.aspect*this.aspect,e.near=n.near,e.far=n.far,e.zoom=n.zoom,e.eyeSep=this.eyeSep;const r=n.projectionMatrix.clone(),i=e.eyeSep/2,s=i*e.near/e.focus,o=e.near*Math.tan(In.DEG2RAD*e.fov*.5)/e.zoom;let a,l;H8.elements[12]=-i,W8.elements[12]=i,a=-o*e.aspect+s,l=o*e.aspect+s,r.elements[0]=2*e.near/(l-a),r.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(r),a=-o*e.aspect-s,l=o*e.aspect-s,r.elements[0]=2*e.near/(l-a),r.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(r)}this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(H8),this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(W8)}});class yle{constructor(e){this.autoStart=e!==void 0?e:!0,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=G8(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=G8();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function G8(){return(typeof performance>"u"?Date:performance).now()}const hm=new Q,j8=new co,o0t=new Q,fm=new Q;class a0t extends rn{constructor(){super(),this.type="AudioListener",this.context=uV.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new yle}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,r=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(hm,j8,o0t),fm.set(0,0,-1).applyQuaternion(j8),t.positionX){const i=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(hm.x,i),t.positionY.linearRampToValueAtTime(hm.y,i),t.positionZ.linearRampToValueAtTime(hm.z,i),t.forwardX.linearRampToValueAtTime(fm.x,i),t.forwardY.linearRampToValueAtTime(fm.y,i),t.forwardZ.linearRampToValueAtTime(fm.z,i),t.upX.linearRampToValueAtTime(r.x,i),t.upY.linearRampToValueAtTime(r.y,i),t.upZ.linearRampToValueAtTime(r.z,i)}else t.setPosition(hm.x,hm.y,hm.z),t.setOrientation(fm.x,fm.y,fm.z,r.x,r.y,r.z)}}class hV extends rn{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const dm=new Q,q8=new co,l0t=new Q,pm=new Q;class c0t extends hV{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,r){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=r,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(dm,q8,l0t),pm.set(0,0,1).applyQuaternion(q8);const t=this.panner;if(t.positionX){const r=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(dm.x,r),t.positionY.linearRampToValueAtTime(dm.y,r),t.positionZ.linearRampToValueAtTime(dm.z,r),t.orientationX.linearRampToValueAtTime(pm.x,r),t.orientationY.linearRampToValueAtTime(pm.y,r),t.orientationZ.linearRampToValueAtTime(pm.z,r)}else t.setPosition(dm.x,dm.y,dm.z),t.setOrientation(pm.x,pm.y,pm.z)}}class ble{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let r=0;r<t.length;r++)e+=t[r];return e/t.length}}function fV(n,e,t){this.binding=n,this.valueSize=t;let r,i,s;switch(e){case"quaternion":r=this._slerp,i=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(t*6),this._workIndex=5;break;case"string":case"bool":r=this._select,i=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(t*5);break;default:r=this._lerp,i=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(t*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=i,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign(fV.prototype,{accumulate:function(n,e){const t=this.buffer,r=this.valueSize,i=n*r+r;let s=this.cumulativeWeight;if(s===0){for(let o=0;o!==r;++o)t[i+o]=t[o];s=e}else{s+=e;const o=e/s;this._mixBufferRegion(t,i,0,o,r)}this.cumulativeWeight=s},accumulateAdditive:function(n){const e=this.buffer,t=this.valueSize,r=t*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,r,0,n,t),this.cumulativeWeightAdditive+=n},apply:function(n){const e=this.valueSize,t=this.buffer,r=n*e+e,i=this.cumulativeWeight,s=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,i<1){const a=e*this._origIndex;this._mixBufferRegion(t,r,a,1-i,e)}s>0&&this._mixBufferRegionAdditive(t,r,this._addIndex*e,1,e);for(let a=e,l=e+e;a!==l;++a)if(t[a]!==t[a+e]){o.setValue(t,r);break}},saveOriginalState:function(){const n=this.binding,e=this.buffer,t=this.valueSize,r=t*this._origIndex;n.getValue(e,r);for(let i=t,s=r;i!==s;++i)e[i]=e[r+i%t];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){const n=this.valueSize*3;this.binding.setValue(this.buffer,n)},_setAdditiveIdentityNumeric:function(){const n=this._addIndex*this.valueSize,e=n+this.valueSize;for(let t=n;t<e;t++)this.buffer[t]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1},_setAdditiveIdentityOther:function(){const n=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let t=0;t<this.valueSize;t++)this.buffer[e+t]=this.buffer[n+t]},_select:function(n,e,t,r,i){if(r>=.5)for(let s=0;s!==i;++s)n[e+s]=n[t+s]},_slerp:function(n,e,t,r){co.slerpFlat(n,e,n,e,n,t,r)},_slerpAdditive:function(n,e,t,r,i){const s=this._workIndex*i;co.multiplyQuaternionsFlat(n,s,n,e,n,t),co.slerpFlat(n,e,n,e,n,s,r)},_lerp:function(n,e,t,r,i){const s=1-r;for(let o=0;o!==i;++o){const a=e+o;n[a]=n[a]*s+n[t+o]*r}},_lerpAdditive:function(n,e,t,r,i){for(let s=0;s!==i;++s){const o=e+s;n[o]=n[o]+n[t+s]*r}}});const dV="\\[\\]\\.:\\/",u0t=new RegExp("["+dV+"]","g"),pV="[^"+dV+"]",h0t="[^"+dV.replace("\\.","")+"]",f0t=/((?:WC+[\/:])*)/.source.replace("WC",pV),d0t=/(WCOD+)?/.source.replace("WCOD",h0t),p0t=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",pV),m0t=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",pV),g0t=new RegExp("^"+f0t+d0t+p0t+m0t+"$"),y0t=["material","materials","bones"];function vle(n,e,t){const r=t||Zo.parseTrackName(e);this._targetGroup=n,this._bindings=n.subscribe_(e,r)}Object.assign(vle.prototype,{getValue:function(n,e){this.bind();const t=this._targetGroup.nCachedObjects_,r=this._bindings[t];r!==void 0&&r.getValue(n,e)},setValue:function(n,e){const t=this._bindings;for(let r=this._targetGroup.nCachedObjects_,i=t.length;r!==i;++r)t[r].setValue(n,e)},bind:function(){const n=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].bind()},unbind:function(){const n=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].unbind()}});function Zo(n,e,t){this.path=e,this.parsedPath=t||Zo.parseTrackName(e),this.node=Zo.findNode(n,this.parsedPath.nodeName)||n,this.rootNode=n}Object.assign(Zo,{Composite:vle,create:function(n,e,t){return n&&n.isAnimationObjectGroup?new Zo.Composite(n,e,t):new Zo(n,e,t)},sanitizeNodeName:function(n){return n.replace(/\s/g,"_").replace(u0t,"")},parseTrackName:function(n){const e=g0t.exec(n);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+n);const t={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},r=t.nodeName&&t.nodeName.lastIndexOf(".");if(r!==void 0&&r!==-1){const i=t.nodeName.substring(r+1);y0t.indexOf(i)!==-1&&(t.nodeName=t.nodeName.substring(0,r),t.objectName=i)}if(t.propertyName===null||t.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+n);return t},findNode:function(n,e){if(!e||e===""||e==="."||e===-1||e===n.name||e===n.uuid)return n;if(n.skeleton){const t=n.skeleton.getBoneByName(e);if(t!==void 0)return t}if(n.children){const t=function(i){for(let s=0;s<i.length;s++){const o=i[s];if(o.name===e||o.uuid===e)return o;const a=t(o.children);if(a)return a}return null},r=t(n.children);if(r)return r}return null}});Object.assign(Zo.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(e,t){e[t]=this.node[this.propertyName]},function(e,t){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)e[t++]=r[i]},function(e,t){e[t]=this.resolvedProperty[this.propertyIndex]},function(e,t){this.resolvedProperty.toArray(e,t)}],SetterByBindingTypeAndVersioning:[[function(e,t){this.targetObject[this.propertyName]=e[t]},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)r[i]=e[t++]},function(e,t){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)r[i]=e[t++];this.targetObject.needsUpdate=!0},function(e,t){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)r[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty[this.propertyIndex]=e[t]},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty.fromArray(e,t)},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(e,t){this.bind(),this.getValue(e,t)},setValue:function(e,t){this.bind(),this.setValue(e,t)},bind:function(){let n=this.node;const e=this.parsedPath,t=e.objectName,r=e.propertyName;let i=e.propertyIndex;if(n||(n=Zo.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=n),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!n){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(t){let l=e.objectIndex;switch(t){case"materials":if(!n.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!n.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}n=n.material.materials;break;case"bones":if(!n.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}n=n.skeleton.bones;for(let c=0;c<n.length;c++)if(n[c].name===l){l=c;break}break;default:if(n[t]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}n=n[t]}if(l!==void 0){if(n[l]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,n);return}n=n[l]}}const s=n[r];if(s===void 0){const l=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+l+"."+r+" but it wasn't found.",n);return}let o=this.Versioning.None;this.targetObject=n,n.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:n.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(i!==void 0){if(r==="morphTargetInfluences"){if(!n.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(n.geometry.isBufferGeometry){if(!n.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}n.morphTargetDictionary[i]!==void 0&&(i=n.morphTargetDictionary[i])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}a=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=i}else s.fromArray!==void 0&&s.toArray!==void 0?(a=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(a=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=r;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}});Object.assign(Zo.prototype,{_getValue_unbound:Zo.prototype.getValue,_setValue_unbound:Zo.prototype.setValue});function wle(){this.uuid=In.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const n={};this._indicesByUUID=n;for(let t=0,r=arguments.length;t!==r;++t)n[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}Object.assign(wle.prototype,{isAnimationObjectGroup:!0,add:function(){const n=this._objects,e=this._indicesByUUID,t=this._paths,r=this._parsedPaths,i=this._bindings,s=i.length;let o,a=n.length,l=this.nCachedObjects_;for(let c=0,u=arguments.length;c!==u;++c){const h=arguments[c],f=h.uuid;let d=e[f];if(d===void 0){d=a++,e[f]=d,n.push(h);for(let p=0,m=s;p!==m;++p)i[p].push(new Zo(h,t[p],r[p]))}else if(d<l){o=n[d];const p=--l,m=n[p];e[m.uuid]=d,n[d]=m,e[f]=p,n[p]=h;for(let g=0,y=s;g!==y;++g){const b=i[g],_=b[p];let w=b[d];b[d]=_,w===void 0&&(w=new Zo(h,t[g],r[g])),b[p]=w}}else n[d]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l},remove:function(){const n=this._objects,e=this._indicesByUUID,t=this._bindings,r=t.length;let i=this.nCachedObjects_;for(let s=0,o=arguments.length;s!==o;++s){const a=arguments[s],l=a.uuid,c=e[l];if(c!==void 0&&c>=i){const u=i++,h=n[u];e[h.uuid]=c,n[c]=h,e[l]=u,n[u]=a;for(let f=0,d=r;f!==d;++f){const p=t[f],m=p[u],g=p[c];p[c]=m,p[u]=g}}}this.nCachedObjects_=i},uncache:function(){const n=this._objects,e=this._indicesByUUID,t=this._bindings,r=t.length;let i=this.nCachedObjects_,s=n.length;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],c=l.uuid,u=e[c];if(u!==void 0)if(delete e[c],u<i){const h=--i,f=n[h],d=--s,p=n[d];e[f.uuid]=u,n[u]=f,e[p.uuid]=h,n[h]=p,n.pop();for(let m=0,g=r;m!==g;++m){const y=t[m],b=y[h],_=y[d];y[u]=b,y[h]=_,y.pop()}}else{const h=--s,f=n[h];h>0&&(e[f.uuid]=u),n[u]=f,n.pop();for(let d=0,p=r;d!==p;++d){const m=t[d];m[u]=m[h],m.pop()}}}this.nCachedObjects_=i},subscribe_:function(n,e){const t=this._bindingsIndicesByPath;let r=t[n];const i=this._bindings;if(r!==void 0)return i[r];const s=this._paths,o=this._parsedPaths,a=this._objects,l=a.length,c=this.nCachedObjects_,u=new Array(l);r=i.length,t[n]=r,s.push(n),o.push(e),i.push(u);for(let h=c,f=a.length;h!==f;++h){const d=a[h];u[h]=new Zo(d,n,e)}return u},unsubscribe_:function(n){const e=this._bindingsIndicesByPath,t=e[n];if(t!==void 0){const r=this._paths,i=this._parsedPaths,s=this._bindings,o=s.length-1,a=s[o],l=n[o];e[l]=t,s[t]=a,s.pop(),i[t]=i[o],i.pop(),r[t]=r[o],r.pop()}}});class b0t{constructor(e,t,r=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=r,this.blendMode=i;const s=t.tracks,o=s.length,a=new Array(o),l={endingStart:Vm,endingEnd:Vm};for(let c=0;c!==o;++c){const u=s[c].createInterpolant(null);a[c]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Vae,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,r){if(e.fadeOut(t),this.fadeIn(t),r){const i=this._clip.duration,s=e._clip.duration,o=s/i,a=i/s;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,r){return e.crossFadeFrom(this,t,r)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,r){const i=this._mixer,s=i.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=i._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=s,l[1]=s+r,c[0]=e/o,c[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,r,i){if(!this.enabled){this._updateWeight(e);return}const s=this._startTime;if(s!==null){const l=(e-s)*r;if(l<0||r===0)return;this._startTime=null,t=r*l}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case Y4:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulateAdditive(a);break;case I$:default:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulate(i,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const r=this._weightInterpolant;if(r!==null){const i=r.evaluate(e)[0];t*=i,e>r.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const r=this._timeScaleInterpolant;if(r!==null){const i=r.evaluate(e)[0];t*=i,e>r.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,r=this.loop;let i=this.time+e,s=this._loopCount;const o=r===Uae;if(e===0)return s===-1?i:o&&(s&1)===1?t-i:i;if(r===Bae){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(s===-1&&(e>=0?(s=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),i>=t||i<0){const a=Math.floor(i/t);i-=t*a,s+=Math.abs(a);const l=this.repetitions-s;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=s,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=i;if(o&&(s&1)===1)return t-i}return i}_setEndings(e,t,r){const i=this._interpolantSettings;r?(i.endingStart=Um,i.endingEnd=Um):(e?i.endingStart=this.zeroSlopeAtStart?Um:Vm:i.endingStart=aS,t?i.endingEnd=this.zeroSlopeAtEnd?Um:Vm:i.endingEnd=aS)}_scheduleFading(e,t,r){const i=this._mixer,s=i.time;let o=this._weightInterpolant;o===null&&(o=i._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=s,l[0]=t,a[1]=s+e,l[1]=r,this}}function YF(n){this._root=n,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}YF.prototype=Object.assign(Object.create(Wu.prototype),{constructor:YF,_bindAction:function(n,e){const t=n._localRoot||this._root,r=n._clip.tracks,i=r.length,s=n._propertyBindings,o=n._interpolants,a=t.uuid,l=this._bindingsByRootAndName;let c=l[a];c===void 0&&(c={},l[a]=c);for(let u=0;u!==i;++u){const h=r[u],f=h.name;let d=c[f];if(d!==void 0)s[u]=d;else{if(d=s[u],d!==void 0){d._cacheIndex===null&&(++d.referenceCount,this._addInactiveBinding(d,a,f));continue}const p=e&&e._propertyBindings[u].binding.parsedPath;d=new fV(Zo.create(t,f,p),h.ValueTypeName,h.getValueSize()),++d.referenceCount,this._addInactiveBinding(d,a,f),s[u]=d}o[u].resultBuffer=d.buffer}},_activateAction:function(n){if(!this._isActiveAction(n)){if(n._cacheIndex===null){const t=(n._localRoot||this._root).uuid,r=n._clip.uuid,i=this._actionsByClip[r];this._bindAction(n,i&&i.knownActions[0]),this._addInactiveAction(n,r,t)}const e=n._propertyBindings;for(let t=0,r=e.length;t!==r;++t){const i=e[t];i.useCount++===0&&(this._lendBinding(i),i.saveOriginalState())}this._lendAction(n)}},_deactivateAction:function(n){if(this._isActiveAction(n)){const e=n._propertyBindings;for(let t=0,r=e.length;t!==r;++t){const i=e[t];--i.useCount===0&&(i.restoreOriginalState(),this._takeBackBinding(i))}this._takeBackAction(n)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const n=this;this.stats={actions:{get total(){return n._actions.length},get inUse(){return n._nActiveActions}},bindings:{get total(){return n._bindings.length},get inUse(){return n._nActiveBindings}},controlInterpolants:{get total(){return n._controlInterpolants.length},get inUse(){return n._nActiveControlInterpolants}}}},_isActiveAction:function(n){const e=n._cacheIndex;return e!==null&&e<this._nActiveActions},_addInactiveAction:function(n,e,t){const r=this._actions,i=this._actionsByClip;let s=i[e];if(s===void 0)s={knownActions:[n],actionByRoot:{}},n._byClipCacheIndex=0,i[e]=s;else{const o=s.knownActions;n._byClipCacheIndex=o.length,o.push(n)}n._cacheIndex=r.length,r.push(n),s.actionByRoot[t]=n},_removeInactiveAction:function(n){const e=this._actions,t=e[e.length-1],r=n._cacheIndex;t._cacheIndex=r,e[r]=t,e.pop(),n._cacheIndex=null;const i=n._clip.uuid,s=this._actionsByClip,o=s[i],a=o.knownActions,l=a[a.length-1],c=n._byClipCacheIndex;l._byClipCacheIndex=c,a[c]=l,a.pop(),n._byClipCacheIndex=null;const u=o.actionByRoot,h=(n._localRoot||this._root).uuid;delete u[h],a.length===0&&delete s[i],this._removeInactiveBindingsForAction(n)},_removeInactiveBindingsForAction:function(n){const e=n._propertyBindings;for(let t=0,r=e.length;t!==r;++t){const i=e[t];--i.referenceCount===0&&this._removeInactiveBinding(i)}},_lendAction:function(n){const e=this._actions,t=n._cacheIndex,r=this._nActiveActions++,i=e[r];n._cacheIndex=r,e[r]=n,i._cacheIndex=t,e[t]=i},_takeBackAction:function(n){const e=this._actions,t=n._cacheIndex,r=--this._nActiveActions,i=e[r];n._cacheIndex=r,e[r]=n,i._cacheIndex=t,e[t]=i},_addInactiveBinding:function(n,e,t){const r=this._bindingsByRootAndName,i=this._bindings;let s=r[e];s===void 0&&(s={},r[e]=s),s[t]=n,n._cacheIndex=i.length,i.push(n)},_removeInactiveBinding:function(n){const e=this._bindings,t=n.binding,r=t.rootNode.uuid,i=t.path,s=this._bindingsByRootAndName,o=s[r],a=e[e.length-1],l=n._cacheIndex;a._cacheIndex=l,e[l]=a,e.pop(),delete o[i],Object.keys(o).length===0&&delete s[r]},_lendBinding:function(n){const e=this._bindings,t=n._cacheIndex,r=this._nActiveBindings++,i=e[r];n._cacheIndex=r,e[r]=n,i._cacheIndex=t,e[t]=i},_takeBackBinding:function(n){const e=this._bindings,t=n._cacheIndex,r=--this._nActiveBindings,i=e[r];n._cacheIndex=r,e[r]=n,i._cacheIndex=t,e[t]=i},_lendControlInterpolant:function(){const n=this._controlInterpolants,e=this._nActiveControlInterpolants++;let t=n[e];return t===void 0&&(t=new AS(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),t.__cacheIndex=e,n[e]=t),t},_takeBackControlInterpolant:function(n){const e=this._controlInterpolants,t=n.__cacheIndex,r=--this._nActiveControlInterpolants,i=e[r];n.__cacheIndex=r,e[r]=n,i.__cacheIndex=t,e[t]=i},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(n,e,t){const r=e||this._root,i=r.uuid;let s=typeof n=="string"?Sl.findByName(r,n):n;const o=s!==null?s.uuid:n,a=this._actionsByClip[o];let l=null;if(t===void 0&&(s!==null?t=s.blendMode:t=I$),a!==void 0){const u=a.actionByRoot[i];if(u!==void 0&&u.blendMode===t)return u;l=a.knownActions[0],s===null&&(s=l._clip)}if(s===null)return null;const c=new b0t(this,s,e,t);return this._bindAction(c,l),this._addInactiveAction(c,o,i),c},existingAction:function(n,e){const t=e||this._root,r=t.uuid,i=typeof n=="string"?Sl.findByName(t,n):n,s=i?i.uuid:n,o=this._actionsByClip[s];return o!==void 0&&o.actionByRoot[r]||null},stopAllAction:function(){const n=this._actions,e=this._nActiveActions;for(let t=e-1;t>=0;--t)n[t].stop();return this},update:function(n){n*=this.timeScale;const e=this._actions,t=this._nActiveActions,r=this.time+=n,i=Math.sign(n),s=this._accuIndex^=1;for(let l=0;l!==t;++l)e[l]._update(r,n,i,s);const o=this._bindings,a=this._nActiveBindings;for(let l=0;l!==a;++l)o[l].apply(s);return this},setTime:function(n){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(n)},getRoot:function(){return this._root},uncacheClip:function(n){const e=this._actions,t=n.uuid,r=this._actionsByClip,i=r[t];if(i!==void 0){const s=i.knownActions;for(let o=0,a=s.length;o!==a;++o){const l=s[o];this._deactivateAction(l);const c=l._cacheIndex,u=e[e.length-1];l._cacheIndex=null,l._byClipCacheIndex=null,u._cacheIndex=c,e[c]=u,e.pop(),this._removeInactiveBindingsForAction(l)}delete r[t]}},uncacheRoot:function(n){const e=n.uuid,t=this._actionsByClip;for(const s in t){const o=t[s].actionByRoot,a=o[e];a!==void 0&&(this._deactivateAction(a),this._removeInactiveAction(a))}const r=this._bindingsByRootAndName,i=r[e];if(i!==void 0)for(const s in i){const o=i[s];o.restoreOriginalState(),this._removeInactiveBinding(o)}},uncacheAction:function(n,e){const t=this.existingAction(n,e);t!==null&&(this._deactivateAction(t),this._removeInactiveAction(t))}});class P${constructor(e){typeof e=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new P$(this.value.clone===void 0?this.value:this.value.clone())}}function ZF(n,e,t){Tl.call(this,n,e),this.meshPerAttribute=t||1}ZF.prototype=Object.assign(Object.create(Tl.prototype),{constructor:ZF,isInstancedInterleavedBuffer:!0,copy:function(n){return Tl.prototype.copy.call(this,n),this.meshPerAttribute=n.meshPerAttribute,this},clone:function(n){const e=Tl.prototype.clone.call(this,n);return e.meshPerAttribute=this.meshPerAttribute,e},toJSON:function(n){const e=Tl.prototype.toJSON.call(this,n);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}});function mV(n,e,t,r,i){this.buffer=n,this.type=e,this.itemSize=t,this.elementSize=r,this.count=i,this.version=0}Object.defineProperty(mV.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(mV.prototype,{isGLBufferAttribute:!0,setBuffer:function(n){return this.buffer=n,this},setType:function(n,e){return this.type=n,this.elementSize=e,this},setItemSize:function(n){return this.itemSize=n,this},setCount:function(n){return this.count=n,this}});function gV(n,e,t,r){this.ray=new ox(n,e),this.near=t||0,this.far=r||1/0,this.camera=null,this.layers=new eV,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function X8(n,e){return n.distance-e.distance}function JF(n,e,t,r){if(n.layers.test(e.layers)&&n.raycast(e,t),r===!0){const i=n.children;for(let s=0,o=i.length;s<o;s++)JF(i[s],e,t,!0)}}Object.assign(gV.prototype,{set:function(n,e){this.ray.set(n,e)},setFromCamera:function(n,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(n.x,n.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(n.x,n.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)},intersectObject:function(n,e,t){const r=t||[];return JF(n,this,r,e),r.sort(X8),r},intersectObjects:function(n,e,t){const r=t||[];if(Array.isArray(n)===!1)return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),r;for(let i=0,s=n.length;i<s;i++)JF(n[i],this,r,e);return r.sort(X8),r}});class QF{constructor(e=1,t=0,r=0){return this.radius=e,this.phi=t,this.theta=r,this}set(e,t,r){return this.radius=e,this.phi=t,this.theta=r,this}clone(){return new this.constructor().copy(this)}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,r){return this.radius=Math.sqrt(e*e+t*t+r*r),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,r),this.phi=Math.acos(In.clamp(t/this.radius,-1,1))),this}}class v0t{constructor(e,t,r){return this.radius=e!==void 0?e:1,this.theta=t!==void 0?t:0,this.y=r!==void 0?r:0,this}set(e,t,r){return this.radius=e,this.theta=t,this.y=r,this}clone(){return new this.constructor().copy(this)}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,r){return this.radius=Math.sqrt(e*e+r*r),this.theta=Math.atan2(e,r),this.y=t,this}}const K8=new st;class xle{constructor(e,t){Object.defineProperty(this,"isBox2",{value:!0}),this.min=e!==void 0?e:new st(1/0,1/0),this.max=t!==void 0?t:new st(-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const r=K8.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return e===void 0&&(console.warn("THREE.Box2: .getCenter() target is now required"),e=new st),this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box2: .getSize() target is now required"),e=new st),this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box2: .getParameter() target is now required"),t=new st),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box2: .clampPoint() target is now required"),t=new st),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return K8.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Y8=new Q,fE=new Q;class _le{constructor(e,t){this.start=e!==void 0?e:new Q,this.end=t!==void 0?t:new Q}set(e,t){return this.start.copy(e),this.end.copy(t),this}clone(){return new this.constructor().copy(this)}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e===void 0&&(console.warn("THREE.Line3: .getCenter() target is now required"),e=new Q),e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e===void 0&&(console.warn("THREE.Line3: .delta() target is now required"),e=new Q),e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return t===void 0&&(console.warn("THREE.Line3: .at() target is now required"),t=new Q),this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){Y8.subVectors(e,this.start),fE.subVectors(this.end,this.start);const r=fE.dot(fE);let s=fE.dot(Y8)/r;return t&&(s=In.clamp(s,0,1)),s}closestPointToPoint(e,t,r){const i=this.closestPointToPointParameter(e,t);return r===void 0&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),r=new Q),this.delta(r).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}}function $S(n){rn.call(this),this.material=n,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}$S.prototype=Object.create(rn.prototype);$S.prototype.constructor=$S;$S.prototype.isImmediateRenderObject=!0;const Z8=new Q;class w0t extends rn{constructor(e,t){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const r=new un,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const c=o/l*Math.PI*2,u=a/l*Math.PI*2;i.push(Math.cos(c),Math.sin(c),1,Math.cos(u),Math.sin(u),1)}r.setAttribute("position",new qt(i,3));const s=new Ei({fog:!1,toneMapped:!1});this.cone=new Ea(r,s),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),Z8.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Z8),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const yd=new Q,dE=new Zn,NP=new Zn;class Sle extends Ea{constructor(e){const t=Cle(e),r=new un,i=[],s=[],o=new Gt(0,0,1),a=new Gt(0,1,0);for(let c=0;c<t.length;c++){const u=t[c];u.parent&&u.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),s.push(o.r,o.g,o.b),s.push(a.r,a.g,a.b))}r.setAttribute("position",new qt(i,3)),r.setAttribute("color",new qt(s,3));const l=new Ei({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(r,l),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,r=this.geometry,i=r.getAttribute("position");NP.copy(this.root.matrixWorld).invert();for(let s=0,o=0;s<t.length;s++){const a=t[s];a.parent&&a.parent.isBone&&(dE.multiplyMatrices(NP,a.matrixWorld),yd.setFromMatrixPosition(dE),i.setXYZ(o,yd.x,yd.y,yd.z),dE.multiplyMatrices(NP,a.parent.matrixWorld),yd.setFromMatrixPosition(dE),i.setXYZ(o+1,yd.x,yd.y,yd.z),o+=2)}r.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function Cle(n){const e=[];n&&n.isBone&&e.push(n);for(let t=0;t<n.children.length;t++)e.push.apply(e,Cle(n.children[t]));return e}class x0t extends ui{constructor(e,t,r){const i=new IS(t,4,2),s=new Dl({wireframe:!0,fog:!1,toneMapped:!1});super(i,s),this.light=e,this.light.updateMatrixWorld(),this.color=r,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const _0t=new Q,J8=new Gt,Q8=new Gt;class S0t extends rn{constructor(e,t,r){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r;const i=new TS(t);i.rotateY(Math.PI*.5),this.material=new Dl({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const s=i.getAttribute("position"),o=new Float32Array(s.count*3);i.setAttribute("color",new Cn(o,3)),this.add(new ui(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");J8.copy(this.light.color),Q8.copy(this.light.groundColor);for(let r=0,i=t.count;r<i;r++){const s=r<i/2?J8:Q8;t.setXYZ(r,s.r,s.g,s.b)}t.needsUpdate=!0}e.lookAt(_0t.setFromMatrixPosition(this.light.matrixWorld).negate())}}class kle extends Ea{constructor(e=10,t=10,r=4473924,i=8947848){r=new Gt(r),i=new Gt(i);const s=t/2,o=e/t,a=e/2,l=[],c=[];for(let f=0,d=0,p=-a;f<=t;f++,p+=o){l.push(-a,0,p,a,0,p),l.push(p,0,-a,p,0,a);const m=f===s?r:i;m.toArray(c,d),d+=3,m.toArray(c,d),d+=3,m.toArray(c,d),d+=3,m.toArray(c,d),d+=3}const u=new un;u.setAttribute("position",new qt(l,3)),u.setAttribute("color",new qt(c,3));const h=new Ei({vertexColors:!0,toneMapped:!1});super(u,h),this.type="GridHelper"}}class C0t extends Ea{constructor(e=10,t=16,r=8,i=64,s=4473924,o=8947848){s=new Gt(s),o=new Gt(o);const a=[],l=[];for(let h=0;h<=t;h++){const f=h/t*(Math.PI*2),d=Math.sin(f)*e,p=Math.cos(f)*e;a.push(0,0,0),a.push(d,0,p);const m=h&1?s:o;l.push(m.r,m.g,m.b),l.push(m.r,m.g,m.b)}for(let h=0;h<=r;h++){const f=h&1?s:o,d=e-e/r*h;for(let p=0;p<i;p++){let m=p/i*(Math.PI*2),g=Math.sin(m)*d,y=Math.cos(m)*d;a.push(g,0,y),l.push(f.r,f.g,f.b),m=(p+1)/i*(Math.PI*2),g=Math.sin(m)*d,y=Math.cos(m)*d,a.push(g,0,y),l.push(f.r,f.g,f.b)}}const c=new un;c.setAttribute("position",new qt(a,3)),c.setAttribute("color",new qt(l,3));const u=new Ei({vertexColors:!0,toneMapped:!1});super(c,u),this.type="PolarGridHelper"}}const eq=new Q,pE=new Q,tq=new Q;class k0t extends rn{constructor(e,t,r){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r,t===void 0&&(t=1);let i=new un;i.setAttribute("position",new qt([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const s=new Ei({fog:!1,toneMapped:!1});this.lightPlane=new Nc(i,s),this.add(this.lightPlane),i=new un,i.setAttribute("position",new qt([0,0,0,0,0,1],3)),this.targetLine=new Nc(i,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){eq.setFromMatrixPosition(this.light.matrixWorld),pE.setFromMatrixPosition(this.light.target.matrixWorld),tq.subVectors(pE,eq),this.lightPlane.lookAt(pE),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(pE),this.targetLine.scale.z=tq.length()}}const mE=new Q,Hi=new Eh;class T0t extends Ea{constructor(e){const t=new un,r=new Ei({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],s=[],o={},a=new Gt(16755200),l=new Gt(16711680),c=new Gt(43775),u=new Gt(16777215),h=new Gt(3355443);f("n1","n2",a),f("n2","n4",a),f("n4","n3",a),f("n3","n1",a),f("f1","f2",a),f("f2","f4",a),f("f4","f3",a),f("f3","f1",a),f("n1","f1",a),f("n2","f2",a),f("n3","f3",a),f("n4","f4",a),f("p","n1",l),f("p","n2",l),f("p","n3",l),f("p","n4",l),f("u1","u2",c),f("u2","u3",c),f("u3","u1",c),f("c","t",u),f("p","c",h),f("cn1","cn2",h),f("cn3","cn4",h),f("cf1","cf2",h),f("cf3","cf4",h);function f(p,m,g){d(p,g),d(m,g)}function d(p,m){i.push(0,0,0),s.push(m.r,m.g,m.b),o[p]===void 0&&(o[p]=[]),o[p].push(i.length/3-1)}t.setAttribute("position",new qt(i,3)),t.setAttribute("color",new qt(s,3)),super(t,r),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update()}update(){const e=this.geometry,t=this.pointMap,r=1,i=1;Hi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),rs("c",t,e,Hi,0,0,-1),rs("t",t,e,Hi,0,0,1),rs("n1",t,e,Hi,-r,-i,-1),rs("n2",t,e,Hi,r,-i,-1),rs("n3",t,e,Hi,-r,i,-1),rs("n4",t,e,Hi,r,i,-1),rs("f1",t,e,Hi,-r,-i,1),rs("f2",t,e,Hi,r,-i,1),rs("f3",t,e,Hi,-r,i,1),rs("f4",t,e,Hi,r,i,1),rs("u1",t,e,Hi,r*.7,i*1.1,-1),rs("u2",t,e,Hi,-r*.7,i*1.1,-1),rs("u3",t,e,Hi,0,i*2,-1),rs("cf1",t,e,Hi,-r,0,1),rs("cf2",t,e,Hi,r,0,1),rs("cf3",t,e,Hi,0,-i,1),rs("cf4",t,e,Hi,0,i,1),rs("cn1",t,e,Hi,-r,0,-1),rs("cn2",t,e,Hi,r,0,-1),rs("cn3",t,e,Hi,0,-i,-1),rs("cn4",t,e,Hi,0,i,-1),e.getAttribute("position").needsUpdate=!0}}function rs(n,e,t,r,i,s,o){mE.set(i,s,o).unproject(r);const a=e[n];if(a!==void 0){const l=t.getAttribute("position");for(let c=0,u=a.length;c<u;c++)l.setXYZ(a[c],mE.x,mE.y,mE.z)}}const gE=new qf;class Tle extends Ea{constructor(e,t=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(8*3),s=new un;s.setIndex(new Cn(r,1)),s.setAttribute("position",new Cn(i,3)),super(s,new Ei({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&gE.setFromObject(this.object),gE.isEmpty())return;const t=gE.min,r=gE.max,i=this.geometry.attributes.position,s=i.array;s[0]=r.x,s[1]=r.y,s[2]=r.z,s[3]=t.x,s[4]=r.y,s[5]=r.z,s[6]=t.x,s[7]=t.y,s[8]=r.z,s[9]=r.x,s[10]=t.y,s[11]=r.z,s[12]=r.x,s[13]=r.y,s[14]=t.z,s[15]=t.x,s[16]=r.y,s[17]=t.z,s[18]=t.x,s[19]=t.y,s[20]=t.z,s[21]=r.x,s[22]=t.y,s[23]=t.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e){return Ea.prototype.copy.call(this,e),this.object=e.object,this}}class E0t extends Ea{constructor(e,t=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],s=new un;s.setIndex(new Cn(r,1)),s.setAttribute("position",new qt(i,3)),super(s,new Ei({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}}class I0t extends Nc{constructor(e,t=1,r=16776960){const i=r,s=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],o=new un;o.setAttribute("position",new qt(s,3)),o.computeBoundingSphere(),super(o,new Ei({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const a=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],l=new un;l.setAttribute("position",new qt(a,3)),l.computeBoundingSphere(),this.add(new ui(l,new Dl({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){let t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8),this.scale.set(.5*this.size,.5*this.size,t),this.children[0].material.side=t<0?ms:nx,this.lookAt(this.plane.normal),super.updateMatrixWorld(e)}}const nq=new Q;let yE,$P;class A0t extends rn{constructor(e,t,r,i,s,o){super(),this.type="ArrowHelper",e===void 0&&(e=new Q(0,0,1)),t===void 0&&(t=new Q(0,0,0)),r===void 0&&(r=1),i===void 0&&(i=16776960),s===void 0&&(s=.2*r),o===void 0&&(o=.2*s),yE===void 0&&(yE=new un,yE.setAttribute("position",new qt([0,0,0,0,1,0],3)),$P=new bv(0,.5,1,5,1),$P.translate(0,-.5,0)),this.position.copy(t),this.line=new Nc(yE,new Ei({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new ui($P,new Dl({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(r,s,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{nq.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(nq,t)}}setLength(e,t,r){t===void 0&&(t=.2*e),r===void 0&&(r=.2*t),this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(r,t,r),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}}class Ele extends Ea{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],r=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new un;i.setAttribute("position",new qt(t,3)),i.setAttribute("color",new qt(r,3));const s=new Ei({vertexColors:!0,toneMapped:!1});super(i,s),this.type="AxesHelper"}}const Ile=new Float32Array(1),M0t=new Int32Array(Ile.buffer),N0t={toHalfFloat:function(n){Ile[0]=n;const e=M0t[0];let t=e>>16&32768,r=e>>12&2047;const i=e>>23&255;return i<103?t:i>142?(t|=31744,t|=(i==255?0:1)&&e&8388607,t):i<113?(r|=2048,t|=(r>>114-i)+(r>>113-i&1),t):(t|=i-112<<10|r>>1,t+=r&1,t)}},Fb=4,Yd=8,oh=Math.pow(2,Yd),Ale=[.125,.215,.35,.446,.526,.582],Mle=Yd-Fb+1+Ale.length,ib=20,dh={[ka]:0,[BC]:1,[M$]:2,[Z4]:3,[J4]:4,[Q4]:5,[A$]:6},_m=new Dl({side:ms,depthWrite:!1,depthTest:!1}),$0t=new ui(new wg,_m),RP=new Sv,{_lodPlanes:a1,_sizeLods:rq,_sigmas:bE}=D0t(),iq=new Gt;let PP=null;const Sm=(1+Math.sqrt(5))/2,sb=1/Sm,sq=[new Q(1,1,1),new Q(-1,1,1),new Q(1,1,-1),new Q(-1,1,-1),new Q(0,Sm,sb),new Q(0,Sm,-sb),new Q(sb,0,Sm),new Q(-sb,0,Sm),new Q(Sm,sb,0),new Q(-Sm,sb,0)];function oq(n){const e=Math.max(n.r,n.g,n.b),t=Math.min(Math.max(Math.ceil(Math.log2(e)),-128),127);return n.multiplyScalar(Math.pow(2,-t)),(t+128)/255}class R0t{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=O0t(ib),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,r=.1,i=100){PP=this._renderer.getRenderTarget();const s=this._allocateTargets();return this._sceneToCubeUV(e,r,i,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=cq(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=lq(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<a1.length;e++)a1[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(PP),e.scissorTest=!1,vE(e,0,0,e.width,e.height)}_fromTexture(e){PP=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:Us,minFilter:Us,generateMipmaps:!1,type:sx,format:rae,encoding:P0t(e)?e.encoding:M$,depthBuffer:!1},r=aq(t);return r.depthBuffer=!e,this._pingPongRenderTarget=aq(t),r}_compileMaterial(e){const t=new ui(a1[0],e);this._renderer.compile(t,RP)}_sceneToCubeUV(e,t,r,i){const a=new _s(90,1,t,r),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,f=u.outputEncoding,d=u.toneMapping;u.getClearColor(iq),u.toneMapping=Ym,u.outputEncoding=ka,u.autoClear=!1;let p=!1;const m=e.background;if(m){if(m.isColor){_m.color.copy(m).convertSRGBToLinear(),e.background=null;const g=oq(_m.color);_m.opacity=g,p=!0}}else{_m.color.copy(iq).convertSRGBToLinear();const g=oq(_m.color);_m.opacity=g,p=!0}for(let g=0;g<6;g++){const y=g%3;y==0?(a.up.set(0,l[g],0),a.lookAt(c[g],0,0)):y==1?(a.up.set(0,0,l[g]),a.lookAt(0,c[g],0)):(a.up.set(0,l[g],0),a.lookAt(0,0,c[g])),vE(i,y*oh,g>2?oh:0,oh,oh),u.setRenderTarget(i),p&&u.render($0t,a),u.render(e,a)}u.toneMapping=d,u.outputEncoding=f,u.autoClear=h}_textureToCubeUV(e,t){const r=this._renderer;e.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=cq()):this._equirectShader==null&&(this._equirectShader=lq());const i=e.isCubeTexture?this._cubemapShader:this._equirectShader,s=new ui(a1[0],i),o=i.uniforms;o.envMap.value=e,e.isCubeTexture||o.texelSize.value.set(1/e.image.width,1/e.image.height),o.inputEncoding.value=dh[e.encoding],o.outputEncoding.value=dh[t.texture.encoding],vE(t,0,0,3*oh,2*oh),r.setRenderTarget(t),r.render(s,RP)}_applyPMREM(e){const t=this._renderer,r=t.autoClear;t.autoClear=!1;for(let i=1;i<Mle;i++){const s=Math.sqrt(bE[i]*bE[i]-bE[i-1]*bE[i-1]),o=sq[(i-1)%sq.length];this._blur(e,i-1,i,s,o)}t.autoClear=r}_blur(e,t,r,i,s){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,r,i,"latitudinal",s),this._halfBlur(o,e,r,r,i,"longitudinal",s)}_halfBlur(e,t,r,i,s,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new ui(a1[i],c),f=c.uniforms,d=rq[r]-1,p=isFinite(s)?Math.PI/(2*d):2*Math.PI/(2*ib-1),m=s/p,g=isFinite(s)?1+Math.floor(u*m):ib;g>ib&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${ib}`);const y=[];let b=0;for(let C=0;C<ib;++C){const k=C/m,A=Math.exp(-k*k/2);y.push(A),C==0?b+=A:C<g&&(b+=2*A)}for(let C=0;C<y.length;C++)y[C]=y[C]/b;f.envMap.value=e.texture,f.samples.value=g,f.weights.value=y,f.latitudinal.value=o==="latitudinal",a&&(f.poleAxis.value=a),f.dTheta.value=p,f.mipInt.value=Yd-r,f.inputEncoding.value=dh[e.texture.encoding],f.outputEncoding.value=dh[e.texture.encoding];const _=rq[i],w=3*Math.max(0,oh-2*_),S=(i===0?0:2*oh)+2*_*(i>Yd-Fb?i-Yd+Fb:0);vE(t,w,S,3*_,2*_),l.setRenderTarget(t),l.render(h,RP)}}function P0t(n){return n===void 0||n.type!==sx?!1:n.encoding===ka||n.encoding===BC||n.encoding===A$}function D0t(){const n=[],e=[],t=[];let r=Yd;for(let i=0;i<Mle;i++){const s=Math.pow(2,r);e.push(s);let o=1/s;i>Yd-Fb?o=Ale[i-Yd+Fb-1]:i==0&&(o=0),t.push(o);const a=1/(s-1),l=-a/2,c=1+a/2,u=[l,l,c,l,c,c,l,l,c,c,l,c],h=6,f=6,d=3,p=2,m=1,g=new Float32Array(d*f*h),y=new Float32Array(p*f*h),b=new Float32Array(m*f*h);for(let w=0;w<h;w++){const S=w%3*2/3-1,C=w>2?0:-1,k=[S,C,0,S+2/3,C,0,S+2/3,C+1,0,S,C,0,S+2/3,C+1,0,S,C+1,0];g.set(k,d*f*w),y.set(u,p*f*w);const A=[w,w,w,w,w,w];b.set(A,m*f*w)}const _=new un;_.setAttribute("position",new Cn(g,d)),_.setAttribute("uv",new Cn(y,p)),_.setAttribute("faceIndex",new Cn(b,m)),n.push(_),r>Fb&&r--}return{_lodPlanes:n,_sizeLods:e,_sigmas:t}}function aq(n){const e=new qd(3*oh,3*oh,n);return e.texture.mapping=rx,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function vE(n,e,t,r,i){n.viewport.set(e,t,r,i),n.scissor.set(e,t,r,i)}function O0t(n){const e=new Float32Array(n),t=new Q(0,1,0);return new Ff({name:"SphericalGaussianBlur",defines:{n},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:t},inputEncoding:{value:dh[ka]},outputEncoding:{value:dh[ka]}},vertexShader:yV(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${bV()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Mf,depthTest:!1,depthWrite:!1})}function lq(){const n=new st(1,1);return new Ff({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:n},inputEncoding:{value:dh[ka]},outputEncoding:{value:dh[ka]}},vertexShader:yV(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${bV()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Mf,depthTest:!1,depthWrite:!1})}function cq(){return new Ff({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:dh[ka]},outputEncoding:{value:dh[ka]}},vertexShader:yV(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${bV()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Mf,depthTest:!1,depthWrite:!1})}function yV(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function bV(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function F0t(n,e,t,r,i,s,o){return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),new tV(n,e,t,i,s,o)}const L0t=0,z0t=1,B0t=0,V0t=1,U0t=2;function W0t(n){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),n}function H0t(n=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),n.isMultiMaterial=!0,n.materials=n,n.clone=function(){return n.slice()},n}function G0t(n,e){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new gv(n,e)}function j0t(n){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new gS(n)}function q0t(n,e){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new gv(n,e)}function X0t(n){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new Au(n)}function K0t(n){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new Au(n)}function Y0t(n){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new Au(n)}function Z0t(n,e,t){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new Q(n,e,t)}function J0t(n,e){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new Cn(n,e).setUsage(yg)}function Q0t(n,e){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new lS(n,e)}function ebt(n,e){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new cS(n,e)}function tbt(n,e){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new uS(n,e)}function nbt(n,e){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new hS(n,e)}function rbt(n,e){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new bg(n,e)}function ibt(n,e){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new fS(n,e)}function sbt(n,e){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new vg(n,e)}function obt(n,e){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new qt(n,e)}function abt(n,e){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new pS(n,e)}on.create=function(n,e){return console.log("THREE.Curve.create() has been deprecated"),n.prototype=Object.create(on.prototype),n.prototype.constructor=n,n.prototype.getPoint=e,n};Object.assign(fu.prototype,{fromPoints:function(n){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(n)}});function Nle(n){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),ta.call(this,n),this.type="catmullrom",this.closed=!0}Nle.prototype=Object.create(ta.prototype);function $le(n){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),ta.call(this,n),this.type="catmullrom"}$le.prototype=Object.create(ta.prototype);function vV(n){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),ta.call(this,n),this.type="catmullrom"}vV.prototype=Object.create(ta.prototype);Object.assign(vV.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}});function lbt(n){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new Ele(n)}function cbt(n,e){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new Tle(n,e)}function ubt(n,e){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new Ea(new iV(n.geometry),new Ei({color:e!==void 0?e:16777215}))}kle.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};Sle.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};function hbt(n,e){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new Ea(new sV(n.geometry),new Ei({color:e!==void 0?e:16777215}))}Object.assign(zr.prototype,{extractUrlBase:function(n){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),lV.extractUrlBase(n)}});zr.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};function fbt(n){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new $c(n)}function dbt(n){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new qA(n)}Object.assign(xle.prototype,{center:function(n){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(n)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(n){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},size:function(n){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(n)}});Object.assign(qf.prototype,{center:function(n){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(n)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(n){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},isIntersectionSphere:function(n){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)},size:function(n){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(n)}});Object.assign(Op.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}});UC.prototype.setFromMatrix=function(n){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(n)};_le.prototype.center=function(n){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(n)};Object.assign(In,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(n){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),In.floorPowerOfTwo(n)},nextPowerOfTwo:function(n){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),In.ceilPowerOfTwo(n)}});Object.assign(kl.prototype,{flattenToArrayOffset:function(n,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,e)},multiplyVector3:function(n){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(n){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},getInverse:function(n){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()}});Object.assign(Zn.prototype,{extractPosition:function(n){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(n)},flattenToArrayOffset:function(n,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,e)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new Q().setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(n){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(n)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(n){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},multiplyVector4:function(n){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(n){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),n.transformDirection(this)},crossVector:function(n){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(n){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(n,e,t,r,i,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(n,e,r,t,i,s)},getInverse:function(n){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()}});uh.prototype.isIntersectionLine=function(n){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(n)};Object.assign(co.prototype,{multiplyVector3:function(n){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),n.applyQuaternion(this)},inverse:function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()}});Object.assign(ox.prototype,{isIntersectionBox:function(n){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},isIntersectionPlane:function(n){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(n)},isIntersectionSphere:function(n){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)}});Object.assign(Xo.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(n,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(n,e)},midpoint:function(n){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(n)},normal:function(n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(n)},plane:function(n){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(n)}});Object.assign(Xo,{barycoordFromPoint:function(n,e,t,r,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Xo.getBarycoord(n,e,t,r,i)},normal:function(n,e,t,r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Xo.getNormal(n,e,t,r)}});Object.assign(Kd.prototype,{extractAllPoints:function(n){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(n)},extrude:function(n){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new _g(this,n)},makeGeometry:function(n){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new ES(this,n)}});Object.assign(st.prototype,{fromAttribute:function(n,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},distanceToManhattan:function(n){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(Q.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(n){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(n)},getScaleFromMatrix:function(n){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(n)},getColumnFromMatrix:function(n,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,n)},applyProjection:function(n){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(n)},fromAttribute:function(n,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},distanceToManhattan:function(n){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(Gr.prototype,{fromAttribute:function(n,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(rn.prototype,{getChildByName:function(n){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(n)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(n,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,n)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(n){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)}});Object.defineProperties(rn.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(n){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=n}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Object.assign(ui.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}});Object.defineProperties(ui.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),Wae},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Object.defineProperties(yS.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}});Object.defineProperty(wS.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}});bS.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Object.defineProperty(on.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(n){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=n}});_s.prototype.setLens=function(n,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(n)};Object.defineProperties(hi.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(n){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=n}},shadowCameraLeft:{set:function(n){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=n}},shadowCameraRight:{set:function(n){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=n}},shadowCameraTop:{set:function(n){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=n}},shadowCameraBottom:{set:function(n){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=n}},shadowCameraNear:{set:function(n){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=n}},shadowCameraFar:{set:function(n){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=n}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(n){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=n}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(n){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=n}},shadowMapHeight:{set:function(n){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=n}}});Object.defineProperties(Cn.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===yg},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(yg)}}});Object.assign(Cn.prototype,{setDynamic:function(n){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?yg:VC),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}});Object.assign(un.prototype,{addIndex:function(n){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(n)},addAttribute:function(n,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(e&&e.isBufferAttribute)&&!(e&&e.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(n,new Cn(arguments[1],arguments[2]))):n==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(n,e)},addDrawCall:function(n,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(n,e)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(n){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(n)},applyMatrix:function(n){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)}});Object.defineProperties(un.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});Object.defineProperties(NS.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(n){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=n}}});Object.defineProperties(gV.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(n){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=n}}});Object.defineProperties(Tl.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===yg},set:function(n){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(n)}}});Object.assign(Tl.prototype,{setDynamic:function(n){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?yg:VC),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}});Object.assign(_g.prototype,{getArrays:function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")}});Object.assign(rV.prototype,{dispose:function(){console.error("THREE.Scene: .dispose() has been removed.")}});Object.defineProperties(P$.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}});Object.defineProperties(kn.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Gt}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(n){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===j4}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(n){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=n}}});Object.defineProperties(vp.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}});Object.defineProperties(bp.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(n){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=n}}});Object.defineProperties(Ta.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(n){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=n}}});Object.assign(WC.prototype,{clearTarget:function(n,e,t,r){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(n),this.clear(e,t,r)},animate:function(n){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(n)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(n){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(n)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}});Object.defineProperties(WC.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=n}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=n}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(n){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=n===!0?BC:ka}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(ole.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});function pbt(n,e,t){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new nV(n,t)}Object.defineProperties(qd.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=n}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=n}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=n}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=n}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(n){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=n}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(n){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=n}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(n){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=n}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(n){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=n}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(n){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=n}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(n){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=n}}});Object.defineProperties(hV.prototype,{load:{value:function(n){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new iM().load(n,function(r){e.setBuffer(r)}),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}});ble.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()};xg.prototype.updateCubeMap=function(n,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(n,e)};xg.prototype.clear=function(n,e,t,r){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(n,e,t,r)};const mbt={merge:function(n,e,t){console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");let r;e.isMesh&&(e.matrixAutoUpdate&&e.updateMatrix(),r=e.matrix,e=e.geometry),n.merge(e,r,t)},center:function(n){return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),n.center()}};Jy.crossOrigin=void 0;Jy.loadTexture=function(n,e,t,r){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new XA;i.setCrossOrigin(this.crossOrigin);const s=i.load(n,t,void 0,r);return e&&(s.mapping=e),s};Jy.loadTextureCube=function(n,e,t,r){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new jA;i.setCrossOrigin(this.crossOrigin);const s=i.load(n,t,void 0,r);return e&&(s.mapping=e),s};Jy.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};Jy.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};function gbt(){console.error("THREE.CanvasRenderer has been removed")}function ybt(){console.error("THREE.JSONLoader has been removed.")}const bbt={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function vbt(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:H4}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=H4);const wbt=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:joe,AddEquation:Pm,AddOperation:Uoe,AdditiveAnimationBlendMode:Y4,AdditiveBlending:bF,AlphaFormat:eae,AlwaysDepth:Doe,AlwaysStencilFunc:Xae,AmbientLight:QA,AmbientLightProbe:KF,AnimationClip:Sl,AnimationLoader:BF,AnimationMixer:YF,AnimationObjectGroup:wle,AnimationUtils:di,ArcCurve:_v,ArrayCamera:TA,ArrowHelper:A0t,Audio:hV,AudioAnalyser:ble,AudioContext:uV,AudioListener:a0t,AudioLoader:iM,AxesHelper:Ele,AxisHelper:lbt,BackSide:ms,BasicDepthPacking:Gae,BasicShadowMap:Pft,BinaryTextureLoader:dbt,Bone:vS,BooleanKeyframeTrack:UA,BoundingBoxHelper:cbt,Box2:xle,Box3:qf,Box3Helper:E0t,BoxBufferGeometry:wg,BoxGeometry:wg,BoxHelper:Tle,BufferAttribute:Cn,BufferGeometry:un,BufferGeometryLoader:rM,ByteType:Xoe,Cache:Mg,Camera:Eh,CameraHelper:T0t,CanvasRenderer:gbt,CanvasTexture:xS,CatmullRomCurve3:ta,CineonToneMapping:Goe,CircleBufferGeometry:AA,CircleGeometry:AA,ClampToEdgeWrapping:ma,Clock:yle,ClosedSplineCurve3:Nle,Color:Gt,ColorKeyframeTrack:WA,CompressedTexture:yv,CompressedTextureLoader:VF,ConeBufferGeometry:MA,ConeGeometry:MA,CubeCamera:xg,CubeReflectionMapping:FC,CubeRefractionMapping:LC,CubeTexture:Ih,CubeTextureLoader:jA,CubeUVReflectionMapping:rx,CubeUVRefractionMapping:zC,CubicBezierCurve:Mu,CubicBezierCurve3:Mh,CubicInterpolant:BA,CullFaceBack:yF,CullFaceFront:woe,CullFaceFrontBack:Rft,CullFaceNone:voe,Curve:on,CurvePath:Fd,CustomBlending:_oe,CustomToneMapping:qoe,CylinderBufferGeometry:bv,CylinderGeometry:bv,Cylindrical:v0t,DataTexture:Of,DataTexture2DArray:pv,DataTexture3D:mv,DataTextureLoader:qA,DataUtils:N0t,DecrementStencilOp:Gft,DecrementWrapStencilOp:qft,DefaultLoadingManager:dle,DepthFormat:Zm,DepthStencilFormat:fv,DepthTexture:_S,DirectionalLight:JA,DirectionalLightHelper:k0t,DiscreteInterpolant:VA,DodecahedronBufferGeometry:NA,DodecahedronGeometry:NA,DoubleSide:DC,DstAlphaFactor:Aoe,DstColorFactor:Noe,DynamicBufferAttribute:J0t,DynamicCopyUsage:adt,DynamicDrawUsage:yg,DynamicReadUsage:idt,EdgesGeometry:iV,EdgesHelper:ubt,EllipseCurve:Fl,EqualDepth:Foe,EqualStencilFunc:Zft,EquirectangularReflectionMapping:_A,EquirectangularRefractionMapping:SA,Euler:ax,EventDispatcher:Wu,ExtrudeBufferGeometry:_g,ExtrudeGeometry:_g,Face3:tV,Face4:F0t,FaceColors:V0t,FileLoader:$c,FlatShading:j4,Float16BufferAttribute:dS,Float32Attribute:obt,Float32BufferAttribute:qt,Float64Attribute:abt,Float64BufferAttribute:pS,FloatType:kf,Fog:$$,FogExp2:N$,Font:mle,FontLoader:qF,FrontSide:nx,Frustum:UC,GLBufferAttribute:mV,GLSL1:cdt,GLSL3:RF,GammaEncoding:A$,GeometryUtils:mbt,GreaterDepth:zoe,GreaterEqualDepth:Loe,GreaterEqualStencilFunc:tdt,GreaterStencilFunc:Qft,GridHelper:kle,Group:Od,HalfFloatType:sS,HemisphereLight:KA,HemisphereLightHelper:S0t,HemisphereLightProbe:XF,IcosahedronBufferGeometry:$A,IcosahedronGeometry:$A,ImageBitmapLoader:jF,ImageLoader:xv,ImageUtils:Jy,ImmediateRenderObject:$S,IncrementStencilOp:Hft,IncrementWrapStencilOp:jft,InstancedBufferAttribute:nM,InstancedBufferGeometry:NS,InstancedInterleavedBuffer:ZF,InstancedMesh:EA,Int16Attribute:nbt,Int16BufferAttribute:hS,Int32Attribute:ibt,Int32BufferAttribute:fS,Int8Attribute:Q0t,Int8BufferAttribute:lS,IntType:Yoe,InterleavedBuffer:Tl,InterleavedBufferAttribute:pp,Interpolant:Nl,InterpolateDiscrete:oS,InterpolateLinear:s_,InterpolateSmooth:QE,InvertStencilOp:Xft,JSONLoader:ybt,KeepStencilOp:eI,KeyframeTrack:So,LOD:yS,LatheBufferGeometry:RA,LatheGeometry:RA,Layers:eV,LensFlare:vbt,LessDepth:Ooe,LessEqualDepth:xA,LessEqualStencilFunc:Jft,LessStencilFunc:Yft,Light:hi,LightProbe:_c,Line:Nc,Line3:_le,LineBasicMaterial:Ei,LineCurve:Ya,LineCurve3:Nu,LineDashedMaterial:Ag,LineLoop:IA,LinePieces:z0t,LineSegments:Ea,LineStrip:L0t,LinearEncoding:ka,LinearFilter:lo,LinearInterpolant:AS,LinearMipMapLinearFilter:zft,LinearMipMapNearestFilter:Lft,LinearMipmapLinearFilter:ix,LinearMipmapNearestFilter:K4,LinearToneMapping:Woe,Loader:zr,LoaderUtils:lV,LoadingManager:oV,LogLuvEncoding:Hae,LoopOnce:Bae,LoopPingPong:Uae,LoopRepeat:Vae,LuminanceAlphaFormat:nae,LuminanceFormat:tae,MOUSE:xf,Material:kn,MaterialLoader:tM,Math:In,MathUtils:In,Matrix3:kl,Matrix4:Zn,MaxEquation:_F,Mesh:ui,MeshBasicMaterial:Dl,MeshDepthMaterial:fp,MeshDistanceMaterial:dp,MeshFaceMaterial:W0t,MeshLambertMaterial:Eg,MeshMatcapMaterial:Ig,MeshNormalMaterial:Tg,MeshPhongMaterial:vp,MeshPhysicalMaterial:bp,MeshStandardMaterial:Ah,MeshToonMaterial:kg,MinEquation:xF,MirroredRepeatWrapping:rS,MixOperation:Voe,MultiMaterial:H0t,MultiplyBlending:wF,MultiplyOperation:OC,NearestFilter:Us,NearestMipMapLinearFilter:Fft,NearestMipMapNearestFilter:Oft,NearestMipmapLinearFilter:kA,NearestMipmapNearestFilter:CA,NeverDepth:Poe,NeverStencilFunc:Kft,NoBlending:Mf,NoColors:B0t,NoToneMapping:Ym,NormalAnimationBlendMode:I$,NormalBlending:Db,NotEqualDepth:Boe,NotEqualStencilFunc:edt,NumberKeyframeTrack:vv,Object3D:rn,ObjectLoader:n0t,ObjectSpaceNormalMap:qae,OctahedronBufferGeometry:TS,OctahedronGeometry:TS,OneFactor:Toe,OneMinusDstAlphaFactor:Moe,OneMinusDstColorFactor:$oe,OneMinusSrcAlphaFactor:X4,OneMinusSrcColorFactor:Ioe,OrthographicCamera:Sv,PCFShadowMap:G4,PCFSoftShadowMap:xoe,PMREMGenerator:R0t,ParametricBufferGeometry:Sg,ParametricGeometry:Sg,Particle:j0t,ParticleBasicMaterial:K0t,ParticleSystem:q0t,ParticleSystemMaterial:Y0t,Path:fu,PerspectiveCamera:_s,Plane:uh,PlaneBufferGeometry:mS,PlaneGeometry:mS,PlaneHelper:I0t,PointCloud:G0t,PointCloudMaterial:X0t,PointLight:ZA,PointLightHelper:x0t,Points:gv,PointsMaterial:Au,PolarGridHelper:C0t,PolyhedronBufferGeometry:gp,PolyhedronGeometry:gp,PositionalAudio:c0t,PropertyBinding:Zo,PropertyMixer:fV,QuadraticBezierCurve:$u,QuadraticBezierCurve3:Nh,Quaternion:co,QuaternionKeyframeTrack:MS,QuaternionLinearInterpolant:HA,REVISION:H4,RGBADepthPacking:jae,RGBAFormat:Ml,RGBAIntegerFormat:cae,RGBA_ASTC_10x10_Format:_ae,RGBA_ASTC_10x5_Format:vae,RGBA_ASTC_10x6_Format:wae,RGBA_ASTC_10x8_Format:xae,RGBA_ASTC_12x10_Format:Sae,RGBA_ASTC_12x12_Format:Cae,RGBA_ASTC_4x4_Format:hae,RGBA_ASTC_5x4_Format:fae,RGBA_ASTC_5x5_Format:dae,RGBA_ASTC_6x5_Format:pae,RGBA_ASTC_6x6_Format:mae,RGBA_ASTC_8x5_Format:gae,RGBA_ASTC_8x6_Format:yae,RGBA_ASTC_8x8_Format:bae,RGBA_BPTC_Format:kae,RGBA_ETC2_EAC_Format:$F,RGBA_PVRTC_2BPPV1_Format:MF,RGBA_PVRTC_4BPPV1_Format:AF,RGBA_S3TC_DXT1_Format:CF,RGBA_S3TC_DXT3_Format:kF,RGBA_S3TC_DXT5_Format:TF,RGBDEncoding:Q4,RGBEEncoding:M$,RGBEFormat:rae,RGBFormat:jd,RGBIntegerFormat:lae,RGBM16Encoding:J4,RGBM7Encoding:Z4,RGB_ETC1_Format:uae,RGB_ETC2_Format:NF,RGB_PVRTC_2BPPV1_Format:IF,RGB_PVRTC_4BPPV1_Format:EF,RGB_S3TC_DXT1_Format:SF,RGFormat:oae,RGIntegerFormat:aae,RawShaderMaterial:Ff,Ray:ox,Raycaster:gV,RectAreaLight:eM,RedFormat:iae,RedIntegerFormat:sae,ReinhardToneMapping:Hoe,RepeatWrapping:nS,ReplaceStencilOp:Wft,ReverseSubtractEquation:Coe,RingBufferGeometry:PA,RingGeometry:PA,SRGB8_ALPHA8_ASTC_10x10_Format:Fae,SRGB8_ALPHA8_ASTC_10x5_Format:Pae,SRGB8_ALPHA8_ASTC_10x6_Format:Dae,SRGB8_ALPHA8_ASTC_10x8_Format:Oae,SRGB8_ALPHA8_ASTC_12x10_Format:Lae,SRGB8_ALPHA8_ASTC_12x12_Format:zae,SRGB8_ALPHA8_ASTC_4x4_Format:Tae,SRGB8_ALPHA8_ASTC_5x4_Format:Eae,SRGB8_ALPHA8_ASTC_5x5_Format:Iae,SRGB8_ALPHA8_ASTC_6x5_Format:Aae,SRGB8_ALPHA8_ASTC_6x6_Format:Mae,SRGB8_ALPHA8_ASTC_8x5_Format:Nae,SRGB8_ALPHA8_ASTC_8x6_Format:$ae,SRGB8_ALPHA8_ASTC_8x8_Format:Rae,Scene:rV,SceneUtils:bbt,ShaderChunk:Jn,ShaderLib:uu,ShaderMaterial:Ta,ShadowMaterial:Cg,Shape:Kd,ShapeBufferGeometry:ES,ShapeGeometry:ES,ShapePath:cV,ShapeUtils:Nf,ShortType:Koe,Skeleton:wS,SkeletonHelper:Sle,SkinnedMesh:bS,SmoothShading:Dft,Sphere:Op,SphereBufferGeometry:IS,SphereGeometry:IS,Spherical:QF,SphericalHarmonics3:ple,Spline:vV,SplineCurve:Ru,SplineCurve3:$le,SpotLight:YA,SpotLightHelper:w0t,Sprite:gS,SpriteMaterial:mp,SrcAlphaFactor:q4,SrcAlphaSaturateFactor:Roe,SrcColorFactor:Eoe,StaticCopyUsage:odt,StaticDrawUsage:VC,StaticReadUsage:rdt,StereoCamera:gle,StreamCopyUsage:ldt,StreamDrawUsage:ndt,StreamReadUsage:sdt,StringKeyframeTrack:GA,SubtractEquation:Soe,SubtractiveBlending:vF,TOUCH:_f,TangentSpaceNormalMap:Zy,TetrahedronBufferGeometry:DA,TetrahedronGeometry:DA,TextBufferGeometry:OA,TextGeometry:OA,Texture:Kr,TextureLoader:XA,TorusBufferGeometry:FA,TorusGeometry:FA,TorusKnotBufferGeometry:LA,TorusKnotGeometry:LA,Triangle:Xo,TriangleFanDrawMode:Vft,TriangleStripDrawMode:Bft,TrianglesDrawMode:Wae,TubeBufferGeometry:zA,TubeGeometry:zA,UVMapping:E$,Uint16Attribute:rbt,Uint16BufferAttribute:bg,Uint32Attribute:sbt,Uint32BufferAttribute:vg,Uint8Attribute:ebt,Uint8BufferAttribute:cS,Uint8ClampedAttribute:tbt,Uint8ClampedBufferAttribute:uS,Uniform:P$,UniformsLib:Pt,UniformsUtils:Zae,UnsignedByteType:sx,UnsignedInt248Type:Ob,UnsignedIntType:i_,UnsignedShort4444Type:Zoe,UnsignedShort5551Type:Joe,UnsignedShort565Type:Qoe,UnsignedShortType:iS,VSMShadowMap:Sb,Vector2:st,Vector3:Q,Vector4:Gr,VectorKeyframeTrack:wv,Vertex:Z0t,VertexColors:U0t,VideoTexture:FF,WebGL1Renderer:DF,WebGLCubeRenderTarget:nV,WebGLMultisampleRenderTarget:hdt,WebGLRenderTarget:qd,WebGLRenderTargetCube:pbt,WebGLRenderer:WC,WebGLUtils:ale,WireframeGeometry:sV,WireframeHelper:hbt,WrapAroundEnding:aS,XHRLoader:fbt,ZeroCurvatureEnding:Vm,ZeroFactor:koe,ZeroSlopeEnding:Um,ZeroStencilOp:Uft,sRGBEncoding:BC},Symbol.toStringTag,{value:"Module"})),Qy=My(wbt);var RS=function(n,e){e===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),e===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=n,this.domElement=e,this.enabled=!0,this.target=new Q,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={LEFT:xf.ROTATE,MIDDLE:xf.DOLLY,RIGHT:xf.PAN},this.touches={ONE:_f.ROTATE,TWO:_f.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return c.phi},this.getAzimuthalAngle=function(){return c.theta},this.listenToKeyEvents=function(ce){ce.addEventListener("keydown",ye),this._domElementKeyEvents=ce},this.saveState=function(){t.target0.copy(t.target),t.position0.copy(t.object.position),t.zoom0=t.object.zoom},this.reset=function(){t.target.copy(t.target0),t.object.position.copy(t.position0),t.object.zoom=t.zoom0,t.object.updateProjectionMatrix(),t.dispatchEvent(r),t.update(),a=o.NONE},this.update=function(){var ce=new Q,rt=new co().setFromUnitVectors(n.up,new Q(0,1,0)),Et=rt.clone().invert(),yt=new Q,Ht=new co,Mn=2*Math.PI;return function(){var Bi=t.object.position;ce.copy(Bi).sub(t.target),ce.applyQuaternion(rt),c.setFromVector3(ce),t.autoRotate&&a===o.NONE&&M(k()),t.enableDamping?(c.theta+=u.theta*t.dampingFactor,c.phi+=u.phi*t.dampingFactor):(c.theta+=u.theta,c.phi+=u.phi);var Ai=t.minAzimuthAngle,Mi=t.maxAzimuthAngle;return isFinite(Ai)&&isFinite(Mi)&&(Ai<-Math.PI?Ai+=Mn:Ai>Math.PI&&(Ai-=Mn),Mi<-Math.PI?Mi+=Mn:Mi>Math.PI&&(Mi-=Mn),Ai<=Mi?c.theta=Math.max(Ai,Math.min(Mi,c.theta)):c.theta=c.theta>(Ai+Mi)/2?Math.max(Ai,c.theta):Math.min(Mi,c.theta)),c.phi=Math.max(t.minPolarAngle,Math.min(t.maxPolarAngle,c.phi)),c.makeSafe(),c.radius*=h,c.radius=Math.max(t.minDistance,Math.min(t.maxDistance,c.radius)),t.enableDamping===!0?t.target.addScaledVector(f,t.dampingFactor):t.target.add(f),ce.setFromSpherical(c),ce.applyQuaternion(Et),Bi.copy(t.target).add(ce),t.object.lookAt(t.target),t.enableDamping===!0?(u.theta*=1-t.dampingFactor,u.phi*=1-t.dampingFactor,f.multiplyScalar(1-t.dampingFactor)):(u.set(0,0,0),f.set(0,0,0)),h=1,d||yt.distanceToSquared(t.object.position)>l||8*(1-Ht.dot(t.object.quaternion))>l?(t.dispatchEvent(r),yt.copy(t.object.position),Ht.copy(t.object.quaternion),d=!1,!0):!1}}(),this.dispose=function(){t.domElement.removeEventListener("contextmenu",pt),t.domElement.removeEventListener("pointerdown",Ve),t.domElement.removeEventListener("wheel",Ge),t.domElement.removeEventListener("touchstart",Je),t.domElement.removeEventListener("touchend",It),t.domElement.removeEventListener("touchmove",bt),t.domElement.ownerDocument.removeEventListener("pointermove",ft),t.domElement.ownerDocument.removeEventListener("pointerup",Ye),t._domElementKeyEvents!==null&&t._domElementKeyEvents.removeEventListener("keydown",ye)};var t=this,r={type:"change"},i={type:"start"},s={type:"end"},o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},a=o.NONE,l=1e-6,c=new QF,u=new QF,h=1,f=new Q,d=!1,p=new st,m=new st,g=new st,y=new st,b=new st,_=new st,w=new st,S=new st,C=new st;function k(){return 2*Math.PI/60/60*t.autoRotateSpeed}function A(){return Math.pow(.95,t.zoomSpeed)}function M(ce){u.theta-=ce}function E(ce){u.phi-=ce}var N=function(){var ce=new Q;return function(Et,yt){ce.setFromMatrixColumn(yt,0),ce.multiplyScalar(-Et),f.add(ce)}}(),O=function(){var ce=new Q;return function(Et,yt){t.screenSpacePanning===!0?ce.setFromMatrixColumn(yt,1):(ce.setFromMatrixColumn(yt,0),ce.crossVectors(t.object.up,ce)),ce.multiplyScalar(Et),f.add(ce)}}(),R=function(){var ce=new Q;return function(Et,yt){var Ht=t.domElement;if(t.object.isPerspectiveCamera){var Mn=t.object.position;ce.copy(Mn).sub(t.target);var Cr=ce.length();Cr*=Math.tan(t.object.fov/2*Math.PI/180),N(2*Et*Cr/Ht.clientHeight,t.object.matrix),O(2*yt*Cr/Ht.clientHeight,t.object.matrix)}else t.object.isOrthographicCamera?(N(Et*(t.object.right-t.object.left)/t.object.zoom/Ht.clientWidth,t.object.matrix),O(yt*(t.object.top-t.object.bottom)/t.object.zoom/Ht.clientHeight,t.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),t.enablePan=!1)}}();function D(ce){t.object.isPerspectiveCamera?h/=ce:t.object.isOrthographicCamera?(t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom*ce)),t.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function z(ce){t.object.isPerspectiveCamera?h*=ce:t.object.isOrthographicCamera?(t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom/ce)),t.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function B(ce){p.set(ce.clientX,ce.clientY)}function X(ce){w.set(ce.clientX,ce.clientY)}function H(ce){y.set(ce.clientX,ce.clientY)}function te(ce){m.set(ce.clientX,ce.clientY),g.subVectors(m,p).multiplyScalar(t.rotateSpeed);var rt=t.domElement;M(2*Math.PI*g.x/rt.clientHeight),E(2*Math.PI*g.y/rt.clientHeight),p.copy(m),t.update()}function ge(ce){S.set(ce.clientX,ce.clientY),C.subVectors(S,w),C.y>0?D(A()):C.y<0&&z(A()),w.copy(S),t.update()}function ae(ce){b.set(ce.clientX,ce.clientY),_.subVectors(b,y).multiplyScalar(t.panSpeed),R(_.x,_.y),y.copy(b),t.update()}function Ne(ce){ce.deltaY<0?z(A()):ce.deltaY>0&&D(A()),t.update()}function Te(ce){var rt=!1;switch(ce.keyCode){case t.keys.UP:R(0,t.keyPanSpeed),rt=!0;break;case t.keys.BOTTOM:R(0,-t.keyPanSpeed),rt=!0;break;case t.keys.LEFT:R(t.keyPanSpeed,0),rt=!0;break;case t.keys.RIGHT:R(-t.keyPanSpeed,0),rt=!0;break}rt&&(ce.preventDefault(),t.update())}function De(ce){if(ce.touches.length==1)p.set(ce.touches[0].pageX,ce.touches[0].pageY);else{var rt=.5*(ce.touches[0].pageX+ce.touches[1].pageX),Et=.5*(ce.touches[0].pageY+ce.touches[1].pageY);p.set(rt,Et)}}function be(ce){if(ce.touches.length==1)y.set(ce.touches[0].pageX,ce.touches[0].pageY);else{var rt=.5*(ce.touches[0].pageX+ce.touches[1].pageX),Et=.5*(ce.touches[0].pageY+ce.touches[1].pageY);y.set(rt,Et)}}function Ke(ce){var rt=ce.touches[0].pageX-ce.touches[1].pageX,Et=ce.touches[0].pageY-ce.touches[1].pageY,yt=Math.sqrt(rt*rt+Et*Et);w.set(0,yt)}function Oe(ce){t.enableZoom&&Ke(ce),t.enablePan&&be(ce)}function ot(ce){t.enableZoom&&Ke(ce),t.enableRotate&&De(ce)}function He(ce){if(ce.touches.length==1)m.set(ce.touches[0].pageX,ce.touches[0].pageY);else{var rt=.5*(ce.touches[0].pageX+ce.touches[1].pageX),Et=.5*(ce.touches[0].pageY+ce.touches[1].pageY);m.set(rt,Et)}g.subVectors(m,p).multiplyScalar(t.rotateSpeed);var yt=t.domElement;M(2*Math.PI*g.x/yt.clientHeight),E(2*Math.PI*g.y/yt.clientHeight),p.copy(m)}function mt(ce){if(ce.touches.length==1)b.set(ce.touches[0].pageX,ce.touches[0].pageY);else{var rt=.5*(ce.touches[0].pageX+ce.touches[1].pageX),Et=.5*(ce.touches[0].pageY+ce.touches[1].pageY);b.set(rt,Et)}_.subVectors(b,y).multiplyScalar(t.panSpeed),R(_.x,_.y),y.copy(b)}function ht(ce){var rt=ce.touches[0].pageX-ce.touches[1].pageX,Et=ce.touches[0].pageY-ce.touches[1].pageY,yt=Math.sqrt(rt*rt+Et*Et);S.set(0,yt),C.set(0,Math.pow(S.y/w.y,t.zoomSpeed)),D(C.y),w.copy(S)}function Ue(ce){t.enableZoom&&ht(ce),t.enablePan&&mt(ce)}function Be(ce){t.enableZoom&&ht(ce),t.enableRotate&&He(ce)}function Ve(ce){if(t.enabled!==!1)switch(ce.pointerType){case"mouse":case"pen":ee(ce);break}}function ft(ce){if(t.enabled!==!1)switch(ce.pointerType){case"mouse":case"pen":J(ce);break}}function Ye(ce){switch(ce.pointerType){case"mouse":case"pen":it();break}}function ee(ce){ce.preventDefault(),t.domElement.focus?t.domElement.focus():window.focus();var rt;switch(ce.button){case 0:rt=t.mouseButtons.LEFT;break;case 1:rt=t.mouseButtons.MIDDLE;break;case 2:rt=t.mouseButtons.RIGHT;break;default:rt=-1}switch(rt){case xf.DOLLY:if(t.enableZoom===!1)return;X(ce),a=o.DOLLY;break;case xf.ROTATE:if(ce.ctrlKey||ce.metaKey||ce.shiftKey){if(t.enablePan===!1)return;H(ce),a=o.PAN}else{if(t.enableRotate===!1)return;B(ce),a=o.ROTATE}break;case xf.PAN:if(ce.ctrlKey||ce.metaKey||ce.shiftKey){if(t.enableRotate===!1)return;B(ce),a=o.ROTATE}else{if(t.enablePan===!1)return;H(ce),a=o.PAN}break;default:a=o.NONE}a!==o.NONE&&(t.domElement.ownerDocument.addEventListener("pointermove",ft),t.domElement.ownerDocument.addEventListener("pointerup",Ye),t.dispatchEvent(i))}function J(ce){if(t.enabled!==!1)switch(ce.preventDefault(),a){case o.ROTATE:if(t.enableRotate===!1)return;te(ce);break;case o.DOLLY:if(t.enableZoom===!1)return;ge(ce);break;case o.PAN:if(t.enablePan===!1)return;ae(ce);break}}function it(ce){t.domElement.ownerDocument.removeEventListener("pointermove",ft),t.domElement.ownerDocument.removeEventListener("pointerup",Ye),t.enabled!==!1&&(t.dispatchEvent(s),a=o.NONE)}function Ge(ce){t.enabled===!1||t.enableZoom===!1||a!==o.NONE&&a!==o.ROTATE||(ce.preventDefault(),ce.stopPropagation(),t.dispatchEvent(i),Ne(ce),t.dispatchEvent(s))}function ye(ce){t.enabled===!1||t.enablePan===!1||Te(ce)}function Je(ce){if(t.enabled!==!1){switch(ce.preventDefault(),ce.touches.length){case 1:switch(t.touches.ONE){case _f.ROTATE:if(t.enableRotate===!1)return;De(ce),a=o.TOUCH_ROTATE;break;case _f.PAN:if(t.enablePan===!1)return;be(ce),a=o.TOUCH_PAN;break;default:a=o.NONE}break;case 2:switch(t.touches.TWO){case _f.DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;Oe(ce),a=o.TOUCH_DOLLY_PAN;break;case _f.DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;ot(ce),a=o.TOUCH_DOLLY_ROTATE;break;default:a=o.NONE}break;default:a=o.NONE}a!==o.NONE&&t.dispatchEvent(i)}}function bt(ce){if(t.enabled!==!1)switch(ce.preventDefault(),ce.stopPropagation(),a){case o.TOUCH_ROTATE:if(t.enableRotate===!1)return;He(ce),t.update();break;case o.TOUCH_PAN:if(t.enablePan===!1)return;mt(ce),t.update();break;case o.TOUCH_DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;Ue(ce),t.update();break;case o.TOUCH_DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;Be(ce),t.update();break;default:a=o.NONE}}function It(ce){t.enabled!==!1&&(t.dispatchEvent(s),a=o.NONE)}function pt(ce){t.enabled!==!1&&ce.preventDefault()}t.domElement.addEventListener("contextmenu",pt),t.domElement.addEventListener("pointerdown",Ve),t.domElement.addEventListener("wheel",Ge),t.domElement.addEventListener("touchstart",Je),t.domElement.addEventListener("touchend",It),t.domElement.addEventListener("touchmove",bt),this.update()};RS.prototype=Object.create(Wu.prototype);RS.prototype.constructor=RS;var sM=function(n,e){RS.call(this,n,e),this.screenSpacePanning=!1,this.mouseButtons.LEFT=xf.PAN,this.mouseButtons.RIGHT=xf.ROTATE,this.touches.ONE=_f.PAN,this.touches.TWO=_f.DOLLY_ROTATE};sM.prototype=Object.create(Wu.prototype);sM.prototype.constructor=sM;const xbt=Object.freeze(Object.defineProperty({__proto__:null,MapControls:sM,OrbitControls:RS},Symbol.toStringTag,{value:"Module"})),_bt=My(xbt);var HC={};(function(n){Object.defineProperty(n,"__esModule",{value:!0});var e=function(){function r(i,s,o,a,l,c,u){this.pointIndices=i,this.labelStrings=s,this.scaleFactors=o,this.useSceneOpacityFlags=a,this.defaultFontSize=l,this.fillColors=c,this.strokeColors=u}return r}();n.LabelRenderParams=e,function(r){r[r.Perspective=0]="Perspective",r[r.Orthographic=1]="Orthographic"}(n.CameraType||(n.CameraType={}));var t=function(){function r(i,s,o,a,l,c,u,h,f,d,p,m,g,y){this.camera=i,this.cameraType=s,this.cameraTarget=o,this.screenWidth=a,this.screenHeight=l,this.nearestCameraSpacePointZ=c,this.farthestCameraSpacePointZ=u,this.backgroundColor=h,this.pointColors=f,this.pointScaleFactors=d,this.labels=p,this.polylineColors=m,this.polylineOpacities=g,this.polylineWidths=y}return r}();n.RenderContext=t})(HC);var Ys={};Object.defineProperty(Ys,"__esModule",{value:!0});var yu=Qy;function Sbt(n,e,t,r){var i=window.devicePixelRatio,s=new yu.Vector3().copy(r).project(n),o=[(s.x+1)/2*e*i,-((s.y-1)/2*t)*i];return o}Ys.vector3DToScreenCoords=Sbt;function Cbt(n,e){var t=e*3;return new yu.Vector3(n[t],n[t+1],n[t+2])}Ys.vector3FromPackedArray=Cbt;function kbt(n,e,t){for(var r=1/0,i=0,s=new yu.Vector3().copy(t).sub(e),o=new yu.Vector3().copy(s).normalize(),a=n.length/3,l=0,c=new yu.Vector3,u=new yu.Vector3,h=0;h<a;h++){c.x=n[l],c.y=n[l+1],c.z=n[l+2],l+=3,u.copy(c).sub(e);var f=o.dot(u);f<0||(i=f>i?f:i,r=f<r?f:r)}return[r,i]}Ys.getNearFarPoints=kbt;function Rle(n,e){return e===void 0&&(e=!0),n.needsUpdate=e,n.minFilter=yu.LinearFilter,n.generateMipmaps=!1,n.flipY=!1,n}function Tbt(n){var e=new yu.Texture(n);return Rle(e)}Ys.createTextureFromCanvas=Tbt;function Ebt(n,e){var t=new yu.Texture(n);return n.complete?(t.needsUpdate=!0,e()):n.onload=function(){t.needsUpdate=!0,e()},Rle(t,!1)}Ys.createTextureFromImage=Ebt;function Ibt(){try{var n=document.createElement("canvas"),e=n.getContext("webgl")||n.getContext("experimental-webgl");return e!=null}catch{return!1}}Ys.hasWebGLSupport=Ibt;function Abt(n){for(var e=1/0,t=-1/0,r=0;r<n.length;r++){var i=n[r];i<e&&(e=i),i>t&&(t=i)}return[e,t]}Ys.extent=Abt;function Mbt(n,e,t){var r=e[1]-e[0],i=t[1]-t[0],s=(n-e[0])/r;return s*i+t[0]}Ys.scaleLinear=Mbt;function Nbt(n,e,t){var r=Math.pow(e[1],Math.E)-Math.pow(e[0],Math.E),i=t[1]-t[0],s=(Math.pow(n,Math.E)-e[0])/r;return s*i+t[0]}Ys.scaleExponential=Nbt;function $bt(n,e,t,r,i){n[e*3]=t,n[e*3+1]=r,n[e*3+2]=i}Ys.packRgbIntoUint8Array=$bt;function Rbt(n){var e=new yu.Color(n);return[e.r*255|0,e.g*255|0,e.b*255|0]}Ys.styleRgbFromHexColor=Rbt;var uq=function(n){return 100*n+"%"};function Pbt(n,e,t,r,i,s){var o=t+(r-t)*n/e,a="hsl("+o+", "+uq(i)+", "+uq(s)+")";return new yu.Color(a)}Ys.getDefaultPointInPolylineColor=Pbt;var wV={};Object.defineProperty(wV,"__esModule",{value:!0});var Dbt=function(){function n(e,t,r){this.startCoordinates=[0,0],this.svgElement=document.createElementNS("http://www.w3.org/2000/svg","svg"),this.svgElement.style.display="none",this.svgElement.style.height="100%",this.svgElement.style.width="100%",this.svgElement.style.position="absolute",e.insertAdjacentElement("afterbegin",this.svgElement),this.rectElement=document.createElementNS("http://www.w3.org/2000/svg","rect"),this.rectElement.style.stroke=r.select.stroke,this.rectElement.style.strokeDasharray=r.select.strokeDashArray,this.rectElement.style.strokeWidth=""+r.select.strokeWidth,this.rectElement.style.fill=r.select.fill,this.rectElement.style.fillOpacity=""+r.select.fillOpacity,this.svgElement.appendChild(this.rectElement),this.selectionCallback=t,this.isMouseDown=!1}return n.prototype.onMouseDown=function(e,t){this.isMouseDown=!0,this.rectElement.style.display="block",this.svgElement.style.display="block",this.startCoordinates=[e,t],this.lastBoundingBox={x:this.startCoordinates[0],y:this.startCoordinates[1],width:1,height:1}},n.prototype.onMouseMove=function(e,t){this.isMouseDown&&(this.lastBoundingBox.x=Math.min(e,this.startCoordinates[0]),this.lastBoundingBox.y=Math.max(t,this.startCoordinates[1]),this.lastBoundingBox.width=Math.max(e,this.startCoordinates[0])-this.lastBoundingBox.x,this.lastBoundingBox.height=this.lastBoundingBox.y-Math.min(t,this.startCoordinates[1]),this.rectElement.setAttribute("x",""+this.lastBoundingBox.x),this.rectElement.setAttribute("y",""+(this.lastBoundingBox.y-this.lastBoundingBox.height)),this.rectElement.setAttribute("width",""+this.lastBoundingBox.width),this.rectElement.setAttribute("height",""+this.lastBoundingBox.height))},n.prototype.onMouseUp=function(){this.isMouseDown=!1,this.svgElement.style.display="none",this.rectElement.style.display="none",this.rectElement.setAttribute("width","0"),this.rectElement.setAttribute("height","0"),this.selectionCallback(this.lastBoundingBox)},n}();wV.ScatterPlotRectangleSelector=Dbt;var oM=gt&&gt.__assign||function(){return oM=Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++){e=arguments[t];for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(n[i]=e[i])}return n},oM.apply(this,arguments)},DP=gt&&gt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),i,s=[],o;try{for(;(e===void 0||e-- >0)&&!(i=r.next()).done;)s.push(i.value)}catch(a){o={error:a}}finally{try{i&&!i.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return s},hq=gt&&gt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(W4,"__esModule",{value:!0});var _r=Qy,Obt=_bt,OP=HC,Fbt=Ys,Lbt=wV,Ple=2,zbt=5*Ple,Bbt=.025*Ple,Vbt=70,Ubt=.01,Wbt=100,wE=1.2,fq="Shift",dq="Control",Hbt=new _r.Vector3(.45,.9,1.6),Gbt=new _r.Vector3(0,0,0),jbt=new _r.Vector3(0,0,4),qbt=new _r.Vector3(0,0,0),Xbt={mouseRotateSpeed:1,autoRotateSpeed:2,zoomSpeed:.125},Kbt=function(){function n(e,t){var r=this;this.clickCallback=function(){},this.hoverCallback=function(){},this.selectCallback=function(){},this.selectEnabled=!0,this.visualizers=new Map,this.onCameraMoveListeners=[],this.height=0,this.width=0,this.dimensions=3,this.interactionMode="PAN",this.pickingTexture=new _r.WebGLRenderTarget(0,0),this.orbitAnimationOnNextCameraCreation=!1,this.orbitAnimationId=null,this.worldSpacePointPositions=new Float32Array(0),this.pointColors=new Float32Array(0),this.pointScaleFactors=new Float32Array(0),this.polylineColors={},this.polylineOpacities=new Float32Array(0),this.polylineWidths=new Float32Array(0),this.selecting=!1,this.nearestPoint=null,this.mouseIsDown=!1,this.isDragSequence=!1,this.lastHovered=null,this.container=e,this.styles=t.styles,this.setParameters(t),this.computeLayoutValues(),this.scene=new _r.Scene,this.renderer=new _r.WebGLRenderer({alpha:!0,premultipliedAlpha:!1,antialias:!1}),this.renderer.setClearColor(this.styles.backgroundColor,1),this.container.appendChild(this.renderer.domElement),this.light=new _r.PointLight(16772287,1,0),this.scene.add(this.light),this.orbitControlParams=oM(oM({},Xbt),t.orbitControlParams),this.rectangleSelector=new Lbt.ScatterPlotRectangleSelector(this.container,function(i){r.selectBoundingBox(i)},this.styles),this.addInteractionListeners(),this.setDimensions(3),this.makeCamera(t.camera),this.resize()}return n.prototype.setParameters=function(e){e.onClick!==void 0&&(this.clickCallback=e.onClick),e.onHover!==void 0&&(this.hoverCallback=e.onHover),e.onSelect!==void 0&&(this.selectCallback=e.onSelect),e.selectEnabled!==void 0&&(this.selectEnabled=e.selectEnabled)},n.prototype.addInteractionListeners=function(){this.container.addEventListener("pointermove",this.onMouseMove.bind(this)),this.container.addEventListener("pointerdown",this.onMouseDown.bind(this)),this.container.addEventListener("pointerup",this.onMouseUp.bind(this)),this.container.addEventListener("click",this.onClick.bind(this)),window.addEventListener("keydown",this.onKeyDown.bind(this),!1),window.addEventListener("keyup",this.onKeyUp.bind(this),!1)},n.prototype.addCameraControlsEventListeners=function(e){var t=this;e.addEventListener("start",function(){t.stopOrbitAnimation(),t.onCameraMoveListeners.forEach(function(r){return r(t.camera.position,e.target)})}),e.addEventListener("change",function(){t.render()}),e.addEventListener("end",function(){})},n.prototype.makeOrbitControls=function(e,t){this.orbitCameraControls!=null&&this.orbitCameraControls.dispose();var r=new Obt.OrbitControls(e,this.renderer.domElement);r.zoomSpeed=this.orbitControlParams.zoomSpeed,r.enableRotate=t,r.autoRotate=!1,r.enableKeys=!1,r.rotateSpeed=this.orbitControlParams.mouseRotateSpeed,t?(r.mouseButtons.LEFT=_r.MOUSE.LEFT,r.mouseButtons.RIGHT=_r.MOUSE.RIGHT):(r.mouseButtons.LEFT=_r.MOUSE.RIGHT,r.mouseButtons.RIGHT=_r.MOUSE.LEFT),r.reset(),this.camera=e,this.orbitCameraControls=r,this.addCameraControlsEventListeners(this.orbitCameraControls)},n.prototype.makeCamera=function(e){e===void 0&&(e={});var t=this.makeDefaultCameraDef(this.dimensions,e);this.recreateCamera(t),this.dimensions===3&&this.styles.axesVisible?this.add3dAxes():this.remove3dAxesFromScene()},n.prototype.makeCamera3D=function(e,t,r){var i;{var s=t/r;i=new _r.PerspectiveCamera(Vbt,s,Ubt,Wbt),i.position.set(e.position[0],e.position[1],e.position[2]);var o=new _r.Vector3(e.target[0],e.target[1],e.target[2]);i.lookAt(o),i.zoom=e.zoom,i.updateProjectionMatrix()}this.camera=i,this.makeOrbitControls(i,!0)},n.prototype.makeCamera2D=function(e,t,r){var i,s=new _r.Vector3(e.target[0],e.target[1],e.target[2]);{var o=t/r,a=-wE,l=wE,c=-wE,u=wE;o>1?(a*=o,l*=o):(u/=o,c/=o),i=new _r.OrthographicCamera(a,l,u,c,-1e3,1e3),i.position.set(e.position[0],e.position[1],e.position[2]),i.up=new _r.Vector3(0,0,1),i.lookAt(s),i.zoom=e.zoom,i.updateProjectionMatrix()}this.camera=i,this.makeOrbitControls(i,!1)},n.prototype.makeDefaultCameraDef=function(e,t){t===void 0&&(t={});var r=e===2,i=r?jbt:Hbt,s=r?qbt:Gbt,o={orthographic:r,zoom:1,position:[i.x,i.y,i.z],target:[s.x,s.y,s.z]};return t.zoom&&(o.zoom=t.zoom),t.position&&(o.position=t.position),t.target&&(o.target=t.target),o},n.prototype.recreateCamera=function(e){e.orthographic?this.makeCamera2D(e,this.width,this.height):this.makeCamera3D(e,this.width,this.height),this.orbitCameraControls.minDistance=Bbt,this.orbitCameraControls.maxDistance=zbt,this.orbitCameraControls.update(),this.orbitAnimationOnNextCameraCreation&&this.startOrbitAnimation()},n.prototype.setInteractionMode=function(e){this.interactionMode=e,e==="SELECT"?(this.selecting=!0,this.container.style.cursor="crosshair",this.orbitCameraControls.enabled=!1):(this.selecting=!1,this.container.style.cursor="default",this.orbitCameraControls.enabled=!0)},n.prototype.onClick=function(e,t){if(t===void 0&&(t=!0),!(e&&this.selecting)){if(!this.isDragSequence&&t){if(this.selectEnabled){var r=this.nearestPoint!=null?[this.nearestPoint]:[];this.selectCallback(r)}this.clickCallback(this.nearestPoint)}this.isDragSequence=!1,this.render()}},n.prototype.onMouseDown=function(e){this.isDragSequence=!1,this.mouseIsDown=!0,this.selecting?(this.rectangleSelector.onMouseDown(e.offsetX,e.offsetY),this.setNearestPointToMouse(e)):!e.ctrlKey&&this.sceneIs3D()&&this.orbitCameraControls.mouseButtons.ORBIT===_r.MOUSE.RIGHT?(this.orbitCameraControls.mouseButtons.ORBIT=_r.MOUSE.LEFT,this.orbitCameraControls.mouseButtons.PAN=_r.MOUSE.RIGHT):e.ctrlKey&&this.sceneIs3D()&&this.orbitCameraControls.mouseButtons.ORBIT===_r.MOUSE.LEFT&&(this.orbitCameraControls.mouseButtons.ORBIT=_r.MOUSE.RIGHT,this.orbitCameraControls.mouseButtons.PAN=_r.MOUSE.LEFT)},n.prototype.onMouseUp=function(e){this.selecting&&(this.rectangleSelector.onMouseUp(),this.render()),this.mouseIsDown=!1},n.prototype.onMouseMove=function(e){this.isDragSequence=this.mouseIsDown,this.selecting&&this.mouseIsDown?(this.rectangleSelector.onMouseMove(e.offsetX,e.offsetY),this.render()):this.mouseIsDown||(this.setNearestPointToMouse(e),this.nearestPoint!=this.lastHovered&&(this.lastHovered=this.nearestPoint,this.hoverCallback(this.nearestPoint)))},n.prototype.onKeyDown=function(e){e.key===dq&&this.sceneIs3D()&&(this.orbitCameraControls.mouseButtons.ORBIT=_r.MOUSE.RIGHT,this.orbitCameraControls.mouseButtons.PAN=_r.MOUSE.LEFT),e.key===fq&&this.selectEnabled&&(this.selecting=!0,this.orbitCameraControls.enabled=!1,this.container.style.cursor="crosshair")},n.prototype.onKeyUp=function(e){e.key===dq&&this.sceneIs3D()&&(this.orbitCameraControls.mouseButtons.ORBIT=_r.MOUSE.LEFT,this.orbitCameraControls.mouseButtons.PAN=_r.MOUSE.RIGHT),e.key===fq&&this.selectEnabled&&(this.selecting=!1,this.orbitCameraControls.enabled=!0,this.container.style.cursor="default",this.render())},n.prototype.getPointIndicesFromBoundingBox=function(e){if(this.worldSpacePointPositions==null)return[];this.camera.updateMatrixWorld();var t=window.devicePixelRatio||1,r=Math.floor(e.x*t),i=Math.floor(e.y*t),s=Math.max(Math.floor(e.width*t),1),o=Math.max(Math.floor(e.height*t),1);if(s<=2&&o<=2)return this.getPointIndicesFromBoundingBoxPickingTexture(e);for(var a=this.renderer.domElement,l=a.width,c=a.height,u=[],h=new _r.Vector3,f=0;f<this.worldSpacePointPositions.length;f++){var d=f*3,p=DP(this.worldSpacePointPositions.slice(d,d+3),3),m=p[0],g=p[1],y=p[2];h.x=m,h.y=g,h.z=y;var b=h.project(this.camera),_=(b.x+1)*l/2,w=-(b.y-1)*c/2;_>=r&&_<=r+s&&w<=i&&w>=i-o&&u.push(f)}return u},n.prototype.getPointIndicesFromBoundingBoxPickingTexture=function(e){if(this.worldSpacePointPositions==null)return[];var t=this.worldSpacePointPositions.length/3,r=window.devicePixelRatio||1,i=Math.floor(e.x*r),s=Math.floor(e.y*r),o=Math.max(Math.floor(e.width*r),1),a=Math.max(Math.floor(e.height*r),1),l=new Uint8Array(o*a*4);this.renderer.readRenderTargetPixels(this.pickingTexture,i,this.pickingTexture.height-s,o,a,l);for(var c=new Uint8Array(this.worldSpacePointPositions.length),u=0;u<o*a;u++){var h=l[u*4]<<16|l[u*4+1]<<8|l[u*4+2];h!==16777215&&h<t&&(c[h]=1)}for(var f=[],u=0;u<c.length;u++)c[u]===1&&f.push(u);return f},n.prototype.selectBoundingBox=function(e){var t=this.getPointIndicesFromBoundingBox(e);this.selectCallback(t)},n.prototype.setNearestPointToMouse=function(e){if(this.pickingTexture==null){this.nearestPoint=null;return}var t={x:e.offsetX,y:e.offsetY,width:1,height:1},r=this.getPointIndicesFromBoundingBoxPickingTexture(t);this.nearestPoint=r.length?r[0]:null},n.prototype.computeLayoutValues=function(){return this.width=this.container.offsetWidth,this.height=Math.max(1,this.container.offsetHeight),[this.width,this.height]},n.prototype.sceneIs3D=function(){return this.dimensions===3},n.prototype.remove3dAxesFromScene=function(){var e=this.scene.getObjectByName("axes");return e!=null&&this.scene.remove(e),e},n.prototype.add3dAxes=function(){var e=new _r.AxesHelper;e.name="axes",this.scene.add(e)},n.prototype.setDimensions=function(e){if(e!==2&&e!==3)throw new RangeError("dimensions must be 2 or 3");this.dimensions!==e&&(this.dimensions=e,this.makeCamera())},n.prototype.getCameraPosition=function(){var e=this.camera.position;return[e.x,e.y,e.z]},n.prototype.getCameraTarget=function(){var e=this.orbitCameraControls.target;return[e.x,e.y,e.z]},n.prototype.setCameraPositionAndTarget=function(e,t){this.stopOrbitAnimation(),this.camera.position.set(e[0],e[1],e[2]),this.orbitCameraControls.target.set(t[0],t[1],t[2]),this.orbitCameraControls.update(),this.render()},n.prototype.startOrbitAnimation=function(){this.sceneIs3D()&&(this.orbitAnimationId!=null&&this.stopOrbitAnimation(),this.orbitCameraControls.autoRotate=!0,this.orbitCameraControls.autoRotateSpeed=this.orbitControlParams.autoRotateSpeed,this.updateOrbitAnimation())},n.prototype.orbitIsAnimating=function(){return this.orbitAnimationId!=null},n.prototype.updateOrbitAnimation=function(){var e=this;this.orbitCameraControls.update(),this.orbitAnimationId=requestAnimationFrame(function(){return e.updateOrbitAnimation()})},n.prototype.stopOrbitAnimation=function(){this.orbitCameraControls.autoRotate=!1,this.orbitCameraControls.rotateSpeed=this.orbitControlParams.mouseRotateSpeed,this.orbitAnimationId!=null&&(cancelAnimationFrame(this.orbitAnimationId),this.orbitAnimationId=null)},n.prototype.setActiveVisualizers=function(e){var t,r,i,s,o=new Set(e.map(function(f){return f.id}));try{for(var a=hq(this.visualizers.values()),l=a.next();!l.done;l=a.next()){var c=l.value;o.has(c.id)||(c.dispose(),this.visualizers.delete(c.id))}}catch(f){t={error:f}}finally{try{l&&!l.done&&(r=a.return)&&r.call(a)}finally{if(t)throw t.error}}try{for(var u=hq(e),h=u.next();!h.done;h=u.next()){var c=h.value;this.visualizers.set(c.id,c),c.setScene(this.scene),c.onResize(this.width,this.height),this.worldSpacePointPositions&&c.onPointPositionsChanged(this.worldSpacePointPositions)}}catch(f){i={error:f}}finally{try{h&&!h.done&&(s=u.return)&&s.call(u)}finally{if(i)throw i.error}}},n.prototype.disposeAllVisualizers=function(){this.visualizers.forEach(function(e){return e.dispose()}),this.visualizers.clear()},n.prototype.setPointPositions=function(e){this.worldSpacePointPositions=e,this.visualizers.forEach(function(t){return t.onPointPositionsChanged(e)})},n.prototype.render=function(){{var e=this.camera.position.clone();e.x+=1,e.y+=1,this.light.position.set(e.x,e.y,e.z)}var t=this.camera instanceof _r.PerspectiveCamera?OP.CameraType.Perspective:OP.CameraType.Orthographic,r=[0,0];this.worldSpacePointPositions!=null&&(r=Fbt.getNearFarPoints(this.worldSpacePointPositions,this.camera.position,this.orbitCameraControls.target));var i=new OP.RenderContext(this.camera,t,this.orbitCameraControls.target,this.width,this.height,r[0],r[1],this.styles.backgroundColor,this.pointColors,this.pointScaleFactors,this.labels,this.polylineColors,this.polylineOpacities,this.polylineWidths);this.visualizers.forEach(function(o){return o.onPickingRender(i)});{var s=this.remove3dAxesFromScene();this.renderer.setRenderTarget(this.pickingTexture),this.renderer.render(this.scene,this.camera),s!=null&&this.scene.add(s)}this.visualizers.forEach(function(o){return o.onRender(i)}),this.renderer.setRenderTarget(null),this.renderer.render(this.scene,this.camera)},n.prototype.setPointColors=function(e){this.pointColors=e},n.prototype.setPointScaleFactors=function(e){this.pointScaleFactors=e},n.prototype.setLabels=function(e){this.labels=e},n.prototype.setPolylineColors=function(e){this.polylineColors=e},n.prototype.setPolylineOpacities=function(e){this.polylineOpacities=e},n.prototype.setPolylineWidths=function(e){this.polylineWidths=e},n.prototype.resetZoom=function(){this.recreateCamera(this.makeDefaultCameraDef(this.dimensions)),this.render()},n.prototype.setDayNightMode=function(e){for(var t=this.container.querySelectorAll("canvas"),r=e?"invert(100%)":"",i=0;i<t.length;i++)t[i].style.filter=r},n.prototype.resize=function(e){e===void 0&&(e=!0);var t=DP([this.width,this.height],2),r=t[0],i=t[1],s=DP(this.computeLayoutValues(),2),o=s[0],a=s[1];if(this.dimensions===3){var l=this.camera;l.aspect=o/a,l.updateProjectionMatrix()}else{var l=this.camera,c=o/r,u=a/i,h=(l.right-l.left)*c/2,f=(l.top-l.bottom)*u/2;l.top=f,l.bottom=-f,l.left=-h,l.right=h,l.updateProjectionMatrix()}var d=window.devicePixelRatio||1;this.renderer.setPixelRatio(d),this.renderer.setSize(o,a);{var p=new _r.Vector2;this.renderer.getSize(p);var m=this.renderer.getPixelRatio();this.pickingTexture=new _r.WebGLRenderTarget(p.width*m,p.height*m),this.pickingTexture.texture.minFilter=_r.LinearFilter}this.visualizers.forEach(function(g){return g.onResize(o,a)}),e&&this.render()},n.prototype.onCameraMove=function(e){this.onCameraMoveListeners.push(e)},n.prototype.clickOnPoint=function(e){this.nearestPoint=e,this.onClick(null,!1)},n}();W4.ScatterPlot=Kbt;var xV={},Ybt=gt&&gt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),i,s=[],o;try{for(;(e===void 0||e-- >0)&&!(i=r.next()).done;)s.push(i.value)}catch(a){o={error:a}}finally{try{i&&!i.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return s};Object.defineProperty(xV,"__esModule",{value:!0});var Zbt=Qy,FP=new Map,Jbt=/^(rgba|hsla)\((\d+),\s*(\d+%?),\s*(\d+%?)(?:,\s*(\d+(?:\.\d+)?))?\)$/;function Qbt(n){var e=Jbt.exec(n);if(e){var t=Ybt(e,6);t[0];var r=t[1],i=t[2],s=t[3],o=t[4],a=t[5],l=r.replace("a","")+"("+i+","+s+","+o+")";return{colorString:l,opacity:parseFloat(a)}}return{colorString:n,opacity:1}}function evt(n){if(FP.has(n))return FP.get(n);var e=Qbt(n),t=e.colorString,r=e.opacity,i=new Zbt.Color(t),s=i.r,o=i.g,a=i.b,l={r:s,g:o,b:a,opacity:r};return FP.set(n,l),l}xV.parseColor=evt;var D$={},tvt=gt&&gt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(D$,"__esModule",{value:!0});var pq="Points must be an array of either 2 or 3 dimensional number arrays",nvt=function(){function n(e,t){var r,i;t===void 0&&(t=[]),this.points=e,this.metadata=t;var s=e[0].length;if(!(s===2||s===3))throw new Error(pq);try{for(var o=tvt(e),a=o.next();!a.done;a=o.next()){var l=a.value;if(s!==l.length)throw new Error(pq)}}catch(c){r={error:c}}finally{try{a&&!a.done&&(i=o.return)&&i.call(o)}finally{if(r)throw r.error}}this.dimensions=s}return n.prototype.setSpriteMetadata=function(e){this.spriteMetadata=e},n}();D$.Dataset=nvt;var _V={};Object.defineProperty(_V,"__esModule",{value:!0});var rvt=function(){var n={backgroundColor:"#ffffff",axesVisible:!0,fog:{color:"#ffffff",enabled:!0,threshold:5e3},label:{fontSize:10,scaleDefault:1,scaleLarge:2,fillColorSelected:"#000000",fillColorHover:"#000000",strokeColorSelected:"#ffffff",strokeColorHover:"#ffffff",strokeWidth:3,fillWidth:6},label3D:{fontSize:80,scale:2.2,color:"black",backgroundColor:"#ffffff",colorUnselected:"#ffffff",colorNoSelection:"#ffffff"},point:{colorUnselected:"rgba(227, 227, 227, 0.7)",colorNoSelection:"rgba(117, 117, 217, 0.7)",colorSelected:"rgba(250, 102, 102, 0.7)",colorHover:"rgba(118, 11, 79, 0.7)",scaleDefault:1,scaleSelected:1.2,scaleHover:1.2},polyline:{startHue:60,endHue:360,saturation:1,lightness:.3,defaultOpacity:.2,defaultLineWidth:2,selectedOpacity:.9,selectedLineWidth:3,deselectedOpacity:.05},select:{fill:"#dddddd",fillOpacity:.2,stroke:"#aaaaaa",strokeWidth:2,strokeDashArray:"10 5"},sprites:{minPointSize:5,imageSize:30,colorUnselected:"#ffffff",colorNoSelection:"#ffffff"}};return n};function ivt(n){var e=rvt();if(n===void 0)return e;for(var t in e){var r=t;typeof e[r]=="object"&&typeof n[r]=="object"?e[r]=Object.assign(e[r],n[r]):n[r]!==void 0&&(e[r]=n[r])}return e}_V.makeStyles=ivt;var Hu={};Object.defineProperty(Hu,"__esModule",{value:!0});Hu.RGB_NUM_ELEMENTS=3;Hu.RGBA_NUM_ELEMENTS=4;Hu.XYZ_NUM_ELEMENTS=3;Hu.UV_NUM_ELEMENTS=2;Hu.INDEX_NUM_ELEMENTS=1;Hu.SCATTER_PLOT_CUBE_LENGTH=2;var SV={};Object.defineProperty(SV,"__esModule",{value:!0});var hf=Qy,mq=Ys,ro=Hu,LP=8192,zP=256,ha=2*3,svt=function(n,e){return`
      attribute vec2 posObj;
      attribute vec4 color;
      varying vec2 vUv;
      varying vec4 vColor;

      void main() {
        vUv = uv;
        vColor = color;

        // Rotate label to face camera.

        vec4 vRight = vec4(
          modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0], 0);

        vec4 vUp = vec4(
          modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1], 0);

        vec4 vAt = -vec4(
          modelViewMatrix[0][2], modelViewMatrix[1][2], modelViewMatrix[2][2], 0);

        mat4 pointToCamera = mat4(vRight, vUp, vAt, vec4(0, 0, 0, 1));

        vec2 scaledPos = posObj * `+1/n+" * "+e+`;

        vec4 posRotated = pointToCamera * vec4(scaledPos, 0, 1);
        vec4 mvPosition = modelViewMatrix * (vec4(position, 0) + posRotated);
        gl_Position = projectionMatrix * mvPosition;
      }`},ovt=`
      uniform sampler2D glyphTexture;
      uniform bool picking;
      varying vec2 vUv;
      varying vec4 vColor;

      void main() {
        if (picking) {
          gl_FragColor = vColor;
        } else {
          vec4 fromTexture = texture(glyphTexture, vUv);
          gl_FragColor = vColor * fromTexture;
        }
      }`,avt=function(){function n(e){this.styles=e,this.id="3D_LABELS",this.labelStrings=[],this.worldSpacePointPositions=new Float32Array(0),this.pickingColors=new Float32Array(0),this.renderColors=new Float32Array(0),this.uniforms={},this.totalVertexCount=0,this.labelVertexMap=[]}return n.prototype.createGlyphTexture=function(){var e=this.styles.label3D,t=e.fontSize,r=e.backgroundColor,i=e.color,s=document.createElement("canvas");s.width=LP,s.height=t;var o=s.getContext("2d");o.font="bold "+t+"px roboto",o.textBaseline="top",o.fillStyle=r,o.rect(0,0,s.width,s.height),o.fill(),o.fillStyle=i;for(var a=o.measureText(" ").width,l=new Float32Array(zP),c=new Float32Array(zP),u=0,h=0;h<zP;h++){var f=" "+String.fromCharCode(h),d=o.measureText(f).width;l[h]=d-a,c[h]=u,o.fillText(f,u-a,0),u+=d}var p=mq.createTextureFromCanvas(s);return{texture:p,lengths:l,offsets:c}},n.prototype.processLabelVerts=function(e){var t=0;this.labelVertexMap=[];for(var r=0;r<e;r++){for(var i=this.labelStrings[r],s=[],o=0;o<i.length;o++){for(var a=0;a<ha;a++)s.push(t*ha+a);t++}this.labelVertexMap.push(s)}this.totalVertexCount=t*ha},n.prototype.createColorBuffers=function(e){var t=this;this.pickingColors=new Float32Array(this.totalVertexCount*ro.RGB_NUM_ELEMENTS),this.renderColors=new Float32Array(this.totalVertexCount*ro.RGB_NUM_ELEMENTS);for(var r=function(o){var a=new hf.Color(o);i.labelVertexMap[o].forEach(function(l){t.pickingColors[ro.RGB_NUM_ELEMENTS*l]=a.r,t.pickingColors[ro.RGB_NUM_ELEMENTS*l+1]=a.g,t.pickingColors[ro.RGB_NUM_ELEMENTS*l+2]=a.b,t.renderColors[ro.RGB_NUM_ELEMENTS*l]=1,t.renderColors[ro.RGB_NUM_ELEMENTS*l+1]=1,t.renderColors[ro.RGB_NUM_ELEMENTS*l+2]=1})},i=this,s=0;s<e;s++)r(s)},n.prototype.createLabels=function(){var e=this,t=this.styles.label3D,r=t.fontSize,i=t.scale;if(!(this.labelStrings==null||this.worldSpacePointPositions==null)){var s=this.worldSpacePointPositions.length/ro.XYZ_NUM_ELEMENTS;if(s===this.labelStrings.length){this.glyphTexture=this.createGlyphTexture(),this.uniforms={glyphTexture:{value:null},picking:{value:!1}},this.material=new hf.ShaderMaterial({uniforms:this.uniforms,transparent:!0,vertexShader:svt(r,i),fragmentShader:ovt}),this.processLabelVerts(s),this.createColorBuffers(s);var o=new Float32Array(this.totalVertexCount*ro.XYZ_NUM_ELEMENTS);this.positions=new hf.BufferAttribute(o,ro.XYZ_NUM_ELEMENTS);var a=new Float32Array(this.totalVertexCount*ro.XYZ_NUM_ELEMENTS),l=new Float32Array(this.totalVertexCount*ro.UV_NUM_ELEMENTS),c=new Float32Array(this.totalVertexCount*ro.RGB_NUM_ELEMENTS),u=new hf.BufferAttribute(a,2),h=new hf.BufferAttribute(l,ro.UV_NUM_ELEMENTS),f=new hf.BufferAttribute(c,ro.RGB_NUM_ELEMENTS);this.geometry=new hf.BufferGeometry,this.geometry.setAttribute("posObj",u),this.geometry.setAttribute("position",this.positions),this.geometry.setAttribute("uv",h),this.geometry.setAttribute("color",f);for(var d=0,p=0;p<s;p++){for(var m=this.labelStrings[p],g=0,y=0;y<m.length;y++){var b=m.charCodeAt(y);g+=this.glyphTexture.lengths[b]}g/=-2;for(var y=0;y<m.length;y++){var b=m.charCodeAt(y),_=this.glyphTexture.lengths[b],w=r,S=(g+_)/w,C=g/w,k=r/w;u.setXY(d*ha+0,C,0),u.setXY(d*ha+1,S,0),u.setXY(d*ha+2,C,k),u.setXY(d*ha+3,C,k),u.setXY(d*ha+4,S,0),u.setXY(d*ha+5,S,k);var A=this.glyphTexture.offsets[b],M=this.glyphTexture.offsets[b]+_;A/=LP,M/=LP;var E=1,N=0;h.setXY(d*ha+0,A,E),h.setXY(d*ha+1,M,E),h.setXY(d*ha+2,A,N),h.setXY(d*ha+3,A,N),h.setXY(d*ha+4,M,E),h.setXY(d*ha+5,M,N),d++,g+=_}}for(var O=function(D){var z=mq.vector3FromPackedArray(R.worldSpacePointPositions,D);R.labelVertexMap[D].forEach(function(B){e.positions.setXYZ(B,z.x,z.y,z.z)})},R=this,p=0;p<s;p++)O(p);this.labelsMesh=new hf.Mesh(this.geometry,this.material),this.labelsMesh.frustumCulled=!1,this.scene.add(this.labelsMesh)}}},n.prototype.colorLabels=function(e){if(!(this.labelStrings==null||this.geometry==null||e==null)){var t=this.geometry.getAttribute("color");t.array=this.renderColors;for(var r=e.length/ro.RGBA_NUM_ELEMENTS,i=0,s=0;s<r;++s){for(var o=new hf.Color(e[i],e[i+1],e[i+2]),a=this.labelVertexMap[s].length,l=0;l<a;++l)t.setXYZ(this.labelVertexMap[s][l],o.r,o.g,o.b);i+=ro.RGBA_NUM_ELEMENTS}t.needsUpdate=!0}},n.prototype.setScene=function(e){this.scene=e},n.prototype.dispose=function(){this.labelsMesh&&(this.scene&&this.scene.remove(this.labelsMesh),this.labelsMesh=null),this.geometry&&(this.geometry.dispose(),this.geometry=null),this.glyphTexture!=null&&this.glyphTexture.texture!=null&&(this.glyphTexture.texture.dispose(),this.glyphTexture.texture=null)},n.prototype.onPickingRender=function(e){if(this.geometry==null){this.createLabels();return}this.material.uniforms.glyphTexture.value=this.glyphTexture.texture,this.material.uniforms.picking.value=!0;var t=this.geometry.getAttribute("color");t.array=this.pickingColors,t.needsUpdate=!0},n.prototype.onRender=function(e){if(this.geometry==null){this.createLabels();return}this.colorLabels(e.pointColors),this.material.uniforms.glyphTexture.value=this.glyphTexture.texture,this.material.uniforms.picking.value=!1;var t=this.geometry.getAttribute("color");t.array=this.renderColors,t.needsUpdate=!0},n.prototype.onPointPositionsChanged=function(e){this.worldSpacePointPositions=e,this.dispose()},n.prototype.setLabelStrings=function(e){this.labelStrings=e,this.dispose()},n.prototype.onResize=function(e,t){},n}();SV.ScatterPlotVisualizer3DLabels=avt;var CV={};Object.defineProperty(CV,"__esModule",{value:!0});var Lo=Qy,lvt=HC,gq=Ys,nc=Hu,yq=function(n){return`
    // Index of the specific vertex (passed in as bufferAttribute), and the
    // variable that will be used to pass it to the fragment shader.
    attribute float spriteIndex;
    attribute vec4 color;
    attribute float scaleFactor;

    varying vec2 xyIndex;
    varying vec4 vColor;

    uniform bool sizeAttenuation;
    uniform float pointSize;
    uniform float spritesPerRow;
    uniform float spritesPerColumn;

    varying float fogDepth;

    void main() {
      // Pass index and color values to fragment shader.
      vColor = color;
      xyIndex = vec2(mod(spriteIndex, spritesPerRow),
                floor(spriteIndex / spritesPerColumn));

      // Transform current vertex by modelViewMatrix (model world position and
      // camera world position matrix).
      vec4 cameraSpacePos = modelViewMatrix * vec4(position, 1.0);

      // Project vertex in camera-space to screen coordinates using the camera's
      // projection matrix.
      gl_Position = projectionMatrix * cameraSpacePos;

      // Create size attenuation (if we're in 3D mode) by making the size of
      // each point inversly proportional to its distance to the camera.
      float outputPointSize = pointSize;
      if (sizeAttenuation) {
        outputPointSize = -pointSize / cameraSpacePos.z;
        fogDepth = pointSize / outputPointSize * 1.2;
      } else {  // Create size attenuation (if we're in 2D mode)
        const float PI = 3.1415926535897932384626433832795;
        const float minScale = 0.1;  // minimum scaling factor
        const float outSpeed = 2.0;  // shrink speed when zooming out
        const float outNorm = (1. - minScale) / atan(outSpeed);
        const float maxScale = 15.0;  // maximum scaling factor
        const float inSpeed = 0.02;  // enlarge speed when zooming in
        const float zoomOffset = 0.3;  // offset zoom pivot
        float zoom = projectionMatrix[0][0] + zoomOffset;  // zoom pivot
        float scale = zoom < 1. ? 1. + outNorm * atan(outSpeed * (zoom - 1.)) :
                      1. + 2. / PI * (maxScale - 1.) * atan(inSpeed * (zoom - 1.));
        outputPointSize = pointSize * scale;
      }

      gl_PointSize =
        max(outputPointSize * scaleFactor, `+n.toFixed(1)+`);
    }`},Dle=`
    bool point_in_unit_circle(vec2 spriteCoord) {
      vec2 centerToP = spriteCoord - vec2(0.5, 0.5);
      return dot(centerToP, centerToP) < (0.5 * 0.5);
    }

    bool point_in_unit_equilateral_triangle(vec2 spriteCoord) {
      vec3 v0 = vec3(0, 1, 0);
      vec3 v1 = vec3(0.5, 0, 0);
      vec3 v2 = vec3(1, 1, 0);
      vec3 p = vec3(spriteCoord, 0);
      float p_in_v0_v1 = cross(v1 - v0, p - v0).z;
      float p_in_v1_v2 = cross(v2 - v1, p - v1).z;
      return (p_in_v0_v1 > 0.0) && (p_in_v1_v2 > 0.0);
    }

    bool point_in_unit_square(vec2 spriteCoord) {
      return true;
    }
  `,cvt=`
    varying vec2 xyIndex;
    varying vec4 vColor;

    uniform sampler2D spriteTexture;
    uniform float spritesPerRow;
    uniform float spritesPerColumn;
    uniform bool isImage;

    `+Lo.ShaderChunk.common+`
    `+Dle+`
    uniform vec3 fogColor;
    varying float fogDepth;
		uniform float fogNear;
    uniform float fogFar;

    void main() {
      if (isImage) {
        // Coordinates of the vertex within the entire sprite image.
        vec2 coords =
          (gl_PointCoord + xyIndex) / vec2(spritesPerRow, spritesPerColumn);
        gl_FragColor = vColor * texture(spriteTexture, coords);
      } else {
        bool inside = point_in_unit_circle(gl_PointCoord);
        if (!inside) {
          discard;
        }
        gl_FragColor = vColor;
      }
      float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
      gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
    }`,uvt=`
    varying vec2 xyIndex;
    varying vec4 vColor;
    uniform bool isImage;

    `+Dle+`

    varying float fogDepth;

    void main() {
      xyIndex; // Silence 'unused variable' warning.
      fogDepth; // Silence 'unused variable' warning.
      if (isImage) {
        gl_FragColor = vColor;
      } else {
        bool inside = point_in_unit_circle(gl_PointCoord);
        if (!inside) {
          discard;
        }
        gl_FragColor = vColor;
      }
    }`,hvt=function(){function n(e,t){this.styles=e,this.id="SPRITES",this.isSpriteSheetMode=!1,this.spritesPerRow=0,this.spritesPerColumn=0,this.spriteDimensions=[0,0],this.worldSpacePointPositions=new Float32Array(0),this.pickingColors=new Float32Array(0),this.renderColors=new Float32Array(0),this.standinTextureForPoints=gq.createTextureFromCanvas(document.createElement("canvas")),t&&(this.spriteSheetParams=t,this.setSpriteSheet(t),this.isSpriteSheetMode=!0),this.renderMaterial=this.createRenderMaterial(),this.pickingMaterial=this.createPickingMaterial()}return n.prototype.createUniforms=function(){return{spriteTexture:{type:"t"},spritesPerRow:{type:"f"},spritesPerColumn:{type:"f"},fogColor:{type:"c"},fogNear:{type:"f"},fogFar:{type:"f"},isImage:{type:"bool"},sizeAttenuation:{type:"bool"},pointSize:{type:"f"}}},n.prototype.createRenderMaterial=function(){this.isSpriteSheetMode;var e=this.createUniforms();return new Lo.ShaderMaterial({uniforms:e,vertexShader:yq(this.styles.sprites.minPointSize),fragmentShader:cvt,transparent:!0,depthFunc:Lo.LessDepth,fog:this.styles.fog.enabled,blending:Lo.NormalBlending})},n.prototype.createPickingMaterial=function(){var e=this.createUniforms();return new Lo.ShaderMaterial({uniforms:e,vertexShader:yq(this.styles.sprites.minPointSize),fragmentShader:uvt,transparent:!0,depthTest:!0,depthWrite:!0,fog:!1,blending:Lo.NormalBlending})},n.prototype.createPointSprites=function(e,t){var r=t!=null?t.length/nc.XYZ_NUM_ELEMENTS:0,i=this.createGeometry(r);this.fog=new Lo.Fog(16777215),this.points=new Lo.Points(i,this.renderMaterial),this.points.frustumCulled=!1,this.spriteIndexBufferAttribute!=null&&this.points.geometry.setAttribute("spriteIndex",this.spriteIndexBufferAttribute),e.add(this.points)},n.prototype.calculatePointSize=function(e){var t=this.styles.sprites.imageSize;if(this.texture)return e?t:this.spriteDimensions[0];var r=this.worldSpacePointPositions!=null?this.worldSpacePointPositions.length/nc.XYZ_NUM_ELEMENTS:1,i=200,s=8,o=1.5,a=i/Math.log(r)/Math.log(s);return e?a:a/o},n.prototype.createGeometry=function(e){var t=e;this.pickingColors=new Float32Array(t*nc.RGBA_NUM_ELEMENTS);for(var r=0,i=0;i<t;i++){var s=new Lo.Color(i);this.pickingColors[r++]=s.r,this.pickingColors[r++]=s.g,this.pickingColors[r++]=s.b,this.pickingColors[r++]=1}var o=new Lo.BufferGeometry;return o.setAttribute("position",new Lo.BufferAttribute(new Float32Array([]),nc.XYZ_NUM_ELEMENTS)),o.setAttribute("color",new Lo.BufferAttribute(new Float32Array([]),nc.RGBA_NUM_ELEMENTS)),o.setAttribute("scaleFactor",new Lo.BufferAttribute(new Float32Array([]),nc.INDEX_NUM_ELEMENTS)),o.computeVertexNormals(),o},n.prototype.setFogDistances=function(e,t,r){var i=this.styles.fog,s=i.threshold,o=i.enabled;if(e&&o){this.fog.near=t;var a=t-r;this.fog.far=t-s*a}else this.fog.near=1/0,this.fog.far=1/0},n.prototype.dispose=function(){this.disposeGeometry(),this.disposeSpriteSheet()},n.prototype.disposeGeometry=function(){this.points!=null&&(this.scene.remove(this.points),this.points.geometry.dispose(),this.points=null,this.worldSpacePointPositions=null)},n.prototype.disposeSpriteSheet=function(){this.texture&&this.texture.dispose(),this.texture=null,this.renderMaterial=null,this.pickingMaterial=null,this.spriteSheetImage=null},n.prototype.setScene=function(e){this.scene=e},n.prototype.setSpriteSheet=function(e){var t=this,r=e.spriteDimensions,i=e.onImageLoad,s=e.spritesheetImage;if(typeof s=="string"){var o=s;s=new Image,s.src=o}this.spriteSheetImage=s,this.texture=gq.createTextureFromImage(this.spriteSheetImage,function(){t.spritesPerRow=t.spriteSheetImage.width/r[0],t.spritesPerColumn=t.spriteSheetImage.height/r[1],i()}),this.spriteDimensions=r,this.setSpriteIndexBuffer()},n.prototype.setSpriteIndexBuffer=function(){var e=this.spriteSheetParams.spriteIndices;this.spriteIndexBufferAttribute=new Lo.BufferAttribute(e,nc.INDEX_NUM_ELEMENTS),this.points!=null&&this.points.geometry.setAttribute("spriteIndex",this.spriteIndexBufferAttribute)},n.prototype.onPointPositionsChanged=function(e){this.points!=null&&this.worldSpacePointPositions.length!==e.length&&this.disposeGeometry(),this.worldSpacePointPositions=e,this.points==null&&this.createPointSprites(this.scene,e),this.spriteSheetParams&&this.setSpriteIndexBuffer(),this.renderMaterial=this.createRenderMaterial(),this.pickingMaterial=this.createPickingMaterial();var t=this.points.geometry.getAttribute("position");t.array=e,t.count=e.length/nc.XYZ_NUM_ELEMENTS,t.needsUpdate=!0},n.prototype.onPickingRender=function(e){var t=e.cameraType===lvt.CameraType.Perspective;this.pickingMaterial.uniforms.spritesPerRow.value=this.spritesPerRow,this.pickingMaterial.uniforms.spritesPerRow.value=this.spritesPerColumn,this.pickingMaterial.uniforms.sizeAttenuation.value=t,this.pickingMaterial.uniforms.pointSize.value=this.calculatePointSize(t),this.points.material=this.pickingMaterial;var r=this.points.geometry.getAttribute("color");r.array=this.pickingColors,r.count=this.pickingColors.length/nc.RGBA_NUM_ELEMENTS,r.needsUpdate=!0;var i=this.points.geometry.getAttribute("scaleFactor");i.array=e.pointScaleFactors,i.count=e.pointScaleFactors.length,i.count=e.pointScaleFactors.length/nc.INDEX_NUM_ELEMENTS,i.needsUpdate=!0},n.prototype.onRender=function(e){var t=e.camera instanceof Lo.PerspectiveCamera;this.setFogDistances(t,e.nearestCameraSpacePointZ,e.farthestCameraSpacePointZ),this.scene.fog=this.fog,this.scene.fog.color=new Lo.Color(e.backgroundColor),this.renderMaterial.uniforms.fogColor.value=this.scene.fog.color,this.renderMaterial.uniforms.fogNear.value=this.fog.near,this.renderMaterial.uniforms.fogFar.value=this.fog.far,this.renderMaterial.uniforms.spritesPerRow.value=this.spritesPerRow,this.renderMaterial.uniforms.spritesPerColumn.value=this.spritesPerColumn,this.renderMaterial.uniforms.isImage.value=this.texture!=null,this.renderMaterial.uniforms.spriteTexture.value=this.texture!=null?this.texture:this.standinTextureForPoints,this.renderMaterial.uniforms.sizeAttenuation.value=t,this.renderMaterial.uniforms.pointSize.value=this.calculatePointSize(t),this.points.material=this.renderMaterial;var r=this.points.geometry.getAttribute("color");this.renderColors=e.pointColors,r.array=this.renderColors,r.count=this.renderColors.length/nc.RGBA_NUM_ELEMENTS,r.needsUpdate=!0;var i=this.points.geometry.getAttribute("scaleFactor");i.array=e.pointScaleFactors,i.count=e.pointScaleFactors.length/nc.INDEX_NUM_ELEMENTS,i.needsUpdate=!0},n.prototype.onResize=function(e,t){},n}();CV.ScatterPlotVisualizerSprites=hvt;var kV={},TV={};Object.defineProperty(TV,"__esModule",{value:!0});var fvt=function(){function n(e,t,r){this.bound=e,this.cellWidth=t,this.cellHeight=r,this.numHorizCells=Math.ceil(this.boundWidth(e)/t),this.numVertCells=Math.ceil(this.boundHeight(e)/r),this.grid=new Array(this.numHorizCells*this.numVertCells)}return n.prototype.boundWidth=function(e){return e.hiX-e.loX},n.prototype.boundHeight=function(e){return e.hiY-e.loY},n.prototype.boundsIntersect=function(e,t){return!(e.loX>t.hiX||e.loY>t.hiY||e.hiX<t.loX||e.hiY<t.loY)},n.prototype.insert=function(e,t){if(t===void 0&&(t=!1),e.hiX<this.bound.loX||e.loX>this.bound.hiX||e.hiY<this.bound.loY||e.loY>this.bound.hiY)return!1;for(var r=this.getCellX(e.loX),i=this.getCellX(e.hiX),s=this.getCellY(e.loY),o=this.getCellY(e.hiY),a=s*this.numHorizCells+r,l=a,c=s;c<=o;c++){for(var u=r;u<=i;u++){var h=this.grid[l++];if(h){for(var f=0;f<h.length;f++)if(this.boundsIntersect(e,h[f]))return!1}}l+=this.numHorizCells-(i-r+1)}if(t)return!0;l=a;for(var c=s;c<=o;c++){for(var u=r;u<=i;u++)this.grid[l]?this.grid[l].push(e):this.grid[l]=[e],l++;l+=this.numHorizCells-(i-r+1)}return!0},n.prototype.getCellX=function(e){return Math.floor((e-this.bound.loX)/this.cellWidth)},n.prototype.getCellY=function(e){return Math.floor((e-this.bound.loY)/this.cellHeight)},n}();TV.CollisionGrid=fvt;var dvt=gt&&gt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),i,s=[],o;try{for(;(e===void 0||e-- >0)&&!(i=r.next()).done;)s.push(i.value)}catch(a){o={error:a}}finally{try{i&&!i.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return s};Object.defineProperty(kV,"__esModule",{value:!0});var pvt=Qy,mvt=HC,gvt=TV,BP=Ys,yvt=1e4,bvt=function(){function n(e,t){this.styles=t,this.id="CANVAS_LABELS",this.worldSpacePointPositions=new Float32Array(0),this.labelsActive=!0,this.canvas=document.createElement("canvas"),e.appendChild(this.canvas),this.gc=this.canvas.getContext("2d"),this.canvas.style.position="absolute",this.canvas.style.left="0",this.canvas.style.top="0",this.canvas.style.pointerEvents="none"}return n.prototype.removeAllLabels=function(){var e=this.canvas.width*window.devicePixelRatio,t=this.canvas.height*window.devicePixelRatio;this.gc.clearRect(0,0,e,t)},n.prototype.makeLabels=function(e){if(!(e.labels==null||e.labels.pointIndices.length===0)&&this.worldSpacePointPositions!=null){var t=e.labels,r=e.cameraType===mvt.CameraType.Perspective,i=parseInt(this.gc.font,10),s=window.devicePixelRatio,o;{var a=this.canvas.width*s,l=this.canvas.height*s,c={loX:0,hiX:a,loY:0,hiY:l};o=new gvt.CollisionGrid(c,a/25,l/50)}var u=[e.farthestCameraSpacePointZ,e.nearestCameraSpacePointZ],h=function(O){return BP.scaleExponential(O,u,[.1,1])},f=e.camera.position,d=f.clone().sub(e.cameraTarget),p=new pvt.Vector3;this.gc.textBaseline="middle",this.gc.miterLimit=2;for(var m=2,g=4,y=Math.min(yvt,t.pointIndices.length),b=0;b<y;++b){var _=void 0;{var w=t.pointIndices[b];_=BP.vector3FromPackedArray(this.worldSpacePointPositions,w)}if(p.copy(f).sub(_),!(d.dot(p)<0)){var S=dvt(BP.vector3DToScreenCoords(e.camera,e.screenWidth,e.screenHeight,_),2),C=S[0],k=S[1];C+=g;var A={loX:C-m,hiX:C+1+m,loY:k-i/2-m,hiY:k+i/2+m};if(o.insert(A,!0)){var M=t.labelStrings[b],E=t.defaultFontSize*t.scaleFactors[b]*s;if(this.gc.font=E+"px roboto",A.hiX+=this.gc.measureText(M).width-1,o.insert(A)){var N=1;r&&t.useSceneOpacityFlags[b]===1&&(N=h(p.length())),this.gc.fillStyle=this.styleStringFromPackedRgba(t.fillColors,b,N),this.gc.strokeStyle=this.styleStringFromPackedRgba(t.strokeColors,b,N),this.gc.lineWidth=this.styles.label.strokeWidth,this.gc.strokeText(M,C,k),this.gc.lineWidth=this.styles.label.fillWidth,this.gc.fillText(M,C,k)}}}}}},n.prototype.styleStringFromPackedRgba=function(e,t,r){var i=t*3,s=e[i],o=e[i+1],a=e[i+2];return"rgba("+s+","+o+","+a+","+r+")"},n.prototype.onResize=function(e,t){var r=window.devicePixelRatio;this.canvas.width=e*r,this.canvas.height=t*r,this.canvas.style.width=e+"px",this.canvas.style.height=t+"px"},n.prototype.dispose=function(){this.removeAllLabels()},n.prototype.onPointPositionsChanged=function(e){this.worldSpacePointPositions=e,this.removeAllLabels()},n.prototype.onRender=function(e){this.labelsActive&&(this.removeAllLabels(),this.makeLabels(e))},n.prototype.setScene=function(e){},n.prototype.onPickingRender=function(e){},n}();kV.ScatterPlotVisualizerCanvasLabels=bvt;var EV={},bq=gt&&gt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(EV,"__esModule",{value:!0});var l1=Qy,vq=Ys,xE=Hu,vvt=function(){function n(){this.id="POLYLINES",this.sequences=[],this.polylines=[],this.polylinePositionBuffer={},this.polylineColorBuffer={},this.pointSequenceIndices=new Map}return n.prototype.getPointSequenceIndex=function(e){return this.pointSequenceIndices.get(e)},n.prototype.updateSequenceIndices=function(){for(var e=0;e<this.sequences.length;e++)for(var t=this.sequences[e],r=0;r<t.indices.length-1;r++){var i=t.indices[r];this.pointSequenceIndices.set(i,e),this.pointSequenceIndices.set(i+1,e)}},n.prototype.createPolylines=function(){var e,t;this.updateSequenceIndices();try{for(var r=bq(this.polylines),i=r.next();!i.done;i=r.next()){var s=i.value;this.scene.remove(s),s.geometry.dispose()}}catch(c){e={error:c}}finally{try{i&&!i.done&&(t=r.return)&&t.call(r)}finally{if(e)throw e.error}}this.polylines=[];for(var o=0;o<this.sequences.length;o++){var a=new l1.BufferGeometry;a.addAttribute("position",this.polylinePositionBuffer[o]),a.addAttribute("color",this.polylineColorBuffer[o]);var l=new l1.LineBasicMaterial({linewidth:1,opacity:1,transparent:!0,vertexColors:!0}),s=new l1.LineSegments(a,l);s.frustumCulled=!1,this.polylines.push(s),this.scene.add(s)}},n.prototype.dispose=function(){var e,t;try{for(var r=bq(this.polylines),i=r.next();!i.done;i=r.next()){var s=i.value;this.scene.remove(s),s.geometry.dispose()}}catch(o){e={error:o}}finally{try{i&&!i.done&&(t=r.return)&&t.call(r)}finally{if(e)throw e.error}}this.polylines=[],this.polylinePositionBuffer={},this.polylineColorBuffer={}},n.prototype.setScene=function(e){this.scene=e},n.prototype.setSequences=function(e){this.sequences=e},n.prototype.onPointPositionsChanged=function(e){if(e==null&&this.dispose(),!(e==null||this.sequences.length===0)){for(var t=0;t<this.sequences.length;t++){var r=this.sequences[t],i=2*(r.indices.length-1),s=new Float32Array(i*xE.XYZ_NUM_ELEMENTS);this.polylinePositionBuffer[t]=new l1.BufferAttribute(s,xE.XYZ_NUM_ELEMENTS);var o=new Float32Array(i*xE.RGBA_NUM_ELEMENTS);this.polylineColorBuffer[t]=new l1.BufferAttribute(o,xE.RGBA_NUM_ELEMENTS)}for(var t=0;t<this.sequences.length;t++){for(var r=this.sequences[t],a=0,l=0;l<r.indices.length-1;l++){var c=r.indices[l],u=r.indices[l+1],h=vq.vector3FromPackedArray(e,c),f=vq.vector3FromPackedArray(e,u);this.polylinePositionBuffer[t].setXYZ(a,h.x,h.y,h.z),this.polylinePositionBuffer[t].setXYZ(a+1,f.x,f.y,f.z),a+=2}this.polylinePositionBuffer[t].needsUpdate=!0}this.createPolylines()}},n.prototype.onRender=function(e){for(var t=0;t<this.polylines.length;t++){var r=this.polylines[t].material;r.opacity=e.polylineOpacities[t],r.linewidth=e.polylineWidths[t],this.polylineColorBuffer[t].array=e.polylineColors[t],this.polylineColorBuffer[t].needsUpdate=!0}},n.prototype.onPickingRender=function(e){},n.prototype.onResize=function(e,t){},n}();EV.ScatterPlotVisualizerPolylines=vvt;var wvt=gt&&gt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),i,s=[],o;try{for(;(e===void 0||e-- >0)&&!(i=r.next()).done;)s.push(i.value)}catch(a){o={error:a}}finally{try{i&&!i.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return s},VP=gt&&gt.__spread||function(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(wvt(arguments[e]));return n},wq=gt&&gt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(U4,"__esModule",{value:!0});var xvt=W4,mm=xV,_vt=D$,Svt=HC,Cvt=_V,Fo=Ys,_E=Hu,kvt=SV,xq=CV,Tvt=kV,Evt=EV,Ivt=function(){function n(e,t){var r=this;t===void 0&&(t={}),this.pointColorer=null,this.sequences=[],this.renderMode="POINT",this.rotateOnStart=!0,this.selectEnabled=!0,this.showLabelsOnHover=!0,this.hoverPointIndex=null,this.selectedPointIndices=new Set,this.clickCallback=function(){},this.hoverCallback=function(){},this.selectCallback=function(){},this.cameraMoveCallback=function(){},this.onHover=function(i){r.hoverCallback(i),r.hoverPointIndex=i,r.updateScatterPlotAttributes(),r.renderScatterPlot()},this.onClick=function(i){r.clickCallback(i)},this.select=function(i){r.selectEnabled&&(r.selectedPointIndices=new Set(i),r.updateScatterPlotAttributes(),r.renderScatterPlot())},this.onSelect=function(i){r.selectEnabled&&(r.selectCallback(i),r.select(i))},this.containerElement=e,this.styles=Cvt.makeStyles(t.styles),this.setParameters(t),this.scatterPlot=new xvt.ScatterPlot(e,{camera:t.camera,onClick:this.onClick,onHover:this.onHover,onSelect:this.onSelect,selectEnabled:this.selectEnabled,styles:this.styles,orbitControlParams:t.orbitControls}),this.scatterPlot.onCameraMove(this.cameraMoveCallback)}return n.prototype.setParameters=function(e){e.onClick!==void 0&&(this.clickCallback=e.onClick),e.onHover!==void 0&&(this.hoverCallback=e.onHover),e.onSelect!==void 0&&(this.selectCallback=e.onSelect),e.onCameraMove!==void 0&&(this.cameraMoveCallback=e.onCameraMove),e.pointColorer!==void 0&&(this.pointColorer=e.pointColorer),e.renderMode!==void 0&&(this.renderMode=e.renderMode),e.rotateOnStart!==void 0&&(this.rotateOnStart=e.rotateOnStart),e.selectEnabled!==void 0&&(this.selectEnabled=e.selectEnabled),e.showLabelsOnHover!==void 0&&(this.showLabelsOnHover=e.showLabelsOnHover)},n.prototype.render=function(e){this.updateDataset(e),this.clearVisualizers(),this.setVisualizers(),this.rotateOnStart&&this.scatterPlot.startOrbitAnimation()},n.prototype.clearVisualizers=function(){this.canvasLabelsVisualizer=void 0,this.labels3DVisualizer=void 0,this.pointVisualizer=void 0,this.polylineVisualizer=void 0,this.spritesheetVisualizer=void 0,this.scatterPlot.disposeAllVisualizers()},n.prototype.renderScatterPlot=function(){this.dataset&&this.scatterPlot.render()},n.prototype.resetZoom=function(){this.scatterPlot.resetZoom()},n.prototype.setRenderMode=function(e){this.renderMode=e,this.setVisualizers(),this.updateScatterPlotAttributes(),this.updateScatterPlotPositions()},n.prototype.setTextRenderMode=function(){this.setRenderMode("TEXT"),this.renderScatterPlot()},n.prototype.setPointRenderMode=function(){this.setRenderMode("POINT"),this.renderScatterPlot()},n.prototype.setSpriteRenderMode=function(){this.dataset&&this.dataset.spriteMetadata&&(this.setRenderMode("SPRITE"),this.renderScatterPlot())},n.prototype.setSequences=function(e){this.sequences=e,this.updatePolylineAttributes(),this.setVisualizers(),this.renderScatterPlot()},n.prototype.setPanMode=function(){this.scatterPlot.setInteractionMode("PAN")},n.prototype.setSelectMode=function(){this.scatterPlot.setInteractionMode("SELECT")},n.prototype.setDimensions=function(e){var t=e<2||e>3,r=this.dataset&&e>this.dataset.dimensions;if(t||r)throw new RangeError("Setting invalid dimensionality");this.scatterPlot.setDimensions(e),this.renderScatterPlot()},n.prototype.setPointColorer=function(e){this.pointColorer=e,this.updateScatterPlotAttributes(),this.renderScatterPlot()},n.prototype.callPointColorer=function(e,t){return e(t,this.selectedPointIndices,this.hoverPointIndex)},n.prototype.setHoverPointIndex=function(e){this.hoverPointIndex=e,this.updateScatterPlotAttributes(),!this.scatterPlot.orbitIsAnimating()&&this.renderScatterPlot()},n.prototype.resize=function(){this.scatterPlot.resize()},n.prototype.updateDataset=function(e){this.setDataset(e),this.scatterPlot.setDimensions(e.dimensions),this.updateScatterPlotAttributes(),this.updateScatterPlotPositions(),this.renderScatterPlot()},n.prototype.isOrbiting=function(){return this.scatterPlot.orbitIsAnimating()},n.prototype.startOrbitAnimation=function(){this.scatterPlot.startOrbitAnimation()},n.prototype.stopOrbitAnimation=function(){this.scatterPlot.stopOrbitAnimation()},n.prototype.setDataset=function(e){this.dataset=e,this.labels3DVisualizer&&this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray())},n.prototype.updateScatterPlotPositions=function(){var e=this.dataset;if(e){var t=this.generatePointPositionArray(e);this.scatterPlot.setPointPositions(t)}},n.prototype.updateScatterPlotAttributes=function(){var e=this.dataset;if(e){var t=this.generatePointColorArray(e),r=this.generatePointScaleFactorArray(e),i=this.generateVisibleLabelRenderParams();this.scatterPlot.setPointColors(t),this.scatterPlot.setPointScaleFactors(r),this.scatterPlot.setLabels(i)}},n.prototype.updatePolylineAttributes=function(){var e=this.dataset;if(e){var t=this.generateLineSegmentColorMap(e),r=this.generateLineSegmentOpacityArray(e),i=this.generateLineSegmentWidthArray(e);this.scatterPlot.setPolylineColors(t),this.scatterPlot.setPolylineOpacities(r),this.scatterPlot.setPolylineWidths(i)}},n.prototype.generatePointPositionArray=function(e){var t=[0,0],r=[0,0],i=[0,0];t=Fo.extent(e.points.map(function(y){return y[0]})),r=Fo.extent(e.points.map(function(y){return y[1]})),e.dimensions===3&&(i=Fo.extent(e.points.map(function(y){return y[2]})));var s=function(y){return Math.abs(y[1]-y[0])},o=s(t),a=s(r),l=s(i),c=Math.max(o,a,l),u=_E.SCATTER_PLOT_CUBE_LENGTH/2,h=function(y,b){return[-b*(y/c),b*(y/c)]},f=h(o,u),d=h(a,u),p=h(l,u),m=new Float32Array(e.points.length*3),g=0;return e.points.forEach(function(y,b){var _=e.points[b];m[g++]=Fo.scaleLinear(_[0],t,f),m[g++]=Fo.scaleLinear(_[1],r,d),e.dimensions===3?m[g++]=Fo.scaleLinear(_[2],i,p):m[g++]=0}),m},n.prototype.generateVisibleLabelRenderParams=function(){var e=this,t=e.hoverPointIndex,r=e.selectedPointIndices,i=e.styles,s=t!==null?1:0,o=new Uint32Array(s),a=new Float32Array(s),l=new Int8Array(s),c=new Uint8Array(s*3),u=new Uint8Array(s*3),h=[];a.fill(i.label.scaleDefault),l.fill(1);var f=0;if(t!==null){h.push(this.getLabelText(t)),o[f]=t,a[f]=i.label.scaleLarge,l[f]=0;var d=Fo.styleRgbFromHexColor(i.label.fillColorHover);Fo.packRgbIntoUint8Array(c,f,d[0],d[1],d[2]);var p=Fo.styleRgbFromHexColor(i.label.strokeColorHover);Fo.packRgbIntoUint8Array(u,f,p[0],p[1],p[1]),++f}{var d=Fo.styleRgbFromHexColor(i.label.fillColorSelected),p=Fo.styleRgbFromHexColor(i.label.strokeColorSelected);if(r.size===1){var m=VP(r)[0];h.push(this.getLabelText(m)),o[f]=m,a[f]=i.label.scaleLarge,l[f]=0,Fo.packRgbIntoUint8Array(c,f,d[0],d[1],d[2]),Fo.packRgbIntoUint8Array(u,f,p[0],p[1],p[2])}}return new Svt.LabelRenderParams(new Float32Array(o),h,a,l,i.label.fontSize,c,u)},n.prototype.generatePointScaleFactorArray=function(e){var t,r,i=this,s=i.hoverPointIndex,o=i.selectedPointIndices,a=i.styles,l=a.point,c=l.scaleDefault,u=l.scaleSelected,h=l.scaleHover,f=new Float32Array(e.points.length);f.fill(c),o.size;try{for(var d=wq(o.values()),p=d.next();!p.done;p=d.next()){var m=p.value;f[m]=u}}catch(g){t={error:g}}finally{try{p&&!p.done&&(r=d.return)&&r.call(d)}finally{if(t)throw t.error}}return s!=null&&(f[s]=h),f},n.prototype.generatePointColorArray=function(e){var t,r,i=this,s=i.hoverPointIndex,o=i.pointColorer,a=i.selectedPointIndices,l=i.styles,c=l.point,u=c.colorHover,h=c.colorNoSelection,f=c.colorSelected,d=c.colorUnselected,p=new Float32Array(e.points.length*_E.RGBA_NUM_ELEMENTS),m=d,g=h;this.renderMode==="TEXT"&&(m=this.styles.label3D.colorUnselected,g=this.styles.label3D.colorNoSelection),this.renderMode==="SPRITE"&&(m=this.styles.sprites.colorUnselected,g=this.styles.sprites.colorNoSelection);var y=e.points.length,b=this.selectedPointIndices.size;if(o)for(var _=0,w=0;w<y;++w){var S=mm.parseColor(this.callPointColorer(o,w)||g);p[_++]=S.r,p[_++]=S.g,p[_++]=S.b,p[_++]=S.opacity}else{for(var _=0,S=b>0?mm.parseColor(m):mm.parseColor(g),w=0;w<y;++w)p[_++]=S.r,p[_++]=S.g,p[_++]=S.b,p[_++]=S.opacity;S=mm.parseColor(f);try{for(var C=wq(a.values()),k=C.next();!k.done;k=C.next()){var A=k.value,M=A*_E.RGBA_NUM_ELEMENTS;p[M++]=S.r,p[M++]=S.g,p[M++]=S.b,p[M++]=S.opacity}}catch(D){t={error:D}}finally{try{k&&!k.done&&(r=C.return)&&r.call(C)}finally{if(t)throw t.error}}if(s!=null){var E=mm.parseColor(u),N=s*_E.RGBA_NUM_ELEMENTS;p[N++]=E.r,p[N++]=E.g,p[N++]=E.b,p[N++]=E.opacity}}return p},n.prototype.generate3DLabelsArray=function(){var e=this.dataset;if(!e)return[];for(var t=[],r=e.points.length,i=0;i<r;++i)t.push(this.getLabelText(i));return t},n.prototype.generateLineSegmentColorMap=function(e){for(var t=this,r=t.pointColorer,i=t.styles,s={},o=0;o<this.sequences.length;o++){var a=this.sequences[o],l=new Float32Array(2*(a.indices.length-1)*3),c=0;if(r)for(var u=0;u<a.indices.length-1;u++){var h=mm.parseColor(this.callPointColorer(r,a.indices[u])),f=mm.parseColor(this.callPointColorer(r,a.indices[u+1]));l[c++]=h.r,l[c++]=h.g,l[c++]=h.b,l[c++]=f.r,l[c++]=f.g,l[c++]=f.b}else for(var u=0;u<a.indices.length-1;u++){var h=Fo.getDefaultPointInPolylineColor(u,a.indices.length,i.polyline.startHue,i.polyline.endHue,i.polyline.saturation,i.polyline.lightness),f=Fo.getDefaultPointInPolylineColor(u+1,a.indices.length,i.polyline.startHue,i.polyline.endHue,i.polyline.saturation,i.polyline.lightness);l[c++]=h.r,l[c++]=h.g,l[c++]=h.b,l[c++]=f.r,l[c++]=f.g,l[c++]=f.b}s[o]=l}return s},n.prototype.generateLineSegmentOpacityArray=function(e){var t=this,r=t.selectedPointIndices,i=t.styles,s=new Float32Array(this.sequences.length),o=r.size;if(o>0){s.fill(i.polyline.deselectedOpacity);var a=this.polylineVisualizer.getPointSequenceIndex(VP(r)[0]);a!==void 0&&(s[a]=i.polyline.selectedOpacity)}else s.fill(i.polyline.defaultOpacity);return s},n.prototype.generateLineSegmentWidthArray=function(e){var t=this,r=t.selectedPointIndices,i=t.styles,s=new Float32Array(this.sequences.length);s.fill(i.polyline.defaultLineWidth);var o=r.size;if(o>0){var a=this.polylineVisualizer.getPointSequenceIndex(VP(r)[0]);a!==void 0&&(s[a]=i.polyline.selectedLineWidth)}return s},n.prototype.getLabelText=function(e){var t=this.dataset;if(!t)return"";var r=t.metadata[e];return r&&r.label!=null?""+r.label:""},n.prototype.initializeCanvasLabelsVisualizer=function(){return this.canvasLabelsVisualizer||(this.canvasLabelsVisualizer=new Tvt.ScatterPlotVisualizerCanvasLabels(this.containerElement,this.styles)),this.canvasLabelsVisualizer},n.prototype.initialize3DLabelsVisualizer=function(){return this.labels3DVisualizer||(this.labels3DVisualizer=new kvt.ScatterPlotVisualizer3DLabels(this.styles)),this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray()),this.labels3DVisualizer},n.prototype.initializePointVisualizer=function(){return this.pointVisualizer||(this.pointVisualizer=new xq.ScatterPlotVisualizerSprites(this.styles)),this.pointVisualizer},n.prototype.initializeSpritesheetVisualizer=function(){var e=this,t=this.styles,r=this.dataset,i=r.spriteMetadata;if(!this.spritesheetVisualizer&&i){if(!i.spriteImage||!i.singleSpriteSize)return;var s=r.points.length,o=void 0;if(i.spriteIndices)o=new Float32Array(i.spriteIndices);else{o=new Float32Array(s);for(var a=0;a<s;++a)o[a]=a}var l=function(){return e.renderScatterPlot()},c=new xq.ScatterPlotVisualizerSprites(t,{spritesheetImage:i.spriteImage,spriteDimensions:i.singleSpriteSize,spriteIndices:o,onImageLoad:l});c.id="SPRITE_SHEET_VISUALIZER",this.spritesheetVisualizer=c}return this.spritesheetVisualizer},n.prototype.initializePolylineVisualizer=function(){return this.polylineVisualizer||(this.polylineVisualizer=new Evt.ScatterPlotVisualizerPolylines),this.polylineVisualizer.setSequences(this.sequences),this.polylineVisualizer},n.prototype.setVisualizers=function(){var e=this,t=e.dataset,r=e.renderMode,i=[];if(r==="TEXT"){var s=this.initialize3DLabelsVisualizer();i.push(s)}else if(r==="POINT"){var s=this.initializePointVisualizer();i.push(s)}else if(r==="SPRITE"&&t.spriteMetadata){var s=this.initializeSpritesheetVisualizer();s&&i.push(s)}if(this.sequences.length>0){var s=this.initializePolylineVisualizer();i.push(s)}var o=r==="POINT"||r==="SPRITE";if(o&&this.showLabelsOnHover){var s=this.initializeCanvasLabelsVisualizer();i.push(s)}this.scatterPlot.setActiveVisualizers(i)},n.Dataset=_vt.Dataset,n}();U4.ScatterGL=Ivt;Object.defineProperty(V4,"__esModule",{value:!0});var Avt=U4;V4.ScatterGL=Avt.ScatterGL;var Mvt=D$;V4.Dataset=Mvt.Dataset;var Ole={},Xf={},Lh={},fs={},Nvt=gt&&gt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}};Object.defineProperty(fs,"__esModule",{value:!0});function Fle(n,e){return Math.floor(e()*n)}fs.tauRandInt=Fle;function $vt(n){return n()}fs.tauRand=$vt;function Rvt(n){var e,t,r=0;try{for(var i=Nvt(n),s=i.next();!s.done;s=i.next()){var o=s.value;r+=Math.pow(o,2)}}catch(a){e={error:a}}finally{try{s&&!s.done&&(t=i.return)&&t.call(i)}finally{if(e)throw e.error}}return Math.sqrt(r)}fs.norm=Rvt;function O$(n){for(var e=[],t=0;t<n;t++)e.push(void 0);return e}fs.empty=O$;function Pvt(n){return O$(n).map(function(e,t){return t})}fs.range=Pvt;function IV(n,e){return O$(n).map(function(){return e})}fs.filled=IV;function Lle(n){return IV(n,0)}fs.zeros=Lle;function Dvt(n){return IV(n,1)}fs.ones=Dvt;function Ovt(n,e,t){return O$(t).map(function(r,i){return n+i*((e-n)/(t-1))})}fs.linear=Ovt;function zle(n){return n.reduce(function(e,t){return e+t})}fs.sum=zle;function Fvt(n){return zle(n)/n.length}fs.mean=Fvt;function Lvt(n){for(var e=0,t=0;t<n.length;t++)e=n[t]>e?n[t]:e;return e}fs.max=Lvt;function zvt(n){for(var e=0,t=0;t<n.length;t++)for(var r=0;r<n[t].length;r++)e=n[t][r]>e?n[t][r]:e;return e}fs.max2d=zvt;function Bvt(n,e,t){for(var r=Lle(n),i=0;i<n;i++)for(var s=!0;s;){for(var o=Fle(e,t),a=!1,l=0;l<i;l++)if(o===r[l]){a=!0;break}a||(s=!1),r[i]=o}return r}fs.rejectionSample=Bvt;function Vvt(n,e,t){var r=[],i=0;if(n.length!==e*t)throw new Error("Array dimensions must match input length.");for(var s=0;s<e;s++){for(var o=[],a=0;a<t;a++)o.push(n[i]),i+=1;r.push(o)}return r}fs.reshape2d=Vvt;var Uvt=gt&&gt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(Lh,"__esModule",{value:!0});var PS=Uvt(fs);function Ble(n,e){var t=function(i){return PS.empty(n).map(function(){return PS.filled(e,i)})},r=[];return r.push(t(-1)),r.push(t(1/0)),r.push(t(0)),r}Lh.makeHeap=Ble;function Wvt(n,e,t){for(var r=PS.zeros(n),i=0;i<n;i++){for(var s=!0,o=0;s;){o=PS.tauRandInt(e,t);for(var a=!1,l=0;l<i;l++)if(o===r[l]){a=!0;break}a||(s=!1)}r[i]=o}return r}Lh.rejectionSample=Wvt;function eL(n,e,t,r,i){e=Math.floor(e);var s=n[0][e],o=n[1][e];if(n[2][e],t>=o[0])return 0;for(var a=0;a<s.length;a++)if(r===s[a])return 0;return Vle(n,e,t,r,i)}Lh.heapPush=eL;function Vle(n,e,t,r,i){var s=n[0][e],o=n[1][e],a=n[2][e];if(t>=o[0])return 0;o[0]=t,s[0]=r,a[0]=i;for(var l=0,c=0;;){var u=2*l+1,h=u+1,f=n[0][0].length;if(u>=f)break;if(h>=f)if(o[u]>t)c=u;else break;else if(o[u]>=o[h])if(t<o[u])c=u;else break;else if(t<o[h])c=h;else break;o[l]=o[c],s[l]=s[c],a[l]=a[c],l=c}return o[l]=t,s[l]=r,a[l]=i,1}Lh.uncheckedHeapPush=Vle;function Hvt(n,e,t,r,i){for(var s=Ble(e,r),o=0;o<e;o++)for(var a=0;a<t;a++)if(!(n[0][o][a]<0)){var l=n[0][o][a],c=n[2][o][a],u=PS.tauRand(i);eL(s,o,u,l,c),eL(s,l,u,o,c),n[2][o][a]=0}return s}Lh.buildCandidates=Hvt;function Gvt(n){for(var e=n[0],t=n[1],r=0;r<e.length;r++)for(var i=e[r],s=t[r],o=0;o<i.length-1;o++){var a=i.length-o-1,l=s.length-o-1,c=i[0];i[0]=i[a],i[a]=c;var u=s[0];s[0]=s[l],s[l]=u,jvt(s,i,l,0)}return{indices:e,weights:t}}Lh.deheapSort=Gvt;function jvt(n,e,t,r){for(;r*2+1<t;){var i=r*2+1,s=i+1,o=r;if(n[o]<n[i]&&(o=i),s<t&&n[o]<n[s]&&(o=s),o===r)break;var a=n[r];n[r]=n[o],n[o]=a;var l=e[r];e[r]=e[o],e[o]=l,r=o}}function qvt(n,e){for(var t=n[0][e],r=n[1][e],i=n[2][e],s=1/0,o=-1,a=0;a>t.length;a++)i[a]===1&&r[a]<s&&(s=r[a],o=a);return o>=0?(i[o]=0,Math.floor(t[o])):-1}Lh.smallestFlagged=qvt;var nl={},tI=gt&&gt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),i,s=[],o;try{for(;(e===void 0||e-- >0)&&!(i=r.next()).done;)s.push(i.value)}catch(a){o={error:a}}finally{try{i&&!i.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return s},Xvt=gt&&gt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}},Kvt=gt&&gt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(nl,"__esModule",{value:!0});var c1,_q=Kvt(fs),cx=function(){function n(e,t,r,i){if(this.entries=new Map,this.nRows=0,this.nCols=0,e.length!==t.length||e.length!==r.length)throw new Error("rows, cols and values arrays must all have the same length");this.nRows=i[0],this.nCols=i[1];for(var s=0;s<r.length;s++){var o=e[s],a=t[s];this.checkDims(o,a);var l=this.makeKey(o,a);this.entries.set(l,{value:r[s],row:o,col:a})}}return n.prototype.makeKey=function(e,t){return e+":"+t},n.prototype.checkDims=function(e,t){var r=e<this.nRows&&t<this.nCols;if(!r)throw new Error("row and/or col specified outside of matrix dimensions")},n.prototype.set=function(e,t,r){this.checkDims(e,t);var i=this.makeKey(e,t);this.entries.has(i)?this.entries.get(i).value=r:this.entries.set(i,{value:r,row:e,col:t})},n.prototype.get=function(e,t,r){r===void 0&&(r=0),this.checkDims(e,t);var i=this.makeKey(e,t);return this.entries.has(i)?this.entries.get(i).value:r},n.prototype.getAll=function(e){e===void 0&&(e=!0);var t=[];return this.entries.forEach(function(r){t.push(r)}),e&&t.sort(function(r,i){return r.row===i.row?r.col-i.col:r.row-i.row}),t},n.prototype.getDims=function(){return[this.nRows,this.nCols]},n.prototype.getRows=function(){return Array.from(this.entries,function(e){var t=tI(e,2);t[0];var r=t[1];return r.row})},n.prototype.getCols=function(){return Array.from(this.entries,function(e){var t=tI(e,2);t[0];var r=t[1];return r.col})},n.prototype.getValues=function(){return Array.from(this.entries,function(e){var t=tI(e,2);t[0];var r=t[1];return r.value})},n.prototype.forEach=function(e){this.entries.forEach(function(t){return e(t.value,t.row,t.col)})},n.prototype.map=function(e){var t=[];this.entries.forEach(function(i){t.push(e(i.value,i.row,i.col))});var r=[this.nRows,this.nCols];return new n(this.getRows(),this.getCols(),t,r)},n.prototype.toArray=function(){var e=this,t=_q.empty(this.nRows),r=t.map(function(){return _q.zeros(e.nCols)});return this.entries.forEach(function(i){r[i.row][i.col]=i.value}),r},n}();nl.SparseMatrix=cx;function Yvt(n){var e=[],t=[],r=[];n.forEach(function(s,o,a){e.push(o),t.push(a),r.push(s)});var i=[n.nCols,n.nRows];return new cx(t,e,r,i)}nl.transpose=Yvt;function Zvt(n){for(var e=tI(n,1),t=e[0],r=new cx([],[],[],n),i=0;i<t;i++)r.set(i,i,1);return r}nl.identity=Zvt;function Jvt(n,e){return F$(n,e,function(t,r){return t*r})}nl.pairwiseMultiply=Jvt;function Qvt(n,e){return F$(n,e,function(t,r){return t+r})}nl.add=Qvt;function ewt(n,e){return F$(n,e,function(t,r){return t-r})}nl.subtract=ewt;function twt(n,e){return F$(n,e,function(t,r){return t>r?t:r})}nl.maximum=twt;function nwt(n,e){return n.map(function(t){return t*e})}nl.multiplyScalar=nwt;function rwt(n){for(var e=new Set,t=n.getValues(),r=n.getRows(),i=n.getCols(),s=0;s<t.length;s++)t[s]===0&&e.add(s);var o=function(u,h){return!e.has(h)},a=t.filter(o),l=r.filter(o),c=i.filter(o);return new cx(l,c,a,n.getDims())}nl.eliminateZeros=rwt;function iwt(n,e){e===void 0&&(e="l2");var t,r,i=swt[e],s=new Map;n.forEach(function(h,f,d){var p=s.get(f)||[];p.push(d),s.set(f,p)});var o=new cx([],[],[],n.getDims()),a=function(h){for(var f=s.get(h).sort(),d=f.map(function(g){return n.get(h,g)}),p=i(d),m=0;m<p.length;m++)o.set(h,f[m],p[m])};try{for(var l=Xvt(s.keys()),c=l.next();!c.done;c=l.next()){var u=c.value;a(u)}}catch(h){t={error:h}}finally{try{c&&!c.done&&(r=l.return)&&r.call(l)}finally{if(t)throw t.error}}return o}nl.normalize=iwt;var swt=(c1={},c1.max=function(n){for(var e=-1/0,t=0;t<n.length;t++)e=n[t]>e?n[t]:e;return n.map(function(r){return r/e})},c1.l1=function(n){for(var e=0,t=0;t<n.length;t++)e+=n[t];return n.map(function(r){return r/e})},c1.l2=function(n){for(var e=0,t=0;t<n.length;t++)e+=Math.pow(n[t],2);return n.map(function(r){return Math.sqrt(Math.pow(r,2)/e)})},c1);function F$(n,e,t){for(var r=new Set,i=[],s=[],o=[],a=function(_,w){i.push(_),s.push(w);var S=t(n.get(_,w),e.get(_,w));o.push(S)},l=n.getValues(),c=n.getRows(),u=n.getCols(),h=0;h<l.length;h++){var f=c[h],d=u[h],p=f+":"+d;r.add(p),a(f,d)}for(var m=e.getValues(),g=e.getRows(),y=e.getCols(),h=0;h<m.length;h++){var f=g[h],d=y[h],p=f+":"+d;r.has(p)||a(f,d)}var b=[n.nRows,n.nCols];return new cx(i,s,o,b)}function owt(n){var e=[];n.forEach(function(h,f,d){e.push({value:h,row:f,col:d})}),e.sort(function(h,f){return h.row===f.row?h.col-f.col:h.row-f.row});for(var t=[],r=[],i=[],s=-1,o=0;o<e.length;o++){var a=e[o],l=a.row,c=a.col,u=a.value;l!==s&&(s=l,i.push(o)),t.push(c),r.push(u)}return{indices:t,values:r,indptr:i}}nl.getCSR=owt;var ux={},e0={},awt=gt&&gt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),i,s=[],o;try{for(;(e===void 0||e-- >0)&&!(i=r.next()).done;)s.push(i.value)}catch(a){o={error:a}}finally{try{i&&!i.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return s},Ule=gt&&gt.__spread||function(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(awt(arguments[e]));return n},lwt=gt&&gt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}},cwt=gt&&gt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(e0,"__esModule",{value:!0});var Uo=cwt(fs),Wle=function(){function n(e,t,r,i){this.hyperplanes=e,this.offsets=t,this.children=r,this.indices=i}return n}();e0.FlatTree=Wle;function uwt(n,e,t,r){var i=Math.max(10,e),s=Uo.range(t).map(function(a,l){return hwt(n,i,l,r)}),o=s.map(function(a){return dwt(a,i)});return o}e0.makeForest=uwt;function hwt(n,e,t,r){e===void 0&&(e=30);var i=Uo.range(n.length),s=tL(n,i,e,t,r);return s}function tL(n,e,t,r,i){if(t===void 0&&(t=30),e.length>t){var s=fwt(n,e,i),o=s.indicesLeft,a=s.indicesRight,l=s.hyperplane,c=s.offset,u=tL(n,o,t,r+1,i),h=tL(n,a,t,r+1,i),f={leftChild:u,rightChild:h,isLeaf:!1,hyperplane:l,offset:c};return f}else{var f={indices:e,isLeaf:!0};return f}}function fwt(n,e,t){var r=n[0].length,i=Uo.tauRandInt(e.length,t),s=Uo.tauRandInt(e.length,t);s+=i===s?1:0,s=s%e.length;for(var o=e[i],a=e[s],l=0,c=Uo.zeros(r),u=0;u<c.length;u++)c[u]=n[o][u]-n[a][u],l-=c[u]*(n[o][u]+n[a][u])/2;for(var h=0,f=0,d=Uo.zeros(e.length),u=0;u<e.length;u++){for(var p=l,m=0;m<r;m++)p+=c[m]*n[e[u]][m];p===0?(d[u]=Uo.tauRandInt(2,t),d[u]===0?h+=1:f+=1):p>0?(d[u]=0,h+=1):(d[u]=1,f+=1)}var g=Uo.zeros(h),y=Uo.zeros(f);h=0,f=0;for(var u=0;u<d.length;u++)d[u]===0?(g[h]=e[u],h+=1):(y[f]=e[u],f+=1);return{indicesLeft:g,indicesRight:y,hyperplane:c,offset:l}}function dwt(n,e){var t=rL(n),r=iL(n),i=Uo.range(t).map(function(){return Uo.zeros(n.hyperplane?n.hyperplane.length:0)}),s=Uo.zeros(t),o=Uo.range(t).map(function(){return[-1,-1]}),a=Uo.range(r).map(function(){return Uo.range(e).map(function(){return-1})});return nL(n,i,s,o,a,0,0),new Wle(i,s,o,a)}function nL(n,e,t,r,i,s,o){var a;if(n.isLeaf)return r[s][0]=-o,(a=i[o]).splice.apply(a,Ule([0,n.indices.length],n.indices)),o+=1,{nodeNum:s,leafNum:o};e[s]=n.hyperplane,t[s]=n.offset,r[s][0]=s+1;var l=s,c=nL(n.leftChild,e,t,r,i,s+1,o);return s=c.nodeNum,o=c.leafNum,r[l][1]=s+1,c=nL(n.rightChild,e,t,r,i,s+1,o),{nodeNum:c.nodeNum,leafNum:c.leafNum}}function rL(n){return n.isLeaf?1:1+rL(n.leftChild)+rL(n.rightChild)}function iL(n){return n.isLeaf?1:iL(n.leftChild)+iL(n.rightChild)}function pwt(n){var e,t;if(n.length>0){var r=[];try{for(var i=lwt(n),s=i.next();!s.done;s=i.next()){var o=s.value;r.push.apply(r,Ule(o.indices))}}catch(a){e={error:a}}finally{try{s&&!s.done&&(t=i.return)&&t.call(i)}finally{if(e)throw e.error}}return r}else return[[-1]]}e0.makeLeafArray=pwt;function mwt(n,e,t,r){for(var i=e,s=0;s<t.length;s++)i+=n[s]*t[s];if(i===0){var o=Uo.tauRandInt(2,r);return o}else return i>0?0:1}function gwt(n,e,t){for(var r=0;e.children[r][0]>0;){var i=mwt(e.hyperplanes[r],e.offsets[r],n,t);i===0?r=e.children[r][0]:r=e.children[r][1]}var s=-1*e.children[r][0];return e.indices[s]}e0.searchFlatTree=gwt;var Hle=gt&&gt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}},L$=gt&&gt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(ux,"__esModule",{value:!0});var da=L$(Lh),ywt=L$(nl),bwt=L$(e0),Gle=L$(fs);function vwt(n,e){return function(r,i,s,o,a,l,c,u){o===void 0&&(o=10),a===void 0&&(a=50),l===void 0&&(l=.001),c===void 0&&(c=.5),u===void 0&&(u=!0);for(var h=r.length,f=da.makeHeap(r.length,s),d=0;d<r.length;d++)for(var p=da.rejectionSample(s,r.length,e),m=0;m<p.length;m++){var g=n(r[d],r[p[m]]);da.heapPush(f,d,g,p[m],1),da.heapPush(f,p[m],g,d,1)}if(u)for(var y=0;y<i.length;y++)for(var d=0;d<i[y].length&&!(i[y][d]<0);d++)for(var m=d+1;m<i[y].length&&!(i[y][m]<0);m++){var g=n(r[i[y][d]],r[i[y][m]]);da.heapPush(f,i[y][d],g,i[y][m],1),da.heapPush(f,i[y][m],g,i[y][d],1)}for(var y=0;y<o;y++){for(var b=da.buildCandidates(f,h,s,a,e),_=0,d=0;d<h;d++)for(var m=0;m<a;m++){var w=Math.floor(b[0][d][m]);if(!(w<0||Gle.tauRand(e)<c))for(var S=0;S<a;S++){var C=Math.floor(b[0][d][S]),k=b[2][d][m],A=b[2][d][S];if(!(C<0||!k&&!A)){var g=n(r[w],r[C]);_+=da.heapPush(f,w,g,C,1),_+=da.heapPush(f,C,g,w,1)}}}if(_<=l*s*r.length)break}var M=da.deheapSort(f);return M}}ux.makeNNDescent=vwt;function wwt(n){function e(r,i,s,o,a){for(var l=0;l<s.length;l++)for(var c=Gle.rejectionSample(r,i.length,a),u=0;u<c.length;u++)if(!(c[u]<0)){var h=n(i[c[u]],s[l]);da.heapPush(o,l,h,c[u],1)}}function t(r,i,s,o,a){for(var l=0;l<s.length;l++)for(var c=bwt.searchFlatTree(s[l],r,a),u=0;u<c.length;u++){if(c[u]<0)return;var h=n(i[c[u]],s[l]);da.heapPush(o,l,h,c[u],1)}}return{initFromRandom:e,initFromTree:t}}ux.makeInitializations=wwt;function xwt(n){return function(t,r,i,s){for(var o,a,l=ywt.getCSR(r),c=l.indices,u=l.indptr,h=0;h<s.length;h++)for(var f=new Set(i[0][h]);;){var d=da.smallestFlagged(i,h);if(d===-1)break;var p=c.slice(u[d],u[d+1]);try{for(var m=Hle(p),g=m.next();!g.done;g=m.next()){var y=g.value;if(!(y===d||y===-1||f.has(y))){var b=n(t[y],s[h]);da.uncheckedHeapPush(i,h,b,y,1),f.add(y)}}}catch(_){o={error:_}}finally{try{g&&!g.done&&(a=m.return)&&a.call(m)}finally{if(o)throw o.error}}}return i}}ux.makeInitializedNNSearch=xwt;function _wt(n,e,t,r,i,s,o){var a,l,c=da.makeHeap(t.length,r);if(i(r,e,t,c,o),n)try{for(var u=Hle(n),h=u.next();!h.done;h=u.next()){var f=h.value;s(f,e,t,c,o)}}catch(d){a={error:d}}finally{try{h&&!h.done&&(l=u.return)&&l.call(u)}finally{if(a)throw a.error}}return c}ux.initializeSearch=_wt;const Swt=Object.prototype.toString;function UP(n){return Swt.call(n).endsWith("Array]")}function Sq(n,e,t){let r=0;const i=t(e);for(let s=0;s<n.x.length;s++)r+=Math.abs(n.y[s]-i(n.x[s]));return r}function Cwt(n,e,t,r,i){const s=t.length,o=n.x.length;let a=new Array(s);for(let l=0;l<s;l++){a[l]=new Array(o);let c=t.slice();c[l]+=r;let u=i(c);for(let h=0;h<o;h++)a[l][h]=e[h]-u(n.x[h])}return new en(a)}function kwt(n,e){const t=n.x.length;let r=new Array(t);for(let i=0;i<t;i++)r[i]=[n.y[i]-e[i]];return new en(r)}function Twt(n,e,t,r,i){let s=t*r*r,o=en.eye(e.length,e.length,s);const a=i(e);let l=new Float64Array(n.x.length);for(let f=0;f<n.x.length;f++)l[f]=a(n.x[f]);let c=Cwt(n,l,e,r,i),u=kwt(n,l),h=sht(o.add(c.mmul(c.transpose())));return e=new en([e]),e=e.sub(h.mmul(c).mmul(u).mul(r).transpose()),e.to1DArray()}function Ewt(n,e,t={}){let{maxIterations:r=100,gradientDifference:i=.1,damping:s=0,errorTolerance:o=.01,minValues:a,maxValues:l,initialValues:c}=t;if(s<=0)throw new Error("The damping option must be a positive number");if(!n.x||!n.y)throw new Error("The data parameter must have x and y elements");if(!UP(n.x)||n.x.length<2||!UP(n.y)||n.y.length<2)throw new Error("The data parameter elements must be an array with more than 2 points");if(n.x.length!==n.y.length)throw new Error("The data parameter elements must have the same size");let u=c||new Array(e.length).fill(1),h=u.length;if(l=l||new Array(h).fill(Number.MAX_SAFE_INTEGER),a=a||new Array(h).fill(Number.MIN_SAFE_INTEGER),l.length!==a.length)throw new Error("minValues and maxValues must be the same size");if(!UP(u))throw new Error("initialValues must be an array");let f=Sq(n,u,e),d=f<=o,p;for(p=0;p<r&&!d;p++){u=Twt(n,u,s,i,e);for(let m=0;m<h;m++)u[m]=Math.min(Math.max(a[m],u[m]),l[m]);if(f=Sq(n,u,e),isNaN(f))break;d=f<=o}return{parameterValues:u,parameterError:f,iterations:p}}const Iwt=Object.freeze(Object.defineProperty({__proto__:null,default:Ewt},Symbol.toStringTag,{value:"Module"})),Awt=My(Iwt);var Cq=gt&&gt.__awaiter||function(n,e,t,r){return new(t||(t=Promise))(function(i,s){function o(c){try{l(r.next(c))}catch(u){s(u)}}function a(c){try{l(r.throw(c))}catch(u){s(u)}}function l(c){c.done?i(c.value):new t(function(u){u(c.value)}).then(o,a)}l((r=r.apply(n,e||[])).next())})},kq=gt&&gt.__generator||function(n,e){var t={label:0,sent:function(){if(s[0]&1)throw s[1];return s[1]},trys:[],ops:[]},r,i,s,o;return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(c){return function(u){return l([c,u])}}function l(c){if(r)throw new TypeError("Generator is already executing.");for(;t;)try{if(r=1,i&&(s=c[0]&2?i.return:c[0]?i.throw||((s=i.return)&&s.call(i),0):i.next)&&!(s=s.call(i,c[1])).done)return s;switch(i=0,s&&(c=[c[0]&2,s.value]),c[0]){case 0:case 1:s=c;break;case 4:return t.label++,{value:c[1],done:!1};case 5:t.label++,i=c[1],c=[0];continue;case 7:c=t.ops.pop(),t.trys.pop();continue;default:if(s=t.trys,!(s=s.length>0&&s[s.length-1])&&(c[0]===6||c[0]===2)){t=0;continue}if(c[0]===3&&(!s||c[1]>s[0]&&c[1]<s[3])){t.label=c[1];break}if(c[0]===6&&t.label<s[1]){t.label=s[1],s=c;break}if(s&&t.label<s[2]){t.label=s[2],t.ops.push(c);break}s[2]&&t.ops.pop(),t.trys.pop();continue}c=e.call(n,t)}catch(u){c=[6,u],i=0}finally{r=s=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}},sL=gt&&gt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),i,s=[],o;try{for(;(e===void 0||e-- >0)&&!(i=r.next()).done;)s.push(i.value)}catch(a){o={error:a}}finally{try{i&&!i.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return s},Tq=gt&&gt.__spread||function(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(sL(arguments[e]));return n},GC=gt&&gt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e},Mwt=gt&&gt.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(Xf,"__esModule",{value:!0});var Nwt=GC(Lh),ji=GC(nl),SE=GC(ux),Eq=GC(e0),is=GC(fs),$wt=Mwt(Awt),Iq=1e-5,CE=.001,Rwt=function(){function n(e){e===void 0&&(e={});var t=this;this.learningRate=1,this.localConnectivity=1,this.minDist=.1,this.nComponents=2,this.nEpochs=0,this.nNeighbors=15,this.negativeSampleRate=5,this.random=Math.random,this.repulsionStrength=1,this.setOpMixRatio=1,this.spread=1,this.transformQueueSize=4,this.targetMetric="categorical",this.targetWeight=.5,this.targetNNeighbors=this.nNeighbors,this.distanceFn=jle,this.isInitialized=!1,this.rpForest=[],this.embedding=[],this.optimizationState=new Dwt;var r=function(i){e[i]!==void 0&&(t[i]=e[i])};r("distanceFn"),r("learningRate"),r("localConnectivity"),r("minDist"),r("nComponents"),r("nEpochs"),r("nNeighbors"),r("negativeSampleRate"),r("random"),r("repulsionStrength"),r("setOpMixRatio"),r("spread"),r("transformQueueSize")}return n.prototype.fit=function(e){return this.initializeFit(e),this.optimizeLayout(),this.embedding},n.prototype.fitAsync=function(e,t){return t===void 0&&(t=function(){return!0}),Cq(this,void 0,void 0,function(){return kq(this,function(r){switch(r.label){case 0:return this.initializeFit(e),[4,this.optimizeLayoutAsync(t)];case 1:return r.sent(),[2,this.embedding]}})})},n.prototype.setSupervisedProjection=function(e,t){t===void 0&&(t={}),this.Y=e,this.targetMetric=t.targetMetric||this.targetMetric,this.targetWeight=t.targetWeight||this.targetWeight,this.targetNNeighbors=t.targetNNeighbors||this.targetNNeighbors},n.prototype.setPrecomputedKNN=function(e,t){this.knnIndices=e,this.knnDistances=t},n.prototype.initializeFit=function(e){if(e.length<=this.nNeighbors)throw new Error("Not enough data points ("+e.length+") to create nNeighbors: "+this.nNeighbors+".  Add more data points or adjust the configuration.");if(this.X===e&&this.isInitialized)return this.getNEpochs();if(this.X=e,!this.knnIndices&&!this.knnDistances){var t=this.nearestNeighbors(e);this.knnIndices=t.knnIndices,this.knnDistances=t.knnDistances}this.graph=this.fuzzySimplicialSet(e,this.nNeighbors,this.setOpMixRatio),this.makeSearchFns(),this.searchGraph=this.makeSearchGraph(e),this.processGraphForSupervisedProjection();var r=this.initializeSimplicialSetEmbedding(),i=r.head,s=r.tail,o=r.epochsPerSample;return this.optimizationState.head=i,this.optimizationState.tail=s,this.optimizationState.epochsPerSample=o,this.initializeOptimization(),this.prepareForOptimizationLoop(),this.isInitialized=!0,this.getNEpochs()},n.prototype.makeSearchFns=function(){var e=SE.makeInitializations(this.distanceFn),t=e.initFromTree,r=e.initFromRandom;this.initFromTree=t,this.initFromRandom=r,this.search=SE.makeInitializedNNSearch(this.distanceFn)},n.prototype.makeSearchGraph=function(e){for(var t=this.knnIndices,r=this.knnDistances,i=[e.length,e.length],s=new ji.SparseMatrix([],[],[],i),o=0;o<t.length;o++)for(var a=t[o],l=r[o],c=0;c<a.length;c++){var u=a[c],h=l[c];h>0&&s.set(o,u,h)}var f=ji.transpose(s);return ji.maximum(s,f)},n.prototype.transform=function(e){var t=this,r=this.X;if(r===void 0||r.length===0)throw new Error("No data has been fit.");var i=Math.floor(this.nNeighbors*this.transformQueueSize);i=Math.min(r.length,i);var s=SE.initializeSearch(this.rpForest,r,e,i,this.initFromRandom,this.initFromTree,this.random),o=this.search(r,this.searchGraph,s,e),a=Nwt.deheapSort(o),l=a.indices,c=a.weights;l=l.map(function(z){return z.slice(0,t.nNeighbors)}),c=c.map(function(z){return z.slice(0,t.nNeighbors)});var u=Math.max(0,this.localConnectivity-1),h=this.smoothKNNDistance(c,this.nNeighbors,u),f=h.sigmas,d=h.rhos,p=this.computeMembershipStrengths(l,c,f,d),m=p.rows,g=p.cols,y=p.vals,b=[e.length,r.length],_=new ji.SparseMatrix(m,g,y,b),w=ji.normalize(_,"l1"),S=ji.getCSR(w),C=e.length,k=is.reshape2d(S.indices,C,this.nNeighbors),A=is.reshape2d(S.values,C,this.nNeighbors),M=Yle(k,A,this.embedding),E=this.nEpochs?this.nEpochs/3:_.nRows<=1e4?100:30,N=_.getValues().reduce(function(z,B){return B>z?B:z},0);_=_.map(function(z){return z<N/E?0:z}),_=ji.eliminateZeros(_);var O=this.makeEpochsPerSample(_.getValues(),E),R=_.getRows(),D=_.getCols();return this.assignOptimizationStateParameters({headEmbedding:M,tailEmbedding:this.embedding,head:R,tail:D,currentEpoch:0,nEpochs:E,nVertices:_.getDims()[1],epochsPerSample:O}),this.prepareForOptimizationLoop(),this.optimizeLayout()},n.prototype.processGraphForSupervisedProjection=function(){var e=this,t=e.Y,r=e.X;if(t){if(t.length!==r.length)throw new Error("Length of X and y must be equal");if(this.targetMetric==="categorical"){var i=this.targetWeight<1,s=i?2.5*(1/(1-this.targetWeight)):1e12;this.graph=this.categoricalSimplicialSetIntersection(this.graph,t,s)}}},n.prototype.step=function(){var e=this.optimizationState.currentEpoch;return e<this.getNEpochs()&&this.optimizeLayoutStep(e),this.optimizationState.currentEpoch},n.prototype.getEmbedding=function(){return this.embedding},n.prototype.nearestNeighbors=function(e){var t=this,r=t.distanceFn,i=t.nNeighbors,s=function(p){return Math.log(p)/Math.log(2)},o=SE.makeNNDescent(r,this.random),a=function(p){return p===.5?0:Math.round(p)},l=5+Math.floor(a(Math.pow(e.length,.5)/20)),c=Math.max(5,Math.floor(Math.round(s(e.length))));this.rpForest=Eq.makeForest(e,i,l,this.random);var u=Eq.makeLeafArray(this.rpForest),h=o(e,u,i,c),f=h.indices,d=h.weights;return{knnIndices:f,knnDistances:d}},n.prototype.fuzzySimplicialSet=function(e,t,r){r===void 0&&(r=1);var i=this,s=i.knnIndices,o=s===void 0?[]:s,a=i.knnDistances,l=a===void 0?[]:a,c=i.localConnectivity,u=this.smoothKNNDistance(l,t,c),h=u.sigmas,f=u.rhos,d=this.computeMembershipStrengths(o,l,h,f),p=d.rows,m=d.cols,g=d.vals,y=[e.length,e.length],b=new ji.SparseMatrix(p,m,g,y),_=ji.transpose(b),w=ji.pairwiseMultiply(b,_),S=ji.subtract(ji.add(b,_),w),C=ji.multiplyScalar(S,r),k=ji.multiplyScalar(w,1-r),A=ji.add(C,k);return A},n.prototype.categoricalSimplicialSetIntersection=function(e,t,r,i){i===void 0&&(i=1);var s=Xle(e,t,i,r);return s=ji.eliminateZeros(s),Kle(s)},n.prototype.smoothKNNDistance=function(e,t,r,i,s){r===void 0&&(r=1),i===void 0&&(i=64),s===void 0&&(s=1);for(var o=Math.log(t)/Math.log(2)*s,a=is.zeros(e.length),l=is.zeros(e.length),c=0;c<e.length;c++){var u=0,h=1/0,f=1,d=e[c],p=d.filter(function(k){return k>0});if(p.length>=r){var m=Math.floor(r),g=r-m;m>0?(a[c]=p[m-1],g>Iq&&(a[c]+=g*(p[m]-p[m-1]))):a[c]=g*p[0]}else p.length>0&&(a[c]=is.max(p));for(var y=0;y<i;y++){for(var b=0,_=1;_<e[c].length;_++){var w=e[c][_]-a[c];w>0?b+=Math.exp(-(w/f)):b+=1}if(Math.abs(b-o)<Iq)break;b>o?(h=f,f=(u+h)/2):(u=f,h===1/0?f*=2:f=(u+h)/2)}if(l[c]=f,a[c]>0){var S=is.mean(d);l[c]<CE*S&&(l[c]=CE*S)}else{var C=is.mean(e.map(is.mean));l[c]<CE*C&&(l[c]=CE*C)}}return{sigmas:l,rhos:a}},n.prototype.computeMembershipStrengths=function(e,t,r,i){for(var s=e.length,o=e[0].length,a=is.zeros(s*o),l=is.zeros(s*o),c=is.zeros(s*o),u=0;u<s;u++)for(var h=0;h<o;h++){var f=0;e[u][h]!==-1&&(e[u][h]===u?f=0:t[u][h]-i[u]<=0?f=1:f=Math.exp(-((t[u][h]-i[u])/r[u])),a[u*o+h]=u,l[u*o+h]=e[u][h],c[u*o+h]=f)}return{rows:a,cols:l,vals:c}},n.prototype.initializeSimplicialSetEmbedding=function(){for(var e=this,t=this.getNEpochs(),r=this.nComponents,i=this.graph.getValues(),s=0,o=0;o<i.length;o++){var a=i[o];s<i[o]&&(s=a)}var l=this.graph.map(function(m){return m<s/t?0:m});this.embedding=is.zeros(l.nRows).map(function(){return is.zeros(r).map(function(){return is.tauRand(e.random)*20+-10})});for(var c=[],u=[],h=[],f=l.getAll(),o=0;o<f.length;o++){var d=f[o];d.value&&(c.push(d.value),h.push(d.row),u.push(d.col))}var p=this.makeEpochsPerSample(c,t);return{head:u,tail:h,epochsPerSample:p}},n.prototype.makeEpochsPerSample=function(e,t){var r=is.filled(e.length,-1),i=is.max(e),s=e.map(function(o){return o/i*t});return s.forEach(function(o,a){o>0&&(r[a]=t/s[a])}),r},n.prototype.assignOptimizationStateParameters=function(e){Object.assign(this.optimizationState,e)},n.prototype.prepareForOptimizationLoop=function(){var e=this,t=e.repulsionStrength,r=e.learningRate,i=e.negativeSampleRate,s=this.optimizationState,o=s.epochsPerSample,a=s.headEmbedding,l=s.tailEmbedding,c=a[0].length,u=a.length===l.length,h=o.map(function(p){return p/i}),f=Tq(h),d=Tq(o);this.assignOptimizationStateParameters({epochOfNextSample:d,epochOfNextNegativeSample:f,epochsPerNegativeSample:h,moveOther:u,initialAlpha:r,alpha:r,gamma:t,dim:c})},n.prototype.initializeOptimization=function(){var e=this.embedding,t=this.embedding,r=this.optimizationState,i=r.head,s=r.tail,o=r.epochsPerSample,a=this.getNEpochs(),l=this.graph.nCols,c=qle(this.spread,this.minDist),u=c.a,h=c.b;this.assignOptimizationStateParameters({headEmbedding:e,tailEmbedding:t,head:i,tail:s,epochsPerSample:o,a:u,b:h,nEpochs:a,nVertices:l})},n.prototype.optimizeLayoutStep=function(e){for(var t=this.optimizationState,r=t.head,i=t.tail,s=t.headEmbedding,o=t.tailEmbedding,a=t.epochsPerSample,l=t.epochOfNextSample,c=t.epochOfNextNegativeSample,u=t.epochsPerNegativeSample,h=t.moveOther,f=t.initialAlpha,d=t.alpha,p=t.gamma,m=t.a,g=t.b,y=t.dim,b=t.nEpochs,_=t.nVertices,w=4,S=0;S<a.length;S++)if(!(l[S]>e)){var C=r[S],k=i[S],A=s[C],M=o[k],E=Mq(A,M),N=0;E>0&&(N=-2*m*g*Math.pow(E,g-1),N/=m*Math.pow(E,g)+1);for(var O=0;O<y;O++){var R=Aq(N*(A[O]-M[O]),w);A[O]+=R*d,h&&(M[O]+=-R*d)}l[S]+=a[S];for(var D=Math.floor((e-c[S])/u[S]),z=0;z<D;z++){var B=is.tauRandInt(_,this.random),X=o[B],H=Mq(A,X),te=0;if(H>0)te=2*p*g,te/=(.001+H)*(m*Math.pow(H,g)+1);else if(C===B)continue;for(var O=0;O<y;O++){var R=4;te>0&&(R=Aq(te*(A[O]-X[O]),w)),A[O]+=R*d}}c[S]+=D*u[S]}return t.alpha=f*(1-e/b),t.currentEpoch+=1,s},n.prototype.optimizeLayoutAsync=function(e){var t=this;return e===void 0&&(e=function(){return!0}),new Promise(function(r,i){var s=function(){return Cq(t,void 0,void 0,function(){var o,a,l,c,u,h;return kq(this,function(f){try{if(o=this.optimizationState,a=o.nEpochs,l=o.currentEpoch,this.embedding=this.optimizeLayoutStep(l),c=this.optimizationState.currentEpoch,u=e(c)===!1,h=c===a,!u&&!h)setTimeout(function(){return s()},0);else return[2,r(h)]}catch(d){i(d)}return[2]})})};setTimeout(function(){return s()},0)})},n.prototype.optimizeLayout=function(e){e===void 0&&(e=function(){return!0});for(var t=!1,r=[];!t;){var i=this.optimizationState,s=i.nEpochs,o=i.currentEpoch;r=this.optimizeLayoutStep(o);var a=this.optimizationState.currentEpoch,l=e(a)===!1;t=a===s||l}return r},n.prototype.getNEpochs=function(){var e=this.graph;if(this.nEpochs>0)return this.nEpochs;var t=e.nRows;return t<=2500?500:t<=5e3?400:t<=7500?300:200},n}();Xf.UMAP=Rwt;function jle(n,e){for(var t=0,r=0;r<n.length;r++)t+=Math.pow(n[r]-e[r],2);return Math.sqrt(t)}Xf.euclidean=jle;function Pwt(n,e){for(var t=0,r=0,i=0,s=0;s<n.length;s++)t+=n[s]*e[s],r+=Math.pow(n[s],2),i+=Math.pow(e[s],2);return r===0&&i===0?0:r===0||i===0?1:1-t/Math.sqrt(r*i)}Xf.cosine=Pwt;var Dwt=function(){function n(){this.currentEpoch=0,this.headEmbedding=[],this.tailEmbedding=[],this.head=[],this.tail=[],this.epochsPerSample=[],this.epochOfNextSample=[],this.epochOfNextNegativeSample=[],this.epochsPerNegativeSample=[],this.moveOther=!0,this.initialAlpha=1,this.alpha=1,this.gamma=1,this.a=1.5769434603113077,this.b=.8950608779109733,this.dim=2,this.nEpochs=500,this.nVertices=0}return n}();function Aq(n,e){return n>e?e:n<-e?-e:n}function Mq(n,e){for(var t=0,r=0;r<n.length;r++)t+=Math.pow(n[r]-e[r],2);return t}function qle(n,e){var t=function(f){var d=sL(f,2),p=d[0],m=d[1];return function(g){return 1/(1+p*Math.pow(g,2*m))}},r=is.linear(0,n*3,300).map(function(f){return f<e?1:f}),i=is.zeros(r.length).map(function(f,d){var p=r[d]>=e;return p?Math.exp(-(r[d]-e)/n):f}),s=[.5,.5],o={x:r,y:i},a={damping:1.5,initialValues:s,gradientDifference:.1,maxIterations:100,errorTolerance:.01},l=$wt.default(o,t,a).parameterValues,c=sL(l,2),u=c[0],h=c[1];return{a:u,b:h}}Xf.findABParams=qle;function Xle(n,e,t,r){return t===void 0&&(t=1),r===void 0&&(r=5),n.map(function(i,s,o){return e[s]===-1||e[o]===-1?i*Math.exp(-t):e[s]!==e[o]?i*Math.exp(-r):i})}Xf.fastIntersection=Xle;function Kle(n){n=ji.normalize(n,"max");var e=ji.transpose(n),t=ji.pairwiseMultiply(e,n);return n=ji.add(n,ji.subtract(e,t)),ji.eliminateZeros(n)}Xf.resetLocalConnectivity=Kle;function Yle(n,e,t){for(var r=is.zeros(n.length).map(function(l){return is.zeros(t[0].length)}),i=0;i<n.length;i++)for(var s=0;s<n[0].length;s++)for(var o=0;o<t[0].length;o++){var a=n[i][s];r[i][o]+=e[i][s]*t[a][o]}return r}Xf.initTransform=Yle;Object.defineProperty(Ole,"__esModule",{value:!0});var Owt=Xf;Ole.UMAP=Owt.UMAP;function Ze(){}const z$=n=>n;function Fwt(n,e){for(const t in e)n[t]=e[t];return n}function Lwt(n){return!!n&&(typeof n=="object"||typeof n=="function")&&typeof n.then=="function"}function Zle(n){return n()}function Nq(){return Object.create(null)}function Io(n){n.forEach(Zle)}function t0(n){return typeof n=="function"}function hn(n,e){return n!=n?e==e:n!==e||n&&typeof n=="object"||typeof n=="function"}let kE;function aM(n,e){return kE||(kE=document.createElement("a")),kE.href=e,n===kE.href}function zwt(n){return Object.keys(n).length===0}function vr(n,...e){if(n==null)return Ze;const t=n.subscribe(...e);return t.unsubscribe?()=>t.unsubscribe():t}function c_(n){let e;return vr(n,t=>e=t)(),e}function AV(n,e,t){n.$$.on_destroy.push(vr(e,t))}function Fp(n,e,t,r){if(n){const i=Jle(n,e,t,r);return n[0](i)}}function Jle(n,e,t,r){return n[1]&&r?Fwt(t.ctx.slice(),n[1](r(e))):t.ctx}function Lp(n,e,t,r){if(n[2]&&r){const i=n[2](r(t));if(e.dirty===void 0)return i;if(typeof i=="object"){const s=[],o=Math.max(e.dirty.length,i.length);for(let a=0;a<o;a+=1)s[a]=e.dirty[a]|i[a];return s}return e.dirty|i}return e.dirty}function zp(n,e,t,r,i,s){if(i){const o=Jle(e,t,r,s);n.p(o,i)}}function Bp(n){if(n.ctx.length>32){const e=[],t=n.ctx.length/32;for(let r=0;r<t;r++)e[r]=-1;return e}return-1}function Bwt(n){return n&&t0(n.destroy)?n.destroy:Ze}function Vwt(n){const e=typeof n=="string"&&n.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);return e?[parseFloat(e[1]),e[2]||"px"]:[n,"px"]}const Qle=typeof window<"u";let B$=Qle?()=>window.performance.now():()=>Date.now(),MV=Qle?n=>requestAnimationFrame(n):Ze;const Lb=new Set;function ece(n){Lb.forEach(e=>{e.c(n)||(Lb.delete(e),e.f())}),Lb.size!==0&&MV(ece)}function V$(n){let e;return Lb.size===0&&MV(ece),{promise:new Promise(t=>{Lb.add(e={c:n,f:t})}),abort(){Lb.delete(e)}}}const Uwt=typeof window<"u"?window:typeof globalThis<"u"?globalThis:global;function ie(n,e){n.appendChild(e)}function tce(n){if(!n)return document;const e=n.getRootNode?n.getRootNode():n.ownerDocument;return e&&e.host?e:n.ownerDocument}function Wwt(n){const e=we("style");return Hwt(tce(n),e),e.sheet}function Hwt(n,e){return ie(n.head||n,e),e.sheet}function me(n,e,t){n.insertBefore(e,t||null)}function pe(n){n.parentNode&&n.parentNode.removeChild(n)}function os(n,e){for(let t=0;t<n.length;t+=1)n[t]&&n[t].d(e)}function we(n){return document.createElement(n)}function bi(n){return document.createElementNS("http://www.w3.org/2000/svg",n)}function qe(n){return document.createTextNode(n)}function tt(){return qe(" ")}function po(){return qe("")}function Yn(n,e,t,r){return n.addEventListener(e,t,r),()=>n.removeEventListener(e,t,r)}function jC(n){return function(e){return e.preventDefault(),n.call(this,e)}}function Gwt(n){return function(e){return e.stopPropagation(),n.call(this,e)}}function Z(n,e,t){t==null?n.removeAttribute(e):n.getAttribute(e)!==t&&n.setAttribute(e,t)}function kb(n,e,t){e in n?n[e]=typeof n[e]=="boolean"&&t===""?!0:t:Z(n,e,t)}function jwt(n){return Array.from(n.childNodes)}function cn(n,e){e=""+e,n.data!==e&&(n.data=e)}function Bs(n,e,t,r){t==null?n.style.removeProperty(e):n.style.setProperty(e,t,r?"important":"")}function $q(n,e,t){for(let r=0;r<n.options.length;r+=1){const i=n.options[r];if(i.__value===e){i.selected=!0;return}}(!t||e!==void 0)&&(n.selectedIndex=-1)}function qwt(n){const e=n.querySelector(":checked");return e&&e.__value}let TE;function Xwt(){if(TE===void 0){TE=!1;try{typeof window<"u"&&window.parent&&window.parent.document}catch{TE=!0}}return TE}function Kwt(n,e){getComputedStyle(n).position==="static"&&(n.style.position="relative");const r=we("iframe");r.setAttribute("style","display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;"),r.setAttribute("aria-hidden","true"),r.tabIndex=-1;const i=Xwt();let s;return i?(r.src="data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>",s=Yn(window,"message",o=>{o.source===r.contentWindow&&e()})):(r.src="about:blank",r.onload=()=>{s=Yn(r.contentWindow,"resize",e),e()}),ie(n,r),()=>{(i||s&&r.contentWindow)&&s(),pe(r)}}function Wt(n,e,t){n.classList[t?"add":"remove"](e)}function nce(n,e,{bubbles:t=!1,cancelable:r=!1}={}){const i=document.createEvent("CustomEvent");return i.initCustomEvent(n,t,r,e),i}class Ywt{constructor(e=!1){this.is_svg=!1,this.is_svg=e,this.e=this.n=null}c(e){this.h(e)}m(e,t,r=null){this.e||(this.is_svg?this.e=bi(t.nodeName):this.e=we(t.nodeType===11?"TEMPLATE":t.nodeName),this.t=t.tagName!=="TEMPLATE"?t:t.content,this.c(e)),this.i(r)}h(e){this.e.innerHTML=e,this.n=Array.from(this.e.nodeName==="TEMPLATE"?this.e.content.childNodes:this.e.childNodes)}i(e){for(let t=0;t<this.n.length;t+=1)me(this.t,this.n[t],e)}p(e){this.d(),this.h(e),this.i(this.a)}d(){this.n.forEach(pe)}}const lM=new Map;let cM=0;function Zwt(n){let e=5381,t=n.length;for(;t--;)e=(e<<5)-e^n.charCodeAt(t);return e>>>0}function Jwt(n,e){const t={stylesheet:Wwt(e),rules:{}};return lM.set(n,t),t}function DS(n,e,t,r,i,s,o,a=0){const l=16.666/r;let c=`{
`;for(let g=0;g<=1;g+=l){const y=e+(t-e)*s(g);c+=g*100+`%{${o(y,1-y)}}
`}const u=c+`100% {${o(t,1-t)}}
}`,h=`__svelte_${Zwt(u)}_${a}`,f=tce(n),{stylesheet:d,rules:p}=lM.get(f)||Jwt(f,n);p[h]||(p[h]=!0,d.insertRule(`@keyframes ${h} ${u}`,d.cssRules.length));const m=n.style.animation||"";return n.style.animation=`${m?`${m}, `:""}${h} ${r}ms linear ${i}ms 1 both`,cM+=1,h}function OS(n,e){const t=(n.style.animation||"").split(", "),r=t.filter(e?s=>s.indexOf(e)<0:s=>s.indexOf("__svelte")===-1),i=t.length-r.length;i&&(n.style.animation=r.join(", "),cM-=i,cM||Qwt())}function Qwt(){MV(()=>{cM||(lM.forEach(n=>{const{ownerNode:e}=n.stylesheet;e&&pe(e)}),lM.clear())})}function ext(n,e,t,r){if(!e)return Ze;const i=n.getBoundingClientRect();if(e.left===i.left&&e.right===i.right&&e.top===i.top&&e.bottom===i.bottom)return Ze;const{delay:s=0,duration:o=300,easing:a=z$,start:l=B$()+s,end:c=l+o,tick:u=Ze,css:h}=t(n,{from:e,to:i},r);let f=!0,d=!1,p;function m(){h&&(p=DS(n,0,1,o,s,a,h)),s||(d=!0)}function g(){h&&OS(n,p),f=!1}return V$(y=>{if(!d&&y>=l&&(d=!0),d&&y>=c&&(u(1,0),g()),!f)return!1;if(d){const b=y-l,_=0+1*a(b/o);u(_,1-_)}return!0}),m(),u(0,1),g}function txt(n){const e=getComputedStyle(n);if(e.position!=="absolute"&&e.position!=="fixed"){const{width:t,height:r}=e,i=n.getBoundingClientRect();n.style.position="absolute",n.style.width=t,n.style.height=r,rce(n,i)}}function rce(n,e){const t=n.getBoundingClientRect();if(e.left!==t.left||e.top!==t.top){const r=getComputedStyle(n),i=r.transform==="none"?"":r.transform;n.style.transform=`${i} translate(${e.left-t.left}px, ${e.top-t.top}px)`}}let FS;function If(n){FS=n}function n0(){if(!FS)throw new Error("Function called outside component initialization");return FS}function $h(n){n0().$$.on_mount.push(n)}function ice(n){n0().$$.after_update.push(n)}function Ng(n){n0().$$.on_destroy.push(n)}function Oc(){const n=n0();return(e,t,{cancelable:r=!1}={})=>{const i=n.$$.callbacks[e];if(i){const s=nce(e,t,{cancelable:r});return i.slice().forEach(o=>{o.call(n,s)}),!s.defaultPrevented}return!0}}function nxt(n,e){return n0().$$.context.set(n,e),e}function sce(n){return n0().$$.context.get(n)}function uM(n,e){const t=n.$$.callbacks[e.type];t&&t.slice().forEach(r=>r.call(this,e))}const gb=[],Li=[];let zb=[];const oL=[],oce=Promise.resolve();let aL=!1;function ace(){aL||(aL=!0,oce.then(LS))}function Za(){return ace(),oce}function Rc(n){zb.push(n)}function Fc(n){oL.push(n)}const WP=new Set;let ob=0;function LS(){if(ob!==0)return;const n=FS;do{try{for(;ob<gb.length;){const e=gb[ob];ob++,If(e),rxt(e.$$)}}catch(e){throw gb.length=0,ob=0,e}for(If(null),gb.length=0,ob=0;Li.length;)Li.pop()();for(let e=0;e<zb.length;e+=1){const t=zb[e];WP.has(t)||(WP.add(t),t())}zb.length=0}while(gb.length);for(;oL.length;)oL.pop()();aL=!1,WP.clear(),If(n)}function rxt(n){if(n.fragment!==null){n.update(),Io(n.before_update);const e=n.dirty;n.dirty=[-1],n.fragment&&n.fragment.p(n.ctx,e),n.after_update.forEach(Rc)}}function ixt(n){const e=[],t=[];zb.forEach(r=>n.indexOf(r)===-1?e.push(r):t.push(r)),t.forEach(r=>r()),zb=e}let u1;function NV(){return u1||(u1=Promise.resolve(),u1.then(()=>{u1=null})),u1}function Jm(n,e,t){n.dispatchEvent(nce(`${e?"intro":"outro"}${t}`))}const nI=new Set;let ph;function sr(){ph={r:0,c:[],p:ph}}function or(){ph.r||Io(ph.c),ph=ph.p}function ke(n,e){n&&n.i&&(nI.delete(n),n.i(e))}function $e(n,e,t,r){if(n&&n.o){if(nI.has(n))return;nI.add(n),ph.c.push(()=>{nI.delete(n),r&&(t&&n.d(1),r())}),n.o(e)}else r&&r()}const $V={duration:0};function sxt(n,e,t){const r={direction:"in"};let i=e(n,t,r),s=!1,o,a,l=0;function c(){o&&OS(n,o)}function u(){const{delay:f=0,duration:d=300,easing:p=z$,tick:m=Ze,css:g}=i||$V;g&&(o=DS(n,0,1,d,f,p,g,l++)),m(0,1);const y=B$()+f,b=y+d;a&&a.abort(),s=!0,Rc(()=>Jm(n,!0,"start")),a=V$(_=>{if(s){if(_>=b)return m(1,0),Jm(n,!0,"end"),c(),s=!1;if(_>=y){const w=p((_-y)/d);m(w,1-w)}}return s})}let h=!1;return{start(){h||(h=!0,OS(n),t0(i)?(i=i(r),NV().then(u)):u())},invalidate(){h=!1},end(){s&&(c(),s=!1)}}}function oxt(n,e,t){const r={direction:"out"};let i=e(n,t,r),s=!0,o;const a=ph;a.r+=1;function l(){const{delay:c=0,duration:u=300,easing:h=z$,tick:f=Ze,css:d}=i||$V;d&&(o=DS(n,1,0,u,c,h,d));const p=B$()+c,m=p+u;Rc(()=>Jm(n,!1,"start")),V$(g=>{if(s){if(g>=m)return f(0,1),Jm(n,!1,"end"),--a.r||Io(a.c),!1;if(g>=p){const y=h((g-p)/u);f(1-y,y)}}return s})}return t0(i)?NV().then(()=>{i=i(r),l()}):l(),{end(c){c&&i.tick&&i.tick(1,0),s&&(o&&OS(n,o),s=!1)}}}function Cv(n,e,t,r){const i={direction:"both"};let s=e(n,t,i),o=r?0:1,a=null,l=null,c=null;function u(){c&&OS(n,c)}function h(d,p){const m=d.b-o;return p*=Math.abs(m),{a:o,b:d.b,d:m,duration:p,start:d.start,end:d.start+p,group:d.group}}function f(d){const{delay:p=0,duration:m=300,easing:g=z$,tick:y=Ze,css:b}=s||$V,_={start:B$()+p,b:d};d||(_.group=ph,ph.r+=1),a||l?l=_:(b&&(u(),c=DS(n,o,d,m,p,g,b)),d&&y(0,1),a=h(_,m),Rc(()=>Jm(n,d,"start")),V$(w=>{if(l&&w>l.start&&(a=h(l,m),l=null,Jm(n,a.b,"start"),b&&(u(),c=DS(n,o,a.b,a.duration,0,g,s.css))),a){if(w>=a.end)y(o=a.b,1-o),Jm(n,a.b,"end"),l||(a.b?u():--a.group.r||Io(a.group.c)),a=null;else if(w>=a.start){const S=w-a.start;o=a.a+a.d*g(S/a.duration),y(o,1-o)}}return!!(a||l)}))}return{run(d){t0(s)?NV().then(()=>{s=s(i),f(d)}):f(d)},end(){u(),a=l=null}}}function Rq(n,e){const t=e.token={};function r(i,s,o,a){if(e.token!==t)return;e.resolved=a;let l=e.ctx;o!==void 0&&(l=l.slice(),l[o]=a);const c=i&&(e.current=i)(l);let u=!1;e.block&&(e.blocks?e.blocks.forEach((h,f)=>{f!==s&&h&&(sr(),$e(h,1,1,()=>{e.blocks[f]===h&&(e.blocks[f]=null)}),or())}):e.block.d(1),c.c(),ke(c,1),c.m(e.mount(),e.anchor),u=!0),e.block=c,e.blocks&&(e.blocks[s]=c),u&&LS()}if(Lwt(n)){const i=n0();if(n.then(s=>{If(i),r(e.then,1,e.value,s),If(null)},s=>{if(If(i),r(e.catch,2,e.error,s),If(null),!e.hasCatch)throw s}),e.current!==e.pending)return r(e.pending,0),!0}else{if(e.current!==e.then)return r(e.then,1,e.value,n),!0;e.resolved=n}}function axt(n,e,t){const r=e.slice(),{resolved:i}=n;n.current===n.then&&(r[n.value]=i),n.current===n.catch&&(r[n.error]=i),n.block.p(r,t)}function lce(n,e){$e(n,1,1,()=>{e.delete(n.key)})}function lxt(n,e){n.f(),lce(n,e)}function cce(n,e,t,r,i,s,o,a,l,c,u,h){let f=n.length,d=s.length,p=f;const m={};for(;p--;)m[n[p].key]=p;const g=[],y=new Map,b=new Map,_=[];for(p=d;p--;){const k=h(i,s,p),A=t(k);let M=o.get(A);M?r&&_.push(()=>M.p(k,e)):(M=c(A,k),M.c()),y.set(A,g[p]=M),A in m&&b.set(A,Math.abs(p-m[A]))}const w=new Set,S=new Set;function C(k){ke(k,1),k.m(a,u),o.set(k.key,k),u=k.first,d--}for(;f&&d;){const k=g[d-1],A=n[f-1],M=k.key,E=A.key;k===A?(u=k.first,f--,d--):y.has(E)?!o.has(M)||w.has(M)?C(k):S.has(E)?f--:b.get(M)>b.get(E)?(S.add(M),C(k)):(w.add(E),f--):(l(A,o),f--)}for(;f--;){const k=n[f];y.has(k.key)||l(k,o)}for(;d;)C(g[d-1]);return Io(_),g}function Lc(n,e,t){const r=n.$$.props[e];r!==void 0&&(n.$$.bound[r]=t,t(n.$$.ctx[r]))}function Ct(n){n&&n.c()}function xt(n,e,t,r){const{fragment:i,after_update:s}=n.$$;i&&i.m(e,t),r||Rc(()=>{const o=n.$$.on_mount.map(Zle).filter(t0);n.$$.on_destroy?n.$$.on_destroy.push(...o):Io(o),n.$$.on_mount=[]}),s.forEach(Rc)}function _t(n,e){const t=n.$$;t.fragment!==null&&(ixt(t.after_update),Io(t.on_destroy),t.fragment&&t.fragment.d(e),t.on_destroy=t.fragment=null,t.ctx=[])}function cxt(n,e){n.$$.dirty[0]===-1&&(gb.push(n),ace(),n.$$.dirty.fill(0)),n.$$.dirty[e/31|0]|=1<<e%31}function mn(n,e,t,r,i,s,o,a=[-1]){const l=FS;If(n);const c=n.$$={fragment:null,ctx:[],props:s,update:Ze,not_equal:i,bound:Nq(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(e.context||(l?l.$$.context:[])),callbacks:Nq(),dirty:a,skip_bound:!1,root:e.target||l.$$.root};o&&o(c.root);let u=!1;if(c.ctx=t?t(n,e.props||{},(h,f,...d)=>{const p=d.length?d[0]:f;return c.ctx&&i(c.ctx[h],c.ctx[h]=p)&&(!c.skip_bound&&c.bound[h]&&c.bound[h](p),u&&cxt(n,h)),f}):[],c.update(),u=!0,Io(c.before_update),c.fragment=r?r(c.ctx):!1,e.target){if(e.hydrate){const h=jwt(e.target);c.fragment&&c.fragment.l(h),h.forEach(pe)}else c.fragment&&c.fragment.c();e.intro&&ke(n.$$.fragment),xt(n,e.target,e.anchor,e.customElement),LS()}If(l)}class gn{$destroy(){_t(this,1),this.$destroy=Ze}$on(e,t){if(!t0(t))return Ze;const r=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return r.push(t),()=>{const i=r.indexOf(t);i!==-1&&r.splice(i,1)}}$set(e){this.$$set&&!zwt(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}function uxt(n){let e,t,r,i,s;const o=n[10].default,a=Fp(o,n,n[9],null);return{c(){e=tt(),t=we("button"),a&&a.c(),Z(t,"class","marcelle svelte-2j0fl0"),t.disabled=n[1],Wt(t,"outline",n[0]==="outline"),Wt(t,"filled",n[0]==="filled"),Wt(t,"light",n[0]==="light"),Wt(t,"success",n[2]==="success"),Wt(t,"warning",n[2]==="warning"),Wt(t,"danger",n[2]==="danger"),Wt(t,"size-small",n[3]==="small"),Wt(t,"size-large",n[3]==="large"),Wt(t,"round",n[4])},m(l,c){me(l,e,c),me(l,t,c),a&&a.m(t,null),r=!0,i||(s=[Yn(document.body,"mouseup",n[6]),Yn(document.body,"touchend",n[6]),Yn(t,"click",n[11]),Yn(t,"mousedown",n[5]),Yn(t,"touchstart",jC(n[5])),Yn(t,"touchend",n[7])],i=!0)},p(l,[c]){a&&a.p&&(!r||c&512)&&zp(a,o,l,l[9],r?Lp(o,l[9],c,null):Bp(l[9]),null),(!r||c&2)&&(t.disabled=l[1]),(!r||c&1)&&Wt(t,"outline",l[0]==="outline"),(!r||c&1)&&Wt(t,"filled",l[0]==="filled"),(!r||c&1)&&Wt(t,"light",l[0]==="light"),(!r||c&4)&&Wt(t,"success",l[2]==="success"),(!r||c&4)&&Wt(t,"warning",l[2]==="warning"),(!r||c&4)&&Wt(t,"danger",l[2]==="danger"),(!r||c&8)&&Wt(t,"size-small",l[3]==="small"),(!r||c&8)&&Wt(t,"size-large",l[3]==="large"),(!r||c&16)&&Wt(t,"round",l[4])},i(l){r||(ke(a,l),r=!0)},o(l){$e(a,l),r=!1},d(l){l&&pe(e),l&&pe(t),a&&a.d(l),i=!1,Io(s)}}}function hxt(n,e,t){let{$$slots:r={},$$scope:i}=e,{variant:s="outline"}=e,{disabled:o=!1}=e,{type:a="default"}=e,{size:l="medium"}=e,{round:c=!1}=e,{pressed:u=!1}=e;const h=Oc();function f(){t(8,u=!0),h("pressed",u)}function d(){u&&(t(8,u=!1),h("pressed",u))}function p(g){h("click",g)}function m(g){uM.call(this,n,g)}return n.$$set=g=>{"variant"in g&&t(0,s=g.variant),"disabled"in g&&t(1,o=g.disabled),"type"in g&&t(2,a=g.type),"size"in g&&t(3,l=g.size),"round"in g&&t(4,c=g.round),"pressed"in g&&t(8,u=g.pressed),"$$scope"in g&&t(9,i=g.$$scope)},[s,o,a,l,c,f,d,p,u,i,r,m]}let zi=class extends gn{constructor(e){super(),mn(this,e,hxt,uxt,hn,{variant:0,disabled:1,type:2,size:3,round:4,pressed:8})}};function fxt(n){let e,t,r;return{c(){e=we("input"),Z(e,"class","marcelle svelte-1mutsa0"),e.disabled=n[2],Z(e,"type",n[3]),Z(e,"placeholder",n[1]),e.value=n[0]},m(i,s){me(i,e,s),t||(r=Yn(e,"input",n[4]),t=!0)},p(i,[s]){s&4&&(e.disabled=i[2]),s&8&&Z(e,"type",i[3]),s&2&&Z(e,"placeholder",i[1]),s&1&&e.value!==i[0]&&(e.value=i[0])},i:Ze,o:Ze,d(i){i&&pe(e),t=!1,r()}}}function dxt(n,e,t){let{placeholder:r=""}=e,{disabled:i=!1}=e,{type:s="text"}=e,{value:o=null}=e;function a(l){t(0,o=l.currentTarget.value)}return n.$$set=l=>{"placeholder"in l&&t(1,r=l.placeholder),"disabled"in l&&t(2,i=l.disabled),"type"in l&&t(3,s=l.type),"value"in l&&t(0,o=l.value)},[o,r,i,s,a]}class uce extends gn{constructor(e){super(),mn(this,e,dxt,fxt,hn,{placeholder:1,disabled:2,type:3,value:0})}}function pxt(n){let e,t,r,i,s,o,a,l;const c=n[2].default,u=Fp(c,n,n[1],null);return{c(){e=we("div"),t=we("div"),r=we("div"),i=tt(),s=we("div"),u&&u.c(),Z(r,"class","absolute inset-0 bg-gray-500 opacity-50"),Z(t,"class","overlay svelte-1sg0y6b"),Z(s,"class","modal svelte-1sg0y6b"),Z(e,"class","modal-container svelte-1sg0y6b")},m(h,f){me(h,e,f),ie(e,t),ie(t,r),ie(e,i),ie(e,s),u&&u.m(s,null),o=!0,a||(l=[Yn(r,"click",n[0]),Yn(r,"keypress",jC(n[3]))],a=!0)},p(h,[f]){u&&u.p&&(!o||f&2)&&zp(u,c,h,h[1],o?Lp(c,h[1],f,null):Bp(h[1]),null)},i(h){o||(ke(u,h),o=!0)},o(h){$e(u,h),o=!1},d(h){h&&pe(e),u&&u.d(h),a=!1,Io(l)}}}function mxt(n,e,t){let{$$slots:r={},$$scope:i}=e;const s=Oc();function o(){s("quit")}const a=l=>l.key==="Escape"&&o();return n.$$set=l=>{"$$scope"in l&&t(1,i=l.$$scope)},[o,i,r,a]}class hce extends gn{constructor(e){super(),mn(this,e,mxt,pxt,hn,{quit:0})}get quit(){return this.$$.ctx[0]}}function gxt(n){return n<.5?4*n*n*n:.5*Math.pow(2*n-2,3)+1}function RV(n){const e=n-1;return e*e*e+1}function hM(n,{delay:e=0,duration:t=400,easing:r=gxt,amount:i=5,opacity:s=0}={}){const o=getComputedStyle(n),a=+o.opacity,l=o.filter==="none"?"":o.filter,c=a*(1-s),[u,h]=Vwt(i);return{delay:e,duration:t,easing:r,css:(f,d)=>`opacity: ${a-c*d}; filter: ${l} blur(${d*u}${h});`}}function Pq(n,{delay:e=0,duration:t=400,easing:r=RV,axis:i="y"}={}){const s=getComputedStyle(n),o=+s.opacity,a=i==="y"?"height":"width",l=parseFloat(s[a]),c=i==="y"?["top","bottom"]:["left","right"],u=c.map(y=>`${y[0].toUpperCase()}${y.slice(1)}`),h=parseFloat(s[`padding${u[0]}`]),f=parseFloat(s[`padding${u[1]}`]),d=parseFloat(s[`margin${u[0]}`]),p=parseFloat(s[`margin${u[1]}`]),m=parseFloat(s[`border${u[0]}Width`]),g=parseFloat(s[`border${u[1]}Width`]);return{delay:e,duration:t,easing:r,css:y=>`overflow: hidden;opacity: ${Math.min(y*20,1)*o};${a}: ${y*l}px;padding-${c[0]}: ${y*h}px;padding-${c[1]}: ${y*f}px;margin-${c[0]}: ${y*d}px;margin-${c[1]}: ${y*p}px;border-${c[0]}-width: ${y*m}px;border-${c[1]}-width: ${y*g}px;`}}function Dq(n,{delay:e=0,duration:t=400,easing:r=RV,start:i=0,opacity:s=0}={}){const o=getComputedStyle(n),a=+o.opacity,l=o.transform==="none"?"":o.transform,c=1-i,u=a*(1-s);return{delay:e,duration:t,easing:r,css:(h,f)=>`
			transform: ${l} scale(${1-c*f});
			opacity: ${a-u*f}
		`}}function yxt(n,{from:e,to:t},r={}){const i=getComputedStyle(n),s=i.transform==="none"?"":i.transform,[o,a]=i.transformOrigin.split(" ").map(parseFloat),l=e.left+e.width*o/t.width-(t.left+o),c=e.top+e.height*a/t.height-(t.top+a),{delay:u=0,duration:h=d=>Math.sqrt(d)*120,easing:f=RV}=r;return{delay:u,duration:t0(h)?h(Math.sqrt(l*l+c*c)):h,easing:f,css:(d,p)=>{const m=p*l,g=p*c,y=d+p*e.width/t.width,b=d+p*e.height/t.height;return`transform: ${s} translate(${m}px, ${g}px) scale(${y}, ${b});`}}}function Oq(n,e,t){const r=n.slice();return r[6]=e[t].title,r[7]=e[t].message,r[8]=e[t].type,r[9]=e[t].id,r}function bxt(n){let e;return{c(){e=bi("path"),Z(e,"d",`M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0
                4.34 4.34a8 8 0 0 0 11.32 11.32zM9 5h2v6H9V5zm0 8h2v2H9v-2z`)},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function vxt(n){let e;return{c(){e=bi("path"),Z(e,"d",`M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0
                4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z`)},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function Fq(n,e){let t,r,i,s,o,a,l,c=e[6]+"",u,h,f,d=e[7]+"",p,m,g,y,b,_,w,S,C,k,A=Ze,M,E,N;function O(X,H){if(X[8]==="default")return vxt;if(X[8]==="danger")return bxt}let R=O(e),D=R&&R(e);function z(){return e[3](e[9])}function B(...X){return e[4](e[9],...X)}return{key:n,first:null,c(){t=we("div"),r=we("div"),i=we("div"),s=bi("svg"),D&&D.c(),o=tt(),a=we("div"),l=we("p"),u=qe(c),h=tt(),f=we("p"),p=qe(d),m=tt(),g=we("div"),y=bi("svg"),b=bi("title"),_=qe("Close"),w=bi("path"),S=tt(),Z(s,"class","notification-svg mr-4 svelte-c58nio"),Z(s,"xmlns","http://www.w3.org/2000/svg"),Z(s,"viewBox","0 0 20 20"),Wt(s,"default",e[8]==="default"),Wt(s,"danger",e[8]==="danger"),Z(i,"class","py-1"),Z(l,"class","my-1 font-bold"),Z(f,"class","my-1 text-sm"),Z(w,"d",`M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1
              1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10
              8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0
              1.698z`),Z(y,"class","notification-svg ml-4 cursor-pointer svelte-c58nio"),Z(y,"role","button"),Z(y,"xmlns","http://www.w3.org/2000/svg"),Z(y,"viewBox","0 0 20 20"),Wt(y,"default",e[8]==="default"),Wt(y,"danger",e[8]==="danger"),Z(r,"class","flex items-start"),Z(t,"class","notification-card svelte-c58nio"),Z(t,"role","alert"),Wt(t,"default",e[8]==="default"),Wt(t,"danger",e[8]==="danger"),this.first=t},m(X,H){me(X,t,H),ie(t,r),ie(r,i),ie(i,s),D&&D.m(s,null),ie(r,o),ie(r,a),ie(a,l),ie(l,u),ie(a,h),ie(a,f),ie(f,p),ie(r,m),ie(r,g),ie(g,y),ie(y,b),ie(b,_),ie(y,w),ie(t,S),M=!0,E||(N=[Yn(y,"click",z),Yn(y,"keypress",jC(B))],E=!0)},p(X,H){e=X,R!==(R=O(e))&&(D&&D.d(1),D=R&&R(e),D&&(D.c(),D.m(s,null))),(!M||H&1)&&Wt(s,"default",e[8]==="default"),(!M||H&1)&&Wt(s,"danger",e[8]==="danger"),(!M||H&1)&&c!==(c=e[6]+"")&&cn(u,c),(!M||H&1)&&d!==(d=e[7]+"")&&cn(p,d),(!M||H&1)&&Wt(y,"default",e[8]==="default"),(!M||H&1)&&Wt(y,"danger",e[8]==="danger"),(!M||H&1)&&Wt(t,"default",e[8]==="default"),(!M||H&1)&&Wt(t,"danger",e[8]==="danger")},r(){k=t.getBoundingClientRect()},f(){txt(t),A(),rce(t,k)},a(){A(),A=ext(t,k,yxt,{})},i(X){M||(Rc(()=>{M&&(C||(C=Cv(t,hM,{amount:10},!0)),C.run(1))}),M=!0)},o(X){C||(C=Cv(t,hM,{amount:10},!1)),C.run(0),M=!1},d(X){X&&pe(t),D&&D.d(),X&&C&&C.end(),E=!1,Io(N)}}}function wxt(n){let e,t=[],r=new Map,i,s=n[0].slice(0,10);const o=a=>a[9];for(let a=0;a<s.length;a+=1){let l=Oq(n,s,a),c=o(l);r.set(c,t[a]=Fq(c,l))}return{c(){e=we("div");for(let a=0;a<t.length;a+=1)t[a].c();Z(e,"class","marcelle notification-container svelte-c58nio")},m(a,l){me(a,e,l);for(let c=0;c<t.length;c+=1)t[c]&&t[c].m(e,null);i=!0},p(a,[l]){if(l&3){s=a[0].slice(0,10),sr();for(let c=0;c<t.length;c+=1)t[c].r();t=cce(t,l,o,1,a,s,r,e,lxt,Fq,null,Oq);for(let c=0;c<t.length;c+=1)t[c].a();or()}},i(a){if(!i){for(let l=0;l<s.length;l+=1)ke(t[l]);i=!0}},o(a){for(let l=0;l<t.length;l+=1)$e(t[l]);i=!1},d(a){a&&pe(e);for(let l=0;l<t.length;l+=1)t[l].d()}}}function xxt(n,e,t){let{notifications:r=[]}=e;function i(c){t(0,r=r.filter(u=>u.id!==c))}let s=1;function o({title:c,message:u,type:h="default",duration:f=3e3}){const d={id:s,title:c,message:u,type:h};s+=1,t(0,r=[...r,d]),f>0&&setTimeout(()=>{i(d.id)},f)}const a=c=>i(c),l=(c,u)=>u.key==="Escape"&&i(c);return n.$$set=c=>{"notifications"in c&&t(0,r=c.notifications)},[r,i,o,a,l]}class _xt extends gn{constructor(e){super(),mn(this,e,xxt,wxt,hn,{notifications:0,add:2})}get add(){return this.$$.ctx[2]}}function Sxt(n){let e,t,r,i,s,o,a,l,c,u;return{c(){e=we("div"),t=we("button"),r=qe("-"),i=tt(),s=we("input"),o=tt(),a=we("button"),l=qe("+"),t.disabled=n[1],Z(t,"class","left svelte-1w23q60"),Z(s,"type","number"),Z(s,"inputmode","decimal"),s.value=n[0],s.disabled=n[1],Bs(s,"width","80px"),Z(s,"class","svelte-1w23q60"),a.disabled=n[1],Z(a,"class","right svelte-1w23q60"),Z(e,"class","flex")},m(h,f){me(h,e,f),ie(e,t),ie(t,r),ie(e,i),ie(e,s),ie(e,o),ie(e,a),ie(a,l),c||(u=[Yn(t,"click",n[3]),Yn(s,"change",n[2]),Yn(a,"click",n[4])],c=!0)},p(h,[f]){f&2&&(t.disabled=h[1]),f&1&&s.value!==h[0]&&(s.value=h[0]),f&2&&(s.disabled=h[1]),f&2&&(a.disabled=h[1])},i:Ze,o:Ze,d(h){h&&pe(e),c=!1,Io(u)}}}function Cxt(n,e,t){let{disabled:r=!1}=e,{value:i}=e;function s(l){const c=l.target,u=parseFloat(c.value);Number.isNaN(u)?c.value=i.toString():t(0,i=u)}const o=()=>{t(0,i-=1)},a=()=>{t(0,i+=1)};return n.$$set=l=>{"disabled"in l&&t(1,r=l.disabled),"value"in l&&t(0,i=l.value)},[i,r,s,o,a]}class kxt extends gn{constructor(e){super(),mn(this,e,Cxt,Sxt,hn,{disabled:1,value:0})}}function Lq(n,e,t){const r=n.slice();return r[12]=e[t],r[14]=t,r}function zq(n){let e,t,r,i,s,o,a,l,c,u=n[0],h=[];for(let f=0;f<u.length;f+=1)h[f]=Bq(Lq(n,u,f));return{c(){e=we("div");for(let f=0;f<h.length;f+=1)h[f].c();t=tt(),r=we("button"),i=qe("-"),s=tt(),o=we("button"),a=qe("+"),r.disabled=n[1],Z(r,"class","left svelte-1w23q60"),o.disabled=n[1],Z(o,"class","right svelte-1w23q60"),Bs(o,"border-left","none"),Z(e,"class","flex items-center")},m(f,d){me(f,e,d);for(let p=0;p<h.length;p+=1)h[p]&&h[p].m(e,null);ie(e,t),ie(e,r),ie(r,i),ie(e,s),ie(e,o),ie(o,a),l||(c=[Yn(r,"click",n[10]),Yn(o,"click",n[11])],l=!0)},p(f,d){if(d&31){u=f[0];let p;for(p=0;p<u.length;p+=1){const m=Lq(f,u,p);h[p]?h[p].p(m,d):(h[p]=Bq(m),h[p].c(),h[p].m(e,t))}for(;p<h.length;p+=1)h[p].d(1);h.length=u.length}d&2&&(r.disabled=f[1]),d&2&&(o.disabled=f[1])},d(f){f&&pe(e),os(h,f),l=!1,Io(c)}}}function Bq(n){let e,t,r,i,s,o,a,l,c,u,h;function f(){return n[7](n[14])}function d(...m){return n[8](n[14],...m)}function p(){return n[9](n[14])}return{c(){e=we("div"),t=we("button"),r=qe("-"),i=tt(),s=we("input"),a=tt(),l=we("button"),c=qe("+"),t.disabled=n[1],Z(t,"class","left svelte-1w23q60"),Z(s,"type","number"),Z(s,"inputmode","decimal"),s.value=o=n[12],s.disabled=n[1],Bs(s,"width","80px"),Z(s,"class","svelte-1w23q60"),l.disabled=n[1],Z(l,"class","right svelte-1w23q60"),Z(e,"class","flex mr-2")},m(m,g){me(m,e,g),ie(e,t),ie(t,r),ie(e,i),ie(e,s),ie(e,a),ie(e,l),ie(l,c),u||(h=[Yn(t,"click",f),Yn(s,"change",d),Yn(l,"click",p)],u=!0)},p(m,g){n=m,g&2&&(t.disabled=n[1]),g&1&&o!==(o=n[12])&&s.value!==o&&(s.value=o),g&2&&(s.disabled=n[1]),g&2&&(l.disabled=n[1])},d(m){m&&pe(e),u=!1,Io(h)}}}function Txt(n){let e=n[0]&&Array.isArray(n[0]),t,r=e&&zq(n);return{c(){r&&r.c(),t=po()},m(i,s){r&&r.m(i,s),me(i,t,s)},p(i,[s]){s&1&&(e=i[0]&&Array.isArray(i[0])),e?r?r.p(i,s):(r=zq(i),r.c(),r.m(t.parentNode,t)):r&&(r.d(1),r=null)},i:Ze,o:Ze,d(i){r&&r.d(i),i&&pe(t)}}}function Ext(n,e,t){let{disabled:r=!1}=e,{value:i}=e;function s(m,g){const y=m.target,b=parseFloat(y.value);Number.isNaN(b)?y.value=i[g].toString():t(0,i[g]=b,i)}function o(m){const g=i.slice();g[m]-=1,t(0,i=g)}function a(m){const g=i.slice();g[m]+=1,t(0,i=g)}function l(){const m=i.slice();m.push(m.length?m[m.length-1]:0),t(0,i=m)}function c(){t(0,i=i.slice(0,i.length-1))}const u=m=>o(m),h=(m,g)=>s(g,m),f=m=>a(m),d=()=>c(),p=()=>l();return n.$$set=m=>{"disabled"in m&&t(1,r=m.disabled),"value"in m&&t(0,i=m.value)},[i,r,s,o,a,l,c,u,h,f,d,p]}let Ixt=class extends gn{constructor(e){super(),mn(this,e,Ext,Txt,hn,{disabled:1,value:0})}};function Vq(n,e,t){const r=n.slice();return r[7]=e[t],r}function Axt(n){let e,t;return{c(){e=bi("svg"),t=bi("path"),Z(t,"d","M10 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0-6a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"),Z(e,"class","fill-current inline-block h-5 w-5"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"viewBox","0 0 20 20")},m(r,i){me(r,e,i),ie(e,t)},p:Ze,d(r){r&&pe(e)}}}function Uq(n){let e,t,r,i,s,o=n[0],a=[];for(let l=0;l<o.length;l+=1)a[l]=Wq(Vq(n,o,l));return{c(){e=we("div"),t=we("div"),r=we("div");for(let l=0;l<a.length;l+=1)a[l].c();Z(r,"class","py-1"),Z(r,"role","menu"),Z(r,"aria-orientation","vertical"),Z(r,"aria-labelledby","options-menu"),Z(t,"class","origin-top-right absolute right-0 mt-1 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none"),Z(e,"class","origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg z-50"),Wt(e,"hidden",!1)},m(l,c){me(l,e,c),ie(e,t),ie(t,r);for(let u=0;u<a.length;u+=1)a[u]&&a[u].m(r,null);s=!0},p(l,c){if(c&9){o=l[0];let u;for(u=0;u<o.length;u+=1){const h=Vq(l,o,u);a[u]?a[u].p(h,c):(a[u]=Wq(h),a[u].c(),a[u].m(r,null))}for(;u<a.length;u+=1)a[u].d(1);a.length=o.length}},i(l){s||(Rc(()=>{s&&(i||(i=Cv(e,Pq,{duration:100},!0)),i.run(1))}),s=!0)},o(l){i||(i=Cv(e,Pq,{duration:100},!1)),i.run(0),s=!1},d(l){l&&pe(e),os(a,l),l&&i&&i.end()}}}function Wq(n){let e,t=n[7].text+"",r,i,s,o;function a(){return n[5](n[7])}return{c(){e=we("button"),r=qe(t),i=tt(),Z(e,"class","text-sm py-2 px-4 font-normal block w-full whitespace-no-wrap bg-transparent text-gray-800 hover:bg-gray-100 border-0 cursor-pointer")},m(l,c){me(l,e,c),ie(e,r),ie(e,i),s||(o=Yn(e,"click",a),s=!0)},p(l,c){n=l,c&1&&t!==(t=n[7].text+"")&&cn(r,t)},d(l){l&&pe(e),s=!1,o()}}}function Mxt(n){let e,t,r,i,s,o,a;r=new zi({props:{size:"small",round:!0,$$slots:{default:[Axt]},$$scope:{ctx:n}}}),r.$on("click",n[2]);let l=n[1]&&Uq(n);return{c(){e=tt(),t=we("div"),Ct(r.$$.fragment),i=tt(),l&&l.c(),Z(t,"class","relative")},m(c,u){me(c,e,u),me(c,t,u),xt(r,t,null),ie(t,i),l&&l.m(t,null),s=!0,o||(a=Yn(document.body,"click",n[4]),o=!0)},p(c,[u]){const h={};u&1024&&(h.$$scope={dirty:u,ctx:c}),r.$set(h),c[1]?l?(l.p(c,u),u&2&&ke(l,1)):(l=Uq(c),l.c(),ke(l,1),l.m(t,null)):l&&(sr(),$e(l,1,1,()=>{l=null}),or())},i(c){s||(ke(r.$$.fragment,c),ke(l),s=!0)},o(c){$e(r.$$.fragment,c),$e(l),s=!1},d(c){c&&pe(e),c&&pe(t),_t(r),l&&l.d(),o=!1,a()}}}function Nxt(n,e,t){let{actions:r=[]}=e;const i=Oc();let s=!1;function o(u){u.stopPropagation(),s?t(1,s=!1):t(1,s=!0)}function a(u){i("select",u)}const l=()=>{t(1,s=!1)},c=u=>a(u.code);return n.$$set=u=>{"actions"in u&&t(0,r=u.actions)},[r,s,o,a,l,c]}class $xt extends gn{constructor(e){super(),mn(this,e,Nxt,Mxt,hn,{actions:0})}}function Rxt(n){let e,t;return{c(){e=we("div"),Z(e,"class","progress-line svelte-dee3y"),Z(e,"style",t=n[0]>=0?`--bar-mr: ${100-Math.floor(n[0]*100)}%;`:"--bar-mr: 0px"),Wt(e,"thin",n[2]),Wt(e,"indeterminate",n[0]===void 0||n[0]===null||n[0]<0),Wt(e,"gray",n[1]==="idle"),Wt(e,"green",n[1]==="success"),Wt(e,"red",n[1]==="danger")},m(r,i){me(r,e,i)},p(r,[i]){i&1&&t!==(t=r[0]>=0?`--bar-mr: ${100-Math.floor(r[0]*100)}%;`:"--bar-mr: 0px")&&Z(e,"style",t),i&4&&Wt(e,"thin",r[2]),i&1&&Wt(e,"indeterminate",r[0]===void 0||r[0]===null||r[0]<0),i&2&&Wt(e,"gray",r[1]==="idle"),i&2&&Wt(e,"green",r[1]==="success"),i&2&&Wt(e,"red",r[1]==="danger")},i:Ze,o:Ze,d(r){r&&pe(e)}}}function Pxt(n,e,t){let{progress:r}=e,{type:i="default"}=e,{thin:s=!1}=e;return n.$$set=o=>{"progress"in o&&t(0,r=o.progress),"type"in o&&t(1,i=o.type),"thin"in o&&t(2,s=o.thin)},[r,i,s]}class fce extends gn{constructor(e){super(),mn(this,e,Pxt,Rxt,hn,{progress:0,type:1,thin:2})}}function Hq(n,e,t){const r=n.slice();return r[7]=e[t],r}function Gq(n){let e,t;return{c(){e=we("option"),t=qe(n[2]),e.__value="",e.value=e.__value,e.disabled=!0,Z(e,"class","svelte-g3sqa4")},m(r,i){me(r,e,i),ie(e,t)},p(r,i){i&4&&cn(t,r[2])},d(r){r&&pe(e)}}}function jq(n){let e,t=n[7]+"",r,i;return{c(){e=we("option"),r=qe(t),e.__value=i=n[7],e.value=e.__value,Z(e,"class","svelte-g3sqa4")},m(s,o){me(s,e,o),ie(e,r)},p(s,o){o&2&&t!==(t=s[7]+"")&&cn(r,t),o&2&&i!==(i=s[7])&&(e.__value=i,e.value=e.__value)},d(s){s&&pe(e)}}}function Dxt(n){let e,t,r,i,s,o,a,l=n[2]&&Gq(n),c=n[1],u=[];for(let h=0;h<c.length;h+=1)u[h]=jq(Hq(n,c,h));return{c(){e=we("div"),t=we("select"),l&&l.c(),r=po();for(let h=0;h<u.length;h+=1)u[h].c();i=tt(),s=we("div"),s.innerHTML='<svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"></path></svg>',Z(t,"class","svelte-g3sqa4"),n[0]===void 0&&Rc(()=>n[5].call(t)),Wt(t,"small",n[3]==="small"),Z(s,"class","pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700"),Z(e,"class","select-container svelte-g3sqa4")},m(h,f){me(h,e,f),ie(e,t),l&&l.m(t,null),ie(t,r);for(let d=0;d<u.length;d+=1)u[d]&&u[d].m(t,null);$q(t,n[0],!0),ie(e,i),ie(e,s),o||(a=[Yn(t,"change",n[5]),Yn(t,"change",n[6])],o=!0)},p(h,[f]){if(h[2]?l?l.p(h,f):(l=Gq(h),l.c(),l.m(t,r)):l&&(l.d(1),l=null),f&2){c=h[1];let d;for(d=0;d<c.length;d+=1){const p=Hq(h,c,d);u[d]?u[d].p(p,f):(u[d]=jq(p),u[d].c(),u[d].m(t,null))}for(;d<u.length;d+=1)u[d].d(1);u.length=c.length}f&3&&$q(t,h[0]),f&8&&Wt(t,"small",h[3]==="small")},i:Ze,o:Ze,d(h){h&&pe(e),l&&l.d(),os(u,h),o=!1,Io(a)}}}function Oxt(n,e,t){let{options:r}=e,{value:i=""}=e,{placeholder:s="Select an Option"}=e,{size:o="normal"}=e;const a=Oc();function l(){i=qwt(this),t(0,i),t(1,r)}const c=u=>a("change",u.currentTarget.value);return n.$$set=u=>{"options"in u&&t(1,r=u.options),"value"in u&&t(0,i=u.value),"placeholder"in u&&t(2,s=u.placeholder),"size"in u&&t(3,o=u.size)},[i,r,s,o,a,l,c]}let dce=class extends gn{constructor(e){super(),mn(this,e,Oxt,Dxt,hn,{options:1,value:0,placeholder:2,size:3})}};function Fxt(n){let e;return{c(){e=we("span"),e.innerHTML='<span class="spinner svelte-zvuq20"><span class="dot1 svelte-zvuq20"></span>  <span class="dot2 svelte-zvuq20"></span></span>',Z(e,"class","spinner-container svelte-zvuq20")},m(t,r){me(t,e,r)},p:Ze,i:Ze,o:Ze,d(t){t&&pe(e)}}}class PV extends gn{constructor(e){super(),mn(this,e,null,Fxt,hn,{})}}function Lxt(n){let e,t,r,i,s,o,a,l,c;return{c(){e=we("label"),t=we("input"),r=tt(),i=we("span"),i.innerHTML=`<span class="track svelte-smv03c"></span> 
    <span class="thumb svelte-smv03c"></span>`,s=tt(),o=we("span"),a=qe(n[1]),Z(t,"type","checkbox"),t.disabled=n[2],Z(t,"class","svelte-smv03c"),Z(i,"class","switch svelte-smv03c"),Z(o,"class","ml-2 cursor-pointer"),Z(e,"class","marcelle")},m(u,h){me(u,e,h),ie(e,t),t.checked=n[0],ie(e,r),ie(e,i),ie(e,s),ie(e,o),ie(o,a),l||(c=Yn(t,"change",n[3]),l=!0)},p(u,[h]){h&4&&(t.disabled=u[2]),h&1&&(t.checked=u[0]),h&2&&cn(a,u[1])},i:Ze,o:Ze,d(u){u&&pe(e),l=!1,c()}}}function zxt(n,e,t){let{text:r=""}=e,{checked:i=!1}=e,{disabled:s=!1}=e;function o(){i=this.checked,t(0,i)}return n.$$set=a=>{"text"in a&&t(1,r=a.text),"checked"in a&&t(0,i=a.checked),"disabled"in a&&t(2,s=a.disabled)},[i,r,s,o]}class DV extends gn{constructor(e){super(),mn(this,e,zxt,Lxt,hn,{text:1,checked:0,disabled:2})}}const ab=[];function u_(n,e=Ze){let t;const r=new Set;function i(a){if(hn(n,a)&&(n=a,t)){const l=!ab.length;for(const c of r)c[1](),ab.push(c,n);if(l){for(let c=0;c<ab.length;c+=2)ab[c][0](ab[c+1]);ab.length=0}}}function s(a){i(a(n))}function o(a,l=Ze){const c=[a,l];return r.add(c),r.size===1&&(t=e(i)||Ze),a(n),()=>{r.delete(c),r.size===0&&t&&(t(),t=null)}}return{set:i,update:s,subscribe:o}}function Bxt(n){let e,t;const r=n[1].default,i=Fp(r,n,n[0],null);return{c(){e=we("div"),i&&i.c(),Z(e,"class","tabs")},m(s,o){me(s,e,o),i&&i.m(e,null),t=!0},p(s,[o]){i&&i.p&&(!t||o&1)&&zp(i,r,s,s[0],t?Lp(r,s[0],o,null):Bp(s[0]),null)},i(s){t||(ke(i,s),t=!0)},o(s){$e(i,s),t=!1},d(s){s&&pe(e),i&&i.d(s)}}}const OV={};function Vxt(n,e,t){let{$$slots:r={},$$scope:i}=e;const s=[],o=[],a=u_(null),l=u_(null);return nxt(OV,{registerTab:c=>{s.push(c),a.update(u=>u||c),Ng(()=>{const u=s.indexOf(c);s.splice(u,1),a.update(h=>h===c?s[u]||s[s.length-1]:h)})},registerPanel:c=>{o.push(c),l.update(u=>u||c),Ng(()=>{const u=o.indexOf(c);o.splice(u,1),l.update(h=>h===c?o[u]||o[o.length-1]:h)})},selectTab:c=>{const u=s.indexOf(c);a.set(c),l.set(o[u])},selectedTab:a,selectedPanel:l}),n.$$set=c=>{"$$scope"in c&&t(0,i=c.$$scope)},[i,r]}class Uxt extends gn{constructor(e){super(),mn(this,e,Vxt,Bxt,hn,{})}}function Wxt(n){let e,t,r,i;const s=n[5].default,o=Fp(s,n,n[4],null);return{c(){e=we("div"),o&&o.c(),Z(e,"class","text-sm font-semibold text-gray-600 cursor-pointer mx-4 p-2 hover:text-gray-800 svelte-d0yt2a"),Z(e,"role","tab"),Wt(e,"selected",n[0]===n[1])},m(a,l){me(a,e,l),o&&o.m(e,null),t=!0,r||(i=Yn(e,"click",n[6]),r=!0)},p(a,[l]){o&&o.p&&(!t||l&16)&&zp(o,s,a,a[4],t?Lp(s,a[4],l,null):Bp(a[4]),null),(!t||l&3)&&Wt(e,"selected",a[0]===a[1])},i(a){t||(ke(o,a),t=!0)},o(a){$e(o,a),t=!1},d(a){a&&pe(e),o&&o.d(a),r=!1,i()}}}function Hxt(n,e,t){let r,{$$slots:i={},$$scope:s}=e;const o={},{registerTab:a,selectTab:l,selectedTab:c}=sce(OV);AV(n,c,h=>t(0,r=h)),a(o);const u=()=>l(o);return n.$$set=h=>{"$$scope"in h&&t(4,s=h.$$scope)},[r,o,l,c,s,i,u]}class EE extends gn{constructor(e){super(),mn(this,e,Hxt,Wxt,hn,{})}}function qq(n){let e;const t=n[4].default,r=Fp(t,n,n[3],null);return{c(){r&&r.c()},m(i,s){r&&r.m(i,s),e=!0},p(i,s){r&&r.p&&(!e||s&8)&&zp(r,t,i,i[3],e?Lp(t,i[3],s,null):Bp(i[3]),null)},i(i){e||(ke(r,i),e=!0)},o(i){$e(r,i),e=!1},d(i){r&&r.d(i)}}}function Gxt(n){let e,t,r=n[0]===n[1]&&qq(n);return{c(){r&&r.c(),e=po()},m(i,s){r&&r.m(i,s),me(i,e,s),t=!0},p(i,[s]){i[0]===i[1]?r?(r.p(i,s),s&1&&ke(r,1)):(r=qq(i),r.c(),ke(r,1),r.m(e.parentNode,e)):r&&(sr(),$e(r,1,1,()=>{r=null}),or())},i(i){t||(ke(r),t=!0)},o(i){$e(r),t=!1},d(i){r&&r.d(i),i&&pe(e)}}}function jxt(n,e,t){let r,{$$slots:i={},$$scope:s}=e;const o={},{registerPanel:a,selectedPanel:l}=sce(OV);return AV(n,l,c=>t(0,r=c)),a(o),n.$$set=c=>{"$$scope"in c&&t(3,s=c.$$scope)},[r,o,l,s,i]}class IE extends gn{constructor(e){super(),mn(this,e,jxt,Gxt,hn,{})}}function qxt(n){let e;return{c(){e=qe(n[1])},m(t,r){me(t,e,r)},p(t,r){r&2&&cn(e,t[1])},i:Ze,o:Ze,d(t){t&&pe(e)}}}function Xxt(n){let e=n[1].toPrecision(2)+"",t;return{c(){t=qe(e)},m(r,i){me(r,t,i)},p(r,i){i&2&&e!==(e=r[1].toPrecision(2)+"")&&cn(t,e)},i:Ze,o:Ze,d(r){r&&pe(t)}}}function Kxt(n){let e,t=lL(n[1]).join(", ")+"",r,i;return{c(){e=qe("Array("),r=qe(t),i=qe(")")},m(s,o){me(s,e,o),me(s,r,o),me(s,i,o)},p(s,o){o&2&&t!==(t=lL(s[1]).join(", ")+"")&&cn(r,t)},i:Ze,o:Ze,d(s){s&&pe(e),s&&pe(r),s&&pe(i)}}}function Yxt(n){let e=n[3](n[1])+"",t;return{c(){t=qe(e)},m(r,i){me(r,t,i)},p(r,i){i&2&&e!==(e=r[3](r[1])+"")&&cn(t,e)},i:Ze,o:Ze,d(r){r&&pe(t)}}}function Zxt(n){let e;const t=n[4].default,r=Fp(t,n,n[7],null);return{c(){r&&r.c()},m(i,s){r&&r.m(i,s),e=!0},p(i,s){r&&r.p&&(!e||s&128)&&zp(r,t,i,i[7],e?Lp(t,i[7],s,null):Bp(i[7]),null)},i(i){e||(ke(r,i),e=!0)},o(i){$e(r,i),e=!1},d(i){r&&r.d(i)}}}function Jxt(n){let e,t;return e=new zi({props:{size:"small",$$slots:{default:[t1t]},$$scope:{ctx:n}}}),e.$on("click",n[6]),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,i){const s={};i&130&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function Qxt(n){let e,t=n[1].text+"",r,i,s;return{c(){e=we("sl-button"),r=qe(t),kb(e,"type","text"),kb(e,"size","small")},m(o,a){me(o,e,a),ie(e,r),i||(s=Yn(e,"click",n[5]),i=!0)},p(o,a){a&2&&t!==(t=o[1].text+"")&&cn(r,t)},i:Ze,o:Ze,d(o){o&&pe(e),i=!1,s()}}}function e1t(n){let e,t;return{c(){e=we("img"),Z(e,"alt","thumbnail"),aM(e.src,t=n[1])||Z(e,"src",t),Z(e,"width","30"),Z(e,"height","30"),Z(e,"class","rounded-md")},m(r,i){me(r,e,i)},p(r,i){i&2&&!aM(e.src,t=r[1])&&Z(e,"src",t)},i:Ze,o:Ze,d(r){r&&pe(e)}}}function t1t(n){let e;return{c(){e=qe(n[1])},m(t,r){me(t,e,r)},p(t,r){r&2&&cn(e,t[1])},d(t){t&&pe(e)}}}function n1t(n){let e,t,r,i;const s=[e1t,Qxt,Jxt,Zxt,Yxt,Kxt,Xxt,qxt],o=[];function a(l,c){return l[0]==="image"?0:l[0]==="link"?1:l[0]==="action"?2:l[0]==="slot"?3:l[0]==="date"?4:l[0]==="array"?5:typeof l[1]=="number"?6:7}return t=a(n),r=o[t]=s[t](n),{c(){e=we("td"),r.c(),Z(e,"class","svelte-fe0rg4")},m(l,c){me(l,e,c),o[t].m(e,null),i=!0},p(l,[c]){let u=t;t=a(l),t===u?o[t].p(l,c):(sr(),$e(o[u],1,1,()=>{o[u]=null}),or(),r=o[t],r?r.p(l,c):(r=o[t]=s[t](l),r.c()),ke(r,1),r.m(e,null))},i(l){i||(ke(r),i=!0)},o(l){$e(r),i=!1},d(l){l&&pe(e),o[t].d()}}}function lL(n){return Array.isArray(n)?n.length>0&&Array.isArray(n[0])?[n.length,...lL(n[0])]:[n.length]:[]}function r1t(n,e,t){let{$$slots:r={},$$scope:i}=e,{type:s="generic"}=e,{value:o=null}=e;const a=Oc();function l(h){try{return kje(Date.parse(h),{includeSeconds:!0,addSuffix:!0})}catch(f){return console.log("Date Parsing Error",h,f),h}}const c=()=>{console.log("GOTO:",o.href)},u=()=>a("action",o);return n.$$set=h=>{"type"in h&&t(0,s=h.type),"value"in h&&t(1,o=h.value),"$$scope"in h&&t(7,i=h.$$scope)},[s,o,a,l,r,c,u,i]}class pce extends gn{constructor(e){super(),mn(this,e,r1t,n1t,hn,{type:0,value:1})}}function Xq(n){let e,t,r,i;const s=[s1t,i1t],o=[];function a(l,c){return l[2]?0:1}return e=a(n),t=o[e]=s[e](n),{c(){t.c(),r=po()},m(l,c){o[e].m(l,c),me(l,r,c),i=!0},p(l,c){let u=e;e=a(l),e===u?o[e].p(l,c):(sr(),$e(o[u],1,1,()=>{o[u]=null}),or(),t=o[e],t?t.p(l,c):(t=o[e]=s[e](l),t.c()),ke(t,1),t.m(r.parentNode,r))},i(l){i||(ke(t),i=!0)},o(l){$e(t),i=!1},d(l){o[e].d(l),l&&pe(r)}}}function i1t(n){let e,t;return e=new zi({props:{round:!0,size:"small",$$slots:{default:[o1t]},$$scope:{ctx:n}}}),e.$on("click",n[3]),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,i){const s={};i&64&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function s1t(n){let e,t;return e=new zi({props:{round:!0,size:"small",$$slots:{default:[a1t]},$$scope:{ctx:n}}}),e.$on("click",n[3]),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,i){const s={};i&64&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function o1t(n){let e,t;return{c(){e=bi("svg"),t=bi("path"),Z(t,"stroke-linecap","round"),Z(t,"stroke-linejoin","round"),Z(t,"stroke-width","2"),Z(t,"d","M16 17l-4 4m0 0l-4-4m4 4V3"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"class","h-6 w-6"),Z(e,"fill","none"),Z(e,"viewBox","0 0 24 24"),Z(e,"stroke","currentColor")},m(r,i){me(r,e,i),ie(e,t)},p:Ze,d(r){r&&pe(e)}}}function a1t(n){let e,t;return{c(){e=bi("svg"),t=bi("path"),Z(t,"stroke-linecap","round"),Z(t,"stroke-linejoin","round"),Z(t,"stroke-width","2"),Z(t,"d","M8 7l4-4m0 0l4 4m-4-4v18"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"class","h-6 w-6"),Z(e,"fill","none"),Z(e,"viewBox","0 0 24 24"),Z(e,"stroke","currentColor")},m(r,i){me(r,e,i),ie(e,t)},p:Ze,d(r){r&&pe(e)}}}function l1t(n){let e,t,r,i,s,o,a=n[1]&&Xq(n);return{c(){e=we("th"),t=we("span"),r=we("span"),i=qe(n[0]),s=tt(),a&&a.c(),Bs(r,"margin-top","0.5rem"),Bs(r,"margin-bottom","0.5rem"),Bs(t,"display","flex"),Bs(t,"justify-content","space-between"),Bs(t,"align-items","center"),Z(e,"class","svelte-1310j1m")},m(l,c){me(l,e,c),ie(e,t),ie(t,r),ie(r,i),ie(t,s),a&&a.m(t,null),o=!0},p(l,[c]){(!o||c&1)&&cn(i,l[0]),l[1]?a?(a.p(l,c),c&2&&ke(a,1)):(a=Xq(l),a.c(),ke(a,1),a.m(t,null)):a&&(sr(),$e(a,1,1,()=>{a=null}),or())},i(l){o||(ke(a),o=!0)},o(l){$e(a),o=!1},d(l){l&&pe(e),a&&a.d()}}}function c1t(n,e,t){let{name:r="name"}=e,{sortable:i=!1}=e,{sorting:s={col:"",ascending:!0}}=e;const o=Oc();let a=!0;function l(){t(2,a=!a),o("sort",{col:r,ascending:a})}return n.$$set=c=>{"name"in c&&t(0,r=c.name),"sortable"in c&&t(1,i=c.sortable),"sorting"in c&&t(4,s=c.sorting)},n.$$.update=()=>{n.$$.dirty&17&&s.col===r&&t(2,a=s.ascending)},[r,i,a,l,s]}class u1t extends gn{constructor(e){super(),mn(this,e,c1t,l1t,hn,{name:0,sortable:1,sorting:4})}}function Kq(n,e,t){const r=n.slice();return r[10]=e[t].name,r[11]=e[t].multiple,r[12]=e[t].confirm,r}function h1t(n){let e=n[10]+"",t;return{c(){t=qe(e)},m(r,i){me(r,t,i)},p(r,i){i&2&&e!==(e=r[10]+"")&&cn(t,e)},d(r){r&&pe(t)}}}function Yq(n){let e,t;function r(){return n[7](n[10],n[12])}return e=new zi({props:{size:"small",disabled:n[11]===!1&&n[0].length>1,type:n[10]==="delete"?"danger":"default",$$slots:{default:[h1t]},$$scope:{ctx:n}}}),e.$on("click",r),{c(){Ct(e.$$.fragment)},m(i,s){xt(e,i,s),t=!0},p(i,s){n=i;const o={};s&3&&(o.disabled=n[11]===!1&&n[0].length>1),s&2&&(o.type=n[10]==="delete"?"danger":"default"),s&32770&&(o.$$scope={dirty:s,ctx:n}),e.$set(o)},i(i){t||(ke(e.$$.fragment,i),t=!0)},o(i){$e(e.$$.fragment,i),t=!1},d(i){_t(e,i)}}}function Zq(n){let e,t;return e=new hce({props:{$$slots:{default:[p1t]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,i){const s={};i&32780&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function f1t(n){let e;return{c(){e=qe("Cancel")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function d1t(n){let e;return{c(){e=qe("Confirm")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function p1t(n){let e,t,r,i,s,o,a,l,c,u,h,f,d;return l=new zi({props:{type:"danger",$$slots:{default:[f1t]},$$scope:{ctx:n}}}),l.$on("click",n[8]),f=new zi({props:{variant:"filled",$$slots:{default:[d1t]},$$scope:{ctx:n}}}),f.$on("click",n[4]),{c(){e=we("div"),t=we("p"),r=qe("Do you want to "),i=qe(n[2]),s=qe(" the selected items?"),o=tt(),a=we("div"),Ct(l.$$.fragment),c=tt(),u=we("span"),h=tt(),Ct(f.$$.fragment),Z(u,"class","w-2"),Z(a,"class","w-full flex justify-end"),Z(e,"class","p-8")},m(p,m){me(p,e,m),ie(e,t),ie(t,r),ie(t,i),ie(t,s),ie(e,o),ie(e,a),xt(l,a,null),ie(a,c),ie(a,u),ie(a,h),xt(f,a,null),d=!0},p(p,m){(!d||m&4)&&cn(i,p[2]);const g={};m&32768&&(g.$$scope={dirty:m,ctx:p}),l.$set(g);const y={};m&32768&&(y.$$scope={dirty:m,ctx:p}),f.$set(y)},i(p){d||(ke(l.$$.fragment,p),ke(f.$$.fragment,p),d=!0)},o(p){$e(l.$$.fragment,p),$e(f.$$.fragment,p),d=!1},d(p){p&&pe(e),_t(l),_t(f)}}}function m1t(n){let e,t,r,i,s=n[1],o=[];for(let c=0;c<s.length;c+=1)o[c]=Yq(Kq(n,s,c));const a=c=>$e(o[c],1,1,()=>{o[c]=null});let l=n[3]&&Zq(n);return{c(){e=we("div");for(let c=0;c<o.length;c+=1)o[c].c();t=tt(),l&&l.c(),r=po(),Z(e,"class","actions")},m(c,u){me(c,e,u);for(let h=0;h<o.length;h+=1)o[h]&&o[h].m(e,null);me(c,t,u),l&&l.m(c,u),me(c,r,u),i=!0},p(c,[u]){if(u&35){s=c[1];let h;for(h=0;h<s.length;h+=1){const f=Kq(c,s,h);o[h]?(o[h].p(f,u),ke(o[h],1)):(o[h]=Yq(f),o[h].c(),ke(o[h],1),o[h].m(e,null))}for(sr(),h=s.length;h<o.length;h+=1)a(h);or()}c[3]?l?(l.p(c,u),u&8&&ke(l,1)):(l=Zq(c),l.c(),ke(l,1),l.m(r.parentNode,r)):l&&(sr(),$e(l,1,1,()=>{l=null}),or())},i(c){if(!i){for(let u=0;u<s.length;u+=1)ke(o[u]);ke(l),i=!0}},o(c){o=o.filter(Boolean);for(let u=0;u<o.length;u+=1)$e(o[u]);$e(l),i=!1},d(c){c&&pe(e),os(o,c),c&&pe(t),l&&l.d(c),c&&pe(r)}}}function g1t(n,e,t){let{provider:r}=e,{actions:i}=e,{selected:s}=e;const o=Oc();let a="",l=!1;async function c(){if(a==="delete")for(const d of s)await r.delete(d);else o("action",[a,s]);t(3,l=!1),t(0,s=[]),o("selected",s)}function u(d,p){t(2,a=d),!(!a||s.length===0)&&(p?t(3,l=!0):c())}const h=(d,p)=>u(d,p),f=()=>{t(3,l=!1)};return n.$$set=d=>{"provider"in d&&t(6,r=d.provider),"actions"in d&&t(1,i=d.actions),"selected"in d&&t(0,s=d.selected)},[s,i,a,l,c,u,r,h,f]}class y1t extends gn{constructor(e){super(),mn(this,e,g1t,m1t,hn,{provider:6,actions:1,selected:0})}}function Jq(n){let e,t,r;function i(o){n[11](o)}let s={provider:n[1],actions:n[2]};return n[0]!==void 0&&(s.selected=n[0]),e=new y1t({props:s}),Li.push(()=>Lc(e,"selected",i)),e.$on("selected",n[12]),e.$on("action",n[13]),{c(){Ct(e.$$.fragment)},m(o,a){xt(e,o,a),r=!0},p(o,a){const l={};a&2&&(l.provider=o[1]),a&4&&(l.actions=o[2]),!t&&a&1&&(t=!0,l.selected=o[0],Fc(()=>t=!1)),e.$set(l)},i(o){r||(ke(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){_t(e,o)}}}function b1t(n){let e,t;return{c(){e=bi("svg"),t=bi("path"),Z(t,"stroke-linecap","round"),Z(t,"stroke-linejoin","round"),Z(t,"stroke-width","2"),Z(t,"d","M15 19l-7-7 7-7"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"class","h-3 w-3"),Z(e,"fill","none"),Z(e,"viewBox","0 0 24 24"),Z(e,"stroke","currentColor")},m(r,i){me(r,e,i),ie(e,t)},p:Ze,d(r){r&&pe(e)}}}function v1t(n){let e,t;return{c(){e=bi("svg"),t=bi("path"),Z(t,"stroke-linecap","round"),Z(t,"stroke-linejoin","round"),Z(t,"stroke-width","2"),Z(t,"d","M9 5l7 7-7 7"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"class","h-3 w-3"),Z(e,"fill","none"),Z(e,"viewBox","0 0 24 24"),Z(e,"stroke","currentColor")},m(r,i){me(r,e,i),ie(e,t)},p:Ze,d(r){r&&pe(e)}}}function w1t(n){let e,t,r,i,s,o,a,l,c,u,h,f,d,p,m,g,y,b,_,w,S,C,k,A,M,E=n[2].length>0&&n[0].length>0&&Jq(n);return l=new dce({props:{size:"small",options:["10","20","50","all"],value:n[5].toString()}}),l.$on("change",n[14]),y=new zi({props:{round:!0,disabled:n[3]===1,$$slots:{default:[b1t]},$$scope:{ctx:n}}}),y.$on("click",n[15]),C=new zi({props:{round:!0,disabled:n[3]===n[6],$$slots:{default:[v1t]},$$scope:{ctx:n}}}),C.$on("click",n[17]),{c(){e=we("div"),t=we("div"),E&&E.c(),r=tt(),i=we("div"),s=we("div"),o=qe(`Items per page:
			`),a=we("div"),Ct(l.$$.fragment),c=tt(),u=we("div"),h=qe(n[7]),f=qe("-"),d=qe(n[8]),p=qe(" of "),m=qe(n[4]),g=tt(),Ct(y.$$.fragment),b=tt(),_=we("input"),S=tt(),Ct(C.$$.fragment),Z(t,"class","actions"),Z(a,"class","w-12 ml-2"),Z(s,"class","flex items-center mx-4"),Z(u,"class","mx-3"),Z(_,"class","marcelle w-8 rounded mr-1 mb-1 bg-white text-gray-600 border border-solid border-gray-300 text-center focus:outline-none focus:ring-blue-400 focus:ring-2 focus:ring-opacity-50 active:ring-blue-400 active:ring-4 active:ring-opacity-50"),_.value=w=n[3].toString(),Z(i,"class","flex items-center"),Z(e,"class","table-footer svelte-13k2ee6")},m(N,O){me(N,e,O),ie(e,t),E&&E.m(t,null),ie(e,r),ie(e,i),ie(i,s),ie(s,o),ie(s,a),xt(l,a,null),ie(i,c),ie(i,u),ie(u,h),ie(u,f),ie(u,d),ie(u,p),ie(u,m),ie(i,g),xt(y,i,null),ie(i,b),ie(i,_),ie(i,S),xt(C,i,null),k=!0,A||(M=Yn(_,"blur",n[16]),A=!0)},p(N,[O]){N[2].length>0&&N[0].length>0?E?(E.p(N,O),O&5&&ke(E,1)):(E=Jq(N),E.c(),ke(E,1),E.m(t,null)):E&&(sr(),$e(E,1,1,()=>{E=null}),or());const R={};O&32&&(R.value=N[5].toString()),l.$set(R),(!k||O&128)&&cn(h,N[7]),(!k||O&256)&&cn(d,N[8]),(!k||O&16)&&cn(m,N[4]);const D={};O&8&&(D.disabled=N[3]===1),O&262144&&(D.$$scope={dirty:O,ctx:N}),y.$set(D),(!k||O&8&&w!==(w=N[3].toString())&&_.value!==w)&&(_.value=w);const z={};O&72&&(z.disabled=N[3]===N[6]),O&262144&&(z.$$scope={dirty:O,ctx:N}),C.$set(z)},i(N){k||(ke(E),ke(l.$$.fragment,N),ke(y.$$.fragment,N),ke(C.$$.fragment,N),k=!0)},o(N){$e(E),$e(l.$$.fragment,N),$e(y.$$.fragment,N),$e(C.$$.fragment,N),k=!1},d(N){N&&pe(e),E&&E.d(),_t(l),_t(y),_t(C),A=!1,M()}}}function x1t(n,e,t){let r,{provider:i}=e,{actions:s}=e,{selected:o}=e,a=1,l=1,c=0,u=0,h=0,f=()=>{};function d(S){t(3,a=S),i.page(S)}function p(S){o=S,t(0,o)}function m(S){uM.call(this,n,S)}function g(S){uM.call(this,n,S)}const y=({detail:S})=>{const C=S==="all"?h:parseInt(S);i.paginate(C),t(5,r=C)},b=()=>{d(a-1)},_=S=>{let C=parseInt(S.currentTarget.value);isNaN(C)||d(Math.max(1,Math.min(l,C)))},w=()=>{d(a+1)};return n.$$set=S=>{"provider"in S&&t(1,i=S.provider),"actions"in S&&t(2,s=S.actions),"selected"in S&&t(0,o=S.selected)},n.$$.update=()=>{n.$$.dirty&2&&t(5,r=i.options.itemsPerPage),n.$$.dirty&1082&&(f(),t(10,f=i.total.subscribe(S=>{S===void 0||S===0?(t(6,l=1),t(7,c=0),t(8,u=0),t(4,h=0)):(t(6,l=Math.ceil(h/r)),t(7,c=(a-1)*r+1),t(8,u=Math.min(h||0,a*r)),t(4,h=S))})))},[o,i,s,a,h,r,l,c,u,d,f,p,m,g,y,b,_,w]}class _1t extends gn{constructor(e){super(),mn(this,e,x1t,w1t,hn,{provider:1,actions:2,selected:0})}}function Qq(n,e,t){const r=n.slice();return r[22]=e[t],r[24]=t,r}function e9(n,e,t){const r=n.slice();return r[25]=e[t].type,r[26]=e[t].name,r}function t9(n,e,t){const r=n.slice();return r[26]=e[t].name,r[29]=e[t].sortable,r}function n9(n){let e,t,r,i,s,o,a,l;return{c(){e=we("div"),t=we("sl-alert"),r=we("sl-icon"),i=tt(),s=we("strong"),s.textContent="Table Data Error",o=we("br"),a=tt(),l=qe(n[9]),kb(r,"slot","icon"),kb(r,"name","check2-circle"),kb(t,"type","danger"),kb(t,"open",""),Z(e,"class","service-error")},m(c,u){me(c,e,u),ie(e,t),ie(t,r),ie(t,i),ie(t,s),ie(t,o),ie(t,a),ie(t,l)},p(c,u){u[0]&512&&cn(l,c[9])},d(c){c&&pe(e)}}}function r9(n){let e,t=!n[4]&&i9(n);return{c(){e=we("th"),t&&t.c(),Z(e,"class","svelte-12gp9na")},m(r,i){me(r,e,i),t&&t.m(e,null)},p(r,i){r[4]?t&&(t.d(1),t=null):t?t.p(r,i):(t=i9(r),t.c(),t.m(e,null))},d(r){r&&pe(e),t&&t.d()}}}function i9(n){let e,t,r,i;return{c(){e=we("input"),Z(e,"type","checkbox"),e.checked=t=n[6].length>0&&n[6].length===n[10].length},m(s,o){me(s,e,o),r||(i=Yn(e,"click",n[12]),r=!0)},p(s,o){o[0]&1088&&t!==(t=s[6].length>0&&s[6].length===s[10].length)&&(e.checked=t)},d(s){s&&pe(e),r=!1,i()}}}function s9(n){let e,t;return e=new u1t({props:{name:n[26],sortable:n[29],sorting:n[7]}}),e.$on("sort",n[11]),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,i){const s={};i[0]&1&&(s.name=r[26]),i[0]&1&&(s.sortable=r[29]),i[0]&128&&(s.sorting=r[7]),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function o9(n){let e,t;return e=new pce({props:{type:"slot",$$slots:{default:[S1t]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,i){const s={};i[0]&64|i[1]&2&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function S1t(n){let e,t,r,i;function s(...o){return n[16](n[24],...o)}return{c(){e=we("input"),Z(e,"type","checkbox"),e.checked=t=n[6].includes(n[24])},m(o,a){me(o,e,a),r||(i=Yn(e,"click",s),r=!0)},p(o,a){n=o,a[0]&64&&t!==(t=n[6].includes(n[24]))&&(e.checked=t)},d(o){o&&pe(e),r=!1,i()}}}function a9(n){let e,t;function r(...i){return n[17](n[24],...i)}return e=new pce({props:{type:n[25],value:n[22][n[26]]}}),e.$on("action",r),{c(){Ct(e.$$.fragment)},m(i,s){xt(e,i,s),t=!0},p(i,s){n=i;const o={};s[0]&1&&(o.type=n[25]),s[0]&1025&&(o.value=n[22][n[26]]),e.$set(o)},i(i){t||(ke(e.$$.fragment,i),t=!0)},o(i){$e(e.$$.fragment,i),t=!1},d(i){_t(e,i)}}}function l9(n){let e,t,r,i,s=n[3]&&o9(n),o=n[0],a=[];for(let c=0;c<o.length;c+=1)a[c]=a9(e9(n,o,c));const l=c=>$e(a[c],1,1,()=>{a[c]=null});return{c(){e=we("tr"),s&&s.c(),t=tt();for(let c=0;c<a.length;c+=1)a[c].c();r=tt(),Z(e,"class","svelte-12gp9na")},m(c,u){me(c,e,u),s&&s.m(e,null),ie(e,t);for(let h=0;h<a.length;h+=1)a[h]&&a[h].m(e,null);ie(e,r),i=!0},p(c,u){if(c[3]?s?(s.p(c,u),u[0]&8&&ke(s,1)):(s=o9(c),s.c(),ke(s,1),s.m(e,t)):s&&(sr(),$e(s,1,1,()=>{s=null}),or()),u[0]&17409){o=c[0];let h;for(h=0;h<o.length;h+=1){const f=e9(c,o,h);a[h]?(a[h].p(f,u),ke(a[h],1)):(a[h]=a9(f),a[h].c(),ke(a[h],1),a[h].m(e,r))}for(sr(),h=o.length;h<a.length;h+=1)l(h);or()}},i(c){if(!i){ke(s);for(let u=0;u<o.length;u+=1)ke(a[u]);i=!0}},o(c){$e(s),a=a.filter(Boolean);for(let u=0;u<a.length;u+=1)$e(a[u]);i=!1},d(c){c&&pe(e),s&&s.d(),os(a,c)}}}function C1t(n){let e,t,r,i,s,o,a,l,c,u,h,f,d=n[9]&&n9(n),p=n[3]&&r9(n),m=n[0],g=[];for(let k=0;k<m.length;k+=1)g[k]=s9(t9(n,m,k));const y=k=>$e(g[k],1,1,()=>{g[k]=null});let b=n[10],_=[];for(let k=0;k<b.length;k+=1)_[k]=l9(Qq(n,b,k));const w=k=>$e(_[k],1,1,()=>{_[k]=null});function S(k){n[18](k)}let C={provider:n[1],actions:n[2]};return n[6]!==void 0&&(C.selected=n[6]),u=new _1t({props:C}),Li.push(()=>Lc(u,"selected",S)),u.$on("action",n[19]),{c(){d&&d.c(),e=tt(),t=we("div"),r=we("table"),i=we("thead"),s=we("tr"),p&&p.c(),o=tt();for(let k=0;k<g.length;k+=1)g[k].c();a=tt(),l=we("tbody");for(let k=0;k<_.length;k+=1)_[k].c();c=tt(),Ct(u.$$.fragment),Z(s,"class","svelte-12gp9na"),Z(i,"class","svelte-12gp9na"),Z(l,"class","svelte-12gp9na"),Z(r,"class","svelte-12gp9na"),Z(t,"class","marcelle table-container svelte-12gp9na")},m(k,A){d&&d.m(k,A),me(k,e,A),me(k,t,A),ie(t,r),ie(r,i),ie(i,s),p&&p.m(s,null),ie(s,o);for(let M=0;M<g.length;M+=1)g[M]&&g[M].m(s,null);ie(r,a),ie(r,l);for(let M=0;M<_.length;M+=1)_[M]&&_[M].m(l,null);ie(t,c),xt(u,t,null),f=!0},p(k,A){if(k[9]?d?d.p(k,A):(d=n9(k),d.c(),d.m(e.parentNode,e)):d&&(d.d(1),d=null),k[3]?p?p.p(k,A):(p=r9(k),p.c(),p.m(s,o)):p&&(p.d(1),p=null),A[0]&2177){m=k[0];let E;for(E=0;E<m.length;E+=1){const N=t9(k,m,E);g[E]?(g[E].p(N,A),ke(g[E],1)):(g[E]=s9(N),g[E].c(),ke(g[E],1),g[E].m(s,null))}for(sr(),E=m.length;E<g.length;E+=1)y(E);or()}if(A[0]&25673){b=k[10];let E;for(E=0;E<b.length;E+=1){const N=Qq(k,b,E);_[E]?(_[E].p(N,A),ke(_[E],1)):(_[E]=l9(N),_[E].c(),ke(_[E],1),_[E].m(l,null))}for(sr(),E=b.length;E<_.length;E+=1)w(E);or()}const M={};A[0]&2&&(M.provider=k[1]),A[0]&4&&(M.actions=k[2]),!h&&A[0]&64&&(h=!0,M.selected=k[6],Fc(()=>h=!1)),u.$set(M)},i(k){if(!f){for(let A=0;A<m.length;A+=1)ke(g[A]);for(let A=0;A<b.length;A+=1)ke(_[A]);ke(u.$$.fragment,k),f=!0}},o(k){g=g.filter(Boolean);for(let A=0;A<g.length;A+=1)$e(g[A]);_=_.filter(Boolean);for(let A=0;A<_.length;A+=1)$e(_[A]);$e(u.$$.fragment,k),f=!1},d(k){d&&d.d(k),k&&pe(e),k&&pe(t),p&&p.d(),os(g,k),os(_,k),_t(u)}}}function k1t(n,e,t){let r,i,s,o=Ze,a=()=>(o(),o=vr(i,R=>t(9,s=R)),i),l,c=Ze,u=()=>(c(),c=vr(r,R=>t(10,l=R)),r);n.$$.on_destroy.push(()=>o()),n.$$.on_destroy.push(()=>c());let{columns:h}=e,{provider:f}=e,{actions:d=[]}=e,{selectable:p=!0}=e,{singleSelection:m=!1}=e,{selection:g=[]}=e,y=[];const b=Oc();let _={col:"",ascending:!0};function w({detail:R}){t(7,_=R),f.sort(R)}async function S(){t(15,g=await Promise.all(y.map(f.get.bind(f)))),b("selection",g)}function C(){y.length===c_(r).length?t(6,y=[]):t(6,y=c_(r).map((R,D)=>D)),S()}function k(R,D){m?(t(6,y=D.currentTarget.checked?[R]:[]),S()):D.currentTarget.checked?y.includes(R)||(t(6,y=y.concat([R])),S()):(t(6,y=y.filter(z=>z!==R)),S())}async function A([R,D]){const z=Array.isArray(D)?await Promise.all(D.map(f.get.bind(f))):await f.get(D);b(R,z)}const M=(R,D)=>k(R,D),E=(R,{detail:D})=>{A([D,R])};function N(R){y=R,t(6,y),t(15,g),t(5,r),t(1,f)}const O=({detail:R})=>A(R);return n.$$set=R=>{"columns"in R&&t(0,h=R.columns),"provider"in R&&t(1,f=R.provider),"actions"in R&&t(2,d=R.actions),"selectable"in R&&t(3,p=R.selectable),"singleSelection"in R&&t(4,m=R.singleSelection),"selection"in R&&t(15,g=R.selection)},n.$$.update=()=>{n.$$.dirty[0]&2&&u(t(5,r=f.data)),n.$$.dirty[0]&2&&a(t(8,i=f.error)),n.$$.dirty[0]&32800&&t(6,y=g.map(R=>c_(r).indexOf(R)))},[h,f,d,p,m,r,y,_,i,s,l,w,C,k,A,g,M,E,N,O]}class mce extends gn{constructor(e){super(),mn(this,e,k1t,C1t,hn,{columns:0,provider:1,actions:2,selectable:3,singleSelection:4,selection:15},null,[-1,-1])}}function T1t(n){let e,t;const r=n[1].default,i=Fp(r,n,n[0],null);return{c(){e=we("div"),i&&i.c(),Z(e,"class","flex border-solid border-0 border-b border-gray-200 mb-2")},m(s,o){me(s,e,o),i&&i.m(e,null),t=!0},p(s,[o]){i&&i.p&&(!t||o&1)&&zp(i,r,s,s[0],t?Lp(r,s[0],o,null):Bp(s[0]),null)},i(s){t||(ke(i,s),t=!0)},o(s){$e(i,s),t=!1},d(s){s&&pe(e),i&&i.d(s)}}}function E1t(n,e,t){let{$$slots:r={},$$scope:i}=e;return n.$$set=s=>{"$$scope"in s&&t(0,i=s.$$scope)},[i,r]}class I1t extends gn{constructor(e){super(),mn(this,e,E1t,T1t,hn,{})}}const c9={itemsPerPage:10};class gce{constructor(e=c9){Nt(this,"options");Nt(this,"data",u_([]));Nt(this,"total",u_(0));Nt(this,"error",u_(null));this.options={...c9,...e}}paginate(e){this.options.itemsPerPage=e,this.update()}async get(e){const t=c_(this.data);return e>=0&&e<t.length?t[e]:null}}class A1t extends gce{constructor({data:t,...r}){super(r);Nt(this,"rawData");Nt(this,"currentPage",1);this.rawData=t,this.total.set(t.length),this.data.set(this.rawData.slice(0,this.options.itemsPerPage))}async update(){this.page(this.currentPage)}async page(t){this.data.set(this.rawData.slice((t-1)*this.options.itemsPerPage,Math.min(t*this.options.itemsPerPage,this.rawData.length))),this.currentPage=t}async sort(t){this.rawData.sort((r,i)=>r[t.col]>i[t.col]?t.ascending?1:-1:r[t.col]<i[t.col]?t.ascending?-1:1:0),this.page(this.currentPage)}async delete(t){return this.rawData.splice(t,1),this.page(this.currentPage),null}}class M1t extends gce{constructor({service:t,columns:r,transform:i,...s}){super(s);Nt(this,"service");Nt(this,"query");Nt(this,"transform");this.service=t,this.transform=i||{},this.query={$sort:{updatedAt:-1},$limit:this.options.itemsPerPage},r&&(this.query.$select=r.map(o=>o.name).concat(["id"])),this.update(),this.service.on("created",this.update.bind(this)),this.service.on("patched",this.update.bind(this)),this.service.on("updated",this.update.bind(this)),this.service.on("removed",this.update.bind(this))}paginate(t){super.paginate(t),this.query.$limit=this.options.itemsPerPage,this.update()}async update(){try{const t=await this.service.find({query:this.query}),r=t.data.map((i,s)=>{const o=Object.entries(this.transform).map(([a,l])=>{try{return{[a]:l(i,s)}}catch{return{[a]:"transform error"}}}).reduce((a,l)=>({...a,...l}),{});return{...i,...o}});this.data.set(r),this.total.set(t.total),this.error.set(null)}catch(t){this.data.set([]),this.total.set(0),this.error.set(t)}}async page(t){this.query.$skip=(t-1)*this.query.$limit,this.update()}async sort(t){const{col:r,ascending:i}=t;r?this.query.$sort={[r]:i?1:-1}:delete this.query.$sort,this.update()}async delete(t){const r=c_(this.data)[t];return await this.service.remove(r.id),this.update(),r}}function u9(n){let e,t,r;return t=new fce({props:{progress:n[2],thin:!0}}),{c(){e=we("div"),Ct(t.$$.fragment),Z(e,"class","absolute top-0 left-0 right-0")},m(i,s){me(i,e,s),xt(t,e,null),r=!0},p(i,s){const o={};s&4&&(o.progress=i[2]),t.$set(o)},i(i){r||(ke(t.$$.fragment,i),r=!0)},o(i){$e(t.$$.fragment,i),r=!1},d(i){i&&pe(e),_t(t)}}}function h9(n){let e,t;return e=new PV({}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function N1t(n){let e,t,r,i,s,o,a,l=n[2]!==!1&&u9(n),c=n[1]&&h9();const u=n[4].default,h=Fp(u,n,n[3],null);return{c(){e=we("div"),l&&l.c(),t=tt(),r=we("span"),i=qe(n[0]),s=tt(),c&&c.c(),o=tt(),h&&h.c(),Z(r,"class","card-title"),Z(e,"class","card-container svelte-xnhseh")},m(f,d){me(f,e,d),l&&l.m(e,null),ie(e,t),ie(e,r),ie(r,i),ie(e,s),c&&c.m(e,null),ie(e,o),h&&h.m(e,null),a=!0},p(f,[d]){f[2]!==!1?l?(l.p(f,d),d&4&&ke(l,1)):(l=u9(f),l.c(),ke(l,1),l.m(e,t)):l&&(sr(),$e(l,1,1,()=>{l=null}),or()),(!a||d&1)&&cn(i,f[0]),f[1]?c?d&2&&ke(c,1):(c=h9(),c.c(),ke(c,1),c.m(e,o)):c&&(sr(),$e(c,1,1,()=>{c=null}),or()),h&&h.p&&(!a||d&8)&&zp(h,u,f,f[3],a?Lp(u,f[3],d,null):Bp(f[3]),null)},i(f){a||(ke(l),ke(c),ke(h,f),a=!0)},o(f){$e(l),$e(c),$e(h,f),a=!1},d(f){f&&pe(e),l&&l.d(),c&&c.d(),h&&h.d(f)}}}function $1t(n,e,t){let{$$slots:r={},$$scope:i}=e,{title:s}=e,{loading:o=!1}=e,{progress:a=!1}=e;return n.$$set=l=>{"title"in l&&t(0,s=l.title),"loading"in l&&t(1,o=l.loading),"progress"in l&&t(2,a=l.progress),"$$scope"in l&&t(3,i=l.$$scope)},[s,o,a,i,r]}class Ao extends gn{constructor(e){super(),mn(this,e,$1t,N1t,hn,{title:0,loading:1,progress:2})}}let h1,AE;function fM({title:n,message:e,duration:t=3e3,type:r="default"}){h1||(h1=document.createElement("div"),h1.id="notification-container",document.body.appendChild(h1),AE=new _xt({target:h1})),AE==null||AE.add({title:n,message:e,duration:t,type:r})}function On(n,e,t,r){var i=arguments.length,s=i<3?e:r===null?r=Object.getOwnPropertyDescriptor(e,t):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(n,e,t,r);else for(var a=n.length-1;a>=0;a--)(o=n[a])&&(s=(i<3?o(s):i>3?o(e,t,s):o(e,t))||s);return i>3&&s&&Object.defineProperty(e,t,s),s}function ze(n,e,t,r){if(t==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?n!==e||!r:!e.has(n))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?r:t==="a"?r.call(n):r?r.value:e.get(n)}function Pn(n,e,t,r,i){if(r==="m")throw new TypeError("Private method is not writable");if(r==="a"&&!i)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?n!==e||!i:!e.has(n))throw new TypeError("Cannot write private member to an object whose class did not declare it");return r==="a"?i.call(n,t):i?i.value=t:e.set(n,t),t}function Qm(){}var Cm,km,rI;function R1t(n){}const f9=Qje();function P1t(n){return n&&typeof n=="object"&&n.run!==void 0}function FV(n){return n&&typeof n=="object"&&n.run!==void 0&&n.id!==void 0}class ct{constructor(e,t=void 0){this.id=ct.nextId++,this.subscribers=[],this.value=void 0,this.ready=!1,Cm.set(this,void 0),km.set(this,!1),rI.set(this,void 0),Pn(this,Cm,!!t,"f");const[r,i]=aG(),[s,o]=aG();this.stopStream=r,this.set=l=>{this.value=l,s(l)};let a;FV(e)?(a=e,t===void 0&&Pn(this,Cm,e.holding,"f"),e.holding&&(this.value=e.value)):P1t(e)?a=e:(a=nG(()=>this.value,FD(e)),this.value=e),this.stream=I9e(rG(this.runListeners.bind(this),oG(i,iG(a,o))))}get(){return this.value}get holding(){return ze(this,Cm,"f")}run(e,t){return this.stream.run(e,t)}runListeners(e){this.value=e;for(const t of this.subscribers)t(e)}subscribe(e=R1t,t=Qm){ze(this,Cm,"f")&&ze(this,km,"f")&&e(this.value);const r=i=>{t(),e(i)};return this.subscribers.push(r),ze(this,km,"f")||this.start(),()=>{const i=this.subscribers.indexOf(r);i!==-1&&this.subscribers.splice(i,1)}}async start(){return ze(this,km,"f")||(ct.numActive++,S8e(this.stream,f9).then(()=>{ct.numActive--}),Pn(this,km,!0,"f"),Pn(this,rI,new Promise((e,t)=>{zN({run:()=>{this.ready=!0,e()},error(r){t(r)},dispose(){}},f9)}),"f")),ze(this,rI,"f")}stop(){this.stopStream(void 0),Pn(this,km,!1,"f")}hold(e=!0){return Pn(this,Cm,e,"f"),this}thru(e){return new ct(e(this))}startWith(e){const t=new ct(P9e(e,this));return this.holding&&(t.value=e),t}continueWith(e){const t=new ct(L9e(e,this));return this.holding&&(t.value=this.value),t}map(e){const t=new ct(nG(e,this));return this.holding&&(t.value=e(this.value)),t}constant(e){const t=new ct(D9e(e,this));return this.holding&&(t.value=e),t}tap(e){const t=new ct(rG(e,this));return this.holding&&(t.value=this.value),t}ap(e){const t=new ct(O9e(e,this));return this.holding&&e.holding&&(t.value=e.get()(this.value)),t}scan(e,t){const r=new ct(R9e(e,t,this));return this.holding&&(r.value=t),r}loop(e,t){return new ct($9e(e,t,this))}withItems(e){return new ct(G9e(e,this))}zipItems(e,t){return new ct(H9e(e,t,this))}switchLatest(){return new ct(Xqe(this))}join(){return new ct(YQ(this))}chain(e){return new ct(F9e(e,this))}concatMap(e){return new ct(z9e(e,this))}mergeConcurrently(e){return new ct(B9e(e,this))}mergeMapConcurrently(e,t){return new ct(V9e(e,t,this))}merge(e){const t=new ct(iG(e,this));return this.holding&&(t.value=this.value),t}combine(e,t){const r=new ct(U9e(e,t,this));return this.holding&&(r.value=e(t.value,this.value)),r}zip(e,t){const r=new ct(j9e(e,t,this));return this.holding&&(r.value=e(t.value,this.value)),r}resample(e){return new ct(sG(this,e))}sample(e){return new ct(sG(e,this))}snapshot(e,t){return new ct(W9e(e,t,this))}filter(e){const t=new ct(q9e(e,this));return this.holding&&e(this.value)&&(t.value=this.value),t}skipRepeats(){const e=new ct(Qqe(this));return this.holding&&(e.value=this.value),e}skipRepeatsWith(e){return new ct(X9e(e,this))}slice(e,t){return new ct(Z9e(e,t,this))}take(e){return new ct(K9e(e,this))}skip(e){return new ct(Y9e(e,this))}takeWhile(e){return new ct(J9e(e,this))}skipWhile(e){return new ct(Q9e(e,this))}skipAfter(e){return new ct(e7e(e,this))}until(e){return new ct(oG(e,this))}since(e){return new ct(t7e(e,this))}during(e){return new ct(n7e(e,this))}delay(e){return new ct(r7e(e,this))}withLocalTime(e){return new ct(N9e(e,this))}throttle(e){return new ct(i7e(e,this))}debounce(e){return new ct(s7e(e,this))}awaitPromises(){return new ct(v9e(this))}recoverWith(e){return new ct(o7e(e,this))}static empty(){return new ct(Ks())}static never(){return new ct($_())}static now(e){return new ct(FD(e))}static at(e,t){return new ct(WQ(e,t))}static periodic(e){return new ct(x8e(e))}static throwError(e){return new ct(C9e(e))}}Cm=new WeakMap,km=new WeakMap,rI=new WeakMap;ct.nextId=0;ct.numActive=0;var bc;(function(n){n[n.Debug=0]="Debug",n[n.Info=1]="Info",n[n.Warning=2]="Warning",n[n.Error=3]="Error"})(bc||(bc={}));const P1=new ct($_()),ba={log(...n){console.log(...n),P1.set([bc.Info,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])},debug(...n){P1.set([bc.Debug,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])},info(...n){this.log(...n)},warning(...n){P1.set([bc.Warning,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])},error(...n){console.error(...n),P1.set([bc.Error,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])}};function D1t(){return P1}function zn(n,e,t){const r=t.value;return t.value=function(...s){try{return r.apply(this,s)}catch(o){return ba.error(o),fM({title:o.name,message:o.message,type:"danger"}),o}},t}class wp extends Error{constructor(e){super(e),this.name="Training Error"}}function Co(n,{duration:e=3e3}={}){ba.error(`${n.name}: ${n.message}`,n),fM({title:n.name,message:n.message,type:"danger",duration:e})}function yce(n,e){return async function*(){let t=0;for await(const r of n())e(r,t++)&&(yield await r)}}function HP(n,e){return async function*(){let t=0;for await(const r of n())yield await e(r,t++)}}function O1t(n,e){if(e<0)throw Error("Negative count is not supported, use await and sync iterator instead.");return async function*(){yield*yce(n,(t,r)=>r>=e)()}}function F1t(n,e){if(e<0)throw Error("Negative count is not supported, use await and sync iterator instead.");return async function*(){let t=e;for await(const r of n()){if(t--===0)return;yield await r}}}function GP(n,e){return async function*(){yield*await n(),yield*await e}}async function L1t(n,e){let t=0;for await(const r of n())e(r,t++)}async function z1t(n){const e=[];for await(const t of n())e.push(t);return e}function B1t(n,e){return async function*(){const t=e()[Symbol.asyncIterator]();for await(const r of n()){const i=await t.next();if(i.done)return;yield[r,i.value]}}}async function V1t(n,e,t){let[r,i]=[-1,t];for await(const s of n())i=++r===0&&t===void 0?s:e(i,s,r);if(t===void 0&&r===-1)throw new Error("Sequence contains no elements.");return i}function U1t(n){return typeof n[Symbol.iterator]=="function"}function W1t(n){return typeof n[Symbol.asyncIterator]=="function"}class ml{constructor(e){this.source=e}[Symbol.asyncIterator](){return this.source()[Symbol.asyncIterator]()}entries(){return new ml(HP(this.source,(e,t)=>[t,e]))}keys(){return new ml(HP(this.source,(e,t)=>t))}values(){return new ml(this.source)}forEach(e){return L1t(this.source,e)}concat(e){return U1t(e)?new ml(GP(this.source,async function*(t){yield*t}(e))):W1t(e)?new ml(GP(this.source,e)):new ml(GP(this.source,async function*(t){yield t}(e)))}reduce(e,t){return V1t(this.source,e,t)}filter(e){return new ml(yce(this.source,e))}take(e){return new ml(F1t(this.source,e))}skip(e){return new ml(O1t(this.source,e))}map(e){return new ml(HP(this.source,e))}zip(e){return new ml(B1t(this.source,e))}toArray(){return z1t(this.source)}}function jP(n){return n&&typeof n=="object"&&!Array.isArray(n)}function wl(n,...e){if(!e.length)return n;const t=e.shift(),r={...n};if(jP(n)&&jP(t))for(const i in t)jP(t[i])?(r[i]||Object.assign(r,{[i]:{}}),r[i]=wl(r[i],t[i])):Object.assign(r,{[i]:t[i]});return wl(r,...e)}window&&(window.onerror=n=>{typeof n=="string"&&fM({title:"An error occurred",message:n,type:"danger"})},window.addEventListener("unhandledrejection",n=>{fM({title:"An error occurred",message:n.reason,type:"danger"})}));let H1t=0;class ia{constructor(){this.id=`component-${String(H1t++).padStart(3,"0")}`,this.$$={streams:[],app:void 0},f7e(this)}destroy(){var e;(e=this.$$.app)===null||e===void 0||e.$destroy(),this.$$.app=void 0}start(){this.$$.streams=Object.entries(this).filter(([e,t])=>e[0]==="$"&&FV(t)).map(([,e])=>(e.start(),e))}stop(){for(const e of this.$$.streams)e.stop()}dispose(){this.destroy(),this.stop()}}let qP=~~(Math.random()*16777215);const XP=parseInt((Math.random()*16777215).toString(),10);function G1t(){const n=~~(Date.now()/1e3),e=Math.floor(Math.random()*1e5);qP=(qP+1)%16777215;const t=qP,r=new Uint8Array(12);return r[3]=n&255,r[2]=n>>8&255,r[1]=n>>16&255,r[0]=n>>24&255,r[6]=XP&255,r[5]=XP>>8&255,r[4]=XP>>16&255,r[8]=e&255,r[7]=e>>8&255,r[11]=t&255,r[10]=t>>8&255,r[9]=t>>16&255,r.reduce((i,s)=>i+`0${s.toString(16)}`.slice(-2),"")}const Tm=document.createElement("canvas"),lb=Tm.getContext("2d"),f1=new Image;function d9(n){return new Promise((e,t)=>{n?(f1.addEventListener("load",()=>{Tm.width=f1.width,Tm.height=f1.height,lb==null||lb.drawImage(f1,0,0,Tm.width,Tm.height),e(lb==null?void 0:lb.getImageData(0,0,Tm.width,Tm.height))},!1),f1.src=n):t()})}function j1t(n){const{data:e,service:t}=n;return n.data={[t.id]:G1t(),...e},n}function gm(n){const{result:e,params:t}=n;if(e){if(e._id)e.id=e._id,delete e._id;else if(e.total&&Array.isArray(e.data))for(const[r,i]of e.data.entries())i._id&&(e.data[r].id=e.data[r]._id,delete e.data[r]._id)}else t&&t.query&&(t.query.id&&(n.params.query._id=n.params.query.id,delete n.params.query.id),t.query.$select&&t.query.$select.includes("id")&&!t.query.$select.includes("_id")&&n.params.query.$select.push("_id"));return n}function q1t(n){return n.data||(n.data={}),n.data.createdAt=new Date,n.data.updatedAt=n.data.createdAt,n}function p9(n){return!n.data||!n.data.createdAt||(n.data.updatedAt=new Date),n}function X1t(n,e){return t=>{const{data:r}=t;return t.data={[n]:e,...r},t}}function d1(n,e){return t=>(t.params=t.params||{},t.params.query=t.params.query||{},t.params.query[n]=e,t)}const iI=document.createElement("canvas"),K1t=iI.getContext("2d");async function Y1t(n){const{data:e}=n;for(const[t,r]of Object.entries(e))if(r instanceof ImageData){const i=r.width,s=r.height;iI.width=i,iI.height=s,K1t.putImageData(r,0,0),n.data[t]=iI.toDataURL("image/jpeg")}return n}async function m9(n){if(!n.result)return n;const{result:e}=n,t=r=>r&&typeof r=="string"&&r.slice(0,22)==="data:image/jpeg;base64";if(e._id)for(const[r,i]of Object.entries(e).filter(([s])=>s!=="thumbnail"))t(i)&&(e[r]=await d9(i));else if(e.total&&Array.isArray(e.data))for(const[r,i]of e.data.entries())for(const[s,o]of Object.entries(i).filter(([a])=>a!=="thumbnail"))t(o)&&(e.data[r][s]=await d9(o));return n}async function Z1t(n){var e,t;if(!(!((t=(e=n.params)===null||e===void 0?void 0:e.query)===null||t===void 0)&&t.$distinct)||n.type!=="before"||n.method!=="find")return n;const{$distinct:r,...i}=n.params.query;i.$select=[r],i.$skip=0;let s=1;const o=new Set;for(;i.$skip<s;){const a=await n.service.find({query:i});for(const l of a.data)o.add(l[r]);i.$skip+=a.limit,s=a.total}return n.result=Array.from(o),n}function J1t(n){let e;return{c(){e=qe("Register")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function Q1t(n){let e;return{c(){e=qe("Log In")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function g9(n){let e,t,r,i,s,o,a,l,c;return{c(){e=we("div"),t=we("span"),t.innerHTML='<i class="fas fa-bell"></i>',r=tt(),i=we("span"),s=we("b"),s.textContent="Login Error",o=tt(),a=qe(n[1]),l=tt(),c=we("button"),c.innerHTML="<span>×</span>",Z(t,"class","text-xl inline-block mr-5 align-middle"),Z(s,"class","capitalize"),Z(i,"class","inline-block align-middle mr-8"),Z(c,"class","absolute bg-transparent text-2xl font-semibold leading-none right-0 top-0 mt-4 mr-6 outline-none focus:outline-none"),Z(e,"class","text-white px-6 py-4 border-0 rounded relative mb-4 bg-red-500")},m(u,h){me(u,e,h),ie(e,t),ie(e,r),ie(e,i),ie(i,s),ie(i,o),ie(i,a),ie(e,l),ie(e,c)},p(u,h){h&2&&cn(a,u[1])},d(u){u&&pe(e)}}}function e_t(n){let e;return{c(){e=qe("Register")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function t_t(n){let e;return{c(){e=qe("Log In")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function n_t(n){let e,t,r,i;return{c(){e=qe(`Already have an account?
        `),t=we("button"),t.textContent="Log In",Z(t,"class","text-blue-500")},m(s,o){me(s,e,o),me(s,t,o),r||(i=Yn(t,"click",n[2]),r=!0)},p:Ze,d(s){s&&pe(e),s&&pe(t),r=!1,i()}}}function r_t(n){let e,t,r,i;return{c(){e=qe(`Don't have an account?
        `),t=we("button"),t.textContent="Register Here",Z(t,"class","text-blue-500")},m(s,o){me(s,e,o),me(s,t,o),r||(i=Yn(t,"click",n[2]),r=!0)},p:Ze,d(s){s&&pe(e),s&&pe(t),r=!1,i()}}}function i_t(n){let e,t,r,i,s,o,a,l,c,u,h,f,d,p,m,g,y,b;function _(R,D){return R[0]==="login"?Q1t:J1t}let w=_(n),S=w(n),C=n[1]&&g9(n);function k(R,D){return R[0]==="login"?t_t:e_t}let A=k(n),M=A(n);function E(R,D){return R[0]==="login"?r_t:n_t}let N=E(n),O=N(n);return{c(){e=we("div"),t=we("div"),r=we("h2"),S.c(),i=tt(),s=we("p"),s.textContent="This Marcelle application requires authentication.",o=tt(),C&&C.c(),a=tt(),l=we("form"),c=we("div"),c.innerHTML=`<label class="block uppercase text-gray-700 text-xs font-bold mb-2" for="grid-password">Email</label> 
        <input type="email" name="email" class="bg-gray-200 appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500" placeholder="Email" style="transition: all 0.15s ease 0s;"/>`,u=tt(),h=we("div"),h.innerHTML=`<label class="block uppercase text-gray-700 text-xs font-bold mb-2" for="grid-password">Password</label> 
        <input type="password" name="password" class="bg-gray-200 appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500" placeholder="Password" style="transition: all 0.15s ease 0s;"/>`,f=tt(),d=we("div"),p=we("button"),M.c(),m=tt(),g=we("p"),O.c(),Z(r,"class","text-xl"),Z(s,"class","text-gray-600"),Z(t,"class","p-4 text-center"),Z(c,"class","relative w-full mb-3"),Z(h,"class","relative w-full mb-3"),Z(p,"class","bg-gray-900 text-white active:bg-gray-700 text-sm font-bold uppercase px-6 py-3 rounded shadow hover:shadow-lg outline-none focus:outline-none mr-1 mb-1 w-full"),Z(p,"type","submit"),Bs(p,"transition","all 0.15s ease 0s"),Z(d,"class","text-center mt-6"),Z(g,"class","my-4"),Z(e,"class","marcelle p-12")},m(R,D){me(R,e,D),ie(e,t),ie(t,r),S.m(r,null),ie(t,i),ie(t,s),ie(e,o),C&&C.m(e,null),ie(e,a),ie(e,l),ie(l,c),ie(l,u),ie(l,h),ie(l,f),ie(l,d),ie(d,p),M.m(p,null),ie(e,m),ie(e,g),O.m(g,null),y||(b=Yn(l,"submit",jC(n[7])),y=!0)},p(R,D){w!==(w=_(R))&&(S.d(1),S=w(R),S&&(S.c(),S.m(r,null))),R[1]?C?C.p(R,D):(C=g9(R),C.c(),C.m(e,a)):C&&(C.d(1),C=null),A!==(A=k(R))&&(M.d(1),M=A(R),M&&(M.c(),M.m(p,null))),N===(N=E(R))&&O?O.p(R,D):(O.d(1),O=N(R),O&&(O.c(),O.m(g,null)))},d(R){R&&pe(e),S.d(),C&&C.d(),M.d(),O.d(),y=!1,b()}}}function s_t(n){let e,t;return e=new hce({props:{$$slots:{default:[i_t]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&515&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function o_t(n,e,t){const r=Oc();let{dataStore:i}=e,{mode:s="login"}=e,o;function a(){t(0,s=s==="login"?"register":"login")}function l(f){r("terminate",f)}async function c(f){const d=new FormData(f.target);try{const p=await i.login(d.get("email"),d.get("password"));l(p)}catch(p){t(1,o=p)}}async function u(f){const d=new FormData(f.target);try{const p=await i.signup(d.get("email"),d.get("password"));l(p)}catch{l(null)}}const h=f=>s==="login"?c(f):u(f);return n.$$set=f=>{"dataStore"in f&&t(5,i=f.dataStore),"mode"in f&&t(0,s=f.mode)},[s,o,a,c,u,i,l,h]}class a_t extends gn{constructor(e){super(),mn(this,e,o_t,s_t,hn,{dataStore:5,mode:0,terminate:6})}get terminate(){return this.$$.ctx[6]}}class Tb extends ml{constructor(e,t={}){super(async function*(){const r={query:{},skip:0,take:-1,...t},i=r.take;let s=0,o=[];const a={...r.query,$skip:r.skip,$limit:10};for(;;)try{if(i>0&&s>=i)return;if(s++,o.length>0)yield o.shift();else{const l=await e.find({query:a});if(a.$skip=l.skip+l.limit,o=l.data,o.length>0)yield o.shift();else return}}catch(l){throw l.message=`Error thrown while iterating through a service: ${l.message}`,l}}),this.service=e,this.params={query:{},skip:0,take:-1,...t}}skip(e){return new Tb(this.service,{...this.params,skip:e})}take(e){return new Tb(this.service,{...this.params,take:e})}select(e){const t=IYe.cloneDeep(this.params);return t.query.$select=e,new Tb(this.service,t)}query(e){return new Tb(this.service,wl(this.params,{query:e}))}}function l_t(n){return new Tb(n)}var sI,D1,O1,yb,F1;function c_t(n){try{new URL(n)}catch{return!1}return!0}var bl;(function(n){n[n.Memory=0]="Memory",n[n.LocalStorage=1]="LocalStorage",n[n.Remote=2]="Remote"})(bl||(bl={}));class bce{constructor(e="memory"){if(this.requiresAuth=!1,this.apiPrefix="",this.$services=new ct([],!0),sI.set(this,void 0),D1.set(this,void 0),O1.set(this,Promise.resolve()),yb.set(this,!1),F1.set(this,Qm),this.feathers=KKe(),this.location=e,c_t(e)){this.backend=bl.Remote;const t=new URL(e),r=t.host;this.apiPrefix=t.pathname.replace(/\/$/,"");const i=iKe(r,{transports:["websocket"],reconnectionAttempts:5,path:this.apiPrefix+"/socket.io"});this.feathers.configure(iYe(i,{timeout:15e3})),Pn(this,sI,new Promise(s=>{this.feathers.io.on("init",({auth:o})=>{this.requiresAuth=o,o&&this.feathers.configure(SKe({path:`${this.apiPrefix}/authentication`})),s()})}),"f")}else if(e==="localStorage"){this.backend=bl.LocalStorage;const t=r=>EYe({storage:window.localStorage,name:r,id:"_id",multi:!0,paginate:{default:100,max:200}});Pn(this,F1,r=>{this.feathers.use(`/${r}`,t(r))},"f")}else if(e==="memory")this.backend=bl.Memory,Pn(this,F1,t=>{this.feathers.use(`/${t}`,CYe({id:"_id",paginate:{default:100,max:200}}))},"f");else throw new Error(`Cannot process backend location '${e}'`);this.setupAppHooks()}async connect(){return this.backend!==bl.Remote?{email:null}:(ze(this,D1,"f")||(ba.log(`Connecting to backend ${this.location}...`),Pn(this,D1,new Promise((e,t)=>{this.feathers.io.on("connect",()=>{ba.log(`Connected to backend ${this.location}!`),e()}),this.feathers.io.on("reconnect_failed",()=>{const r=new Error(`Cannot reach backend at location ${this.location}. Is the server running?
          If using locally, run 'npm run backend'`);r.name="DataStore connection error",t(),Co(r,{duration:0})})}),"f")),await ze(this,sI,"f"),await ze(this,D1,"f"),this.authenticate())}async authenticate(){if(!this.requiresAuth)return this.user={email:null},this.user;if(this.user)return this.user;const e=()=>(Pn(this,yb,!0,"f"),new Promise((t,r)=>{this.feathers.reAuthenticate().then(({user:i})=>{Pn(this,yb,!1,"f"),this.user=i,ba.log(`Authenticated as ${i.email}`),t()}).catch(i=>{Pn(this,yb,!1,"f"),r(i)})}));return Pn(this,O1,ze(this,O1,"f").then(()=>ze(this,yb,"f")?null:e()),"f"),ze(this,O1,"f").then(()=>this.user)}async login(e,t){const r=await this.feathers.authenticate({strategy:"local",email:e,password:t});return this.user=r.user,this.user}async loginWithUI(){const e=new a_t({target:document.body,props:{dataStore:this}});return new Promise((t,r)=>{e.$on("terminate",i=>{e.$destroy(),i?t(i):r()})})}async signup(e,t){try{return await this.service("users").create({email:e,password:t}),await this.login(e,t),this.user}catch(r){return ba.error("An error occurred during signup",r),{email:null}}}async logout(){await this.feathers.logout(),document.location.reload()}service(e){const t=Object.keys(this.feathers.services).includes(e);t||(ze(this,F1,"f").call(this,e),this.$services.set(Object.keys(this.feathers.services)));const r=this.backend===bl.Remote?this.feathers.service(`${this.apiPrefix}/${e}`):this.feathers.service(e);return t||(r.items=()=>l_t(r)),r}setupAppHooks(){const e=this.backend!==bl.Remote?[j1t]:[],t=this.backend!==bl.Remote?[Z1t]:[];this.feathers.hooks({before:{find:[...t,gm],create:[...e,q1t],update:[p9],patch:[p9]},after:{find:[gm],get:[gm],create:[gm],update:[gm],patch:[gm],remove:[gm]}})}}sI=new WeakMap,D1=new WeakMap,O1=new WeakMap,yb=new WeakMap,F1=new WeakMap;function LV(n){return new bce(n)}async function zS(n,e,t){const r=document.createElement("a");r.style.display="none",document.body.appendChild(r);const i=new Blob([n],{type:t});r.href=URL.createObjectURL(i),r.download=e,r.click()}async function vce(n){return new Promise((e,t)=>{const r=new FileReader;r.onload=()=>{const i=JSON.parse(r.result);e(i)},r.onerror=i=>{t(i)},r.readAsText(n)})}function qC(n){return n.replace(/([a-z])([A-Z])/g,"$1-$2").replace(/[\s_]+/g,"-").toLowerCase()}var L1,z1;class u_t extends ia{constructor(e,t=LV()){super(),this.title="dataset",this.isDataset=!0,L1.set(this,void 0),this.query={},z1.set(this,new Set),this.$count=new ct(0,!0),this.$changes=new ct([]),this.name=e,this.title=`dataset (${e})`,Pn(this,L1,t,"f"),this.start(),this.ready=new Promise((r,i)=>{ze(this,L1,"f").connect().then(()=>this.setup()).then(r).catch(s=>{const o=new Error(s==null?void 0:s.message);o.name=`Dataset Error (${e}): datastore connection failed`,Co(o,{duration:0}),i(o)})})}async setup(){const e=qC(`instances-${this.name}`);this.instanceService=ze(this,L1,"f").service(e),this.instanceService.__hooks.before.find===void 0&&this.instanceService.hooks({before:{all:[],create:[X1t("datasetName",this.name),Y1t],find:[d1("datasetName",this.name)],get:[d1("datasetName",this.name)],update:[d1("datasetName",this.name)],patch:[d1("datasetName",this.name)],remove:[d1("datasetName",this.name)]},after:{find:[m9],get:[m9]}}),this.instanceService.hooks({before:{update:[this.checkUpdates],patch:[this.checkUpdates]}}),await this.reset(),this.watchChanges()}async reset(){const{total:e}=await this.find({query:{$limit:0}});this.$count.set(e),this.$changes.set([{level:"dataset",type:"created"}])}async checkUpdates(e){if(Object.keys(this.query).length===0)return;const t=$G(this.query),r=t(e.data);try{const i=await this.get(e.id);t(i)&&!r&&(this.$count.set(this.$count.get()-1),this.$changes.set([{level:"instance",type:"removed",data:i}]))}catch{ze(this,z1,"f").add(e.id)}}watchChanges(){const e=$G(this.query);this.instanceService.on("created",r=>{if(!e(r))return;const i={...r,id:r.id||r._id};this.$count.set(this.$count.get()+1),this.$changes.set([{level:"instance",type:"created",data:i}])});const t=r=>{if(!e(r))return;const i={...r,id:r.id||r._id};ze(this,z1,"f").has(i.id)?(this.$count.set(this.$count.get()+1),this.$changes.set([{level:"instance",type:"created",data:i}]),ze(this,z1,"f").delete(i.id)):this.$changes.set([{level:"instance",type:"updated",data:i}])};this.instanceService.on("updated",t),this.instanceService.on("patched",t),this.instanceService.on("removed",r=>{if(!e(r))return;this.$count.set(this.$count.get()-1);const i={...r,id:r.id||r._id};this.$changes.set([{level:"instance",type:"removed",data:i}])})}async sift(e={}){return this.query=e,this.ready.then(()=>this.reset())}items(){return this.instanceService.items().query(this.query)}async find(e){const t=wl(e||{},{query:this.query});return this.instanceService.find(t)}async get(e,t){const r=wl(t||{},{query:this.query});return this.instanceService.get(e,r)}async create(e,t){const r=wl(t||{},{query:this.query});return this.instanceService.create(e,r)}async update(e,t,r){const i=wl(r||{},{query:this.query});return this.instanceService.update(e,t,i)}async patch(e,t,r){const i=wl(r||{},{query:this.query});return this.instanceService.patch(e,t,i)}async remove(e,t){const r=wl(t||{},{query:this.query});return this.instanceService.remove(e,r)}async clear(){await this.remove(null,{query:{}})}async distinct(e){const t={$distinct:e,...this.query};return this.instanceService.find({query:t})}async download(){const e=await this.find(),t={marcelleMeta:{type:"dataset"},instances:e.data},r=new Date(Date.now()),i=`${this.title}-${r.toISOString()}.json`;await zS(JSON.stringify(t),i,"text/plain")}async upload(e){const t=e.filter(s=>s.type==="application/json").map(s=>vce(s)),i=(await Promise.all(t)).map(s=>s.instances.map(o=>{const{id:a,...l}=o;return this.create(l).catch(c=>{Co(c)})}));await Promise.all(i)}mount(){}}L1=new WeakMap,z1=new WeakMap;function h_t(n,e){return new u_t(n,e)}function zf(n){return typeof n=="object"&&n!==null&&n.isDataset}class r0 extends ia{constructor(){super(),this.ready=!1,this.$training=new ct({status:"idle"},!0),this.$training.start(),this.$training.subscribe(({status:e})=>{(e==="success"||e==="loaded")&&(this.ready=!0)})}sync(e,t){return this.syncData={name:t,store:e},this.syncData.store.connect().then(()=>{this.syncData.service=this.syncData.store.service(this.serviceName),this.setupSync()}).catch(r=>{const i=new Error(r==null?void 0:r.message);i.name=`Model Sync Error (${t}): datastore connection failed`,Co(i,{duration:0})}),this}async setupSync(){if(!this.syncData.service)return;const{data:e}=await this.syncData.service.find({query:{name:this.syncData.name,$select:["id"],$limit:1,$sort:{updatedAt:-1}}});let t=null;e.length===1&&(t=e[0].id,this.load(this.syncData.store,t));let r=!1;this.$training.subscribe(({status:s,data:o})=>{(s==="success"||s==="loaded"&&(o==null?void 0:o.source)!=="datastore")&&(r=!0,this.save(this.syncData.store,this.syncData.name,{},t).then(a=>{t=a}))});const i=s=>{(s._id===t||!t&&s.name===this.syncData.name)&&(t=s._id,r||this.load(this.syncData.store,t),r=!1)};this.syncData.service.on("created",i),this.syncData.service.on("updated",i),this.syncData.service.on("patched",i)}async saveToDatastore(e,t,r=null){await e.connect();const i=e.service(this.serviceName);if(!i||!t)return null;let s=r;return r?await i.update(r,t):s=(await i.create(t)).id,ba.info(`Model was saved to data store at location ${e.location}`),s}async loadFromDatastore(e,t){await e.connect();const r=e.service(this.serviceName);if(!r||!t)return null;let i;try{i=await r.get(t)}catch{const{data:o}=await r.find({query:{name:t,$limit:1,$sort:{updatedAt:-1}}});o.length===1&&(i=o[0])}if(i){const s=i.name;ba.info(`Model ${s} was loaded from data store at location ${e.location}`)}return i}mount(){}}function wce(n){if(!n.modelTopology.model_config||!n.modelTopology.model_config.config||!n.modelTopology.model_config.config.layers||n.modelTopology.model_config.config.layers.length>0&&!n.modelTopology.model_config.config.layers[0].class_name)return n;try{let e=!1;for(const[t,r]of n.modelTopology.model_config.config.layers.entries())if(r.class_name==="SeparableConv2D"){const i=["kernel_constraint","kernel_initializer","kernel_regularizer"];for(const s of i)Object.keys(n.modelTopology.model_config.config.layers[t].config).includes(s)&&(e=!0),delete n.modelTopology.model_config.config.layers[t].config[s]}e&&ba.warning("TFJS Model loading: experimentally removing Kernel attributes from SeparableConv2D layers")}catch(e){ba.warning("TFJS Model loading: An error occurred whil experimentally removing Kernel attributes from SeparableConv2D layers",e)}return n}function cL(...n){const e=sN(...n),t=e.load.bind(e);return e.load=async function(){const i=await t();return wce(i)},e}function xce(...n){const e=aY(...n),t=e.load.bind(e);return e.load=async function(){const i=await t();return wce(i)},e}class U$ extends r0{constructor(){super(...arguments),this.serviceName="tfjs-models"}async warmup(){const e=this.model.inputs[0].shape.map(r=>r&&r>0?r:1),t=this.model.predict(Se(()=>pi(e)));await t.data(),t.dispose()}async save(e,t,r,i=null){if(!this.model)return null;let s;if(e.backend===bl.LocalStorage)await this.model.save(`indexeddb://${t}`),s=[["main",`indexeddb://${t}`]];else if(e.backend===bl.Remote){const a={};if(e.requiresAuth){const l=await e.feathers.authentication.getAccessToken(),c=new Headers({Authorization:`Bearer ${l}`});a.requestInit={headers:c}}s=await this.model.save(cL(`${e.location}/tfjs-models/upload`,a)).then(l=>l.responses[0].json())}const o={name:t,files:s,format:"tfjs",metadata:{tfjsModelFormat:this.model instanceof Ud?"layers-model":"graph-model",...this.labels&&{labels:this.labels},...r}};return this.saveToDatastore(e,o,i)}async load(e,t){if(!t)return null;this.$training.set({status:"loading"}),this.ready=!1,await H2();try{const r=await this.loadFromDatastore(e,t);this.loadFn=r.metadata.tfjsModelFormat==="graph-model"?Pl:q_;let i;if(e.backend===bl.LocalStorage)i=await this.loadFn(r.files[0][1]);else if(e.backend===bl.Remote){const s={};if(e.requiresAuth){const o=await e.feathers.authentication.getAccessToken(),a=new Headers({Authorization:`Bearer ${o}`});s.requestInit={headers:a}}i=await this.loadFn(cL(`${e.location}/tfjs-models/${r.id}/model.json`,s))}return i&&(this.model=i,await this.warmup()),r.metadata&&r.metadata.labels?this.labels=r.metadata.labels:this.labels=void 0,this.$training.set({status:"loaded",data:{source:"datastore",url:e.location}}),r}catch(r){throw console.log("[tfjs-model] Loading error",r),this.$training.set({status:"error"}),r}}async download(e){const t=qC(this.title),r={type:"tfjs-model",tfjsModelFormat:this.model instanceof Ud?"layers-model":"graph-model",name:t,...this.labels&&{labels:this.labels},...e},i=new Date(Date.now());await this.model.save(dY(async s=>{const o={modelTopology:s.modelTopology,weightsManifest:[{paths:[`./${t}.weights.bin`],weights:s.weightSpecs}],marcelle:r};return await zS(s.weightData,`${t}.weights.bin`,"application/octet-stream"),await zS(JSON.stringify(o),`${t}.json`,"text/plain"),{modelArtifactsInfo:{dateSaved:i,modelTopologyType:"JSON"}}}))}async upload(...e){this.$training.set({status:"loading"});try{const t=e.filter(o=>o.name.includes(".json")),r=e.filter(o=>o.name.includes(".bin")),{marcelle:i}=await new Promise((o,a)=>{const l=new FileReader;l.onload=()=>{const c=JSON.parse(l.result);o(c)},l.onerror=c=>a(new Error(`The provided files are not a valid marcelle model ${c}`)),l.readAsText(t[0])});if(this.loadFn=i.tfjsModelFormat==="graph-model"?Pl:q_,t.length===1&&e.length){const o=await this.loadFn(xce([t[0],...r]));return o&&(this.model=o,await this.warmup()),i&&i.labels?this.labels=i.labels:this.labels=null,this.$training.set({status:"loaded",data:{source:"file"}}),{name:i.name,format:"tfjs",files:[],metadata:i}}const s=new Error("The provided files are not compatible with this model");throw s.name="File upload error",s}catch(t){throw this.$training.set({status:"error"}),t}}}On([zn],U$.prototype,"warmup",null);On([zn],U$.prototype,"upload",null);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f_t=1e-7,d_t=1e-4;class p_t{refCount(e){return za("refCount")}incRef(e){return za("incRef")}timerAvailable(){return!0}time(e){return za("time")}read(e){return za("read")}readSync(e){return za("readSync")}readToGPU(e,t){return za("readToGPU")}numDataIds(){return za("numDataIds")}disposeData(e,t){return za("disposeData")}write(e,t,r){return za("write")}move(e,t,r,i,s){return za("move")}createTensorFromGPUData(e,t,r){return za("createTensorFromGPUData")}memory(){return za("memory")}floatPrecision(){return za("floatPrecision")}epsilon(){return this.floatPrecision()===32?f_t:d_t}dispose(){return za("dispose")}}function za(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zs(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Bb(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function _ce(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function m_t(n){return n%1===0}function oI(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function Sce(n,e){const t=e.length;return n=n==null?e.map((r,i)=>i):[].concat(n),zs(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),zs(n.every(r=>m_t(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function g_t(n,e){const t=[],r=[],i=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||i?null:Sce(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(s!=null){if(s[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(s[o]==null||s[o]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),s[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function y_t(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function b_t(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function uL(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function v_t(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function zV(n){return typeof n=="string"||n instanceof String}function w_t(n){return typeof n=="boolean"}function x_t(n){return typeof n=="number"}function BV(n){return Array.isArray(n)?BV(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":x_t(n)?"float32":zV(n)?"string":w_t(n)?"bool":"float32"}function y9(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Cce(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function kce(n,e,t,r=!1){const i=new Array;if(e.length===1){const s=e[0]*(r?2:1);for(let o=0;o<s;o++)i[o]=t[n+o]}else{const s=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<s;l++)i[l]=kce(n+l*a,o,t,r)}return i}function b9(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((i,s)=>i*s)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return kce(0,n,e,t)}function __t(n,e){const t=Tce(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function Tce(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function S_t(n){n.forEach(e=>{zs(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function VV(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v9="tfjsflags";class C_t{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=k_t,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Ha().getBool("IS_TEST")||Ha().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const i=this.urlFlags[e];Ha().getBool("IS_TEST")||Ha().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${i}.`),this.set(e,i)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(VV(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);v9 in e&&e[v9].split(",").forEach(r=>{const[i,s]=r.split(":");this.urlFlags[i]=E_t(i,s)})}}function k_t(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(T_t(e,r[0],r[1]),r.join("="))),e}function T_t(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function E_t(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function Ha(){return Ece}let Ece=null;function I_t(n){Ece=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let KP;function Ice(){if(KP==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");KP=n}return KP}function A_t(){const n=Ice();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function UV(n,e){const t=A_t();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const M_t="Abs",N_t="Add",$_t="ArgMax",R_t="BatchMatMul",Ace="Cast",P_t="ComplexAbs",D_t="ExpandDims",O_t="GatherV2",F_t="Identity",L_t="Max",z_t="Min",B_t="Multiply",V_t="Pow",U_t="Reshape",W_t="Sqrt",H_t="Sum";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p1(...n){Ha().getBool("IS_TEST")||Ha().getBool("PROD")||console.warn(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mce=UV("kernelRegistry",()=>new Map),G_t=UV("gradRegistry",()=>new Map);function w9(n,e){const t=j_t(n,e);return Mce.get(t)}function x9(n){return G_t.get(n)}function _9(n){const e=Mce.entries(),t=[];for(;;){const{done:r,value:i}=e.next();if(r)break;const[s,o]=i,[a]=s.split("_");a===n&&t.push(o)}return t}function j_t(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q_t(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X_t(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Nce(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=BS(n)),Ha().getBool("DEBUG")&&y_t(n,e),X_t(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function dM(){return Ha().platform.now()}function K_t(n,e="utf-8"){return e=e||"utf-8",Ha().platform.encode(n,e)}function S9(n,e="utf-8"){return e=e||"utf-8",Ha().platform.decode(n,e)}function Pu(n){return Ha().platform.isTypedArray!=null?Ha().platform.isTypedArray(n):q_t(n)}function BS(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||VV(n)||n==null||Pu(n)&&t)e.push(n);else if(Array.isArray(n)||Pu(n))for(let r=0;r<n.length;++r)BS(n[r],e,t);else{let r=-1;for(const i of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(i)&&(r=Math.max(r,Number(i)));for(let i=0;i<=r;i++)BS(n[i],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y_t{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new J_t)}profileKernel(e,t,r){let i;const s=()=>{i=r()};let o;const a=dM();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(s);else{s();for(const c of i)c.dataSync();o=Promise.resolve({kernelMs:dM()-a})}if(Ha().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<i.length;c++){const u=i[c];u.data().then(h=>{Z_t(h,u.dtype,e)})}return{kernelName:e,outputs:i,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:i,inputs:s,extraInfo:o}=e;r.forEach(a=>{Promise.all([a.data(),i,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],s,l[2])})})}}function Z_t(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const i=n[r];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${t}'`),!0}return!1}class J_t{logKernelProfile(e,t,r,i,s,o){const a=typeof i=="number"?oI(`${i}ms`,9):i.error,l=oI(e,25),c=t.rank,u=t.size,h=oI(t.shape.toString(),14);let f="";for(const d in s){const p=s[d];if(p!=null){const m=p.shape||t.shape,g=m.length;f+=`${d}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${h}	%c${u}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q_t(n,e,t){const r={},i={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const h in u){const f=u[h];let d=!1;for(let p=0;p<e.length;p++)if(r[f.id]){c.outputs.forEach(m=>r[m.id]=!0),d=!0,i[c.id]=!0;break}if(d)break}}const s={};s[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(s[c.outputs[h].id]){for(const f in u)s[u[f].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(i[c.id]&&o[c.id]){const u={};for(const f in c.inputs){const d=c.inputs[f];r[d.id]&&(u[f]=d)}const h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,a.push(h)}}return a}function eSt(n,e,t,r){for(let i=e.length-1;i>=0;i--){const s=e[i],o=[];if(s.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const a=s.gradient(o);for(const l in s.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=t(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=s.inputs[l];if(!_ce(c.shape,u.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{const h=n[u.id];n[u.id]=r(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C9=20,m1=3,YP=7;function tSt(n,e,t,r){const i=Cce(e),s=nSt(n,e,t,i),o=e.length,a=aI(n,e,t,i,s),l=["Tensor"];return r&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function nSt(n,e,t,r){const i=Bb(e),s=r[r.length-1],o=new Array(s).fill(0),a=e.length,l=t==="complex64"?V1(n):n;if(a>1)for(let c=0;c<i/s;c++){const u=c*s;for(let h=0;h<s;h++)o[h]=Math.max(o[h],B1(l[u+h],0,t).length)}return o}function B1(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(YP))} + ${parseFloat(n[1].toFixed(YP))}j`:zV(n)?r=`'${n}'`:t==="bool"?r=$ce(n):r=parseFloat(n.toFixed(YP)).toString(),oI(r,e)}function $ce(n){return n===0?"false":"true"}function aI(n,e,t,r,i,s=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const m=V1(n);return[B1(m[0],0,t)]}return t==="bool"?[$ce(n[0])]:[n[0].toString()]}if(l===1){if(a>C9){const g=m1*o;let y=Array.from(n.slice(0,g)),b=Array.from(n.slice((a-m1)*o,a*o));return t==="complex64"&&(y=V1(y),b=V1(b)),["["+y.map((_,w)=>B1(_,i[w],t)).join(", ")+", ..., "+b.map((_,w)=>B1(_,i[a-m1+w],t)).join(", ")+"]"]}return["["+(t==="complex64"?V1(n):Array.from(n)).map((g,y)=>B1(g,i[y],t)).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,f=[];if(a>C9){for(let m=0;m<m1;m++){const g=m*h,y=g+h;f.push(...aI(n.slice(g,y),c,t,u,i,!1))}f.push("...");for(let m=a-m1;m<a;m++){const g=m*h,y=g+h;f.push(...aI(n.slice(g,y),c,t,u,i,m===a-1))}}else for(let m=0;m<a;m++){const g=m*h,y=g+h;f.push(...aI(n.slice(g,y),c,t,u,i,m===a-1))}const d=l===2?",":"";f[0]="["+(a>0?f[0]+d:"");for(let m=1;m<f.length-1;m++)f[m]=" "+f[m]+d;let p=`,
`;for(let m=2;m<l;m++)p+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(s?"":p),f}function V1(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hh=null,g1=null;function rSt(n){hh=n}class cc{constructor(e,t,r,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Bb(e),this.strides=Cce(e),this.dataId=r,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return g1.buffer(this.shape,this.dtype,e)}bufferSync(){return g1.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return b9(this.shape,e,this.dtype==="complex64")}arraySync(){return b9(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=hh().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>S9(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),hh().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=hh().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>S9(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await hh().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),hh().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return g1.print(this,e)}clone(){return this.throwIfDisposed(),g1.clone(this)}toString(e=!1){const t=this.dataSync();return tSt(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),g1.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),hh().makeVariable(this,e,t,r)}}Object.defineProperty(cc,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function zc(){return UV("Tensor",()=>cc)}zc();class hL extends cc{constructor(e,t,r,i){super(e.shape,e.dtype,e.dataId,i),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!_ce(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);hh().disposeTensor(this),this.dataId=e.dataId,hh().incRef(this,null)}dispose(){hh().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(hL,Symbol.hasInstance,{value:n=>n instanceof cc&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var k9;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(k9||(k9={}));var fL;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(fL||(fL={}));var dL;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(dL||(dL={}));var pL;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(pL||(pL={}));var mL;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(mL||(mL={}));const iSt={float32:pL,int32:fL,bool:dL,complex64:mL};function sSt(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return iSt[n][e]}function Rce(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function Pce(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WV(n,e){if(n.dtype===e.dtype)return[n,e];const t=sSt(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function oSt(n){const e=[];return Dce(n,e,new Set),e}function Dce(n,e,t){if(n==null)return;if(n instanceof cc){e.push(n);return}if(!aSt(n))return;const r=n;for(const i in r){const s=r[i];t.has(s)||(t.add(s),Dce(s,e,t))}}function aSt(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZP(n){return n.kernelName!=null}class T9{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class kv{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new T9}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(p1(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Y_t(this.backendInstance),!0}setupRegisteredKernels(){_9(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){_9(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof p_t)&&typeof r.then=="function"){const i=++this.pendingBackendInitId,s=r.then(o=>i<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,p1(`Initialization of backend ${e} failed`),p1(o.stack||o.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return p1(`Initialization of backend ${e} failed`),p1(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:i,asyncInit:s}=this.initializeBackend(r);if(s||i)return{name:r,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),i=r.backend,s=this.readSync(t),o=i.refCount(t);i.disposeData(t,!0),r.backend=e,e.move(t,s,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let i;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(i),()=>(i=t(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,t,r){e();try{const i=r();return t(),i}catch(i){throw t(),i}}nextTensorId(){return kv.nextTensorId++}nextVariableId(){return kv.nextVariableId++}clone(e){const t=wi.runKernel(F_t,{x:e}),r={x:e},i=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return wi.runKernel(Ace,l,c)}}),s=[];return this.addTapeNode(this.state.activeScope.name,r,[t],i,s,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(w9(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const i=this.backend.numDataIds();let s=0;r.forEach(l=>{s+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=i-t-s-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const i=this.isTapeOn(),s=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=ZP(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(ZP(e)){const{kernelName:p,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=w9(p,this.backendName);zs(y!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),a=()=>{const b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const _=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,b,_);const w=_.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(i){const S=this.getTensorsForGradient(p,m,w);r=this.saveTensorsForBackwardMode(S)}return w}}else{const{forwardFunc:p}=e,m=g=>{i&&(r=g.map(y=>this.keep(this.clone(y))))};a=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>p(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,g,y),y}}const{inputs:u,attrs:h}=e,f=ZP(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(d=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),i&&this.addTapeNode(c,u,t,f,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(p=>u[p]!=null?u[p].shape:null),outputShapes:t.map(p=>p.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const i=x9(e);if(i!=null){const s=i.inputsToSave||[],o=i.outputsToSave||[];let a;i.saveAllInputs?(zs(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(c=>t[c])):a=s.map(c=>t[c]);const l=r.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(e,t,r,i){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",i=i||this.backend;let s=e;r==="string"&&zV(e[0])&&(s=e.map(l=>K_t(l)));const o=i.write(s,t,r),a=new cc(t,r,o,this.nextTensorId());if(this.trackTensor(a,i),r==="string"){const l=this.state.tensorInfo.get(o),c=v_t(s);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,t,r,i){r=r||"float32";const s={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(s,i)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:i,dtype:s}=e,o=new cc(i,s,r,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,r,i){r=r||this.nextVariableId().toString(),i!=null&&i!==e.dtype&&(e=e.cast(i));const s=new hL(e,t,r,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*uL(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof hL||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*uL(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,i,s,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:s},l=x9(e);l!=null&&(i=l.gradFunc),i!=null&&(a.gradient=c=>(c=c.map((u,h)=>{if(u==null){const f=r[h],d=Tce(f.size,f.dtype);return this.makeTensor(d,f.shape,f.dtype)}return u}),i(c.length>1?c:c[0],s,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=oSt(e),r=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){const o=this.state.activeScope.track[s];!o.kept&&!r.has(o.id)&&o.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===i.id&&this.track(s)})}gradients(e,t,r,i=!1){if(zs(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));zs(s instanceof cc,()=>"The result y returned by f() must be a tensor.");const o=Q_t(this.state.activeTape,t,s);if(!i&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[s.id]=r??lSt(s.shape),eSt(a,o,c=>this.tidy(c),uSt);const l=t.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(e){return zs(y9(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{zs(t.every(a=>a instanceof cc),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const i={};t.forEach((a,l)=>{i[l]=a});const s=(a,l)=>(r=e(...t,l),zs(r.value instanceof cc,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),zs(y9(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(a,l)=>{const c=r.gradFunc(a,l),u=Array.isArray(c)?c:[c];zs(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),zs(u.every(f=>f instanceof cc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((f,d)=>{h[d]=()=>f}),h};return this.runKernelFunc({forwardFunc:s,backwardsFunc:o,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=dM(),r=await this.backend.time(e);return r.wallMs=dM()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new T9;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}kv.nextTensorId=0;kv.nextVariableId=0;function lSt(n){const e=__t(Bb(n),"float32");return wi.makeTensor(e,n,"float32")}function cSt(){const n=Ice();if(n._tfengine==null){const e=new C_t(n);n._tfengine=new kv(e)}return I_t(n._tfengine.ENV),rSt(()=>n._tfengine),n._tfengine}const wi=cSt();function uSt(n,e){const t={a:n,b:e};return wi.runKernel(N_t,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hSt(n,e){let t=n;if(Pu(n))return e==="string"?[]:[n.length];if(Rce(n)){const i=n.channels||"RGBA";return[n.height,n.width*i.length]}else if(Pce(n))return[n.buffer.size/(e==null?4:uL(e))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||Pu(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&Ha().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Oce(n,r,[]),r}function Oce(n,e,t){if(t=t||[],!Array.isArray(n)&&!Pu(n)){zs(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}zs(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),zs(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let i=0;i<n.length;++i)Oce(n[i],r,t.concat(i))}function E9(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function Ns(n,e,t,r="numeric"){if(n instanceof cc)return E9(r,n.dtype,e,t),n;let i=BV(n);if(i!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(i=r),E9(r,i,e,t),n==null||!Pu(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const s=hSt(n,i);!Pu(n)&&!Array.isArray(n)&&(n=[n]);const a=i!=="string"?Nce(n,i):BS(n,[],!0);return wi.makeTensor(a,s,i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fSt="__op";function sa(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+fSt;const i=(...s)=>{wi.startScope(t);try{const o=r(...s);return VV(o)&&console.error("Cannot return a Promise inside of tidy."),wi.endScope(o),o}catch(o){throw wi.endScope(null),o}};return Object.defineProperty(i,"name",{value:t,configurable:!0}),i}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dSt(n,e,t=0,r=0){const i=Ns(n,"x","gather"),s=Ns(e,"indices","gather","int32"),o={x:i,indices:s},a={axis:t,batchDims:r};return wi.runKernel(O_t,o,a)}const pSt=sa({gather_:dSt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.gather=function(n,e,t){return this.throwIfDisposed(),pSt(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mSt(n,e=0){const r={x:Ns(n,"x","argMax")},i={axis:e};return wi.runKernel($_t,r,i)}const gSt=sa({argMax_:mSt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.argMax=function(n){return this.throwIfDisposed(),gSt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ySt(n,e){const r={x:Ns(n,"x","reshape","string_or_numeric")},i={shape:e};return wi.runKernel(U_t,r,i)}const hx=sa({reshape_:ySt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bSt(n,e){const t=Ns(n,"x","squeeze","string_or_numeric");return hx(t,g_t(t.shape,e).newShape)}const vSt=sa({squeeze_:bSt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.squeeze=function(n){return this.throwIfDisposed(),vSt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wSt(n,e=0){const t=Ns(n,"x","expandDims","string_or_numeric");zs(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},i={dim:e};return wi.runKernel(D_t,r,i)}const xSt=sa({expandDims_:wSt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.expandDims=function(n){return this.throwIfDisposed(),xSt(this,n)};function I9(n,e=null,t=!1){const r=e?{$select:e}:{},i=zf(n)?n.items().query(r):n,s=t?i.toArray():Promise.resolve(i);async function*o(){const a=await s;for await(const l of a)yield l}return wrt(o)}function A9(n){const e={};for(const[t,r]of Object.entries(n)){const i=t.startsWith("val_")?t.replace("val_","")+"Val":t;e[i]=r}return e}class Fce extends U${constructor({epochs:e=20,batchSize:t=8,validationSplit:r=.2}={}){super(),this.title="TFJSCustomModel",this.loadFn=q_,this.validationSplit=Math.max(Math.min(r,1),0),this.parameters={epochs:new ct(e,!0),batchSize:new ct(t,!0)}}transformDataset(e){return e.map(t=>({xs:Ts(t.x),ys:Ts(t.y)}))}async train(e,t){this.$training.set({status:"start",epochs:this.parameters.epochs.get()});const i=zf(e)?e.$count.value:(await e.toArray()).length,s=Math.min(200,i),o=this.transformDataset(I9(e,["x","y"],i<200)).shuffle(s);let a,l;if(t)a=o,l=this.transformDataset(I9(t,["x","y"],i<200)).shuffle(s);else{const h=Math.floor(i*(1-this.validationSplit));a=o.take(h),l=this.validationSplit>0&&o.skip(h)}const[{xs:c,ys:u}]=await a.take(1).toArray();this.buildModel(c.shape,u.shape),this.fit(a,l)}_predict(e){return this.model?Se(()=>this.model.predict(Ts(e).expandDims(0)).gather(0)):null}clear(){delete this.model}fit(e,t){this.model.fitDataset(e.batch(this.parameters.batchSize.get()),{...t?{validationData:t.batch(this.parameters.batchSize.get())}:{},epochs:this.parameters.epochs.get(),callbacks:{onEpochEnd:(r,i)=>{this.$training.set({status:"epoch",epoch:r+1,epochs:this.parameters.epochs.get(),data:A9(i)})}}}).then(r=>{this.$training.set({status:"success",data:A9(r.history)})}).catch(r=>{throw this.$training.set({status:"error",data:r}),new wp(r.message)})}}On([zn],Fce.prototype,"train",null);class Lce extends Fce{constructor(){super(...arguments),this.title="TFJSCustomClassifier"}async train(e,t){const r=zf(e);if(this.labels=r?await e.distinct("y"):this.labels=Array.from(new Set(await e.map(({y:s})=>s).toArray())),this.labels.length===0){Co(new wp("This dataset is empty or is missing labels")),this.$training.set({status:"error"});return}if(this.labels.length===1){Co(new wp("At least two classes are needed to train the classifier")),this.$training.set({status:"error"});return}const i=this.labels.length;this.transformDataset=s=>s.map(o=>({xs:Ts(o.x),ys:Xb(this.labels.indexOf(o.y),i)})),super.train(e,t)}async predict(e){return this.model?Se(()=>{const t=this._predict(e),r=this.labels[t.argMax().arraySync()],s=t.arraySync().reduce((o,a,l)=>({...o,[this.labels[l]]:a}),{});return{label:r,confidences:s}}):{label:void 0,confidences:{}}}}On([zn],Lce.prototype,"train",null);function _St(n){var g,y,b,_;let e,t,r,i,s=((g=n[2])==null?void 0:g.message)+"",o,a,l,c,u=Math.floor(((y=n[2])==null?void 0:y.progress)*100)+"",h,f,d,p,m;return p=new fce({props:{progress:(b=n[2])==null?void 0:b.progress,type:(_=n[2])==null?void 0:_.type}}),{c(){var w,S,C,k,A,M;e=we("div"),t=we("div"),r=we("div"),i=we("span"),o=qe(s),a=tt(),l=we("div"),c=we("span"),h=qe(u),f=qe("%"),d=tt(),Ct(p.$$.fragment),Z(i,"class","text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200 svelte-cymqgb"),Wt(i,"gray",((w=n[2])==null?void 0:w.type)==="idle"),Wt(i,"green",((S=n[2])==null?void 0:S.type)==="success"),Wt(i,"red",((C=n[2])==null?void 0:C.type)==="danger"),Z(c,"class","text-xs font-semibold inline-block text-blue-600 svelte-cymqgb"),Wt(c,"tgray",((k=n[2])==null?void 0:k.type)==="idle"),Wt(c,"tgreen",((A=n[2])==null?void 0:A.type)==="success"),Wt(c,"tred",((M=n[2])==null?void 0:M.type)==="danger"),Z(l,"class","text-right"),Z(t,"class","flex mb-2 items-center justify-between"),Z(e,"class","relative pt-6 w-full"),Bs(e,"min-width","250px")},m(w,S){me(w,e,S),ie(e,t),ie(t,r),ie(r,i),ie(i,o),ie(t,a),ie(t,l),ie(l,c),ie(c,h),ie(c,f),ie(e,d),xt(p,e,null),m=!0},p(w,S){var k,A,M,E,N,O,R,D,z,B;(!m||S&4)&&s!==(s=((k=w[2])==null?void 0:k.message)+"")&&cn(o,s),(!m||S&4)&&Wt(i,"gray",((A=w[2])==null?void 0:A.type)==="idle"),(!m||S&4)&&Wt(i,"green",((M=w[2])==null?void 0:M.type)==="success"),(!m||S&4)&&Wt(i,"red",((E=w[2])==null?void 0:E.type)==="danger"),(!m||S&4)&&u!==(u=Math.floor(((N=w[2])==null?void 0:N.progress)*100)+"")&&cn(h,u),(!m||S&4)&&Wt(c,"tgray",((O=w[2])==null?void 0:O.type)==="idle"),(!m||S&4)&&Wt(c,"tgreen",((R=w[2])==null?void 0:R.type)==="success"),(!m||S&4)&&Wt(c,"tred",((D=w[2])==null?void 0:D.type)==="danger");const C={};S&4&&(C.progress=(z=w[2])==null?void 0:z.progress),S&4&&(C.type=(B=w[2])==null?void 0:B.type),p.$set(C)},i(w){m||(ke(p.$$.fragment,w),m=!0)},o(w){$e(p.$$.fragment,w),m=!1},d(w){w&&pe(e),_t(p)}}}function SSt(n){let e,t;return e=new Ao({props:{title:n[0],$$slots:{default:[_St]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&12&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function CSt(n,e,t){let r,i=Ze,s=()=>(i(),i=vr(a,l=>t(2,r=l)),a);n.$$.on_destroy.push(()=>i());let{title:o}=e,{progress:a}=e;return s(),n.$$set=l=>{"title"in l&&t(0,o=l.title),"progress"in l&&s(t(1,a=l.progress))},[o,a,r]}class kSt extends gn{constructor(e){super(),mn(this,e,CSt,SSt,hn,{title:0,progress:1})}}class TSt extends ia{constructor(e){super(),this.$progress=e,this.title="progress bar",this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new kSt({target:t,props:{title:this.title,progress:this.$progress}}))}}function ESt(n){if(!n.$training)throw new Error("The argument is not a valid MLP");const e=n.$training.map(({status:r,epoch:i,epochs:s})=>{let o="default",a=s>0?i/s:null;return r==="error"&&(o="danger"),r==="idle"&&(o="idle",a=0),["success","loaded"].includes(r)&&(o="success",a=1),["start","loading"].includes(r)&&(a=null),{message:`Status: ${r}`,progress:a,type:o}}).hold(),t=new TSt(e);return t.title="Training Progress",t}var U1;class ISt extends ia{constructor(e,t=LV()){super(),this.title="batch prediction",U1.set(this,void 0),this.$status=new ct({status:"loading"},!0),this.name=e,this.title=`batch prediction (${e})`,Pn(this,U1,t||new bce,"f"),this.start(),ze(this,U1,"f").connect().then(()=>{this.setup()}).catch(r=>{const i=new Error(r==null?void 0:r.message);i.name=`Batch Prediction Error (${e}): Datastore connection failed`,Co(i,{duration:0})})}async setup(){const e=qC(`predictions-${this.name}`);this.predictionService=ze(this,U1,"f").service(e);const{total:t}=await this.predictionService.find({query:{$limit:1,$select:["id"]}});this.$status.set({status:t>0?"loaded":"idle"})}async predict(e,t){try{const r=zf(t)?t.$count.value:(await t.toArray()).length;this.$status.set({status:"start"});const i=zf(t)?t.items():t;let s=0;for await(const{id:o,x:a,y:l}of i){const c=await e.predict(a),u=await this.predictionService.create({...c,instanceId:o,yTrue:l});this.$status.set({status:"running",count:++s,total:r,data:u})}this.$status.set({status:"success",count:s,total:r})}catch(r){this.$status.set({status:"error",data:{error:r}})}}async clear(){await this.predictionService.remove(null,{query:{}})}items(){return this.predictionService.items()}mount(){}}U1=new WeakMap;function ASt(...n){return new ISt(...n)}function MSt(n){let e;return{c(){e=qe(n[10])},m(t,r){me(t,e,r)},p(t,r){r&1024&&cn(e,t[10])},d(t){t&&pe(e)}}}function NSt(n){let e,t,r,i;function s(a){n[11](a)}let o={disabled:n[7],type:n[8],$$slots:{default:[MSt]},$$scope:{ctx:n}};return n[9]!==void 0&&(o.pressed=n[9]),t=new zi({props:o}),Li.push(()=>Lc(t,"pressed",s)),t.$on("click",n[12]),{c(){e=we("div"),Ct(t.$$.fragment)},m(a,l){me(a,e,l),xt(t,e,null),i=!0},p(a,l){const c={};l&128&&(c.disabled=a[7]),l&256&&(c.type=a[8]),l&9216&&(c.$$scope={dirty:l,ctx:a}),!r&&l&512&&(r=!0,c.pressed=a[9],Fc(()=>r=!1)),t.$set(c)},i(a){i||(ke(t.$$.fragment,a),i=!0)},o(a){$e(t.$$.fragment,a),i=!1},d(a){a&&pe(e),_t(t)}}}function $St(n){let e,t;return e=new Ao({props:{title:n[0],loading:n[6],$$slots:{default:[NSt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&64&&(s.loading=r[6]),i&10112&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function RSt(n,e,t){let r,i=Ze,s=()=>(i(),i=vr(S,E=>t(6,r=E)),S),o,a=Ze,l=()=>(a(),a=vr(C,E=>t(7,o=E)),C),c,u=Ze,h=()=>(u(),u=vr(k,E=>t(8,c=E)),k),f,d=Ze,p=()=>(d(),d=vr(w,E=>t(9,f=E)),w),m,g=Ze,y=()=>(g(),g=vr(_,E=>t(10,m=E)),_);n.$$.on_destroy.push(()=>i()),n.$$.on_destroy.push(()=>a()),n.$$.on_destroy.push(()=>u()),n.$$.on_destroy.push(()=>d()),n.$$.on_destroy.push(()=>g());let{title:b}=e,{text:_}=e;y();let{pressed:w}=e;p();let{loading:S}=e;s();let{disabled:C}=e;l();let{type:k}=e;h();function A(E){f=E,w.set(f)}function M(E){uM.call(this,n,E)}return n.$$set=E=>{"title"in E&&t(0,b=E.title),"text"in E&&y(t(1,_=E.text)),"pressed"in E&&p(t(2,w=E.pressed)),"loading"in E&&s(t(3,S=E.loading)),"disabled"in E&&l(t(4,C=E.disabled)),"type"in E&&h(t(5,k=E.type))},[b,_,w,S,C,k,r,o,c,f,m,A,M]}class PSt extends gn{constructor(e){super(),mn(this,e,RSt,$St,hn,{title:0,text:1,pressed:2,loading:3,disabled:4,type:5})}}class DSt extends ia{constructor(e="click me"){super(),this.title="button",this.$click=new ct($_()),this.$pressed=new ct(!1,!0),this.$loading=new ct(!1,!0),this.$disabled=new ct(!1,!0),this.$type=new ct("default",!0),this.$text=new ct(e,!0),this.start(),this.$loading.skip(1).subscribe(t=>{this.$disabled.set(t)})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new PSt({target:t,props:{title:this.title,text:this.$text,pressed:this.$pressed,loading:this.$loading,disabled:this.$disabled,type:this.$type}}),this.$$.app.$on("click",this.$click.set))}}function HV(...n){return new DSt(...n)}function OSt(n){let e,t;return{c(){e=qe("COCO-SSD loaded with base "),t=qe(n[2])},m(r,i){me(r,e,i),me(r,t,i)},p(r,i){i&4&&cn(t,r[2])},d(r){r&&pe(e),r&&pe(t)}}}function FSt(n){let e;return{c(){e=qe(" ")},m(t,r){me(t,e,r)},p:Ze,d(t){t&&pe(e)}}}function LSt(n){let e;function t(s,o){return s[3]?FSt:OSt}let r=t(n),i=r(n);return{c(){e=we("p"),i.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(s,o){me(s,e,o),i.m(e,null)},p(s,o){r===(r=t(s))&&i?i.p(s,o):(i.d(1),i=r(s),i&&(i.c(),i.m(e,null)))},d(s){s&&pe(e),i.d()}}}function zSt(n){let e,t;return e=new Ao({props:{title:n[0],loading:n[3],$$slots:{default:[LSt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&8&&(s.loading=r[3]),i&28&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function BSt(n,e,t){let r,i=Ze,s=()=>(i(),i=vr(a,c=>t(3,r=c)),a);n.$$.on_destroy.push(()=>i());let{title:o}=e,{loading:a}=e;s();let{base:l}=e;return n.$$set=c=>{"title"in c&&t(0,o=c.title),"loading"in c&&s(t(1,a=c.loading)),"base"in c&&t(2,l=c.base)},[o,a,l,r]}class VSt extends gn{constructor(e){super(),mn(this,e,BSt,zSt,hn,{title:0,loading:1,base:2})}}var Em,vd;class fx extends r0{constructor({base:e="lite_mobilenet_v2"}={}){super(),this.title="COCO-SSD Object Detection",this.parameters={},this.serviceName="undefined",Em.set(this,void 0),vd.set(this,void 0),this.$loading=new ct(!0,!0),Pn(this,vd,e,"f"),this.setup()}async setup(){await H2();const e=await $L(),t=Object.keys(e).filter(r=>r.includes("cocossd"));try{Pn(this,Em,await v6.load({base:ze(this,vd,"f"),modelUrl:`indexeddb://cocossd-${ze(this,vd,"f")}`}),"f")}catch{t.length>0&&await RL(t[0]),Pn(this,Em,await v6.load({base:ze(this,vd,"f")}),"f"),await ze(this,Em,"f").model.save(`indexeddb://cocossd-${ze(this,vd,"f")}`)}ba.info("COCO-SSD loaded with base `lite_mobilenet_v2`"),this.$loading.set(!1),this.start()}train(){throw new wp("Model `CocoSsd` cannot be trained")}async predict(e){if(!ze(this,Em,"f"))throw new Error("Model is not loaded");return{outputs:(await ze(this,Em,"f").detect(e)).map(i=>({bbox:i.bbox,class:i.class,confidence:i.score}))}}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new VSt({target:t,props:{title:this.title,loading:this.$loading,base:ze(this,vd,"f")}}))}save(){throw new Error("CocoSsd does not support saving")}load(){throw new Error("CocoSsd does not support loading")}download(){throw new Error("CocoSsd does not support downloading")}upload(){throw new Error("CocoSsd does not support uploading")}}Em=new WeakMap,vd=new WeakMap;On([zn],fx.prototype,"train",null);On([zn],fx.prototype,"predict",null);On([zn],fx.prototype,"save",null);On([zn],fx.prototype,"load",null);On([zn],fx.prototype,"download",null);On([zn],fx.prototype,"upload",null);function USt(n){let e,t;return{c(){e=we("div"),t=we("canvas"),Z(e,"class","w-full h-96")},m(r,i){me(r,e,i),ie(e,t),n[6](t)},p:Ze,d(r){r&&pe(e),n[6](null)}}}function WSt(n){let e,t;return e=new Ao({props:{title:n[0],$$slots:{default:[USt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&32770&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function HSt(n,e,t){let{title:r}=e,{preset:i}=e,{options:s}=e,{datasets:o}=e;cu.register(XE,BE,VE,fA,_b,kat,Nat,Rd,UE,nF,rF,ZO,KE,WE,HE,I1,YE,GE,eS,sF,zie,Vie);const a=["rgb(54, 162, 235)","rgb(255, 99, 132)","rgb(255, 206, 86)","rgb(75, 192, 192)","rgb(153, 102, 255)","rgb(255, 159, 64)"],l={data:{},options:{maintainAspectRatio:!1,animation:{duration:200},borderWidth:4}};function c(b){return{borderColor:a[b%6],backgroundColor:a[b%6],fill:!1,lineTension:.2}}function u(b,_,w){const S={labels:[]};let C=0;return S.datasets=b.map(({dataStream:k,label:A,options:M},E)=>{C=Math.max(C,k.get()?k.get().length:0),E===0&&(S.labels=M.labels||[],!M.labels&&k.get()&&k.get().length>0&&(typeof k.get()[0]=="number"?S.labels=Array.from(Array(k.get().length),(O,R)=>R.toString()):S.labels=k.get().map(O=>O.x.toString())));let N={...c(E),..._,...M,label:A,data:k.get()||[]};return(["bar","bar-fast"].includes(M.type)||["bar","bar-fast"].includes(w.type)&&!M.type)&&b.length===1&&(N.borderColor=a,N.backgroundColor=a),N}),S}let h,f=[],d;function p(){let b=wl(l,i.global);b=wl(b,{data:u(o,i.datasets,b),options:s}),s.xlabel&&(b=wl(b,{options:{scales:{x:{title:{display:!0,text:s.xlabel}}}}})),s.ylabel&&(b=wl(b,{options:{scales:{y:{title:{display:!0,text:s.ylabel}}}}}));const _=o.map(({dataStream:S})=>{var C;return((C=S.get())===null||C===void 0?void 0:C.length)||0});f=o.map(({dataStream:S,options:C},k)=>S.subscribe(A=>{if(A&&h){const M=_.reduce((E,N)=>Math.max(E,N));_[k]=A.length,!C.labels&&A.length>0&&_[k]>M&&(typeof A[0]=="number"?b.data.labels=Array.from(Array(A.length),(E,N)=>N.toString()):b.data.labels=A.map(E=>E.x.toString())),b.data.datasets[k].data=A;try{h.update()}catch(E){console.log(E)}}}));const w=d.getContext("2d");h=new cu(w,b)}function m(){for(const b of f)b();h==null||h.destroy()}$h(async()=>{await Za(),await Za(),p()});let g=o.length;Ng(m);function y(b){Li[b?"unshift":"push"](()=>{d=b,t(1,d)})}return n.$$set=b=>{"title"in b&&t(0,r=b.title),"preset"in b&&t(2,i=b.preset),"options"in b&&t(3,s=b.options),"datasets"in b&&t(4,o=b.datasets)},n.$$.update=()=>{n.$$.dirty&48&&o.length!==g&&(m(),p(),t(5,g=o.length))},[r,d,i,s,o,g,y]}class GSt extends gn{constructor(e){super(),mn(this,e,HSt,WSt,hn,{title:0,preset:2,options:3,datasets:4})}}var lI,cI,fl;const M9={line:{global:{type:"line",options:{animation:{duration:200},scales:{x:{ticks:{sampleSize:11}}}}},datasets:{fill:!1,lineTension:.2}},"line-fast":{global:{type:"line",options:{elements:{point:{radius:0}},animation:!1,tooltips:!1,spanGaps:!0,scales:{x:{ticks:{sampleSize:11}}}}},datasets:{fill:!1,lineTension:0}},bar:{global:{type:"bar",options:{animation:{duration:200},scales:{y:{beginAtZero:!0}}}}},"bar-fast":{global:{type:"bar",options:{animation:!1,scales:{y:{beginAtZero:!0}}}}},scatter:{global:{type:"scatter",options:{scales:{x:{type:"linear",position:"bottom"}}}}}};class jSt extends ia{constructor({preset:e="line",options:t={}}={}){super(),this.title="generic chart",lI.set(this,void 0),cI.set(this,void 0),fl.set(this,[]),Object.keys(M9).includes(e)||Co(new Error(`Preset ${e} is not recognized`)),Pn(this,lI,e,"f"),Pn(this,cI,M9[e],"f"),this.options=t,this.start()}addSeries(e,t,r={}){if(FV(e)){if(ze(this,lI,"f")==="line-fast"){const i=e.debounce(10);i.value=e.get(),ze(this,fl,"f").push({dataStream:i,label:t,options:r})}else ze(this,fl,"f").push({dataStream:e,label:t,options:r});this.updateView()}else e.toArray().then(i=>{const s=new ct(i,!0);ze(this,fl,"f").push({dataStream:s,label:t,options:r}),this.updateView()})}setColors(e){ze(this,fl,"f")[0].label="clusters",ze(this,fl,"f")[0].options.backgroundColor=e.get(),ze(this,fl,"f")[0].options.color=e.get()}removeSeries(e){const t=ze(this,fl,"f").map(r=>r.dataStream).indexOf(e);t>-1&&ze(this,fl,"f").splice(t,1)}clear(){Pn(this,fl,[],"f"),this.updateView()}updateView(){this.$$.app&&this.$$.app.$set({datasets:ze(this,fl,"f")})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new GSt({target:t,props:{title:this.title,preset:ze(this,cI,"f"),options:this.options,datasets:ze(this,fl,"f")}}))}}lI=new WeakMap,cI=new WeakMap,fl=new WeakMap;function zce(...n){return new jSt(...n)}function N9(n){let e,t;return{c(){e=new Ywt(!1),t=po(),e.a=t},m(r,i){e.m(n[2],r,i),me(r,t,i)},p(r,i){i&4&&e.p(r[2])},d(r){r&&pe(t),r&&e.d()}}}function qSt(n){let e,t=n[2]&&N9(n);return{c(){e=we("div"),t&&t.c(),Z(e,"class","grow")},m(r,i){me(r,e,i),t&&t.m(e,null)},p(r,i){r[2]?t?t.p(r,i):(t=N9(r),t.c(),t.m(e,null)):t&&(t.d(1),t=null)},d(r){r&&pe(e),t&&t.d()}}}function XSt(n){let e,t;return e=new Ao({props:{title:n[0],$$slots:{default:[qSt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&12&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function KSt(n,e,t){let r,i=Ze,s=()=>(i(),i=vr(a,l=>t(2,r=l)),a);n.$$.on_destroy.push(()=>i());let{title:o}=e,{text:a}=e;return s(),n.$$set=l=>{"title"in l&&t(0,o=l.title),"text"in l&&s(t(1,a=l.text))},[o,a,r]}class YSt extends gn{constructor(e){super(),mn(this,e,KSt,XSt,hn,{title:0,text:1})}get title(){return this.$$.ctx[0]}set title(e){this.$$set({title:e}),LS()}get text(){return this.$$.ctx[1]}set text(e){this.$$set({text:e}),LS()}}class ZSt extends ia{constructor(e="click me"){super(),this.title="text",this.$value=new ct(e,!0),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new YSt({target:t,props:{title:this.title,text:this.$value}}))}}function JSt(...n){return new ZSt(...n)}var pf,th;class QSt extends ia{constructor(e){super(),this.title="confidence plot",pf.set(this,void 0),th.set(this,void 0),this.$confidenceStream=e.map(({confidences:t})=>Object.entries(t).map(([r,i])=>({x:r,y:i})).sort((r,i)=>r.x<i.x?-1:r.x>i.x?1:0)),Pn(this,pf,zce({preset:"bar-fast",options:{xlabel:"Label",ylabel:"Confidence",scales:{y:{suggestedMax:1}}}}),"f"),ze(this,pf,"f").addSeries(this.$confidenceStream,"Confidences"),ze(this,pf,"f").title="",Pn(this,th,JSt("Waiting for predictions..."),"f"),ze(this,th,"f").title=this.title,ze(this,th,"f").$value=new ct(e.map(({label:t})=>`<p>Predicted Label: <code style="font-size: 1.5rem;">${t}</code></p>`).startWith("Waiting for predictions..."),!0),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);if(!t)return;const r=document.createElement("div");r.id=`${t.id}-${ze(this,th,"f").id}`;const i=document.createElement("div");i.id=`${t.id}-${ze(this,pf,"f").id}`,t.appendChild(r),t.appendChild(i),ze(this,th,"f").title=this.title,ze(this,th,"f").mount(r),ze(this,pf,"f").mount(i),this.destroy=()=>{r.parentElement.removeChild(r),i.parentElement.removeChild(i),ze(this,th,"f").destroy(),ze(this,pf,"f").destroy()}}destroy(){ze(this,th,"f").destroy(),ze(this,pf,"f").destroy()}}pf=new WeakMap,th=new WeakMap;function e2t(...n){return new QSt(...n)}function t2t(n){let e;return{c(){e=we("p"),e.textContent="Waiting for predictions...",Z(e,"class","m-2")},m(t,r){me(t,e,r)},p:Ze,d(t){t&&pe(e)}}}function n2t(n){let e,t,r=n[6].toFixed(2)+"",i,s,o,a,l,c;return{c(){e=we("p"),t=qe("Global Accuracy: "),i=qe(r),s=tt(),o=we("div"),a=we("canvas"),Z(e,"class","m-2"),Z(o,"class","confusion-container svelte-1d2i0ke")},m(u,h){me(u,e,h),ie(e,t),ie(e,i),me(u,s,h),me(u,o,h),ie(o,a),l||(c=Bwt(n[7].call(null,a)),l=!0)},p(u,h){h&64&&r!==(r=u[6].toFixed(2)+"")&&cn(i,r)},d(u){u&&pe(e),u&&pe(s),u&&pe(o),l=!1,c()}}}function r2t(n){let e;function t(s,o){return s[6]!==void 0?n2t:t2t}let r=t(n),i=r(n);return{c(){i.c(),e=po()},m(s,o){i.m(s,o),me(s,e,o)},p(s,o){r===(r=t(s))&&i?i.p(s,o):(i.d(1),i=r(s),i&&(i.c(),i.m(e.parentNode,e)))},d(s){i.d(s),s&&pe(e)}}}function i2t(n){let e,t;return e=new Ao({props:{title:n[0],loading:n[4],progress:n[5],$$slots:{default:[r2t]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&16&&(s.loading=r[4]),i&32&&(s.progress=r[5]),i&131136&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function s2t(n,e,t){let r,i=Ze,s=()=>(i(),i=vr(d,E=>t(4,r=E)),d),o,a=Ze,l=()=>(a(),a=vr(p,E=>t(5,o=E)),p),c,u=Ze,h=()=>(u(),u=vr(m,E=>t(6,c=E)),m);n.$$.on_destroy.push(()=>i()),n.$$.on_destroy.push(()=>a()),n.$$.on_destroy.push(()=>u());let{title:f}=e,{loading:d}=e;s();let{progress:p}=e;l();let{accuracy:m}=e;h();let{confusion:g}=e,{labels:y}=e,{selected:b}=e;cu.register(fA,zie,Vie,fF,N1);let _=1,w=1,S=-1;const C={type:"matrix",data:{datasets:[{label:"Confusion Matrix",data:[],backgroundColor(E){if(E.dataset.data.length>0){if(E.dataIndex===S){const{x:O,y:R}=E.dataset.data[E.dataIndex];return O===R?"green":"red"}return`rgba(54, 162, 235, ${E.dataset.data[E.dataIndex].v/_})`}return"rgba(54, 162, 235, 0)"},width(E){const N=E.chart.chartArea;return N?(N.right-N.left)/w-2:0},height(E){const N=E.chart.chartArea;return N?(N.bottom-N.top)/w-2:0}}]},options:{aspectRatio:1,legend:{display:!1},plugins:{tooltip:{callbacks:{title([E]){return["count: "+E.dataset.data[E.dataIndex].v]},label(E){const N=E.dataset.data[E.dataIndex];return["true label: "+N.y,"predicted label: "+N.x]}}}},scales:{x:{type:"category",labels:[],ticks:{display:!0,autoSkip:!1},gridLines:{display:!1},title:{display:!0,text:"Predicted Label"}},y:{type:"category",labels:[],offset:!0,reverse:!0,ticks:{display:!0,autoSkip:!1},gridLines:{display:!1},title:{display:!0,text:"True Label"}}},onClick(E){try{const N=E.chart.tooltip.dataPoints[0].dataIndex;S===N?(b.set(null),S=-1):(b.set(E.chart.tooltip.dataPoints[0].raw),S=N,E.chart.update())}catch(N){console.log("[confusion matrix] selection error:",N)}}}};let k,A=[];function M(E){const N=E.getContext("2d");k=new cu(N,C),A.push(y.subscribe(O=>{w=O.length,C.options.scales.x.labels=O.sort(),C.options.scales.y.labels=O.sort(),k.update()})),A.push(g.subscribe(O=>{_=O.reduce((R,{v:D})=>Math.max(R,D),0),C.data.datasets[0].data=O,k.update()}))}return Ng(()=>{for(const E of A)E()}),n.$$set=E=>{"title"in E&&t(0,f=E.title),"loading"in E&&s(t(1,d=E.loading)),"progress"in E&&l(t(2,p=E.progress)),"accuracy"in E&&h(t(3,m=E.accuracy)),"confusion"in E&&t(8,g=E.confusion),"labels"in E&&t(9,y=E.labels),"selected"in E&&t(10,b=E.selected)},[f,d,p,m,r,o,c,M,g,y,b]}class o2t extends gn{constructor(e){super(),mn(this,e,s2t,i2t,hn,{title:0,loading:1,progress:2,accuracy:3,confusion:8,labels:9,selected:10})}}var bb;class a2t extends ia{constructor(e){super(),this.title="confusion matrix",bb.set(this,void 0),this.$confusion=new ct([],!0),this.$accuracy=new ct(void 0,!0),this.$labels=new ct([],!0),this.$selected=new ct(null,!0),this.$progress=new ct(!1,!0),Pn(this,bb,e,"f"),this.start(),this.setup()}setup(){let e=[];ze(this,bb,"f").$status.subscribe(async({status:t,count:r,total:i,data:s})=>{t==="start"?(e=[],this.$progress.set(null)):t==="running"?(e.push(s),this.$progress.set(r/i)):t==="loaded"?(e=await ze(this,bb,"f").predictionService.items().query({$select:["id","label","yTrue"]}).toArray(),this.$progress.set(!1)):t==="loading"?(e=[],this.$progress.set(null)):this.$progress.set(!1),this.updateConfusionMatrix(e),this.updateAccuracy(e)})}updateConfusionMatrix(e){const t=e.map(c=>c.label),r=e.map(c=>c.yTrue),i=Array.from(new Set(t.concat(r)));r_(i,this.$labels.value)||this.$labels.set(i);const s=i.length,o=i.reduce((c,u,h)=>({...c,[u]:h}),{}),a=Array.from(Array(s**2),()=>0);for(let c=0;c<t.length;c+=1)a[o[t[c]]*s+o[r[c]]]+=1;const l=a.map((c,u)=>({x:i[Math.floor(u/s)],y:i[u%s],v:c}));this.$confusion.set(l)}updateAccuracy(e){e.length===0?this.$accuracy.set(void 0):this.$accuracy.set(e.reduce((t,{label:r,yTrue:i})=>t+(r===i?1:0),0)/e.length)}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new o2t({target:t,props:{title:this.title,loading:ze(this,bb,"f").$status.map(({status:r})=>r==="loading"),progress:this.$progress,confusion:this.$confusion,accuracy:this.$accuracy,labels:this.$labels,selected:this.$selected}}))}}bb=new WeakMap;function l2t(...n){return new a2t(...n)}const{window:$9}=Uwt;function R9(n,e,t){const r=n.slice();return r[27]=e[t][0],r[28]=e[t][1].loaded,r[29]=e[t][1].total,r[30]=e[t][1].instances,r}function P9(n,e,t){const r=n.slice();return r[33]=e[t].id,r[34]=e[t].thumbnail,r}function D9(n){let e,t,r,i,s;function o(f,d){return f[6]>0?u2t:c2t}let a=o(n),l=a(n),c=Object.entries(n[5]),u=[];for(let f=0;f<c.length;f+=1)u[f]=L9(R9(n,c,f));const h=f=>$e(u[f],1,1,()=>{u[f]=null});return{c(){l.c(),e=tt(),t=we("div");for(let f=0;f<u.length;f+=1)u[f].c();Z(t,"class","flex flex-wrap")},m(f,d){l.m(f,d),me(f,e,d),me(f,t,d);for(let p=0;p<u.length;p+=1)u[p]&&u[p].m(t,null);r=!0,i||(s=[Yn(t,"click",n[18]),Yn(t,"keypress",jC(n[19]))],i=!0)},p(f,d){if(a===(a=o(f))&&l?l.p(f,d):(l.d(1),l=a(f),l&&(l.c(),l.m(e.parentNode,e))),d[0]&6560){c=Object.entries(f[5]);let p;for(p=0;p<c.length;p+=1){const m=R9(f,c,p);u[p]?(u[p].p(m,d),ke(u[p],1)):(u[p]=L9(m),u[p].c(),ke(u[p],1),u[p].m(t,null))}for(sr(),p=c.length;p<u.length;p+=1)h(p);or()}},i(f){if(!r){for(let d=0;d<c.length;d+=1)ke(u[d]);r=!0}},o(f){u=u.filter(Boolean);for(let d=0;d<u.length;d+=1)$e(u[d]);r=!1},d(f){l.d(f),f&&pe(e),f&&pe(t),os(u,f),i=!1,Io(s)}}}function c2t(n){let e;return{c(){e=we("p"),e.textContent="This dataset is empty.",Z(e,"class","ml-3 mt-2")},m(t,r){me(t,e,r)},p:Ze,d(t){t&&pe(e)}}}function u2t(n){let e,t,r,i,s=n[6]>1?"s":"",o,a;return{c(){e=we("p"),t=qe("This dataset contains "),r=qe(n[6]),i=qe(" instance"),o=qe(s),a=qe("."),Z(e,"class","ml-3 mt-2")},m(l,c){me(l,e,c),ie(e,t),ie(e,r),ie(e,i),ie(e,o),ie(e,a)},p(l,c){c[0]&64&&cn(r,l[6]),c[0]&64&&s!==(s=l[6]>1?"s":"")&&cn(o,s)},d(l){l&&pe(e)}}}function O9(n,e){let t,r,i,s,o,a,l;function c(){return e[16](e[33])}return{key:n,first:null,c(){t=we("img"),aM(t.src,r=e[34])||Z(t,"src",r),Z(t,"alt","thumbnail"),Z(t,"class","m-1 svelte-14ms951"),Wt(t,"selected",e[7].includes(e[33])),this.first=t},m(u,h){me(u,t,h),o=!0,a||(l=Yn(t,"click",Gwt(c)),a=!0)},p(u,h){e=u,(!o||h[0]&32&&!aM(t.src,r=e[34]))&&Z(t,"src",r),(!o||h[0]&160)&&Wt(t,"selected",e[7].includes(e[33]))},i(u){o||(Rc(()=>{o&&(s&&s.end(1),i=sxt(t,Dq,{}),i.start())}),o=!0)},o(u){i&&i.invalidate(),s=oxt(t,Dq,{}),o=!1},d(u){u&&pe(t),u&&s&&s.end(),a=!1,l()}}}function F9(n){let e,t;function r(){return n[17](n[27])}return e=new zi({props:{size:"small",variant:"light",$$slots:{default:[h2t]},$$scope:{ctx:n}}}),e.$on("click",r),{c(){Ct(e.$$.fragment)},m(i,s){xt(e,i,s),t=!0},p(i,s){n=i;const o={};s[1]&64&&(o.$$scope={dirty:s,ctx:n}),e.$set(o)},i(i){t||(ke(e.$$.fragment,i),t=!0)},o(i){$e(e.$$.fragment,i),t=!1},d(i){_t(e,i)}}}function h2t(n){let e;return{c(){e=qe("View More")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function L9(n){let e,t,r,i,s=n[27]+"",o,a,l,c,u,h=[],f=new Map,d,p,m,g;function y(...S){return n[15](n[27],...S)}l=new $xt({props:{actions:[{code:"edit",text:"Edit class label"},{code:"delete",text:"Delete class"}].concat(n[7].length>0?[{code:"deleteInstances",text:`Delete selected instance${n[7].length>1?"s":""}`},{code:"relabelInstances",text:`Relabel selected instance${n[7].length>1?"s":""}`}]:[])}}),l.$on("select",y);let b=n[30];const _=S=>S[33];for(let S=0;S<b.length;S+=1){let C=P9(n,b,S),k=_(C);f.set(k,h[S]=O9(k,C))}let w=n[28]<n[29]&&F9(n);return{c(){e=we("div"),t=we("div"),r=we("div"),i=we("span"),o=qe(s),a=tt(),Ct(l.$$.fragment),c=tt(),u=we("div");for(let S=0;S<h.length;S+=1)h[S].c();d=tt(),p=we("div"),w&&w.c(),m=tt(),Z(i,"class","browser-class-title svelte-14ms951"),Z(r,"class","browser-class-header svelte-14ms951"),Z(u,"class","browser-class-body svelte-14ms951"),Z(t,"class","w-full"),Z(p,"class","pb-1"),Z(e,"class","browser-class svelte-14ms951")},m(S,C){me(S,e,C),ie(e,t),ie(t,r),ie(r,i),ie(i,o),ie(r,a),xt(l,r,null),ie(t,c),ie(t,u);for(let k=0;k<h.length;k+=1)h[k]&&h[k].m(u,null);ie(e,d),ie(e,p),w&&w.m(p,null),ie(e,m),g=!0},p(S,C){n=S,(!g||C[0]&32)&&s!==(s=n[27]+"")&&cn(o,s);const k={};C[0]&128&&(k.actions=[{code:"edit",text:"Edit class label"},{code:"delete",text:"Delete class"}].concat(n[7].length>0?[{code:"deleteInstances",text:`Delete selected instance${n[7].length>1?"s":""}`},{code:"relabelInstances",text:`Relabel selected instance${n[7].length>1?"s":""}`}]:[])),l.$set(k),C[0]&2208&&(b=n[30],sr(),h=cce(h,C,_,1,n,b,f,u,lce,O9,null,P9),or()),n[28]<n[29]?w?(w.p(n,C),C[0]&32&&ke(w,1)):(w=F9(n),w.c(),ke(w,1),w.m(p,null)):w&&(sr(),$e(w,1,1,()=>{w=null}),or())},i(S){if(!g){ke(l.$$.fragment,S);for(let C=0;C<b.length;C+=1)ke(h[C]);ke(w),g=!0}},o(S){$e(l.$$.fragment,S);for(let C=0;C<h.length;C+=1)$e(h[C]);$e(w),g=!1},d(S){S&&pe(e),_t(l);for(let C=0;C<h.length;C+=1)h[C].d();w&&w.d()}}}function z9(n){let e;return{c(){e=we("div"),e.innerHTML=`<svg class="inline flex-shrink-0 mr-3 w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg> 
      <div><span class="font-medium">Data Store connection Error!</span> This data store probably requires
        authentication</div>`,Z(e,"class","flex p-4 mb-4 text-sm text-red-700 bg-red-100 rounded-lg dark:bg-red-200 dark:text-red-800"),Z(e,"role","alert")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function f2t(n){let e,t,r,i=n[5]&&!n[4]&&D9(n),s=n[4]&&z9();return{c(){i&&i.c(),e=tt(),s&&s.c(),t=po()},m(o,a){i&&i.m(o,a),me(o,e,a),s&&s.m(o,a),me(o,t,a),r=!0},p(o,a){o[5]&&!o[4]?i?(i.p(o,a),a[0]&48&&ke(i,1)):(i=D9(o),i.c(),ke(i,1),i.m(e.parentNode,e)):i&&(sr(),$e(i,1,1,()=>{i=null}),or()),o[4]?s||(s=z9(),s.c(),s.m(t.parentNode,t)):s&&(s.d(1),s=null)},i(o){r||(ke(i),r=!0)},o(o){$e(i),r=!1},d(o){i&&i.d(o),o&&pe(e),s&&s.d(o),o&&pe(t)}}}function d2t(n){let e,t,r,i;return e=new Ao({props:{title:n[0],loading:n[3],$$slots:{default:[f2t]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(s,o){xt(e,s,o),t=!0,r||(i=[Yn($9,"keydown",n[9]),Yn($9,"keyup",n[10])],r=!0)},p(s,o){const a={};o[0]&1&&(a.title=s[0]),o[0]&8&&(a.loading=s[3]),o[0]&240|o[1]&64&&(a.$$scope={dirty:o,ctx:s}),e.$set(a)},i(s){t||(ke(e.$$.fragment,s),t=!0)},o(s){$e(e.$$.fragment,s),t=!1},d(s){_t(e,s),r=!1,Io(i)}}}function p2t(n,e,t){let r,i=Ze,s=()=>(i(),i=vr(h,H=>t(6,r=H)),h),o,a=Ze,l=()=>(a(),a=vr(d,H=>t(7,o=H)),d);n.$$.on_destroy.push(()=>i()),n.$$.on_destroy.push(()=>a());let{title:c}=e,{batchSize:u}=e,{count:h}=e;s();let{dataset:f}=e,{selected:d}=e;l();let p=!1,m=!1,g={};async function y(H){await f.ready;for await(const te of f.items().query({y:H,$sort:{updatedAt:-1}}).skip(g[H].loaded).take(u).select(["id","y","thumbnail"]))t(5,g[H].instances=[...g[H].instances,te],g),t(5,g[H].loaded+=1,g)}async function b(){if(p)return;t(3,p=!0);try{t(4,m=!1),await f.ready}catch{t(3,p=!1),t(4,m=!0);return}const H=await f.distinct("y");t(5,g=H.reduce((te,ge)=>({...te,[ge]:{total:0,loaded:0,instances:[]}}),{}));for(const te of H){const{total:ge}=await f.find({query:{$limit:0,y:te}});if(t(5,g[te].total=ge,g),u>0)await y(te);else for(;g[te].loaded<g[te].total;)await y(te)}t(3,p=!1)}function _(H){for(const[te,{instances:ge}]of Object.entries(g))if(ge.map(ae=>ae.id).includes(H))return te;return null}async function w(){let H=Promise.resolve();for(const te of d.get())H=H.then(()=>f.remove(te));await H,d.set([])}async function S(H){let te=Promise.resolve();for(const ge of d.get())te=te.then(()=>f.patch(ge,{y:H}));await te,d.set([])}let C=!1,k=!1;function A(H){["Meta","Control"].includes(H.key)?C=!0:H.key==="Shift"?k=!0:(H.key==="Delete"||H.key==="Backspace"&&C)&&w()}function M(H){["Meta","Control"].includes(H.key)?C=!1:H.key==="Shift"&&(k=!1)}let E=null;function N(H){if(C){if(!H)return;d.get().includes(H)?d.set(d.get().filter(te=>te!==H)):d.set(d.get().concat([H]))}else if(k){if(!E||!H)return;const te=_(E),ge=_(H);if(te!==ge)return;const ae=g[te].instances.map(De=>De.id),Ne=ae.indexOf(E),Te=ae.indexOf(H);d.set(Ne<Te?ae.slice(Ne,Te+1):ae.slice(Te,Ne+1))}else d.set(H?[H]:[]),E=H}function O(H,te){let ge;switch(te){case"edit":ge=window.prompt("Enter the new label",H),ge&&f.patch(null,{y:ge},{query:{y:H}});break;case"delete":f.remove(null,{query:{y:H}});break;case"deleteInstances":w();break;case"relabelInstances":ge=window.prompt("Enter the new label",H),ge&&S(ge);break;default:alert(`Class ${H}: ${te}`);break}}$h(()=>{b(),f.$changes.subscribe(async H=>{for(const{level:te,type:ge,data:ae}of H)if(te==="dataset")ge==="created"&&(N(),b());else if(te==="instance")if(ge==="created")g[ae.y]||t(5,g[ae.y]={total:0,loaded:0,instances:[]},g),t(5,g[ae.y].total+=1,g),t(5,g[ae.y].loaded+=1,g),t(5,g[ae.y].instances=[{id:ae.id,y:ae.y,thumbnail:ae.thumbnail},...g[ae.y].instances],g);else if(ge==="updated"){const Ne=_(ae.id);t(5,g[Ne].total-=1,g),t(5,g[Ne].loaded-=1,g),t(5,g[Ne].instances=g[Ne].instances.filter(({id:Te})=>Te!==ae.id),g),g[Ne].total===0&&(delete g[Ne],t(5,g)),g[ae.y]||t(5,g[ae.y]={total:0,loaded:0,instances:[]},g),t(5,g[ae.y].instances=[{id:ae.id,y:ae.y,thumbnail:ae.thumbnail},...g[ae.y].instances],g)}else ge==="removed"&&(t(5,g[ae.y].total-=1,g),t(5,g[ae.y].loaded-=1,g),t(5,g[ae.y].instances=g[ae.y].instances.filter(({id:Ne})=>Ne!==ae.id),g),g[ae.y].total===0&&(delete g[ae.y],t(5,g)))})});const R=(H,te)=>O(H,te.detail),D=H=>N(H),z=H=>y(H),B=()=>N(),X=H=>H.key==="Escape"&&N();return n.$$set=H=>{"title"in H&&t(0,c=H.title),"batchSize"in H&&t(13,u=H.batchSize),"count"in H&&s(t(1,h=H.count)),"dataset"in H&&t(14,f=H.dataset),"selected"in H&&l(t(2,d=H.selected))},[c,h,d,p,m,g,r,o,y,A,M,N,O,u,f,R,D,z,B,X]}class m2t extends gn{constructor(e){super(),mn(this,e,p2t,d2t,hn,{title:0,batchSize:13,count:1,dataset:14,selected:2},null,[-1,-1])}}var W1;class g2t extends ia{constructor(e,{batchSize:t=6}={}){super(),this.title="dataset browser",W1.set(this,void 0),this.$selected=new ct([],!0),Pn(this,W1,e,"f"),this.batchSize=t,this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new m2t({target:t,props:{title:this.title,batchSize:this.batchSize,count:ze(this,W1,"f").$count,dataset:ze(this,W1,"f"),selected:this.$selected}}))}}W1=new WeakMap;function y2t(...n){return new g2t(...n)}function b2t(n,e){return n.map((t,r)=>Math.abs(t-e[r])**2).reduce((t,r)=>t+r)**(1/2)}class GV extends r0{constructor({k:e=3}={}){super(),this.title="k-means clustering",this.serviceName="kmeans-models",this.parameters={k:new ct(e,!0)},this.$centers=new ct([],!1),this.$clusters=new ct([],!1),this.dataset=[],this.start()}async train(e){this.$training.set({status:"start",epochs:1});const t=zf(e)?e.items():e;for await(const{x:i}of t)this.dataset.push(i);const r=pht(this.dataset,this.parameters.k.get());this.$centers.set(r.centroids.map(i=>i.centroid)),this.$clusters.set(r.clusters),this.$training.set({status:"success"})}async predict(e){let t=0,r=1e3;const i={};let s=0;for(let o=0;o<this.$centers.get().length;o++){const a=b2t(this.$centers.get()[o],e);a<r&&(r=a,t=o),i[`${o}`]=Math.exp(a),s+=Math.exp(a)}if(Object.entries(i).forEach(([o])=>{i[o]/=s}),this.$centers.get().length===0){const o=new Error("KMeans is not trained");o.name="[KMeans] Prediction Error",Co(o)}return{cluster:t,confidences:i}}async batchPredict(e){const t=[],r=zf(e)?e.items():e;for await(const{x:s}of r)t.push(s);const i=[];for(let s=0;s<t.length;s++)this.predict(t[s]).then(o=>i.push(o));if(this.$centers.get().length===0){const s=new Error("KMeans is not trained");s.name="[KMeans] Prediction Error",Co(s)}return i}async save(e,t,r,i=null){const s=await this.write(r);return s.name=t,this.saveToDatastore(e,s,i)}async load(e,t){const r=await this.loadFromDatastore(e,t);return await this.read(r),r}async download(e){const t=await this.write(e);zS(JSON.stringify(t),`${t.name}.json`,"text/plain")}async upload(...e){const t=e.filter(i=>i.name.includes(".json")),r=await new Promise((i,s)=>{const o=new FileReader;o.onload=()=>{const a=JSON.parse(o.result);i(a)},o.onerror=s,o.readAsText(t[0])});return await this.read(r),r}async write(e={}){return{name:qC(this.title),files:[],format:"ml-kmeans",metadata:{clusters:this.$clusters.get(),centers:this.$centers.get(),...e}}}async read(e){const t=e.metadata.data;t&&(Object.entries(t).forEach(([r,i])=>{}),this.$clusters.set(e.metadata.labels),this.$training.set({status:"loaded"}))}}On([zn],GV.prototype,"train",null);On([zn],GV.prototype,"predict",null);On([zn],GV.prototype,"batchPredict",null);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.flatten=function(){return this.throwIfDisposed(),hx(this,[this.size])};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v2t(n){const e=Ns(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return wi.runKernel(P_t,t)}else{const t={x:e};return wi.runKernel(M_t,t)}}const bd=sa({abs_:v2t});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w2t(n,e){const t=Ns(n,"x","cast");if(!b_t(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},i={dtype:e};return wi.runKernel(Ace,r,i)}const Bce=sa({cast_:w2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x2t(n,e,t=!1,r=!1){let i=Ns(n,"a","matMul"),s=Ns(e,"b","matMul");[i,s]=WV(i,s);const o={a:i,b:s},a={transposeA:t,transposeB:r};return wi.runKernel(R_t,o,a)}const _2t=sa({matMul_:x2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S2t(n,e){let t=Ns(n,"a","mul"),r=Ns(e,"b","mul");[t,r]=WV(t,r);const i={a:t,b:r};return wi.runKernel(B_t,i)}const C2t=sa({mul_:S2t});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k2t(n,e,t){const r=n.length+e.length,i=[];let s=0,o=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?i.push(n[s++]):i.push(e[o++]);return i}function T2t(n,e){const t=e.map(r=>1);return k2t(n,t,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E2t(n,e=null,t=!1){const i={x:Ns(n,"x","max")},s={reductionIndices:e,keepDims:t};return wi.runKernel(L_t,i,s)}const JP=sa({max_:E2t});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I2t(n,e=null,t=!1){const i={x:Ns(n,"x","min")},s={axis:e,keepDims:t};return wi.runKernel(z_t,i,s)}const B9=sa({min_:I2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A2t(n,e){let t=Ns(n,"base","pow"),r=Ns(e,"exp","pow");[t,r]=WV(t,r);const i={a:t,b:r};return wi.runKernel(V_t,i)}const M2t=sa({pow_:A2t});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N2t(n,e,t,r){if(r==null)r=BV(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Pce(n)||Rce(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return wi.backend.createTensorFromGPUData(n,e||t,r)}if(!Pu(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){S_t(e);const i=Bb(e),s=Bb(t);zs(i===s,()=>`Based on the provided shape, [${e}], the tensor should have ${i} values but has ${s}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Bb(e.slice(o)):!0;zs(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Pu(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?Nce(n,r):BS(n,[],!0),wi.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $2t(n,e){if((Pu(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Pu(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return N2t(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R2t(n){const t={x:Ns(n,"x","sqrt","float32")};return wi.runKernel(W_t,t)}const V9=sa({sqrt_:R2t});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P2t(n){const e=Ns(n,"x","square"),t={};return wi.runKernel("Square",{x:e},t)}const D2t=sa({square_:P2t});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O2t(n,e=null,t=!1){let r=Ns(n,"x","sum");r.dtype==="bool"&&(r=Bce(r,"int32"));const i={x:r},s={axis:e,keepDims:t};return wi.runKernel(H_t,i,s)}const cb=sa({sum_:O2t});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F2t(n,e="euclidean",t=null,r=!1){n=Ns(n,"x","norm");const i=Vce(n,e,t);let s=i.shape;if(r){const o=Sce(t,n.shape);s=T2t(i.shape,o)}return hx(i,s)}function Vce(n,e,t=null){if(n.rank===0)return bd(n);if(n.rank!==1&&t===null)return Vce(hx(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return cb(bd(n),t);if(e===1/0)return JP(bd(n),t);if(e===-1/0)return B9(bd(n),t);if(e==="euclidean"||e===2)return V9(cb(M2t(bd(n),$2t(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return JP(cb(bd(n),t[0]),t[1]-1);if(e===1/0)return JP(cb(bd(n),t[1]),t[0]);if(e===-1/0)return B9(cb(bd(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return V9(cb(D2t(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const L2t=sa({norm_:F2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.norm=function(n,e,t){return this.throwIfDisposed(),L2t(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),_2t(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.as1D=function(){return this.throwIfDisposed(),hx(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.as2D=function(n,e){return this.throwIfDisposed(),hx(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.asType=function(n){return this.throwIfDisposed(),Bce(this,n)};class Uce extends r0{constructor({k:e=3}={}){super(),this.title="KNN classifier",this.serviceName="knn-classifier-models",this.classifier=new vht,this.parameters={k:new ct(e,!0)}}async train(e){this.labels=zf(e)?await e.distinct("y"):this.labels=Array.from(new Set(await e.map(({y:r})=>r).toArray()));const t=zf(e)?e.items():e;if(this.labels.length<1)throw this.$training.set({status:"error"}),new Error("Cannot train a kNN with no classes");this.$training.set({status:"start",epochs:1}),this.classifier.clearAllClasses();for await(const{x:r,y:i}of t)this.classifier.addExample(Ts(r),i);this.$training.set({status:"success"})}async predict(e){if(!this.classifier||!this.labels||this.labels.length<1)return{label:void 0,confidences:{}};const{label:t,confidences:r}=await this.classifier.predictClass(Ts(e),this.parameters.k.get());return{label:t,confidences:r}}clear(){delete this.classifier}async save(e,t,r,i=null){const s=await this.write(r);return s.name=t,this.saveToDatastore(e,s,i)}async load(e,t){const r=await this.loadFromDatastore(e,t);return await this.read(r),r}async download(e){const t=await this.write(e);zS(JSON.stringify(t),`${t.name}.json`,"text/plain")}async upload(...e){const t=e.filter(i=>i.name.includes(".json")),r=await new Promise((i,s)=>{const o=new FileReader;o.onload=()=>{const a=JSON.parse(o.result);i(a)},o.onerror=s,o.readAsText(t[0])});return await this.read(r),r}async write(e={}){if(!this.classifier)return null;const t=this.classifier.getClassifierDataset(),r={};for(const s of Object.keys(t)){const o=t[s].arraySync();r[s]=o}return{name:qC(this.title),files:[],format:"knn-classifier",metadata:{labels:this.labels,data:r,...e}}}async read(e){const t=e.metadata.data;if(!t)return;const r={};for(const[i,s]of Object.entries(t))r[i]=ja(s);this.labels=e.metadata.labels,this.classifier.setClassifierDataset(r),this.$training.set({status:"loaded"})}}On([zn],Uce.prototype,"train",null);On([zn],Uce.prototype,"predict",null);class z2t extends Lce{constructor({layers:e=[64,32],...t}={}){super(t),this.title="MLPClassifier",this.parameters={layers:new ct(e,!0),...this.parameters}}buildModel(e,t){this.model=Rnt();for(const[i,s]of this.parameters.layers.get().entries()){const o={units:s,activation:"relu"};i===0&&(o.inputDim=e[0]),this.model.add(g6(o))}this.model.add(g6({units:t[0],activation:"softmax"}));const r=wd.adam();this.model.compile({optimizer:r,loss:"categoricalCrossentropy",metrics:["accuracy"]})}}function B2t(...n){return new z2t(...n)}function V2t(n){let e,t,r,i,s;return{c(){e=qe("Using Mobilenet v"),t=qe(n[2]),r=qe(" with alpha = "),i=qe(n[3]),s=qe(".")},m(o,a){me(o,e,a),me(o,t,a),me(o,r,a),me(o,i,a),me(o,s,a)},p(o,a){a&4&&cn(t,o[2]),a&8&&cn(i,o[3])},d(o){o&&pe(e),o&&pe(t),o&&pe(r),o&&pe(i),o&&pe(s)}}}function U2t(n){let e;return{c(){e=qe(" ")},m(t,r){me(t,e,r)},p:Ze,d(t){t&&pe(e)}}}function W2t(n){let e;function t(s,o){return s[4]?U2t:V2t}let r=t(n),i=r(n);return{c(){e=we("p"),i.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(s,o){me(s,e,o),i.m(e,null)},p(s,o){r===(r=t(s))&&i?i.p(s,o):(i.d(1),i=r(s),i&&(i.c(),i.m(e,null)))},d(s){s&&pe(e),i.d()}}}function H2t(n){let e,t;return e=new Ao({props:{title:n[0],loading:n[4],$$slots:{default:[W2t]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&16&&(s.loading=r[4]),i&60&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function G2t(n,e,t){let r,i=Ze,s=()=>(i(),i=vr(a,u=>t(4,r=u)),a);n.$$.on_destroy.push(()=>i());let{title:o}=e,{loading:a}=e;s();let{version:l}=e,{alpha:c}=e;return n.$$set=u=>{"title"in u&&t(0,o=u.title),"loading"in u&&s(t(1,a=u.loading)),"version"in u&&t(2,l=u.version),"alpha"in u&&t(3,c=u.alpha)},[o,a,l,c,r]}class j2t extends gn{constructor(e){super(),mn(this,e,G2t,H2t,hn,{title:0,loading:1,version:2,alpha:3})}}var mf;class dx extends r0{constructor({version:e=1,alpha:t=1}={}){if(super(),this.title="mobileNet",this.parameters={},this.serviceName="undefined",mf.set(this,void 0),this.$loading=new ct(!0,!0),![1,2].includes(e))throw new Error("Mobilenet version must be 1 or 2");if(![.25,.5,.75,1].includes(t))throw new Error("Mobilenet alpha must be 0.25 | 0.50 | 0.75 | 1.0");this.version=e,this.alpha=t,this.setup()}async setup(){await H2();const e=await $L(),t=Object.keys(e).filter(r=>r.includes("mobileNet"));try{Pn(this,mf,await bj({modelUrl:`indexeddb://mobilenet-v${this.version}-${this.alpha}`,version:this.version,alpha:this.alpha}),"f")}catch{t.length>0&&await RL(t[0]),Pn(this,mf,await bj({version:this.version,alpha:this.alpha}),"f"),await ze(this,mf,"f").model.save(`indexeddb://mobilenet-v${this.version}-${this.alpha}`)}return ba.info(`MobileNet v${this.version} loaded with alpha = ${this.alpha}`),this.$loading.set(!1),this.start(),this}async process(e){return ze(this,mf,"f")?Se(()=>ze(this,mf,"f").infer(e,!0).arraySync()[0]):[]}async predict(e){if(!ze(this,mf,"f"))throw new Error("Mobilenet is not loaded");const t=await ze(this,mf,"f").classify(e,5);return{label:t[0].className,confidences:t.reduce((r,i)=>({...r,[i.className]:i.probability}),{})}}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new j2t({target:t,props:{title:this.title,loading:this.$loading,version:this.version,alpha:this.alpha}}))}train(){throw new wp("Model `MobileNet` cannot be trained")}save(){throw new Error("MobileNet does not support saving")}load(){throw new Error("MobileNet does not support loading")}download(){throw new Error("MobileNet does not support downloading")}upload(){throw new Error("MobileNet does not support uploading")}}mf=new WeakMap;On([zn],dx.prototype,"train",null);On([zn],dx.prototype,"save",null);On([zn],dx.prototype,"load",null);On([zn],dx.prototype,"download",null);On([zn],dx.prototype,"upload",null);function q2t(...n){return new dx(...n)}function X2t(n){let e,t,r;function i(o){n[7](o)}let s={type:"text"};return n[2]!==void 0&&(s.value=n[2]),e=new uce({props:s}),Li.push(()=>Lc(e,"value",i)),{c(){Ct(e.$$.fragment)},m(o,a){xt(e,o,a),r=!0},p(o,a){const l={};!t&&a&4&&(t=!0,l.value=o[2],Fc(()=>t=!1)),e.$set(l)},i(o){r||(ke(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){_t(e,o)}}}function K2t(n){let e,t,r;function i(o){n[6](o)}let s={};return n[2]!==void 0&&(s.value=n[2]),e=new Ixt({props:s}),Li.push(()=>Lc(e,"value",i)),{c(){Ct(e.$$.fragment)},m(o,a){xt(e,o,a),r=!0},p(o,a){const l={};!t&&a&4&&(t=!0,l.value=o[2],Fc(()=>t=!1)),e.$set(l)},i(o){r||(ke(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){_t(e,o)}}}function Y2t(n){let e,t,r;function i(o){n[5](o)}let s={};return n[2]!==void 0&&(s.value=n[2]),e=new kxt({props:s}),Li.push(()=>Lc(e,"value",i)),{c(){Ct(e.$$.fragment)},m(o,a){xt(e,o,a),r=!0},p(o,a){const l={};!t&&a&4&&(t=!0,l.value=o[2],Fc(()=>t=!1)),e.$set(l)},i(o){r||(ke(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){_t(e,o)}}}function Z2t(n){let e,t,r;function i(o){n[4](o)}let s={};return n[2]!==void 0&&(s.checked=n[2]),e=new DV({props:s}),Li.push(()=>Lc(e,"checked",i)),{c(){Ct(e.$$.fragment)},m(o,a){xt(e,o,a),r=!0},p(o,a){const l={};!t&&a&4&&(t=!0,l.checked=o[2],Fc(()=>t=!1)),e.$set(l)},i(o){r||(ke(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){_t(e,o)}}}function J2t(n){let e,t,r;function i(o){n[3](o)}let s={options:n[1].options};return n[2]!==void 0&&(s.value=n[2]),e=new dce({props:s}),Li.push(()=>Lc(e,"value",i)),{c(){Ct(e.$$.fragment)},m(o,a){xt(e,o,a),r=!0},p(o,a){const l={};a&2&&(l.options=o[1].options),!t&&a&4&&(t=!0,l.value=o[2],Fc(()=>t=!1)),e.$set(l)},i(o){r||(ke(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){_t(e,o)}}}function Q2t(n){let e,t,r,i,s,o,a,l;const c=[J2t,Z2t,Y2t,K2t,X2t],u=[];function h(f,d){return d&2&&(t=null),d&3&&(r=null),d&3&&(i=null),d&3&&(s=null),t==null&&(t=!!(f[1].type==="menu"&&Array.isArray(f[1].options)&&f[1].options.length>0)),t?0:(r==null&&(r=f[1].type==="boolean"||f[1].type==="auto"&&typeof f[0].get()=="boolean"),r?1:(i==null&&(i=f[1].type==="number"||f[1].type==="auto"&&typeof f[0].get()=="number"),i?2:(s==null&&(s=!!(f[1].type==="number array"||f[1].type==="auto"&&Array.isArray(f[0].get())&&f[0].get().length&&typeof f[0].get()[0]=="number")),s?3:4)))}return o=h(n,-1),a=u[o]=c[o](n),{c(){e=we("div"),a.c(),Bs(e,"flex-grow","1")},m(f,d){me(f,e,d),u[o].m(e,null),l=!0},p(f,[d]){let p=o;o=h(f,d),o===p?u[o].p(f,d):(sr(),$e(u[p],1,1,()=>{u[p]=null}),or(),a=u[o],a?a.p(f,d):(a=u[o]=c[o](f),a.c()),ke(a,1),a.m(e,null))},i(f){l||(ke(a),l=!0)},o(f){$e(a),l=!1},d(f){f&&pe(e),u[o].d()}}}function eCt(n,e,t){let r,i=Ze,s=()=>(i(),i=vr(o,d=>t(2,r=d)),o);n.$$.on_destroy.push(()=>i());let{stream:o}=e;s();let{spec:a}=e;function l(d){r=d,o.set(r)}function c(d){r=d,o.set(r)}function u(d){r=d,o.set(r)}function h(d){r=d,o.set(r)}function f(d){r=d,o.set(r)}return n.$$set=d=>{"stream"in d&&s(t(0,o=d.stream)),"spec"in d&&t(1,a=d.spec)},[o,a,r,l,c,u,h,f]}class Wce extends gn{constructor(e){super(),mn(this,e,eCt,Q2t,hn,{stream:0,spec:1})}}function U9(n,e,t){const r=n.slice();return r[4]=e[t][0],r[5]=e[t][1],r}function tCt(n){let e,t;return e=new Wce({props:{stream:n[5],spec:{type:"auto"}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,i){const s={};i&2&&(s.stream=r[5]),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function nCt(n){let e,t;return e=new Wce({props:{stream:n[5],spec:n[2][n[4]]}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,i){const s={};i&2&&(s.stream=r[5]),i&6&&(s.spec=r[2][r[4]]),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function W9(n){let e,t,r=n[4]+"",i,s,o,a,l,c;const u=[nCt,tCt],h=[];function f(d,p){return d[4]in d[2]?0:1}return o=f(n),a=h[o]=u[o](n),{c(){e=we("div"),t=we("p"),i=qe(r),s=tt(),a.c(),l=tt(),Z(t,"class","w-32 my-2"),Z(e,"class","flex my-1 items-center")},m(d,p){me(d,e,p),ie(e,t),ie(t,i),ie(e,s),h[o].m(e,null),ie(e,l),c=!0},p(d,p){(!c||p&2)&&r!==(r=d[4]+"")&&cn(i,r);let m=o;o=f(d),o===m?h[o].p(d,p):(sr(),$e(h[m],1,1,()=>{h[m]=null}),or(),a=h[o],a?a.p(d,p):(a=h[o]=u[o](d),a.c()),ke(a,1),a.m(e,l))},i(d){c||(ke(a),c=!0)},o(d){$e(a),c=!1},d(d){d&&pe(e),h[o].d()}}}function rCt(n){let e,t,r=Object.entries(n[1]),i=[];for(let o=0;o<r.length;o+=1)i[o]=W9(U9(n,r,o));const s=o=>$e(i[o],1,1,()=>{i[o]=null});return{c(){e=we("div");for(let o=0;o<i.length;o+=1)i[o].c();Z(e,"class","m-2")},m(o,a){me(o,e,a);for(let l=0;l<i.length;l+=1)i[l]&&i[l].m(e,null);t=!0},p(o,a){if(a&6){r=Object.entries(o[1]);let l;for(l=0;l<r.length;l+=1){const c=U9(o,r,l);i[l]?(i[l].p(c,a),ke(i[l],1)):(i[l]=W9(c),i[l].c(),ke(i[l],1),i[l].m(e,null))}for(sr(),l=r.length;l<i.length;l+=1)s(l);or()}},i(o){if(!t){for(let a=0;a<r.length;a+=1)ke(i[a]);t=!0}},o(o){i=i.filter(Boolean);for(let a=0;a<i.length;a+=1)$e(i[a]);t=!1},d(o){o&&pe(e),os(i,o)}}}function iCt(n){let e,t;return e=new Ao({props:{title:n[0],$$slots:{default:[rCt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&262&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function sCt(n,e,t){let{title:r}=e,{parameters:i}=e,{config:s={}}=e,o=[];return n.$$set=a=>{"title"in a&&t(0,r=a.title),"parameters"in a&&t(1,i=a.parameters),"config"in a&&t(2,s=a.config)},n.$$.update=()=>{if(n.$$.dirty&10){for(const a of o)a();t(3,o=Object.values(i).map(a=>a.subscribe()))}},[r,i,s,o]}class oCt extends gn{constructor(e){super(),mn(this,e,sCt,iCt,hn,{title:0,parameters:1,config:2})}}var uI;class aCt extends ia{constructor(e,t={}){super(),this.title="modelParameters",uI.set(this,void 0),Pn(this,uI,e,"f"),this.config=t}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new oCt({target:t,props:{title:this.title,parameters:ze(this,uI,"f").parameters,config:this.config}}))}}uI=new WeakMap;function lCt(n,e={}){if(!n.parameters)throw new Error("The argument is not a valid component with parameters");return new aCt(n,e)}function cCt(n){let e;return{c(){e=we("p"),e.textContent="No model loaded"},m(t,r){me(t,e,r)},p:Ze,d(t){t&&pe(e)}}}function uCt(n){let e,t,r,i;return{c(){e=we("p"),t=qe("Model Loaded from "),r=qe(n[2]),i=qe(".")},m(s,o){me(s,e,o),ie(e,t),ie(e,r),ie(e,i)},p(s,o){o&4&&cn(r,s[2])},d(s){s&&pe(e)}}}function hCt(n){let e;return{c(){e=we("p"),e.textContent="Loading Model..."},m(t,r){me(t,e,r)},p:Ze,d(t){t&&pe(e)}}}function fCt(n){let e;function t(s,o){return s[3]==="loading"?hCt:s[3]==="loaded"?uCt:cCt}let r=t(n),i=r(n);return{c(){e=we("div"),i.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(s,o){me(s,e,o),i.m(e,null)},p(s,o){r===(r=t(s))&&i?i.p(s,o):(i.d(1),i=r(s),i&&(i.c(),i.m(e,null)))},d(s){s&&pe(e),i.d()}}}function dCt(n){let e,t;return e=new Ao({props:{title:n[0],loading:n[3]==="loading",$$slots:{default:[fCt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&8&&(s.loading=r[3]==="loading"),i&268&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function pCt(n,e,t){let r,i,s,o=Ze,a=()=>(o(),o=vr(f,d=>t(7,s=d)),f);n.$$.on_destroy.push(()=>o());var l,c,u;let{title:h}=e,{training:f}=e;return a(),n.$$set=d=>{"title"in d&&t(0,h=d.title),"training"in d&&a(t(1,f=d.training))},n.$$.update=()=>{n.$$.dirty&128&&t(3,r=s.status),n.$$.dirty&240&&t(2,i=!(t(4,l=s.data)===null||l===void 0)&&l.source?s.data.source==="datastore"?`datastore at ${t(5,c=s.data)===null||c===void 0?void 0:c.url}`:s.data.source==="url"?`url ${t(6,u=s.data)===null||u===void 0?void 0:u.url}`:"files":"unknown source")},[h,f,i,r,l,c,u,s]}class mCt extends gn{constructor(e){super(),mn(this,e,pCt,dCt,hn,{title:0,training:1})}}var gf;function H9(n,e){return n===e}function G9(n,e){return n===e}class Gu extends r0{constructor({inputType:e,taskType:t,inputShape:r}){super(),this.title="onnx model",this.parameters={},this.serviceName="onnx-models",this.$loading=new ct(!1,!0),this.$ready=new ct(!1,!0),this.modelName="",this.lockLoading=Promise.resolve(),gf.set(this,void 0),this.inputType=e,this.taskType=t,this.inputShape=r,this.start()}train(){throw new wp("Model `OnnxModel` cannot be trained")}async predict(e){if(!ze(this,gf,"f")||!this.$ready.get())throw new Error("Model is not loaded");const t=this.preprocess(e),r=await ze(this,gf,"f").run({[ze(this,gf,"f").inputNames[0]]:t});return await this.postprocess(r)}async loadFromUrl(e){this.$training.set({status:"loading"}),this.$ready.set(!1),this.$loading.set(!0);try{await this.loadModel(e,e),this.$training.set({status:"loaded",data:{source:"url",url:e}}),this.$loading.set(!1),this.$ready.set(!0)}catch(t){throw this.$training.set({status:"error"}),this.$loading.set(!1),t}}async loadFromFile(e){if(e){this.$training.set({status:"loading"}),this.$ready.set(!1),this.$loading.set(!0);try{const t=await new Promise((r,i)=>{const s=new FileReader;s.onload=function(){const a=this.result;r(a)},s.onerror=function(){i()},s.readAsArrayBuffer(e)});await this.loadModel(t,e.name),this.$training.set({status:"loaded",data:{source:"file"}}),this.$loading.set(!1),this.$ready.set(!0)}catch(t){throw this.$training.set({status:"error"}),this.$loading.set(!1),t}}}async loadModel(e,t){this.ready=!1,this.lockLoading=this.lockLoading.then(()=>ort.InferenceSession.create(e)).then(r=>{Pn(this,gf,r,"f")}),await this.lockLoading,this.modelName=t;try{await this.warmup()}catch(r){console.log("ONNX Model warmup failed",r)}this.ready=!0}preprocess(e){if(H9(this.inputType,"image"))return this.preprocessImage(e);if(H9(this.inputType,"generic")){const t=e.flat().flat().flat().flat().flat();return new ort.Tensor("float32",Float32Array.from(t),this.inputShape)}throw new Error("Invalid input data type")}preprocessImage(e){throw new Error("ONNX for Images: Not yet implemented")}async postprocess(e){if(G9(this.taskType,"classification")){const t=this.labels?i=>this.labels[i]:i=>i.toString(),r=Array.from(e.probabilities.data).reduce((i,s,o)=>({...i,[t(o)]:s}),{});return{label:t(e.label.data[0]),confidences:r}}if(G9(this.taskType,"generic")){const t={};for(const r of ze(this,gf,"f").outputNames)t[r]=Array.from(e[r].data);return t}throw new Error("Invalid output data type")}async warmup(){const e=Float32Array.from(Array(this.inputShape.reduce((r,i)=>r*i,1)),()=>Math.random()),t=new ort.Tensor("float32",e,this.inputShape);await ze(this,gf,"f").run({[ze(this,gf,"f").inputNames[0]]:t})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new mCt({target:t,props:{title:this.title,training:this.$training}}))}save(){throw new Error("OnnxModel does not support saving")}load(){throw new Error("OnnxModel does not support loading")}download(){throw new Error("OnnxModel does not support downloading")}upload(){throw new Error("OnnxModel does not support uploading")}}gf=new WeakMap;On([zn],Gu.prototype,"train",null);On([zn],Gu.prototype,"predict",null);On([zn],Gu.prototype,"loadFromUrl",null);On([zn],Gu.prototype,"loadFromFile",null);On([zn],Gu.prototype,"loadModel",null);On([zn],Gu.prototype,"preprocess",null);On([zn],Gu.prototype,"postprocess",null);On([zn],Gu.prototype,"save",null);On([zn],Gu.prototype,"load",null);On([zn],Gu.prototype,"download",null);On([zn],Gu.prototype,"upload",null);const gCt={MoveNet:.35,PoseNet:.5,BlazePose:.65},yCt=["#ffffff","#800000","#469990","#e6194b","#42d4f4","#fabed4","#aaffc3","#9a6324","#000075","#f58231","#4363d8","#ffd8b1","#dcbeff","#808000","#ffe119","#911eb4","#bfef45","#f032e6","#3cb44b","#a9a9a9"];class j9{constructor(e,t){this.model=e,this.width=t,this.params={lineWidth:2,radius:4,scoreThreshold:gCt[e]},this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.width,this.ctx=this.canvas.getContext("2d")}drawKeypoint(e){if((e.score!=null?e.score:1)>=this.params.scoreThreshold){const r=new Path2D;r.arc(e.x,e.y,this.params.radius,0,2*Math.PI),this.ctx.fill(r),this.ctx.stroke(r)}}drawKeypoints(e){const t=Ij.getKeypointIndexBySide(this.model);this.ctx.fillStyle="Red",this.ctx.strokeStyle="White",this.ctx.lineWidth=this.params.lineWidth;for(const r of t.middle)this.drawKeypoint(e[r]);this.ctx.fillStyle="Green";for(const r of t.left)this.drawKeypoint(e[r]);this.ctx.fillStyle="Orange";for(const r of t.right)this.drawKeypoint(e[r])}drawSkeleton(e,t){const r=t!=null?yCt[t%20]:"White";this.ctx.fillStyle=r,this.ctx.strokeStyle=r,this.ctx.lineWidth=this.params.lineWidth,Ij.getAdjacentPairs(this.model).forEach(([i,s])=>{const o=e[i],a=e[s],l=o.score!=null?o.score:1,c=a.score!=null?a.score:1,u=this.params.scoreThreshold||0;l>=u&&c>=u&&(this.ctx.beginPath(),this.ctx.moveTo(o.x,o.y),this.ctx.lineTo(a.x,a.y),this.ctx.stroke())})}drawResult(e){if(e.keypoints!=null&&(this.drawKeypoints(e.keypoints),this.drawSkeleton(e.keypoints,e.id)),e.keypoints3D!=null)throw new Error("Keypoints 3D is not Implemented...")}drawResults(e){for(const t of e)this.drawResult(t)}drawImage(e){this.ctx.clearRect(0,0,e.width,e.width),this.canvas.height=e.height,this.canvas.width=e.width,this.ctx.putImageData(e,0,0)}render(e,t,r="ImageData"){return this.drawImage(e),this.drawResults(t),r==="ImageData"?this.ctx.getImageData(0,0,this.width,this.width):this.canvas.toDataURL("image/jpeg")}}function bCt(n){let e,t,r;return{c(){e=qe("Using "),t=qe(n[2]),r=qe(" pose detector.")},m(i,s){me(i,e,s),me(i,t,s),me(i,r,s)},p(i,s){s&4&&cn(t,i[2])},d(i){i&&pe(e),i&&pe(t),i&&pe(r)}}}function vCt(n){let e;return{c(){e=qe(" ")},m(t,r){me(t,e,r)},p:Ze,d(t){t&&pe(e)}}}function wCt(n){let e;function t(s,o){return s[3]?vCt:bCt}let r=t(n),i=r(n);return{c(){e=we("p"),i.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(s,o){me(s,e,o),i.m(e,null)},p(s,o){r===(r=t(s))&&i?i.p(s,o):(i.d(1),i=r(s),i&&(i.c(),i.m(e,null)))},d(s){s&&pe(e),i.d()}}}function xCt(n){let e,t;return e=new Ao({props:{title:n[0],loading:n[3],$$slots:{default:[wCt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&8&&(s.loading=r[3]),i&28&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function _Ct(n,e,t){let r,i=Ze,s=()=>(i(),i=vr(a,c=>t(3,r=c)),a);n.$$.on_destroy.push(()=>i());let{title:o}=e,{loading:a}=e;s();let{model:l}=e;return n.$$set=c=>{"title"in c&&t(0,o=c.title),"loading"in c&&s(t(1,a=c.loading)),"model"in c&&t(2,l=c.model)},[o,a,l,r]}class SCt extends gn{constructor(e){super(),mn(this,e,_Ct,xCt,hn,{title:0,loading:1,model:2})}}var H1,hI,fI;class XC extends r0{constructor(e="MoveNet",t){super(),this.model=e,this.modelConfig=t,this.title="Pose Detection",this.parameters={},this.serviceName="undefined",H1.set(this,void 0),this.$loading=new ct(!0,!0),this.$bodyParts=new ct("Full body",!1),hI.set(this,void 0),fI.set(this,void 0),Pn(this,hI,new j9(so[e],224),"f"),Pn(this,fI,new j9(so[e],60),"f"),this.start(),this.setup(e,t)}async setup(e,t){await H2(),Pn(this,H1,await $ft(so[e],t),"f"),ba.info(`${e} loaded`),this.$loading.set(!1),this.start()}async predict(e){return ze(this,H1,"f")?await ze(this,H1,"f").estimatePoses(e):(ba.error("Movenet is not loaded"),[])}postprocess(e,t){const r=t&&Array.isArray(t)&&t.length>0?(i,s)=>t.includes(s):()=>!0;return e.map(i=>{const s=i.keypoints[0];return i.keypoints.filter(r).reduce((o,a)=>[...o,(a.x-s.x)/100,(a.y-s.y)/100],[])}).reduce((i,s)=>[...i,...s],[])}thumbnail(e,t){return ze(this,fI,"f").render(e,t,"dataURL")}render(e,t){return ze(this,hI,"f").render(e,t)}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new SCt({target:t,props:{title:this.title,loading:this.$loading,model:this.model}}))}train(){throw new wp("Model `MobileNet` cannot be trained")}save(){throw new Error("MobileNet does not support saving")}load(){throw new Error("MobileNet does not support loading")}download(){throw new Error("MobileNet does not support downloading")}upload(){throw new Error("MobileNet does not support uploading")}}H1=new WeakMap,hI=new WeakMap,fI=new WeakMap;On([zn],XC.prototype,"train",null);On([zn],XC.prototype,"save",null);On([zn],XC.prototype,"load",null);On([zn],XC.prototype,"download",null);On([zn],XC.prototype,"upload",null);function CCt(n){let e,t,r,i,s;function o(l){n[5](l)}let a={type:"text",placeholder:"Enter a label..",disabled:n[4]};return n[3]!==void 0&&(a.value=n[3]),r=new uce({props:a}),Li.push(()=>Lc(r,"value",o)),{c(){e=we("div"),t=we("div"),Ct(r.$$.fragment),Z(t,"class","md:flex md:items-center mb-2"),Z(e,"class","w-full max-w-sm")},m(l,c){me(l,e,c),ie(e,t),xt(r,t,null),s=!0},p(l,c){const u={};c&16&&(u.disabled=l[4]),!i&&c&8&&(i=!0,u.value=l[3],Fc(()=>i=!1)),r.$set(u)},i(l){s||(ke(r.$$.fragment,l),s=!0)},o(l){$e(r.$$.fragment,l),s=!1},d(l){l&&pe(e),_t(r)}}}function kCt(n){let e,t;return e=new Ao({props:{title:n[0],$$slots:{default:[CCt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&88&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function TCt(n,e,t){let r,i=Ze,s=()=>(i(),i=vr(u,d=>t(3,r=d)),u),o,a=Ze,l=()=>(a(),a=vr(h,d=>t(4,o=d)),h);n.$$.on_destroy.push(()=>i()),n.$$.on_destroy.push(()=>a());let{title:c}=e,{value:u}=e;s();let{disabled:h}=e;l();function f(d){r=d,u.set(r)}return n.$$set=d=>{"title"in d&&t(0,c=d.title),"value"in d&&s(t(1,u=d.value)),"disabled"in d&&l(t(2,h=d.disabled))},[c,u,h,r,o,f]}class ECt extends gn{constructor(e){super(),mn(this,e,TCt,kCt,hn,{title:0,value:1,disabled:2})}}class ICt extends ia{constructor(e){super(),this.title="text input",this.$value=new ct("",!0),this.$disabled=new ct(!1,!0),e!==void 0&&this.$value.set(e),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new ECt({target:t,props:{title:this.title,value:this.$value,disabled:this.$disabled}}))}}function ACt(...n){return new ICt(...n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.mul=function(n){return this.throwIfDisposed(),C2t(this,n)};function MCt(n){let e;return{c(){e=we("p"),e.textContent="No model loaded"},m(t,r){me(t,e,r)},p:Ze,d(t){t&&pe(e)}}}function NCt(n){let e,t,r,i;return{c(){e=we("p"),t=qe("Model Loaded from "),r=qe(n[2]),i=qe(".")},m(s,o){me(s,e,o),ie(e,t),ie(e,r),ie(e,i)},p(s,o){o&4&&cn(r,s[2])},d(s){s&&pe(e)}}}function $Ct(n){let e;return{c(){e=we("p"),e.textContent="Loading Model..."},m(t,r){me(t,e,r)},p:Ze,d(t){t&&pe(e)}}}function RCt(n){let e;function t(s,o){return s[3]==="loading"?$Ct:s[3]==="loaded"?NCt:MCt}let r=t(n),i=r(n);return{c(){e=we("div"),i.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(s,o){me(s,e,o),i.m(e,null)},p(s,o){r===(r=t(s))&&i?i.p(s,o):(i.d(1),i=r(s),i&&(i.c(),i.m(e,null)))},d(s){s&&pe(e),i.d()}}}function PCt(n){let e,t;return e=new Ao({props:{title:n[0],loading:n[3]==="loading",$$slots:{default:[RCt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&8&&(s.loading=r[3]==="loading"),i&268&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function DCt(n,e,t){let r,i,s,o=Ze,a=()=>(o(),o=vr(f,d=>t(7,s=d)),f);n.$$.on_destroy.push(()=>o());var l,c,u;let{title:h}=e,{training:f}=e;return a(),n.$$set=d=>{"title"in d&&t(0,h=d.title),"training"in d&&a(t(1,f=d.training))},n.$$.update=()=>{n.$$.dirty&128&&t(3,r=s.status),n.$$.dirty&240&&t(2,i=!(t(4,l=s.data)===null||l===void 0)&&l.source?s.data.source==="datastore"?`datastore at ${t(5,c=s.data)===null||c===void 0?void 0:c.url}`:s.data.source==="url"?`url ${t(6,u=s.data)===null||u===void 0?void 0:u.url}`:"files":"unknown source")},[h,f,i,r,l,c,u,s]}class OCt extends gn{constructor(e){super(),mn(this,e,DCt,PCt,hn,{title:0,training:1})}}function q9(n,e){return n===e}function QP(n,e){return n===e}class i0 extends U${constructor({inputType:e,taskType:t,segmentationOptions:r={applyArgmax:!1,output:"image"}}){super(),this.title="tfjs model",this.parameters={},this.segmentationOptions={applyArgmax:!1,output:"image",...r},this.inputType=e,this.taskType=t,this.$training.subscribe(({status:i})=>{i==="loaded"&&(this.inputShape=this.model.inputs[0].shape.map(s=>s&&s>0?s:1))})}train(){throw new wp("Model `TfModel` cannot be trained")}async predict(e){if(!this.model||this.$training.get().status!=="loaded")throw new Error("Model is not loaded");const t=Se(()=>{const i=this.preprocess(e);return this.model.predict(i.expandDims(0)).gather(0)}),r=await this.postprocess(t);return t.dispose(),r}preprocess(e){if(q9(this.inputType,"image"))return this.preprocessImage(e);if(q9(this.inputType,"generic"))return Ts(e);throw new Error("Invalid input data type")}preprocessImage(e){return Ss.resizeBilinear(iC(e),[this.inputShape[1],this.inputShape[2]])}async postprocess(e){if(QP(this.taskType,"classification")){const t=this.labels?s=>this.labels[s]:s=>s.toString(),r=Se(()=>e.argMax().dataSync()[0]),i=e.arraySync().reduce((s,o,a)=>({...s,[t(a)]:o}),{});return{label:t(r),confidences:i}}if(QP(this.taskType,"segmentation")){const[t,r]=e.shape,i=this.segmentationOptions.applyArgmax?Se(()=>e.argMax(-1).mul(.5)):e,s=this.segmentationOptions.output==="image"?new ImageData(await rC(i),t,r):await i.array();return this.segmentationOptions.applyArgmax&&i.dispose(),s}if(QP(this.taskType,"generic"))return e.array();throw new Error("Invalid output data type")}async loadFromFiles(e){this.$training.set({status:"loading"});try{const t=e.filter(i=>i.name.includes(".json")),r=e.filter(i=>i.name.includes(".bin"));if(t.length!==1){const i=new Error("The provided files are not compatible with this model");throw i.name="File upload error",i}if(this.$training.set({status:"loading"}),e.length){const i=await vce(t[0]);this.loadFn=i.format==="graph-model"?Pl:q_,this.model=await this.loadFn(xce([t[0],...r])),await this.warmup(),this.$training.set({status:"loaded",data:{source:"file"}})}}catch(t){throw this.$training.set({status:"error"}),t}}async loadFromUrl(e){this.$training.set({status:"loading"});try{const t=await fetch(e).then(r=>r.json());this.loadFn=t.format==="graph-model"?Pl:q_,this.model=await this.loadFn(cL(e)),await this.warmup(),this.$training.set({status:"loaded",data:{source:"url",url:e}})}catch(t){throw console.log("[tf-model] Loading error",t),this.$training.set({status:"error"}),t}}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new OCt({target:t,props:{title:this.title,training:this.$training}}))}}On([zn],i0.prototype,"train",null);On([zn],i0.prototype,"predict",null);On([zn],i0.prototype,"preprocess",null);On([zn],i0.prototype,"preprocessImage",null);On([zn],i0.prototype,"postprocess",null);On([zn],i0.prototype,"loadFromFiles",null);On([zn],i0.prototype,"loadFromUrl",null);function FCt(n){let e,t,r;function i(o){n[7](o)}let s={disabled:n[5],text:n[6]};return n[4]!==void 0&&(s.checked=n[4]),e=new DV({props:s}),Li.push(()=>Lc(e,"checked",i)),{c(){Ct(e.$$.fragment)},m(o,a){xt(e,o,a),r=!0},p(o,a){const l={};a&32&&(l.disabled=o[5]),a&64&&(l.text=o[6]),!t&&a&16&&(t=!0,l.checked=o[4],Fc(()=>t=!1)),e.$set(l)},i(o){r||(ke(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){_t(e,o)}}}function LCt(n){let e,t;return e=new Ao({props:{title:n[0],$$slots:{default:[FCt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&368&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function zCt(n,e,t){let r,i=Ze,s=()=>(i(),i=vr(p,y=>t(4,r=y)),p),o,a=Ze,l=()=>(a(),a=vr(m,y=>t(5,o=y)),m),c,u=Ze,h=()=>(u(),u=vr(d,y=>t(6,c=y)),d);n.$$.on_destroy.push(()=>i()),n.$$.on_destroy.push(()=>a()),n.$$.on_destroy.push(()=>u());let{title:f}=e,{text:d}=e;h();let{checked:p}=e;s();let{disabled:m}=e;l();function g(y){r=y,p.set(r)}return n.$$set=y=>{"title"in y&&t(0,f=y.title),"text"in y&&h(t(1,d=y.text)),"checked"in y&&s(t(2,p=y.checked)),"disabled"in y&&l(t(3,m=y.disabled))},[f,d,p,m,r,o,c,g]}class BCt extends gn{constructor(e){super(),mn(this,e,zCt,LCt,hn,{title:0,text:1,checked:2,disabled:3})}}class VCt extends ia{constructor(e="toggle me"){super(),this.title="toggle",this.$checked=new ct(!1,!0),this.$disabled=new ct(!1,!0),this.$text=new ct(e,!0),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new BCt({target:t,props:{title:this.title,text:this.$text,checked:this.$checked,disabled:this.$disabled}}))}}function UCt(...n){return new VCt(...n)}const WCt=n=>function(t,r,i){const s=i.value;return i.value=function(...a){const l=this[n].then(()=>s.apply(this,a));return this[n]=l,l},i};function HCt(n){let e;return{c(){e=we("div"),e.innerHTML=`<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v18"></path></svg> 
    <p>Select one or several runs to display information</p>`,Z(e,"class","empty svelte-yj1ygt")},m(t,r){me(t,e,r)},p:Ze,i:Ze,o:Ze,d(t){t&&pe(e)}}}function GCt(n){let e,t;return e=new mce({props:{columns:[{name:"field"},...n[2]],provider:n[1],selectable:!1}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,i){const s={};i&4&&(s.columns=[{name:"field"},...r[2]]),i&2&&(s.provider=r[1]),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function jCt(n){let e,t,r,i;const s=[GCt,HCt],o=[];function a(l,c){return l[0].length>0?0:1}return e=a(n),t=o[e]=s[e](n),{c(){t.c(),r=po()},m(l,c){o[e].m(l,c),me(l,r,c),i=!0},p(l,[c]){let u=e;e=a(l),e===u?o[e].p(l,c):(sr(),$e(o[u],1,1,()=>{o[u]=null}),or(),t=o[e],t?t.p(l,c):(t=o[e]=s[e](l),t.c()),ke(t,1),t.m(r.parentNode,r))},i(l){i||(ke(t),i=!0)},o(l){$e(t),i=!1},d(l){o[e].d(l),l&&pe(r)}}}function qCt(n,e,t){let r,i,s,o,{runs:a}=e;return n.$$set=l=>{"runs"in l&&t(0,a=l.runs)},n.$$.update=()=>{n.$$.dirty&1&&t(2,r=a.map((l,c)=>({name:`Run ${c+1}`}))),n.$$.dirty&1&&t(4,i=a.length>0?Object.keys(a[0]).filter(l=>l!=="logs"):[]),n.$$.dirty&17&&t(3,s=i.map(l=>a.map((c,u)=>({[`Run ${u+1}`]:c[l]})).reduce((c,u)=>({...c,...u}),{field:l}))),n.$$.dirty&8&&t(1,o=new A1t({data:s}))},[a,o,r,s,i]}class Hce extends gn{constructor(e){super(),mn(this,e,qCt,jCt,hn,{runs:0})}}function X9(n,e,t){const r=n.slice();return r[5]=e[t],r[6]=e,r[7]=t,r}function K9(n){let e,t=n[7];const r=()=>n[3](e,t),i=()=>n[3](null,t);return{c(){e=we("div"),Z(e,"class","card inner-card xl:flex-1 svelte-1o4ebpu")},m(s,o){me(s,e,o),r()},p(s,o){n=s,t!==n[7]&&(i(),t=n[7],r())},d(s){s&&pe(e),i()}}}function XCt(n){let e,t=Object.values(n[0]),r=[];for(let i=0;i<t.length;i+=1)r[i]=K9(X9(n,t,i));return{c(){e=we("div");for(let i=0;i<r.length;i+=1)r[i].c();Z(e,"class","grid grid-cols-1 gap-1")},m(i,s){me(i,e,s);for(let o=0;o<r.length;o+=1)r[o]&&r[o].m(e,null);n[4](e)},p(i,[s]){if(s&5){t=Object.values(i[0]);let o;for(o=0;o<t.length;o+=1){const a=X9(i,t,o);r[o]?r[o].p(a,s):(r[o]=K9(a),r[o].c(),r[o].m(e,null))}for(;o<r.length;o+=1)r[o].d(1);r.length=t.length}},i:Ze,o:Ze,d(i){i&&pe(e),os(r,i),n[4](null)}}}function KCt(n,e,t){let{charts:r}=e,i,s=[];$h(async()=>{await Za(),await Za(),Object.keys(r).length>1&&i.clientWidth>700&&t(1,i.style.gridTemplateColumns="repeat(2, minmax(0, 1fr))",i);for(const[l,c]of Object.values(r).entries())c.mount(s[l])}),Ng(()=>{for(const l of Object.values(r))l.destroy()});function o(l,c){Li[l?"unshift":"push"](()=>{s[c]=l,t(2,s)})}function a(l){Li[l?"unshift":"push"](()=>{i=l,t(1,i)})}return n.$$set=l=>{"charts"in l&&t(0,r=l.charts)},[r,i,s,o,a]}class YCt extends gn{constructor(e){super(),mn(this,e,KCt,XCt,hn,{charts:0})}}class ZCt extends ia{constructor(e,t={loss:["loss","lossVal"],accuracy:["acc","accVal"]}){if(super(),this.model=e,this.title="training plot",this.charts={},!e){const o=new Error("[training plot] No model was provided");o.name="Component Compatibility Error",Co(o)}if(!e.$training){const o=new Error("[training plot] The provided model is incompatible with the training plot component, missing `$training` stream");o.name="Component Compatibility Error",Co(o)}let r=t;typeof t=="string"&&(r=[t]),Array.isArray(r)&&(r=r.reduce((o,a)=>({...o,[a]:a}),{}));const i={};for(const[o,a]of Object.entries(r)){const l=Array.isArray(a)?a:[a];this.charts[o]=zce({preset:"line-fast",options:{xlabel:"Epoch",ylabel:o}});for(const c of l)Object.keys(i).includes(c)||(i[c]=new ct([],!0)),this.charts[o].addSeries(i[c],c);this.charts[o].title=o}function s(){for(const o of Object.values(i))o.set([])}e.$training.subscribe(o=>{if(o.status==="start")s();else if(o.data)for(const[a,l]of Object.entries(o.data)){if(!Object.keys(i).includes(a))return;Array.isArray(l)?i[a].set(l.map((c,u)=>({x:u+1,y:c}))):i[a].set(i[a].get().concat([{x:i[a].get().length+1,y:l}]))}}),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new YCt({target:t,props:{charts:this.charts}}))}}function Gce(...n){return new ZCt(...n)}function JCt(n){let e;return{c(){e=we("div"),e.innerHTML=`<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v18"></path></svg> 
    <p>Select one or several runs to display information</p>`,Z(e,"class","empty svelte-yj1ygt")},m(t,r){me(t,e,r)},p:Ze,d(t){t&&pe(e)}}}function QCt(n){let e;return{c(){e=we("div")},m(t,r){me(t,e,r),n[7](e)},p:Ze,d(t){t&&pe(e),n[7](null)}}}function ekt(n){let e;function t(s,o){return s[0].length>0?QCt:JCt}let r=t(n),i=r(n);return{c(){i.c(),e=po()},m(s,o){i.m(s,o),me(s,e,o)},p(s,[o]){r===(r=t(s))&&i?i.p(s,o):(i.d(1),i=r(s),i&&(i.c(),i.m(e.parentNode,e)))},i:Ze,o:Ze,d(s){i.d(s),s&&pe(e)}}}function tkt(n,e,t){let r,i,{names:s}=e,{logs:o}=e,a,l,c;Ng(()=>{c&&c.destroy()});function u(h){Li[h?"unshift":"push"](()=>{a=h,t(1,a)})}return n.$$set=h=>{"names"in h&&t(2,s=h.names),"logs"in h&&t(0,o=h.logs)},n.$$.update=()=>{n.$$.dirty&9&&(t(3,l=Array.from(new Set(o.map(Object.keys).flat()))),l.sort()),n.$$.dirty&5&&t(6,r=o.map((h,f)=>Object.entries(h).reduce((d,[p,m])=>({...d,[`${p} (${s[f]})`]:m}),{})).reduce((h,f)=>({...h,...f}),{})),n.$$.dirty&72&&t(5,i=l.reduce((h,f)=>({...h,[f]:Object.keys(r).filter(d=>d.startsWith(`${f} (`))}),{})),n.$$.dirty&114&&(c&&c.destroy(),t(4,c=Gce({$training:new ct({status:"success",data:r},!0)},i)),c.mount(a))},[o,a,s,l,c,i,r,u]}class nkt extends gn{constructor(e){super(),mn(this,e,tkt,ekt,hn,{names:2,logs:0})}}function Y9(n,e,t){const r=n.slice();return r[13]=e[t],r[15]=t,r}function rkt(n){let e;return{c(){e=qe("Graphs")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function ikt(n){let e;return{c(){e=qe("Metadata")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function skt(n){let e;return{c(){e=qe("Parameters")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function okt(n){let e;return{c(){e=qe("Model Summary")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function akt(n){let e,t,r,i,s,o,a,l;return e=new EE({props:{$$slots:{default:[rkt]},$$scope:{ctx:n}}}),r=new EE({props:{$$slots:{default:[ikt]},$$scope:{ctx:n}}}),s=new EE({props:{$$slots:{default:[skt]},$$scope:{ctx:n}}}),a=new EE({props:{$$slots:{default:[okt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment),t=tt(),Ct(r.$$.fragment),i=tt(),Ct(s.$$.fragment),o=tt(),Ct(a.$$.fragment)},m(c,u){xt(e,c,u),me(c,t,u),xt(r,c,u),me(c,i,u),xt(s,c,u),me(c,o,u),xt(a,c,u),l=!0},p(c,u){const h={};u&65536&&(h.$$scope={dirty:u,ctx:c}),e.$set(h);const f={};u&65536&&(f.$$scope={dirty:u,ctx:c}),r.$set(f);const d={};u&65536&&(d.$$scope={dirty:u,ctx:c}),s.$set(d);const p={};u&65536&&(p.$$scope={dirty:u,ctx:c}),a.$set(p)},i(c){l||(ke(e.$$.fragment,c),ke(r.$$.fragment,c),ke(s.$$.fragment,c),ke(a.$$.fragment,c),l=!0)},o(c){$e(e.$$.fragment,c),$e(r.$$.fragment,c),$e(s.$$.fragment,c),$e(a.$$.fragment,c),l=!1},d(c){_t(e,c),c&&pe(t),_t(r,c),c&&pe(i),_t(s,c),c&&pe(o),_t(a,c)}}}function lkt(n){let e,t;return e=new nkt({props:{logs:n[4].map(Q9),names:n[4].map(e7)}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,i){const s={};i&16&&(s.logs=r[4].map(Q9)),i&16&&(s.names=r[4].map(e7)),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function ckt(n){let e,t;return e=new Hce({props:{runs:n[4]}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,i){const s={};i&16&&(s.runs=r[4]),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function ukt(n){let e,t;return e=new Hce({props:{runs:n[4].map(t7)}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,i){const s={};i&16&&(s.runs=r[4].map(t7)),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function Z9(n){let e,t,r,i=n[15]+1+"",s,o,a,l,c=n[13]+"",u,h,f;return{c(){e=we("div"),t=we("h2"),r=qe("Model "),s=qe(i),o=tt(),a=we("div"),l=we("pre"),u=qe(c),h=we("br"),f=tt(),Z(a,"class","summary svelte-y4izzs")},m(d,p){me(d,e,p),ie(e,t),ie(t,r),ie(t,s),ie(e,o),ie(e,a),ie(a,l),ie(l,u),ie(l,h),ie(e,f)},p(d,p){p&16&&c!==(c=d[13]+"")&&cn(u,c)},d(d){d&&pe(e)}}}function hkt(n){let e,t=n[4].map(n7),r=[];for(let i=0;i<t.length;i+=1)r[i]=Z9(Y9(n,t,i));return{c(){e=we("div");for(let i=0;i<r.length;i+=1)r[i].c();Z(e,"class","summaries svelte-y4izzs")},m(i,s){me(i,e,s);for(let o=0;o<r.length;o+=1)r[o]&&r[o].m(e,null)},p(i,s){if(s&16){t=i[4].map(n7);let o;for(o=0;o<t.length;o+=1){const a=Y9(i,t,o);r[o]?r[o].p(a,s):(r[o]=Z9(a),r[o].c(),r[o].m(e,null))}for(;o<r.length;o+=1)r[o].d(1);r.length=t.length}},d(i){i&&pe(e),os(r,i)}}}function fkt(n){let e,t,r,i,s,o,a,l,c,u;return e=new I1t({props:{$$slots:{default:[akt]},$$scope:{ctx:n}}}),r=new IE({props:{$$slots:{default:[lkt]},$$scope:{ctx:n}}}),s=new IE({props:{$$slots:{default:[ckt]},$$scope:{ctx:n}}}),a=new IE({props:{$$slots:{default:[ukt]},$$scope:{ctx:n}}}),c=new IE({props:{$$slots:{default:[hkt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment),t=tt(),Ct(r.$$.fragment),i=tt(),Ct(s.$$.fragment),o=tt(),Ct(a.$$.fragment),l=tt(),Ct(c.$$.fragment)},m(h,f){xt(e,h,f),me(h,t,f),xt(r,h,f),me(h,i,f),xt(s,h,f),me(h,o,f),xt(a,h,f),me(h,l,f),xt(c,h,f),u=!0},p(h,f){const d={};f&65536&&(d.$$scope={dirty:f,ctx:h}),e.$set(d);const p={};f&65552&&(p.$$scope={dirty:f,ctx:h}),r.$set(p);const m={};f&65552&&(m.$$scope={dirty:f,ctx:h}),s.$set(m);const g={};f&65552&&(g.$$scope={dirty:f,ctx:h}),a.$set(g);const y={};f&65552&&(y.$$scope={dirty:f,ctx:h}),c.$set(y)},i(h){u||(ke(e.$$.fragment,h),ke(r.$$.fragment,h),ke(s.$$.fragment,h),ke(a.$$.fragment,h),ke(c.$$.fragment,h),u=!0)},o(h){$e(e.$$.fragment,h),$e(r.$$.fragment,h),$e(s.$$.fragment,h),$e(a.$$.fragment,h),$e(c.$$.fragment,h),u=!1},d(h){_t(e,h),h&&pe(t),_t(r,h),h&&pe(i),_t(s,h),h&&pe(o),_t(a,h),h&&pe(l),_t(c,h)}}}function dkt(n){let e,t,r,i,s,o,a;function l(u){n[10](u)}let c={columns:n[7],provider:n[6],actions:[...n[1].map(J9),{name:"delete",confirm:!0}]};return n[4]!==void 0&&(c.selection=n[4]),e=new mce({props:c}),Li.push(()=>Lc(e,"selection",l)),n[11](e),e.$on("select",n[12]),o=new Uxt({props:{$$slots:{default:[fkt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment),r=tt(),i=we("br"),s=tt(),Ct(o.$$.fragment)},m(u,h){xt(e,u,h),me(u,r,h),me(u,i,h),me(u,s,h),xt(o,u,h),a=!0},p(u,h){const f={};h&2&&(f.actions=[...u[1].map(J9),{name:"delete",confirm:!0}]),!t&&h&16&&(t=!0,f.selection=u[4],Fc(()=>t=!1)),e.$set(f);const d={};h&65552&&(d.$$scope={dirty:h,ctx:u}),o.$set(d)},i(u){a||(ke(e.$$.fragment,u),ke(o.$$.fragment,u),a=!0)},o(u){$e(e.$$.fragment,u),$e(o.$$.fragment,u),a=!1},d(u){n[11](null),_t(e,u),u&&pe(r),u&&pe(i),u&&pe(s),_t(o,u)}}}function pkt(n){let e,t;return e=new Ao({props:{title:n[0],$$slots:{default:[dkt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&65562&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}const J9=n=>typeof n=="string"?{name:n}:n,Q9=n=>n.logs,e7=n=>n.name,t7=n=>n.params,n7=n=>{var e;return((e=n.model)==null?void 0:e.summary)||"No summary available"};function mkt(n,e,t){let r,i=Ze,s=()=>(i(),i=vr(u,b=>t(4,r=b)),u);n.$$.on_destroy.push(()=>i());let{title:o}=e,{service:a}=e,{metrics:l}=e,{actions:c}=e,{selection:u}=e;s();const h=Oc(),f=new M1t({service:a,transform:{...l.reduce((b,_)=>({...b,[_]:w=>_ in w.logs?w.logs[_][w.logs[_].length-1]:"metrics not found"}),{}),...c.reduce((b,_)=>({...b,[typeof _=="string"?_:_.name]:()=>typeof _=="string"?_:_.name}),{})}});f.data.subscribe(()=>{u.set([])});const d=[{name:"name",sortable:!0},{name:"start",sortable:!0,type:"date"},...l.map(b=>({name:b})),{name:"epochs"},{name:"status"},...c.map(b=>({name:typeof b=="string"?b:b.name,type:"action"}))];let p;$h(async()=>{await Za(),await Za();for(const b of c){const _=typeof b=="string"?b:b.name;p.$on(_,({detail:w})=>{h(_,w)})}});function m(b){r=b,u.set(r)}function g(b){Li[b?"unshift":"push"](()=>{p=b,t(3,p)})}const y=({detail:b})=>h("load",b);return n.$$set=b=>{"title"in b&&t(0,o=b.title),"service"in b&&t(8,a=b.service),"metrics"in b&&t(9,l=b.metrics),"actions"in b&&t(1,c=b.actions),"selection"in b&&s(t(2,u=b.selection))},[o,c,u,p,r,h,f,d,a,l,m,g,y]}class gkt extends gn{constructor(e){super(),mn(this,e,mkt,pkt,hn,{title:0,service:8,metrics:9,actions:1,selection:2})}}function ykt(n,e){const t={...n};for(const[r,i]of Object.entries(e))t[r]=(t[r]||[]).concat([i]);return t}const bkt={metrics:["accuracy","accuracyVal","loss","lossVal"],actions:[]};class vkt extends ia{constructor(e,t={}){super(),this.dataStore=e,this.title="Training History",this.$selection=new ct([],!0),this.$actions=new ct(null).skip(1),this.ready=Promise.resolve(),this.stopTracking=Qm,this.lock=Promise.resolve(),this.options={...bkt,...t},this.lock=this.lock.then(Qm),this.start(),this.ready=this.ready.then(()=>this.dataStore.connect()).then(()=>{this.runService=this.dataStore.service("runs")}).catch(()=>{ba.log("[dataset] dataStore connection failed")})}track(e,t="anonymous"){return this.ready.then(()=>(this.stopTracking(),this.model=e,this.modelName=t,this.runService.find({query:{basename:t,$sort:{createdAt:-1},$select:["name"],$limit:1}}))).then(({data:r})=>r.length>0?parseInt(r[0].name.split(`${t}-`)[1])+1:1).then(r=>{this.nextIndex=r,this.crtRun=null,this.stopTracking=this.model?this.model.$training.subscribe(this.trackTrainingStream):Qm}),this}async trackTrainingStream(e){if(e.status==="start")this.crtRun=await this.runService.create({name:`${this.modelName}-${this.nextIndex++}`,basename:this.modelName,start:new Date(Date.now()).toISOString(),source:"js",status:e.status,epochs:e.epochs,params:Object.entries(this.model.parameters).map(([t,r])=>({[t]:r.get()})).reduce((t,r)=>({...t,...r}),{}),logs:{}});else if(e.status==="epoch")this.runService.patch(this.crtRun.id,{status:e.status,epoch:e.epoch,logs:ykt(this.crtRun.logs,e.data)});else if(e.status==="success"){const t=await this.model.save(this.dataStore,this.modelName,{});this.runService.patch(this.crtRun.id,{status:e.status,epoch:e.epoch,logs:e.data,checkpoints:(this.crtRun.checkpoints||[]).concat([{id:t,name:`${this.crtRun.name}@final`,service:this.model.serviceName}])})}else e.status==="error"&&this.runService.patch(this.crtRun.id,{status:e.status})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.ready.then(()=>{this.$$.app=new gkt({target:t,props:{title:this.title,service:this.runService,metrics:this.options.metrics,actions:this.options.actions,selection:this.$selection}});for(const r of this.options.actions){const i=typeof r=="string"?r:r.name;this.$$.app.$on(i,({detail:s})=>{this.$actions.set({name:i,data:s})})}}))}}On([WCt("lock")],vkt.prototype,"trackTrainingStream",null);function r7(n){let e,t;return e=new PV({}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function i7(n){let e,t,r;return t=new zi({props:{round:!0,$$slots:{default:[wkt]},$$scope:{ctx:n}}}),t.$on("click",n[15]),{c(){e=we("div"),Ct(t.$$.fragment),Z(e,"class","absolute bottom-2 right-2 text-right")},m(i,s){me(i,e,s),xt(t,e,null),r=!0},p(i,s){const o={};s&262144&&(o.$$scope={dirty:s,ctx:i}),t.$set(o)},i(i){r||(ke(t.$$.fragment,i),r=!0)},o(i){$e(t.$$.fragment,i),r=!1},d(i){i&&pe(e),_t(t)}}}function wkt(n){let e,t;return{c(){e=bi("svg"),t=bi("path"),Z(t,"stroke-linecap","round"),Z(t,"stroke-linejoin","round"),Z(t,"d","M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"fill","none"),Z(e,"viewBox","0 0 24 24"),Z(e,"stroke-width","1.5"),Z(e,"stroke","currentColor"),Z(e,"class","w-6 h-6")},m(r,i){me(r,e,i),ie(e,t)},p:Ze,d(r){r&&pe(e)}}}function xkt(n){let e,t,r,i,s,o,a,l,c,u,h,f;function d(y){n[13](y)}let p={text:"activate video"};n[9]!==void 0&&(p.checked=n[9]),i=new DV({props:p}),Li.push(()=>Lc(i,"checked",d));let m=n[9]&&!n[10]&&r7(),g=n[8]>1&&i7(n);return{c(){e=we("div"),t=we("div"),r=we("div"),Ct(i.$$.fragment),o=tt(),a=we("div"),m&&m.c(),l=tt(),c=we("video"),u=tt(),g&&g.c(),Z(c,"id","webcam-video"),Z(c,"class","max-w-none svelte-xql639"),Bs(c,"width",n[1]>n[2]?`${n[7]}px`:"auto"),Bs(c,"height",n[1]>n[2]?"auto":`${n[7]*n[2]/n[1]}px`),c.autoplay=!0,c.muted=!0,c.playsInline=!0,Wt(c,"mirror",n[11]==="user"),Z(a,"class","webcam-container svelte-xql639"),Bs(a,"flex-direction",n[1]>n[2]?"column":"row"),Bs(a,"height",n[7]*n[2]/n[1]+"px"),Rc(()=>n[16].call(a)),Z(e,"class","webcam svelte-xql639")},m(y,b){me(y,e,b),ie(e,t),ie(t,r),xt(i,r,null),ie(e,o),ie(e,a),m&&m.m(a,null),ie(a,l),ie(a,c),n[14](c),ie(a,u),g&&g.m(a,null),h=Kwt(a,n[16].bind(a)),f=!0},p(y,b){const _={};!s&&b&512&&(s=!0,_.checked=y[9],Fc(()=>s=!1)),i.$set(_),y[9]&&!y[10]?m?b&1536&&ke(m,1):(m=r7(),m.c(),ke(m,1),m.m(a,l)):m&&(sr(),$e(m,1,1,()=>{m=null}),or()),(!f||b&134)&&Bs(c,"width",y[1]>y[2]?`${y[7]}px`:"auto"),(!f||b&134)&&Bs(c,"height",y[1]>y[2]?"auto":`${y[7]*y[2]/y[1]}px`),(!f||b&2048)&&Wt(c,"mirror",y[11]==="user"),y[8]>1?g?(g.p(y,b),b&256&&ke(g,1)):(g=i7(y),g.c(),ke(g,1),g.m(a,null)):g&&(sr(),$e(g,1,1,()=>{g=null}),or()),(!f||b&6)&&Bs(a,"flex-direction",y[1]>y[2]?"column":"row"),(!f||b&134)&&Bs(a,"height",y[7]*y[2]/y[1]+"px")},i(y){f||(ke(i.$$.fragment,y),ke(m),ke(g),f=!0)},o(y){$e(i.$$.fragment,y),$e(m),$e(g),f=!1},d(y){y&&pe(e),_t(i),m&&m.d(),n[14](null),g&&g.d(),h()}}}function _kt(n){let e,t;return e=new Ao({props:{title:n[0],$$slots:{default:[xkt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title=r[0]),i&266190&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function Skt(n,e,t){let r,i=Ze,s=()=>(i(),i=vr(g,N=>t(9,r=N)),g),o,a=Ze,l=()=>(a(),a=vr(b,N=>t(10,o=N)),b),c,u=Ze,h=()=>(u(),u=vr(m,N=>t(11,c=N)),m);n.$$.on_destroy.push(()=>i()),n.$$.on_destroy.push(()=>a()),n.$$.on_destroy.push(()=>u());let{title:f}=e,{width:d}=e,{height:p}=e,{facingMode:m}=e;h();let{active:g}=e;s();let{mediaStream:y}=e,{ready:b}=e;l();let _,w,S=0,C=Qm;$h(async()=>{await Za(),await Za(),C=y.subscribe(N=>{var O;N&&t(6,_.srcObject=N,_),!((O=navigator.mediaDevices)===null||O===void 0)&&O.enumerateDevices&&navigator.mediaDevices.enumerateDevices().then(R=>R.filter(D=>D.kind==="videoinput")).then(R=>{t(8,S=R.length)}).catch(R=>{console.error(`${R.name}: ${R.message}`)})})}),Ng(()=>{C()});function k(N){r=N,g.set(r)}function A(N){Li[N?"unshift":"push"](()=>{_=N,t(6,_)})}const M=()=>m.set(m.get()==="user"?"environment":"user");function E(){w=this.clientWidth,t(7,w)}return n.$$set=N=>{"title"in N&&t(0,f=N.title),"width"in N&&t(1,d=N.width),"height"in N&&t(2,p=N.height),"facingMode"in N&&h(t(3,m=N.facingMode)),"active"in N&&s(t(4,g=N.active)),"mediaStream"in N&&t(12,y=N.mediaStream),"ready"in N&&l(t(5,b=N.ready))},[f,d,p,m,g,b,_,w,S,r,o,c,y,k,A,M,E]}class Ckt extends gn{constructor(e){super(),mn(this,e,Skt,_kt,hn,{title:0,width:1,height:2,facingMode:3,active:4,mediaStream:12,ready:5})}}var dl,rc,nh,rh,fa,dI,G1,pl,j1,vb,wb,pI;function kkt(n,e){let t=new Date().getTime(),r=!1,i;function s(){if(r)return;new Date().getTime()-t>=e&&(n(),t=new Date().getTime()),i=window.requestAnimationFrame(s)}return i=window.requestAnimationFrame(s),function(){window.cancelAnimationFrame(i),r=!0}}class Tkt extends ia{constructor({width:e=224,height:t=224,period:r=50,facingMode:i="user",audio:s=!1}={}){super(),this.title="webcam",this.$active=new ct(!1,!0),this.$ready=new ct(!1,!0),this.$mediastream=new ct(void 0,!0),this.$images=new ct($_(),!0),this.$thumbnails=new ct($_(),!0),dl.set(this,void 0),rc.set(this,void 0),nh.set(this,void 0),rh.set(this,void 0),fa.set(this,document.createElement("video")),dI.set(this,60),G1.set(this,Qm),pl.set(this,void 0),j1.set(this,void 0),vb.set(this,void 0),wb.set(this,void 0),pI.set(this,void 0),Pn(this,dl,e,"f"),Pn(this,rc,t,"f"),this.period=r,this.$facingMode=new ct(i,!0),Pn(this,pI,s,"f"),this.setupCapture(),ze(this,fa,"f").autoplay=!0,ze(this,fa,"f").muted=!0,ze(this,fa,"f").playsInline=!0;const o=a=>{ze(this,G1,"f").call(this),a?(this.loadCameras(),Pn(this,G1,kkt(this.process,this.period),"f")):this.stopCamera()};this.$active.subscribe(o),this.$facingMode.subscribe(()=>this.$active.get()&&o(!0)),this.start()}getWidth(){return ze(this,dl,"f")}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new Ckt({target:t,props:{title:this.title,width:ze(this,dl,"f"),height:ze(this,rc,"f"),facingMode:this.$facingMode,active:this.$active,mediaStream:this.$mediastream,ready:this.$ready}}))}stop(){if(super.stop(),ze(this,G1,"f").call(this),this.$mediastream.get())for(const e of this.$mediastream.get().getTracks())e.stop()}setupCapture(){Pn(this,pl,document.createElement("canvas"),"f"),ze(this,pl,"f").width=ze(this,dI,"f"),ze(this,pl,"f").height=ze(this,dI,"f")*ze(this,rc,"f")/ze(this,dl,"f"),Pn(this,j1,ze(this,pl,"f").getContext("2d"),"f"),Pn(this,vb,document.createElement("canvas"),"f"),ze(this,vb,"f").width=ze(this,dl,"f"),ze(this,vb,"f").height=ze(this,rc,"f"),Pn(this,wb,ze(this,vb,"f").getContext("2d"),"f")}async loadCameras(){try{const e=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:this.$facingMode.get()}},audio:ze(this,pI,"f")});Pn(this,nh,e.getVideoTracks()[0].getSettings().width,"f"),Pn(this,rh,e.getVideoTracks()[0].getSettings().height,"f"),this.loadSrcStream(e)}catch{Co(new Error("Webcam not supported"))}}loadSrcStream(e){this.$mediastream.set(e),ze(this,fa,"f").srcObject=e,ze(this,fa,"f").play(),ze(this,fa,"f").onloadedmetadata=()=>{Pn(this,nh,ze(this,fa,"f").videoWidth,"f"),Pn(this,rh,ze(this,fa,"f").videoHeight,"f"),this.$ready.set(!0)}}stopCamera(){if(this.$mediastream.get()){const e=this.$mediastream.get().getTracks();for(const t of e)t.stop(),ze(this,fa,"f").srcObject=null;this.$ready.set(!1)}}process(){this.$ready.get()&&(this.$thumbnails.set(this.captureThumbnail()),this.$images.set(this.captureImage()))}captureThumbnail(){if(!this.$ready.get())return null;const e=ze(this,rc,"f")/ze(this,rh,"f"),t=ze(this,dl,"f")/ze(this,nh,"f");if(e>t){const r=ze(this,pl,"f").height*ze(this,nh,"f")/ze(this,rh,"f");ze(this,j1,"f").drawImage(ze(this,fa,"f"),ze(this,pl,"f").width/2-r/2,0,r,ze(this,pl,"f").height)}else{const r=ze(this,pl,"f").width*ze(this,rh,"f")/ze(this,nh,"f");ze(this,j1,"f").drawImage(ze(this,fa,"f"),0,ze(this,pl,"f").height/2-r/2,ze(this,pl,"f").width,r)}return ze(this,pl,"f").toDataURL("image/jpeg")}captureImage(){if(!this.$ready.get())return null;const e=ze(this,rc,"f")/ze(this,rh,"f"),t=ze(this,dl,"f")/ze(this,nh,"f");if(e>t){const r=ze(this,rc,"f")*ze(this,nh,"f")/ze(this,rh,"f");ze(this,wb,"f").drawImage(ze(this,fa,"f"),ze(this,dl,"f")/2-r/2,0,r,ze(this,rc,"f"))}else{const r=ze(this,dl,"f")*ze(this,rh,"f")/ze(this,nh,"f");ze(this,wb,"f").drawImage(ze(this,fa,"f"),0,ze(this,rc,"f")/2-r/2,ze(this,dl,"f"),r)}return ze(this,wb,"f").getImageData(0,0,ze(this,dl,"f"),ze(this,rc,"f"))}}dl=new WeakMap,rc=new WeakMap,nh=new WeakMap,rh=new WeakMap,fa=new WeakMap,dI=new WeakMap,G1=new WeakMap,pl=new WeakMap,j1=new WeakMap,vb=new WeakMap,wb=new WeakMap,pI=new WeakMap;function Ekt(...n){return new Tkt(...n)}function s7(n){return typeof n=="string"}function o7(n){return Array.isArray(n)}let Ikt=class{constructor(e,t=!0){this.name=e,this.showSidebar=t,this.components=[],this.componentsLeft=[]}use(...e){return this.components=this.components.concat(e),this}sidebar(...e){return this.componentsLeft=this.componentsLeft.concat(e),this}mount(){for(const e of this.components)if(o7(e))for(const t of e)t.mount();else s7(e)||e.mount();for(const e of this.componentsLeft)e.mount()}destroy(){for(const e of this.components)if(o7(e))for(const t of e)t.destroy();else s7(e)||e.destroy();for(const e of this.componentsLeft)e.destroy()}};function Akt(n,e,t,r){return n instanceof RegExp?n:(n instanceof Array&&(n=`(${n.join("|")})`),n=n.concat(r?"":"/?").replace(/\/\(/g,"(?:/").replace(/\+/g,"__plus__").replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?/g,(i,s,o,a,l,c)=>(e.push({name:a,optional:!!c}),s=s||"",`${c?"":s}(?:${c?s:""}${o||""}${l||o&&"([^/.]+?)"||"([^/]+?)"})${c||""}`)).replace(/([/.])/g,"\\$1").replace(/__plus__/g,"(.+)").replace(/\*/g,"(.*)"),new RegExp(`^${n}$`,t?"":"i"))}class Mkt{constructor(e,t){this.path=e,this.name=t,this.keys=[],this.fns=[],this.params={},this.regex=Akt(this.path,this.keys,!1,!1)}addHandler(e){this.fns.push(e)}removeHandler(e){this.fns=this.fns.filter(t=>e===t)}run(e){for(const t of this.fns)t.apply(this,e)}match(e,t){const r=this.regex.exec(e);if(!r)return!1;for(let i=1,s=r.length;i<s;i++){const o=this.keys[i-1],a=typeof r[i]=="string"?decodeURIComponent(r[i]):r[i];o&&(this.params[o.name]=a),t.push(a)}return!0}}function Nkt(n,e){const t=[];return e.match(n,t)?(e.run(t),!0):!1}class $kt{constructor(){this.map={},this.routes=[],this.addListener()}route(e,t){const r=e.split(" "),i=r.length===2?r[0]:null;e=r.length===2?r[1]:r[0],Object.keys(this.map).includes(e)||(this.map[e]=new Mkt(e,i),this.routes.push(this.map[e])),this.map[e].addHandler(t),this.reload()}addListener(){window.addEventListener("hashchange",this.reload.bind(this),!1)}removeListener(){window.removeEventListener("hashchange",this.reload.bind(this))}reload(){const e=window.location.hash.substring(1);for(let t=0;t<this.routes.length;t++){const r=this.routes[t];if(Nkt(e,r))return}}navigate(e,{silent:t=!1}={}){t&&this.removeListener(),setTimeout(()=>{window.location.hash=e,t&&setTimeout(()=>{this.addListener()},1)},1)}}function a7(n,e,t){const r=n.slice();return r[1]=e[t],r}function l7(n,e,t){const r=n.slice();return r[4]=e[t].id,r}function c7(n,e,t){const r=n.slice();return r[4]=e[t].id,r}function u7(n){let e,t,r=n[0].showSidebar&&h7(n),i=n[0].components,s=[];for(let o=0;o<i.length;o+=1)s[o]=p7(a7(n,i,o));return{c(){r&&r.c(),e=tt(),t=we("div");for(let o=0;o<s.length;o+=1)s[o].c();Z(t,"class","right svelte-15dyumc"),Wt(t,"fullw",!n[0].showSidebar)},m(o,a){r&&r.m(o,a),me(o,e,a),me(o,t,a);for(let l=0;l<s.length;l+=1)s[l]&&s[l].m(t,null)},p(o,a){if(o[0].showSidebar?r?r.p(o,a):(r=h7(o),r.c(),r.m(e.parentNode,e)):r&&(r.d(1),r=null),a&1){i=o[0].components;let l;for(l=0;l<i.length;l+=1){const c=a7(o,i,l);s[l]?s[l].p(c,a):(s[l]=p7(c),s[l].c(),s[l].m(t,null))}for(;l<s.length;l+=1)s[l].d(1);s.length=i.length}a&1&&Wt(t,"fullw",!o[0].showSidebar)},d(o){r&&r.d(o),o&&pe(e),o&&pe(t),os(s,o)}}}function h7(n){let e,t=n[0].componentsLeft,r=[];for(let i=0;i<t.length;i+=1)r[i]=f7(c7(n,t,i));return{c(){e=we("div");for(let i=0;i<r.length;i+=1)r[i].c();Z(e,"class","left svelte-15dyumc")},m(i,s){me(i,e,s);for(let o=0;o<r.length;o+=1)r[o]&&r[o].m(e,null)},p(i,s){if(s&1){t=i[0].componentsLeft;let o;for(o=0;o<t.length;o+=1){const a=c7(i,t,o);r[o]?r[o].p(a,s):(r[o]=f7(a),r[o].c(),r[o].m(e,null))}for(;o<r.length;o+=1)r[o].d(1);r.length=t.length}},d(i){i&&pe(e),os(r,i)}}}function f7(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[4]),Z(e,"class","card")},m(r,i){me(r,e,i)},p(r,i){i&1&&t!==(t=r[4])&&Z(e,"id",t)},d(r){r&&pe(e)}}}function Rkt(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[1].id),Z(e,"class","card")},m(r,i){me(r,e,i)},p(r,i){i&1&&t!==(t=r[1].id)&&Z(e,"id",t)},d(r){r&&pe(e)}}}function Pkt(n){let e,t=n[1]+"",r;return{c(){e=we("h2"),r=qe(t),Z(e,"class","svelte-15dyumc")},m(i,s){me(i,e,s),ie(e,r)},p(i,s){s&1&&t!==(t=i[1]+"")&&cn(r,t)},d(i){i&&pe(e)}}}function Dkt(n){let e,t,r=n[1],i=[];for(let s=0;s<r.length;s+=1)i[s]=d7(l7(n,r,s));return{c(){e=we("div");for(let s=0;s<i.length;s+=1)i[s].c();t=tt(),Z(e,"class","flex flex-row flex-wrap items-stretch")},m(s,o){me(s,e,o);for(let a=0;a<i.length;a+=1)i[a]&&i[a].m(e,null);ie(e,t)},p(s,o){if(o&1){r=s[1];let a;for(a=0;a<r.length;a+=1){const l=l7(s,r,a);i[a]?i[a].p(l,o):(i[a]=d7(l),i[a].c(),i[a].m(e,t))}for(;a<i.length;a+=1)i[a].d(1);i.length=r.length}},d(s){s&&pe(e),os(i,s)}}}function d7(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[4]),Z(e,"class","card flex-none xl:flex-1 w-full xl:w-auto")},m(r,i){me(r,e,i)},p(r,i){i&1&&t!==(t=r[4])&&Z(e,"id",t)},d(r){r&&pe(e)}}}function p7(n){let e,t;function r(o,a){return a&1&&(e=null),e==null&&(e=!!Array.isArray(o[1])),e?Dkt:typeof o[1]=="string"?Pkt:Rkt}let i=r(n,-1),s=i(n);return{c(){s.c(),t=po()},m(o,a){s.m(o,a),me(o,t,a)},p(o,a){i===(i=r(o,a))&&s?s.p(o,a):(s.d(1),s=i(o),s&&(s.c(),s.m(t.parentNode,t)))},d(o){s.d(o),o&&pe(t)}}}function Okt(n){let e,t=n[0]&&u7(n);return{c(){t&&t.c(),e=po()},m(r,i){t&&t.m(r,i),me(r,e,i)},p(r,[i]){r[0]?t?t.p(r,i):(t=u7(r),t.c(),t.m(e.parentNode,e)):t&&(t.d(1),t=null)},i:Ze,o:Ze,d(r){t&&t.d(r),r&&pe(e)}}}function Fkt(n,e,t){let{dashboard:r}=e;return ice(()=>{r.mount()}),n.$$set=i=>{"dashboard"in i&&t(0,r=i.dashboard)},[r]}class Lkt extends gn{constructor(e){super(),mn(this,e,Fkt,Okt,hn,{dashboard:0})}}function zkt(n){let e;return{c(){e=qe("This dataset is empty")},m(t,r){me(t,e,r)},p:Ze,d(t){t&&pe(e)}}}function Bkt(n){let e,t,r,i=n[3]?"s":"",s,o;return{c(){e=qe("This dataset contains "),t=qe(n[3]),r=qe(" instance"),s=qe(i),o=qe(".")},m(a,l){me(a,e,l),me(a,t,l),me(a,r,l),me(a,s,l),me(a,o,l)},p(a,l){l&8&&cn(t,a[3]),l&8&&i!==(i=a[3]?"s":"")&&cn(s,i)},d(a){a&&pe(e),a&&pe(t),a&&pe(r),a&&pe(s),a&&pe(o)}}}function m7(n){let e,t,r,i;return e=new zi({props:{$$slots:{default:[Vkt]},$$scope:{ctx:n}}}),e.$on("click",n[4]),{c(){Ct(e.$$.fragment),t=tt(),r=we("span"),Z(r,"class","w-1")},m(s,o){xt(e,s,o),me(s,t,o),me(s,r,o),i=!0},p(s,o){const a={};o&256&&(a.$$scope={dirty:o,ctx:s}),e.$set(a)},i(s){i||(ke(e.$$.fragment,s),i=!0)},o(s){$e(e.$$.fragment,s),i=!1},d(s){_t(e,s),s&&pe(t),s&&pe(r)}}}function Vkt(n){let e;return{c(){e=qe("Download Dataset")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function Ukt(n){let e;return{c(){e=qe("Upload Dataset")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function Wkt(n){let e;return{c(){e=qe("Clear Dataset")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function Hkt(n){let e,t=n[0].title+"",r,i,s,o,a,l,c,u,h,f,d,p,m,g;function y(S,C){return S[3]?Bkt:zkt}let b=y(n),_=b(n),w=n[3]&&m7(n);return c=new zi({props:{$$slots:{default:[Ukt]},$$scope:{ctx:n}}}),c.$on("click",n[5]),m=new zi({props:{type:"danger",$$slots:{default:[Wkt]},$$scope:{ctx:n}}}),m.$on("click",n[6]),{c(){e=we("span"),r=qe(t),i=tt(),s=we("p"),_.c(),o=tt(),a=we("div"),w&&w.c(),l=tt(),Ct(c.$$.fragment),u=tt(),h=we("span"),f=tt(),d=we("input"),p=tt(),Ct(m.$$.fragment),Z(e,"class","card-title"),Z(s,"class","pb-2"),Z(h,"class","w-1"),Z(d,"type","file"),d.multiple=!0,Z(d,"class","hidden"),Z(a,"class","flex")},m(S,C){me(S,e,C),ie(e,r),me(S,i,C),me(S,s,C),_.m(s,null),me(S,o,C),me(S,a,C),w&&w.m(a,null),ie(a,l),xt(c,a,null),ie(a,u),ie(a,h),ie(a,f),ie(a,d),n[7](d),ie(a,p),xt(m,a,null),g=!0},p(S,[C]){(!g||C&1)&&t!==(t=S[0].title+"")&&cn(r,t),b===(b=y(S))&&_?_.p(S,C):(_.d(1),_=b(S),_&&(_.c(),_.m(s,null))),S[3]?w?(w.p(S,C),C&8&&ke(w,1)):(w=m7(S),w.c(),ke(w,1),w.m(a,l)):w&&(sr(),$e(w,1,1,()=>{w=null}),or());const k={};C&256&&(k.$$scope={dirty:C,ctx:S}),c.$set(k);const A={};C&256&&(A.$$scope={dirty:C,ctx:S}),m.$set(A)},i(S){g||(ke(w),ke(c.$$.fragment,S),ke(m.$$.fragment,S),g=!0)},o(S){$e(w),$e(c.$$.fragment,S),$e(m.$$.fragment,S),g=!1},d(S){S&&pe(e),S&&pe(i),S&&pe(s),_.d(),S&&pe(o),S&&pe(a),w&&w.d(),_t(c),n[7](null),_t(m)}}}function Gkt(n,e,t){let r,i,s=Ze,o=()=>(s(),s=vr(r,d=>t(3,i=d)),r);n.$$.on_destroy.push(()=>s());let{dataset:a}=e,l;function c(){a.download()}function u(){l==null||l.click()}function h(){a.clear()}$h(async()=>{await Za(),await Za(),l.addEventListener("change",d=>{const p=d.target.files,m=[];for(let g=0;g<p.length;g++)m.push(p[g]);a.upload(m)})});function f(d){Li[d?"unshift":"push"](()=>{l=d,t(1,l)})}return n.$$set=d=>{"dataset"in d&&t(0,a=d.dataset)},n.$$.update=()=>{n.$$.dirty&1&&o(t(2,r=a.$count))},[a,l,r,i,c,u,h,f]}class jkt extends gn{constructor(e){super(),mn(this,e,Gkt,Hkt,hn,{dataset:0})}}function g7(n){let e,t,r,i={ctx:n,current:null,token:null,hasCatch:!1,pending:Ykt,then:Xkt,catch:qkt,value:4,blocks:[,,,]};return Rq(t=n[0].connect(),i),{c(){e=po(),i.block.c()},m(s,o){me(s,e,o),i.block.m(s,i.anchor=o),i.mount=()=>e.parentNode,i.anchor=e,r=!0},p(s,o){n=s,i.ctx=n,o&1&&t!==(t=n[0].connect())&&Rq(t,i)||axt(i,n,o)},i(s){r||(ke(i.block),r=!0)},o(s){for(let o=0;o<3;o+=1){const a=i.blocks[o];$e(a)}r=!1},d(s){s&&pe(e),i.block.d(s),i.token=null,i=null}}}function qkt(n){return{c:Ze,m:Ze,p:Ze,i:Ze,o:Ze,d:Ze}}function Xkt(n){let e,t,r=n[4].email+"",i,s,o,a,l;return a=new zi({props:{$$slots:{default:[Kkt]},$$scope:{ctx:n}}}),a.$on("click",n[3]),{c(){e=we("p"),t=qe("Hello, "),i=qe(r),s=tt(),o=we("div"),Ct(a.$$.fragment),Z(e,"class","pb-2"),Z(o,"class","flex")},m(c,u){me(c,e,u),ie(e,t),ie(e,i),me(c,s,u),me(c,o,u),xt(a,o,null),l=!0},p(c,u){(!l||u&1)&&r!==(r=c[4].email+"")&&cn(i,r);const h={};u&32&&(h.$$scope={dirty:u,ctx:c}),a.$set(h)},i(c){l||(ke(a.$$.fragment,c),l=!0)},o(c){$e(a.$$.fragment,c),l=!1},d(c){c&&pe(e),c&&pe(s),c&&pe(o),_t(a)}}}function Kkt(n){let e;return{c(){e=qe("Log out")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function Ykt(n){let e,t;return e=new PV({}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p:Ze,i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function y7(n){let e,t,r=n[2].join(", ")+"",i;return{c(){e=we("div"),t=qe("This data store contains the following services: "),i=qe(r)},m(s,o){me(s,e,o),ie(e,t),ie(e,i)},p(s,o){o&4&&r!==(r=s[2].join(", ")+"")&&cn(i,r)},d(s){s&&pe(e)}}}function Zkt(n){let e,t,r,i=n[0].requiresAuth&&g7(n),s=n[2]&&y7(n);return{c(){i&&i.c(),e=tt(),s&&s.c(),t=po()},m(o,a){i&&i.m(o,a),me(o,e,a),s&&s.m(o,a),me(o,t,a),r=!0},p(o,a){o[0].requiresAuth?i?(i.p(o,a),a&1&&ke(i,1)):(i=g7(o),i.c(),ke(i,1),i.m(e.parentNode,e)):i&&(sr(),$e(i,1,1,()=>{i=null}),or()),o[2]?s?s.p(o,a):(s=y7(o),s.c(),s.m(t.parentNode,t)):s&&(s.d(1),s=null)},i(o){r||(ke(i),r=!0)},o(o){$e(i),r=!1},d(o){i&&i.d(o),o&&pe(e),s&&s.d(o),o&&pe(t)}}}function Jkt(n){let e,t;return e=new Ao({props:{title:"data store ("+n[0].location+")",$$slots:{default:[Zkt]},$$scope:{ctx:n}}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,[i]){const s={};i&1&&(s.title="data store ("+r[0].location+")"),i&37&&(s.$$scope={dirty:i,ctx:r}),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function Qkt(n,e,t){let r,i,s=Ze,o=()=>(s(),s=vr(r,c=>t(2,i=c)),r);n.$$.on_destroy.push(()=>s());let{dataStore:a}=e;function l(){a.logout()}return n.$$set=c=>{"dataStore"in c&&t(0,a=c.dataStore)},n.$$.update=()=>{n.$$.dirty&1&&o(t(1,r=a.$services))},[a,r,i,l]}class eTt extends gn{constructor(e){super(),mn(this,e,Qkt,Jkt,hn,{dataStore:0})}}function tTt(n){let e;return{c(){e=qe("Download Model")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function nTt(n){let e;return{c(){e=qe("Upload Model")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function rTt(n){let e,t=n[0].title+"",r,i,s,o,a,l,c,u,h,f,d;return o=new zi({props:{$$slots:{default:[tTt]},$$scope:{ctx:n}}}),o.$on("click",n[2]),f=new zi({props:{$$slots:{default:[nTt]},$$scope:{ctx:n}}}),f.$on("click",n[3]),{c(){e=we("span"),r=qe(t),i=tt(),s=we("div"),Ct(o.$$.fragment),a=tt(),l=we("span"),c=tt(),u=we("input"),h=tt(),Ct(f.$$.fragment),Z(e,"class","card-title"),Z(l,"class","w-1"),Z(u,"type","file"),u.multiple=!0,Z(u,"class","hidden"),Z(s,"class","flex")},m(p,m){me(p,e,m),ie(e,r),me(p,i,m),me(p,s,m),xt(o,s,null),ie(s,a),ie(s,l),ie(s,c),ie(s,u),n[4](u),ie(s,h),xt(f,s,null),d=!0},p(p,[m]){(!d||m&1)&&t!==(t=p[0].title+"")&&cn(r,t);const g={};m&32&&(g.$$scope={dirty:m,ctx:p}),o.$set(g);const y={};m&32&&(y.$$scope={dirty:m,ctx:p}),f.$set(y)},i(p){d||(ke(o.$$.fragment,p),ke(f.$$.fragment,p),d=!0)},o(p){$e(o.$$.fragment,p),$e(f.$$.fragment,p),d=!1},d(p){p&&pe(e),p&&pe(i),p&&pe(s),_t(o),n[4](null),_t(f)}}}function eD(n){return"download"in n}function iTt(n,e,t){let{model:r}=e,i;function s(){eD(r)?r.download():Co(new Error("This model cannot be saved"))}function o(){eD(r)?i==null||i.click():Co(new Error("This model cannot be uploaded"))}$h(async()=>{await Za(),await Za(),i.addEventListener("change",l=>{const c=l.target.files,u=[];for(let h=0;h<c.length;h++)u.push(c[h]);eD(r)&&r.upload(...u)})});function a(l){Li[l?"unshift":"push"](()=>{i=l,t(1,i)})}return n.$$set=l=>{"model"in l&&t(0,r=l.model)},[r,i,s,o,a]}class sTt extends gn{constructor(e){super(),mn(this,e,iTt,rTt,hn,{model:0})}}function oTt(n){let e;return{c(){e=qe("This batch prediction component is empty")},m(t,r){me(t,e,r)},p:Ze,d(t){t&&pe(e)}}}function aTt(n){let e,t,r,i=n[3]?"s":"",s;return{c(){e=qe(`This batch prediction component contains
    `),t=qe(n[3]),r=qe(`
    prediction`),s=qe(i)},m(o,a){me(o,e,a),me(o,t,a),me(o,r,a),me(o,s,a)},p(o,a){a&8&&cn(t,o[3]),a&8&&i!==(i=o[3]?"s":"")&&cn(s,i)},d(o){o&&pe(e),o&&pe(t),o&&pe(r),o&&pe(s)}}}function b7(n){let e,t,r,i;return e=new zi({props:{$$slots:{default:[lTt]},$$scope:{ctx:n}}}),e.$on("click",n[4]),{c(){Ct(e.$$.fragment),t=tt(),r=we("span"),Z(r,"class","w-1")},m(s,o){xt(e,s,o),me(s,t,o),me(s,r,o),i=!0},p(s,o){const a={};o&256&&(a.$$scope={dirty:o,ctx:s}),e.$set(a)},i(s){i||(ke(e.$$.fragment,s),i=!0)},o(s){$e(e.$$.fragment,s),i=!1},d(s){_t(e,s),s&&pe(t),s&&pe(r)}}}function lTt(n){let e;return{c(){e=qe("Download Predictions")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function cTt(n){let e;return{c(){e=qe("Upload Predictions")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function uTt(n){let e;return{c(){e=qe("Clear Predictions")},m(t,r){me(t,e,r)},d(t){t&&pe(e)}}}function hTt(n){let e,t=n[0].title+"",r,i,s,o,a,l,c,u,h,f,d,p,m,g;function y(S,C){return S[3]?aTt:oTt}let b=y(n),_=b(n),w=n[3]&&b7(n);return c=new zi({props:{$$slots:{default:[cTt]},$$scope:{ctx:n}}}),c.$on("click",n[5]),m=new zi({props:{type:"danger",$$slots:{default:[uTt]},$$scope:{ctx:n}}}),m.$on("click",n[6]),{c(){e=we("span"),r=qe(t),i=tt(),s=we("p"),_.c(),o=tt(),a=we("div"),w&&w.c(),l=tt(),Ct(c.$$.fragment),u=tt(),h=we("span"),f=tt(),d=we("input"),p=tt(),Ct(m.$$.fragment),Z(e,"class","card-title"),Z(s,"class","pb-2"),Z(h,"class","w-1"),Z(d,"type","file"),d.multiple=!0,Z(d,"class","hidden"),Z(a,"class","flex")},m(S,C){me(S,e,C),ie(e,r),me(S,i,C),me(S,s,C),_.m(s,null),me(S,o,C),me(S,a,C),w&&w.m(a,null),ie(a,l),xt(c,a,null),ie(a,u),ie(a,h),ie(a,f),ie(a,d),n[7](d),ie(a,p),xt(m,a,null),g=!0},p(S,[C]){(!g||C&1)&&t!==(t=S[0].title+"")&&cn(r,t),b===(b=y(S))&&_?_.p(S,C):(_.d(1),_=b(S),_&&(_.c(),_.m(s,null))),S[3]?w?(w.p(S,C),C&8&&ke(w,1)):(w=b7(S),w.c(),ke(w,1),w.m(a,l)):w&&(sr(),$e(w,1,1,()=>{w=null}),or());const k={};C&256&&(k.$$scope={dirty:C,ctx:S}),c.$set(k);const A={};C&256&&(A.$$scope={dirty:C,ctx:S}),m.$set(A)},i(S){g||(ke(w),ke(c.$$.fragment,S),ke(m.$$.fragment,S),g=!0)},o(S){$e(w),$e(c.$$.fragment,S),$e(m.$$.fragment,S),g=!1},d(S){S&&pe(e),S&&pe(i),S&&pe(s),_.d(),S&&pe(o),S&&pe(a),w&&w.d(),_t(c),n[7](null),_t(m)}}}function fTt(n,e,t){let r,i,s=Ze,o=()=>(s(),s=vr(r,d=>t(3,i=d)),r);n.$$.on_destroy.push(()=>s());let{prediction:a}=e,l;function c(){a.download()}function u(){l==null||l.click()}function h(){a.clear()}$h(async()=>{await Za(),await Za(),l.addEventListener("change",d=>{const p=d.target.files,m=[];for(let g=0;g<p.length;g++)m.push(p[g]);a.upload(m)})});function f(d){Li[d?"unshift":"push"](()=>{l=d,t(1,l)})}return n.$$set=d=>{"prediction"in d&&t(0,a=d.prediction)},n.$$.update=()=>{n.$$.dirty&1&&o(t(2,r=a.$count))},[a,l,r,i,c,u,h,f]}class dTt extends gn{constructor(e){super(),mn(this,e,fTt,hTt,hn,{prediction:0})}}function v7(n,e,t){const r=n.slice();return r[1]=e[t],r}function w7(n,e,t){const r=n.slice();return r[4]=e[t].id,r}function x7(n,e,t){const r=n.slice();return r[7]=e[t],r}function _7(n,e,t){const r=n.slice();return r[10]=e[t],r}function S7(n,e,t){const r=n.slice();return r[13]=e[t],r}function C7(n,e,t){const r=n.slice();return r[16]=e[t],r}function k7(n){let e,t,r,i,s,o,a,l,c,u,h,f,d,p,m,g=n[0].xDataStores,y=[];for(let D=0;D<g.length;D+=1)y[D]=T7(C7(n,g,D));const b=D=>$e(y[D],1,1,()=>{y[D]=null});let _=n[0].xModels,w=[];for(let D=0;D<_.length;D+=1)w[D]=E7(S7(n,_,D));const S=D=>$e(w[D],1,1,()=>{w[D]=null});let C=n[0].xDatasets,k=[];for(let D=0;D<C.length;D+=1)k[D]=I7(_7(n,C,D));const A=D=>$e(k[D],1,1,()=>{k[D]=null});let M=n[0].xPredictions,E=[];for(let D=0;D<M.length;D+=1)E[D]=A7(x7(n,M,D));const N=D=>$e(E[D],1,1,()=>{E[D]=null});let O=n[0].components,R=[];for(let D=0;D<O.length;D+=1)R[D]=N7(v7(n,O,D));return{c(){e=we("div"),t=we("h2"),t.textContent="Data Stores",r=tt();for(let D=0;D<y.length;D+=1)y[D].c();i=tt(),s=we("h2"),s.textContent="Models",o=tt();for(let D=0;D<w.length;D+=1)w[D].c();a=tt(),l=we("h2"),l.textContent="Datasets",c=tt();for(let D=0;D<k.length;D+=1)k[D].c();u=tt(),h=we("h2"),h.textContent="Predictions",f=tt();for(let D=0;D<E.length;D+=1)E[D].c();d=tt(),p=we("div");for(let D=0;D<R.length;D+=1)R[D].c();Z(e,"class","left svelte-inuorr"),Z(p,"class","right svelte-inuorr")},m(D,z){me(D,e,z),ie(e,t),ie(e,r);for(let B=0;B<y.length;B+=1)y[B]&&y[B].m(e,null);ie(e,i),ie(e,s),ie(e,o);for(let B=0;B<w.length;B+=1)w[B]&&w[B].m(e,null);ie(e,a),ie(e,l),ie(e,c);for(let B=0;B<k.length;B+=1)k[B]&&k[B].m(e,null);ie(e,u),ie(e,h),ie(e,f);for(let B=0;B<E.length;B+=1)E[B]&&E[B].m(e,null);me(D,d,z),me(D,p,z);for(let B=0;B<R.length;B+=1)R[B]&&R[B].m(p,null);m=!0},p(D,z){if(z&1){g=D[0].xDataStores;let B;for(B=0;B<g.length;B+=1){const X=C7(D,g,B);y[B]?(y[B].p(X,z),ke(y[B],1)):(y[B]=T7(X),y[B].c(),ke(y[B],1),y[B].m(e,i))}for(sr(),B=g.length;B<y.length;B+=1)b(B);or()}if(z&1){_=D[0].xModels;let B;for(B=0;B<_.length;B+=1){const X=S7(D,_,B);w[B]?(w[B].p(X,z),ke(w[B],1)):(w[B]=E7(X),w[B].c(),ke(w[B],1),w[B].m(e,a))}for(sr(),B=_.length;B<w.length;B+=1)S(B);or()}if(z&1){C=D[0].xDatasets;let B;for(B=0;B<C.length;B+=1){const X=_7(D,C,B);k[B]?(k[B].p(X,z),ke(k[B],1)):(k[B]=I7(X),k[B].c(),ke(k[B],1),k[B].m(e,u))}for(sr(),B=C.length;B<k.length;B+=1)A(B);or()}if(z&1){M=D[0].xPredictions;let B;for(B=0;B<M.length;B+=1){const X=x7(D,M,B);E[B]?(E[B].p(X,z),ke(E[B],1)):(E[B]=A7(X),E[B].c(),ke(E[B],1),E[B].m(e,null))}for(sr(),B=M.length;B<E.length;B+=1)N(B);or()}if(z&1){O=D[0].components;let B;for(B=0;B<O.length;B+=1){const X=v7(D,O,B);R[B]?R[B].p(X,z):(R[B]=N7(X),R[B].c(),R[B].m(p,null))}for(;B<R.length;B+=1)R[B].d(1);R.length=O.length}},i(D){if(!m){for(let z=0;z<g.length;z+=1)ke(y[z]);for(let z=0;z<_.length;z+=1)ke(w[z]);for(let z=0;z<C.length;z+=1)ke(k[z]);for(let z=0;z<M.length;z+=1)ke(E[z]);m=!0}},o(D){y=y.filter(Boolean);for(let z=0;z<y.length;z+=1)$e(y[z]);w=w.filter(Boolean);for(let z=0;z<w.length;z+=1)$e(w[z]);k=k.filter(Boolean);for(let z=0;z<k.length;z+=1)$e(k[z]);E=E.filter(Boolean);for(let z=0;z<E.length;z+=1)$e(E[z]);m=!1},d(D){D&&pe(e),os(y,D),os(w,D),os(k,D),os(E,D),D&&pe(d),D&&pe(p),os(R,D)}}}function T7(n){let e,t,r;return t=new eTt({props:{dataStore:n[16]}}),{c(){e=we("div"),Ct(t.$$.fragment),Z(e,"class","card")},m(i,s){me(i,e,s),xt(t,e,null),r=!0},p(i,s){const o={};s&1&&(o.dataStore=i[16]),t.$set(o)},i(i){r||(ke(t.$$.fragment,i),r=!0)},o(i){$e(t.$$.fragment,i),r=!1},d(i){i&&pe(e),_t(t)}}}function E7(n){let e,t,r;return t=new sTt({props:{model:n[13]}}),{c(){e=we("div"),Ct(t.$$.fragment),Z(e,"class","card")},m(i,s){me(i,e,s),xt(t,e,null),r=!0},p(i,s){const o={};s&1&&(o.model=i[13]),t.$set(o)},i(i){r||(ke(t.$$.fragment,i),r=!0)},o(i){$e(t.$$.fragment,i),r=!1},d(i){i&&pe(e),_t(t)}}}function I7(n){let e,t,r;return t=new jkt({props:{dataset:n[10]}}),{c(){e=we("div"),Ct(t.$$.fragment),Z(e,"class","card")},m(i,s){me(i,e,s),xt(t,e,null),r=!0},p(i,s){const o={};s&1&&(o.dataset=i[10]),t.$set(o)},i(i){r||(ke(t.$$.fragment,i),r=!0)},o(i){$e(t.$$.fragment,i),r=!1},d(i){i&&pe(e),_t(t)}}}function A7(n){let e,t,r,i;return t=new dTt({props:{prediction:n[7]}}),{c(){e=we("div"),Ct(t.$$.fragment),r=tt(),Z(e,"class","card")},m(s,o){me(s,e,o),xt(t,e,null),ie(e,r),i=!0},p(s,o){const a={};o&1&&(a.prediction=s[7]),t.$set(a)},i(s){i||(ke(t.$$.fragment,s),i=!0)},o(s){$e(t.$$.fragment,s),i=!1},d(s){s&&pe(e),_t(t)}}}function pTt(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[1].id),Z(e,"class","card")},m(r,i){me(r,e,i)},p(r,i){i&1&&t!==(t=r[1].id)&&Z(e,"id",t)},d(r){r&&pe(e)}}}function mTt(n){let e,t=n[1]+"",r;return{c(){e=we("h2"),r=qe(t)},m(i,s){me(i,e,s),ie(e,r)},p(i,s){s&1&&t!==(t=i[1]+"")&&cn(r,t)},d(i){i&&pe(e)}}}function gTt(n){let e,t,r=n[1],i=[];for(let s=0;s<r.length;s+=1)i[s]=M7(w7(n,r,s));return{c(){e=we("div");for(let s=0;s<i.length;s+=1)i[s].c();t=tt(),Z(e,"class","flex flex-row flex-wrap items-stretch")},m(s,o){me(s,e,o);for(let a=0;a<i.length;a+=1)i[a]&&i[a].m(e,null);ie(e,t)},p(s,o){if(o&1){r=s[1];let a;for(a=0;a<r.length;a+=1){const l=w7(s,r,a);i[a]?i[a].p(l,o):(i[a]=M7(l),i[a].c(),i[a].m(e,t))}for(;a<i.length;a+=1)i[a].d(1);i.length=r.length}},d(s){s&&pe(e),os(i,s)}}}function M7(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[4]),Z(e,"class","card flex-none xl:flex-1 w-full xl:w-auto")},m(r,i){me(r,e,i)},p(r,i){i&1&&t!==(t=r[4])&&Z(e,"id",t)},d(r){r&&pe(e)}}}function N7(n){let e,t;function r(o,a){return a&1&&(e=null),e==null&&(e=!!Array.isArray(o[1])),e?gTt:typeof o[1]=="string"?mTt:pTt}let i=r(n,-1),s=i(n);return{c(){s.c(),t=po()},m(o,a){s.m(o,a),me(o,t,a)},p(o,a){i===(i=r(o,a))&&s?s.p(o,a):(s.d(1),s=i(o),s&&(s.c(),s.m(t.parentNode,t)))},d(o){s.d(o),o&&pe(t)}}}function yTt(n){let e,t,r=n[0]&&k7(n);return{c(){r&&r.c(),e=po()},m(i,s){r&&r.m(i,s),me(i,e,s),t=!0},p(i,[s]){i[0]?r?(r.p(i,s),s&1&&ke(r,1)):(r=k7(i),r.c(),ke(r,1),r.m(e.parentNode,e)):r&&(sr(),$e(r,1,1,()=>{r=null}),or())},i(i){t||(ke(r),t=!0)},o(i){$e(r),t=!1},d(i){r&&r.d(i),i&&pe(e)}}}function bTt(n,e,t){let{settings:r}=e;return ice(()=>{r.mount()}),n.$$set=i=>{"settings"in i&&t(0,r=i.settings)},[r]}let vTt=class extends gn{constructor(e){super(),mn(this,e,bTt,yTt,hn,{settings:0})}};function $7(n,e,t){const r=n.slice();return r[8]=e[t][0],r[9]=e[t][1],r[11]=t,r}function R7(n){let e,t=n[9]+"",r,i,s;return{c(){e=we("a"),r=qe(t),i=tt(),Z(e,"href",s=`#${n[8]}`),Z(e,"class","ml-2 mr-5 flex items-center hover:text-black border-solid border-0 border-b-2 border-transparent svelte-1ut593v"),Wt(e,"active",!n[4]&&n[2]===n[9])},m(o,a){me(o,e,a),ie(e,r),ie(e,i)},p(o,a){a&2&&t!==(t=o[9]+"")&&cn(r,t),a&2&&s!==(s=`#${o[8]}`)&&Z(e,"href",s),a&22&&Wt(e,"active",!o[4]&&o[2]===o[9])},d(o){o&&pe(e)}}}function wTt(n){let e,t,r;return{c(){e=bi("svg"),t=bi("circle"),r=bi("path"),Z(t,"cx","12"),Z(t,"cy","12"),Z(t,"r","3"),Z(r,"d","M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"width","24"),Z(e,"height","24"),Z(e,"viewBox","0 0 24 24"),Z(e,"fill","none"),Z(e,"stroke","currentColor"),Z(e,"stroke-width","2"),Z(e,"stroke-linecap","round"),Z(e,"stroke-linejoin","round"),Z(e,"class","feather feather-settings")},m(i,s){me(i,e,s),ie(e,t),ie(e,r)},p:Ze,d(i){i&&pe(e)}}}function P7(n){let e,t,r,i;return e=new zi({props:{round:!0,type:"danger",$$slots:{default:[xTt]},$$scope:{ctx:n}}}),e.$on("click",n[5]),{c(){Ct(e.$$.fragment),t=tt(),r=we("span"),Z(r,"class","w-1")},m(s,o){xt(e,s,o),me(s,t,o),me(s,r,o),i=!0},p(s,o){const a={};o&4096&&(a.$$scope={dirty:o,ctx:s}),e.$set(a)},i(s){i||(ke(e.$$.fragment,s),i=!0)},o(s){$e(e.$$.fragment,s),i=!1},d(s){_t(e,s),s&&pe(t),s&&pe(r)}}}function xTt(n){let e,t,r;return{c(){e=bi("svg"),t=bi("path"),r=bi("line"),Z(t,"d","M18.36 6.64a9 9 0 1 1-12.73 0"),Z(r,"x1","12"),Z(r,"y1","2"),Z(r,"x2","12"),Z(r,"y2","12"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"width","24"),Z(e,"height","24"),Z(e,"viewBox","0 0 24 24"),Z(e,"fill","none"),Z(e,"stroke","currentColor"),Z(e,"stroke-width","2"),Z(e,"stroke-linecap","round"),Z(e,"stroke-linejoin","round"),Z(e,"class","feather feather-power")},m(i,s){me(i,e,s),ie(e,t),ie(e,r)},p:Ze,d(i){i&&pe(e)}}}function _Tt(n){let e,t,r,i,s,o,a,l,c,u,h,f,d,p,m=Object.entries(n[1]),g=[];for(let b=0;b<m.length;b+=1)g[b]=R7($7(n,m,b));u=new zi({props:{round:!0,$$slots:{default:[wTt]},$$scope:{ctx:n}}}),u.$on("click",n[6]);let y=n[3]&&P7(n);return{c(){e=we("header"),t=we("div"),r=we("a"),i=we("span"),s=qe(n[0]),o=tt(),a=we("nav");for(let b=0;b<g.length;b+=1)g[b].c();l=tt(),c=we("div"),Ct(u.$$.fragment),h=tt(),f=we("span"),d=tt(),y&&y.c(),Z(i,"class","mx-3 text-lg"),Z(r,"href","#/"),Z(r,"class","flex p-3 title-font font-medium items-center text-gray-900 mb-4 md:mb-0 border-solid border-0 border-r border-gray-200 svelte-1ut593v"),Z(a,"class","flex items-stretch justify-start flex-wrap text-base grow mx-4"),Z(f,"class","w-1"),Z(c,"class","flex items-center"),Z(t,"class","mx-auto flex flex-wrap flex-col md:flex-row items-stretch w-full"),Z(e,"class","bg-white text-gray-700 body-font")},m(b,_){me(b,e,_),ie(e,t),ie(t,r),ie(r,i),ie(i,s),ie(t,o),ie(t,a);for(let w=0;w<g.length;w+=1)g[w]&&g[w].m(a,null);ie(t,l),ie(t,c),xt(u,c,null),ie(c,h),ie(c,f),ie(c,d),y&&y.m(c,null),p=!0},p(b,[_]){if((!p||_&1)&&cn(s,b[0]),_&22){m=Object.entries(b[1]);let S;for(S=0;S<m.length;S+=1){const C=$7(b,m,S);g[S]?g[S].p(C,_):(g[S]=R7(C),g[S].c(),g[S].m(a,null))}for(;S<g.length;S+=1)g[S].d(1);g.length=m.length}const w={};_&4096&&(w.$$scope={dirty:_,ctx:b}),u.$set(w),b[3]?y?(y.p(b,_),_&8&&ke(y,1)):(y=P7(b),y.c(),ke(y,1),y.m(c,null)):y&&(sr(),$e(y,1,1,()=>{y=null}),or())},i(b){p||(ke(u.$$.fragment,b),ke(y),p=!0)},o(b){$e(u.$$.fragment,b),$e(y),p=!1},d(b){b&&pe(e),os(g,b),_t(u),y&&y.d()}}}function STt(n,e,t){let{title:r}=e,{items:i}=e,{current:s}=e,{closable:o}=e,{showSettings:a=!1}=e;const l=Oc();function c(){a?window.location.href=window.location.href.split("#")[0]+"#"+Object.keys(i)[Object.values(i).indexOf(s)]:window.location.href=window.location.href.split("#")[0]+"#settings"}function u(){setTimeout(()=>{l("quit")},400)}return n.$$set=h=>{"title"in h&&t(0,r=h.title),"items"in h&&t(1,i=h.items),"current"in h&&t(2,s=h.current),"closable"in h&&t(3,o=h.closable),"showSettings"in h&&t(4,a=h.showSettings)},[r,i,s,o,a,u,c]}class CTt extends gn{constructor(e){super(),mn(this,e,STt,_Tt,hn,{title:0,items:1,current:2,closable:3,showSettings:4,quit:5})}get quit(){return this.$$.ctx[5]}}function kTt(n){let e;return{c(){e=qe(" ")},m(t,r){me(t,e,r)},p:Ze,d(t){t&&pe(e)}}}function TTt(n){let e;function t(s,o){return s[1][0]===bc.Warning?ATt:s[1][0]===bc.Error?ITt:ETt}let r=t(n),i=r(n);return{c(){i.c(),e=po()},m(s,o){i.m(s,o),me(s,e,o)},p(s,o){r===(r=t(s))&&i?i.p(s,o):(i.d(1),i=r(s),i&&(i.c(),i.m(e.parentNode,e)))},d(s){i.d(s),s&&pe(e)}}}function ETt(n){let e=(n[1][1]||"")+"",t;return{c(){t=qe(e)},m(r,i){me(r,t,i)},p(r,i){i&2&&e!==(e=(r[1][1]||"")+"")&&cn(t,e)},d(r){r&&pe(t)}}}function ITt(n){let e,t=(n[1][1]||"")+"",r;return{c(){e=qe(`Err:
        `),r=qe(t)},m(i,s){me(i,e,s),me(i,r,s)},p(i,s){s&2&&t!==(t=(i[1][1]||"")+"")&&cn(r,t)},d(i){i&&pe(e),i&&pe(r)}}}function ATt(n){let e,t=(n[1][1]||"")+"",r;return{c(){e=qe(`Warn:
        `),r=qe(t)},m(i,s){me(i,e,s),me(i,r,s)},p(i,s){s&2&&t!==(t=(i[1][1]||"")+"")&&cn(r,t)},d(i){i&&pe(e),i&&pe(r)}}}function MTt(n){let e,t,r,i,s,o;function a(u,h){return u[1]?TTt:kTt}let l=a(n),c=l(n);return{c(){e=we("footer"),t=we("p"),c.c(),r=tt(),i=we("p"),s=qe("© 2021 "),o=qe(n[0]),Z(t,"class","console svelte-i04gf3"),Wt(t,"error",n[1]&&n[1][0]===bc.Error),Wt(t,"warning",n[1]&&n[1][0]===bc.Warning),Z(i,"class","text-sm text-gray-500 sm:ml-4 sm:pl-4 sm:border-gray-200"),Z(e,"class","bg-white text-gray-600 border-t px-5 py-1 flex items-center justify-between flex-col sm:flex-row")},m(u,h){me(u,e,h),ie(e,t),c.m(t,null),ie(e,r),ie(e,i),ie(i,s),ie(i,o)},p(u,[h]){l===(l=a(u))&&c?c.p(u,h):(c.d(1),c=l(u),c&&(c.c(),c.m(t,null))),h&2&&Wt(t,"error",u[1]&&u[1][0]===bc.Error),h&2&&Wt(t,"warning",u[1]&&u[1][0]===bc.Warning),h&1&&cn(o,u[0])},i:Ze,o:Ze,d(u){u&&pe(e),c.d()}}}function NTt(n,e,t){let r,{author:i}=e;const s=D1t();return AV(n,s,o=>t(1,r=o)),n.$$set=o=>{"author"in o&&t(0,i=o.author)},[i,r,s]}class $Tt extends gn{constructor(e){super(),mn(this,e,NTt,MTt,hn,{author:0})}}function D7(n){let e,t,r,i,s,o,a,l,c,u,h;r=new CTt({props:{title:n[0],items:n[10].reduce(n[12],{}),current:n[9],showSettings:n[8],closable:n[4]}}),r.$on("quit",n[5]);const f=[PTt,RTt],d=[];function p(m,g){return m[8]?0:m[9]?1:-1}return~(o=p(n))&&(a=d[o]=f[o](n)),c=new $Tt({props:{author:n[1]}}),{c(){e=we("div"),t=we("div"),Ct(r.$$.fragment),i=tt(),s=we("main"),a&&a.c(),l=tt(),Ct(c.$$.fragment),Z(s,"class","main-container svelte-1da5cws"),Z(t,"class","app-container svelte-1da5cws"),Z(e,"class","marcelle fixed h-screen w-full max-w-full overflow-y-scroll overflow-x-hidden top-0 left-0 z-50")},m(m,g){me(m,e,g),ie(e,t),xt(r,t,null),ie(t,i),ie(t,s),~o&&d[o].m(s,null),ie(t,l),xt(c,t,null),h=!0},p(m,g){n=m;const y={};g&1&&(y.title=n[0]),g&1088&&(y.items=n[10].reduce(n[12],{})),g&512&&(y.current=n[9]),g&256&&(y.showSettings=n[8]),g&16&&(y.closable=n[4]),r.$set(y);let b=o;o=p(n),o===b?~o&&d[o].p(n,g):(a&&(sr(),$e(d[b],1,1,()=>{d[b]=null}),or()),~o?(a=d[o],a?a.p(n,g):(a=d[o]=f[o](n),a.c()),ke(a,1),a.m(s,null)):a=null);const _={};g&2&&(_.author=n[1]),c.$set(_)},i(m){h||(ke(r.$$.fragment,m),ke(a),ke(c.$$.fragment,m),Rc(()=>{h&&(u||(u=Cv(t,hM,{amount:10,duration:n[4]?400:0},!0)),u.run(1))}),h=!0)},o(m){$e(r.$$.fragment,m),$e(a),$e(c.$$.fragment,m),u||(u=Cv(t,hM,{amount:10,duration:n[4]?400:0},!1)),u.run(0),h=!1},d(m){m&&pe(e),_t(r),~o&&d[o].d(),_t(c),m&&u&&u.end()}}}function RTt(n){let e,t;return e=new Lkt({props:{dashboard:n[2][n[9]]}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,i){const s={};i&516&&(s.dashboard=r[2][r[9]]),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function PTt(n){let e,t;return e=new vTt({props:{settings:n[3]}}),{c(){Ct(e.$$.fragment)},m(r,i){xt(e,r,i),t=!0},p(r,i){const s={};i&8&&(s.settings=r[3]),e.$set(s)},i(r){t||(ke(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){_t(e,r)}}}function DTt(n){let e,t,r,i;document.title=e=n[0];let s=n[7]&&D7(n);return{c(){t=tt(),s&&s.c(),r=po()},m(o,a){me(o,t,a),s&&s.m(o,a),me(o,r,a),i=!0},p(o,[a]){(!i||a&1)&&e!==(e=o[0])&&(document.title=e),o[7]?s?(s.p(o,a),a&128&&ke(s,1)):(s=D7(o),s.c(),ke(s,1),s.m(r.parentNode,r)):s&&(sr(),$e(s,1,1,()=>{s=null}),or())},i(o){i||(ke(s),i=!0)},o(o){$e(s),i=!1},d(o){o&&pe(t),s&&s.d(o),o&&pe(r)}}}function O7(n){let e=n.replace(/^\s+|\s+$/g,"");e=e.toLowerCase();const t="àáäâèéëêìíïîòóöôùúüûñç·/_,:;",r="aaaaeeeeiiiioooouuuunc------";for(let i=0,s=t.length;i<s;i++)e=e.replace(new RegExp(t.charAt(i),"g"),r.charAt(i));return e=e.replace(/[^a-z0-9 -]/g,"").replace(/\s+/g,"-").replace(/-+/g,"-"),e}function OTt(n,e,t){let r,i;const s=Oc();let{title:o}=e,{author:a}=e,{dashboards:l={}}=e,{settings:c}=e,{page:u}=e,{closable:h}=e,f=!1;$h(()=>{t(7,f=!0)});function d(){t(7,f=!1),setTimeout(()=>{s("quit")},400)}let p=!1,m=Object.keys(l)[0]||void 0;$h(()=>{try{const y=new $kt;y.route("settings",()=>{t(8,p=!0),m&&l[m].destroy(),u.set("settings")}),i.forEach((b,_)=>{y.route(b,()=>{t(8,p=!1),m!==r[_]&&(m&&l[m].destroy(),t(9,m=r[_]),u.set(b===""?O7(r[0]):b))})})}catch(y){console.log("Could not enable router",y)}});const g=(y,b,_)=>({...y,[b]:r[_]});return n.$$set=y=>{"title"in y&&t(0,o=y.title),"author"in y&&t(1,a=y.author),"dashboards"in y&&t(2,l=y.dashboards),"settings"in y&&t(3,c=y.settings),"page"in y&&t(11,u=y.page),"closable"in y&&t(4,h=y.closable)},n.$$.update=()=>{n.$$.dirty&4&&t(6,r=Object.keys(l)),n.$$.dirty&64&&t(10,i=[""].concat(r.slice(1).map(O7)))},[o,a,l,c,h,d,r,f,p,m,i,u,g]}let FTt=class extends gn{constructor(e){super(),mn(this,e,OTt,DTt,hn,{title:0,author:1,dashboards:2,settings:3,page:11,closable:4,quit:5})}get quit(){return this.$$.ctx[5]}};function F7(n){return typeof n=="string"}function L7(n){return Array.isArray(n)}class LTt{constructor(){this.name="settings",this.components=[],this.xModels=[],this.xDatasets=[],this.xPredictions=[],this.xDataStores=[]}use(...e){return this.components=this.components.concat(e),this}dataStores(...e){return this.xDataStores=e,this}models(...e){return this.xModels=e,this}datasets(...e){return this.xDatasets=e,this}predictions(...e){return this.xPredictions=e,this}mount(){for(const e of this.components)if(L7(e))for(const t of e)t.mount();else F7(e)||e.mount()}destroy(){for(const e of this.components)if(L7(e))for(const t of e)t.destroy();else F7(e)||e.destroy()}}class zTt{constructor({title:e="Hello, Marcelle!",author:t="author",closable:r=!1}){this.panels={},this.settings=new LTt,this.$active=new ct(!1,!0),this.$page=new ct("",!0),this.title=e,this.author=t,this.closable=r}page(e,t){return Object.keys(this.panels).includes(e)||(this.panels[e]=new Ikt(e,t)),this.panels[e]}show(){this.app=new FTt({target:document.body,props:{title:this.title,author:this.author,dashboards:this.panels,settings:this.settings,page:this.$page,closable:this.closable}}),this.$active.set(!0),this.app.$on("quit",()=>{var e;this.$active.set(!1),(e=this.app)===null||e===void 0||e.$destroy();for(const t of Object.values(this.panels))t.destroy();this.app=void 0})}hide(){var e;(e=this.app)===null||e===void 0||e.quit()}}function BTt(n){return new zTt(n)}const pM=Ekt(),jce=q2t(),jV=ACt();jV.title="Label";const qV=HV("Hold to record");qV.title="Collect images with label";const W$=LV("localStorage"),KC=h_t("training-set-dashboard",W$),qce=y2t(KC);qce.title="Training set";pM.$images.filter(()=>qV.$pressed.get()).map(async n=>({x:await jce.process(n),thumbnail:pM.$thumbnails.get(),y:jV.$value.get()})).awaitPromises().subscribe(KC.create);const H$=HV("Train");H$.title="Train the neural network";const Rh=B2t({layers:[64,32],epochs:20}).sync(W$,"mlp-dashboard");H$.$click.subscribe(()=>Rh.train(KC));const Xce=lCt(Rh);Xce.title="Neural network parameter";const Kce=ESt(Rh);Kce.title="Progress";const Yce=Gce(Rh);Yce.title="Learning curve";const mM=ASt("mlp",W$);l2t(mM);const VTt=HV("Update predictions");VTt.$click.subscribe(async()=>{Rh.ready||Co(new Error("No classifier has been trained")),await mM.clear(),await mM.predict(Rh,KC)});const z7=UCt("toggle prediction");z7.$checked.subscribe(n=>{n&&!Rh.ready&&(Co(new Error("No classifier has been trained")),setTimeout(()=>{z7.$checked.set(!1)},500))});const UTt=pM.$images.filter(()=>Rh.ready).map(async n=>Rh.predict(await jce.process(n))).awaitPromises(),Zce=e2t(UTt);Zce.title="Real-time predictions";const G$=BTt({title:"Demo for CVBE & Crowd Cognition",author:"Téo Sanchez"});G$.page("Train your first model").sidebar(pM,jV,qV).use([H$,Kce],[qce,Zce]);G$.page("Design parameters").use([Xce,H$],Yce);G$.settings.dataStores(W$).datasets(KC).models(Rh).predictions(mM);G$.show();
